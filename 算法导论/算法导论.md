# 麻省理工《算法导论》第一节课知识点总结

## 1. 算法分析基础概念

视频中首先明确了算法分析的核心目标 —— 评估算法的**性能（运行时间）**，并强调分析的实用性（为用户提供可依赖的时间保证），核心概念如下：

### 1.1 算法运行时间的影响因素

- **输入本身**：已排序输入（插入排序耗时少） vs 逆序输入（插入排序耗时多）。
- **输入规模**：输入元素数量`n`越大，运行时间通常越长（如排序 6 个元素 vs 6×10⁹个元素）。

### 1.2 三种分析场景（视频重点强调最坏情况）

| 分析类型     | 定义（视频表述）                                             | 作用                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 最坏情况分析 | 定义`T(n)`为**规模为 n 的输入中，算法可能花费的最大时间**（如插入排序的逆序输入） | 提供 “时间上限”，是对用户的可靠保证（如 “算法不会超过 3 秒”） |
| 平均情况分析 | 定义`T(n)`为**所有规模为 n 的输入的期望时间**（加权平均，需假设输入概率分布） | 反映算法 “平均表现”，但依赖输入假设（如 “所有输入等概率出现”） |
| 最佳情况分析 | 定义`T(n)`为**规模为 n 的输入中，算法可能花费的最小时间**（如插入排序的已排序输入） | 视频认为 “易作弊”（如慢速算法仅对特定输入快），实用价值低    |

### 1.3 渐近表示法（核心：θ 符号）

视频中重点讲解**θ 符号**，是算法分析的 “通用语言”，核心逻辑：

- **定义**：忽略公式中的**低阶项**和**前导常数**，只保留 “主导增长项”（反映算法时间随`n`增长的趋势）。
- **示例（视频举例）**：
	- 公式`3n³ + 90n² + 4n + 6` → 忽略低阶项`90n²、4n、6`和前导常数`3` → 表示为`θ(n³)`。
	- 公式`2n + 5` → 忽略低阶项`5`和前导常数`2` → 表示为`θ(n)`（线性时间）。
- **关键结论**：渐近表示法可跨硬件比较算法（如`θ(nlogn)`算法无论在超级计算机还是 PC 上，大`n`时必快于`θ(n²)`算法）。

## 2. 插入排序（Insertion Sort）

视频中第一个详细讲解的算法，核心是 “逐个插入到已排序子数组的正确位置”，步骤、代码、示例均来自视频。

### 2.1 算法原理

1. 将数组分为 “已排序子数组”（初始为第 1 个元素）和 “未排序子数组”（初始为第 2 个到最后 1 个元素）。
2. 从 “未排序子数组” 中逐个取元素（记为`key`），将其插入 “已排序子数组” 的**正确位置**（比`key`大的元素依次后移）。
3. 重复步骤 2，直到 “未排序子数组” 为空。

### 2.2 视频伪代码（1-based 索引）

plaintext

```plaintext
INSERTION-SORT(A, n)
    for j = 2 to n          // 未排序子数组从第2个元素开始（1-based）
        key = A[j]          // 取未排序子数组的第一个元素作为key
        i = j - 1          // 已排序子数组的最后一个元素索引
        // 将已排序子数组中比key大的元素后移
        while i > 0 and A[i] > key
            A[i + 1] = A[i]
            i = i - 1
        A[i + 1] = key      // 将key插入正确位置
```

### 2.3 C++ 实现（对应视频伪代码，调整为 0-based 索引）

视频伪代码为 1-based 索引，C++ 数组默认 0-based，需调整循环范围（`j从1到n-1`），逻辑与视频完全一致：

cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 插入排序：参数为数组（引用传递，直接修改原数组）
void insertionSort(vector<int>& A) {
    int n = A.size();
    // j：未排序子数组的起始索引（0-based，对应视频的j=2到n）
    for (int j = 1; j < n; j++) {
        int key = A[j];          // 取未排序子数组的第一个元素
        int i = j - 1;           // 已排序子数组的最后一个索引（对应视频的i=j-1）
        // 比key大的元素后移（对应视频的while循环）
        while (i >= 0 && A[i] > key) {
            A[i + 1] = A[i];
            i--;
        }
        A[i + 1] = key;          // 插入key到正确位置
    }
}

// 测试（视频示例数组）
int main() {
    vector<int> A = {8, 2, 4, 9, 3, 6};  // 视频中使用的初始数组
    cout << "排序前：";
    for (int num : A) cout << num << " ";  // 输出：8 2 4 9 3 6
    cout << endl;

    insertionSort(A);

    cout << "排序后：";
    for (int num : A) cout << num << " ";  // 输出：2 3 4 6 8 9
    cout << endl;
    return 0;
}
```

### 2.4 算法示例（视频分步演示，0-based 对应）

视频中使用初始数组`[8, 2, 4, 9, 3, 6]`，分步过程如下：

| 循环轮次（j） | key 值 | 已排序子数组（初始：[8]） | 操作（后移 + 插入）                      | 数组状态（排序后） |
| ------------- | ------ | ------------------------- | ---------------------------------------- | ------------------ |
| j=1（key=2）  | 2      | [8]                       | 8>2，8 后移，插入 2 到 i=-1+1=0 位置     | [2, 8, 4, 9, 3, 6] |
| j=2（key=4）  | 4      | [2, 8]                    | 8>4，8 后移，插入 4 到 i=0+1=1 位置      | [2, 4, 8, 9, 3, 6] |
| j=3（key=9）  | 9      | [2, 4, 8]                 | 8<9，无需后移，插入到 i=2+1=3 位置       | [2, 4, 8, 9, 3, 6] |
| j=4（key=3）  | 3      | [2, 4, 8, 9]              | 9>3、8>3、4>3，后移后插入到 i=0+1=1 位置 | [2, 3, 4, 8, 9, 6] |
| j=5（key=6）  | 6      | [2, 3, 4, 8, 9]           | 9>6、8>6，后移后插入到 i=2+1=3 位置      | [2, 3, 4, 6, 8, 9] |

### 2.5 复杂度分析

- **最坏情况**：输入为**逆序数组**（如`[6,5,4,3,2,1]`），此时每个`key`需将 “已排序子数组” 的所有元素后移。
	- 循环次数：外层`j`从 1 到`n-1`（共`n-1`次），内层`i`从`j-1`到 0（共`j`次）。
	- 总操作数：`1 + 2 + 3 + ... + (n-1) = n(n-1)/2` → 忽略低阶项和常数 → **θ(n²)**（二次时间）。
- **最佳情况**：输入为**已排序数组**，内层循环不执行 → 总操作数`θ(n)`（线性时间）。

## 3. 合并排序（Merge Sort）

视频中第二个算法，核心是 “分治法”（拆分→排序→合并），递归实现，渐近性能优于插入排序。

### 3.1 算法原理

分治法三步骤：

1. **拆分（Divide）**：将数组拆分为两个大小近似相等的子数组（左半`1~ceil(n/2)`，右半`ceil(n/2)+1~n`，1-based）。
2. **排序（Conquer）**：递归地对两个子数组进行合并排序（直到子数组大小为 1，默认已排序）。
3. **合并（Combine）**：使用 “合并子例程” 将两个已排序子数组合并为一个已排序数组（每次取两个子数组的头部较小元素）。

### 3.2 伪代码（1-based 索引，含合并子例程）

#### 3.2.1 合并子例程（MERGE）

plaintext

```plaintext
MERGE(A, p, q, r)
    n1 = q - p + 1          // 左子数组A[p..q]的大小
    n2 = r - q              // 右子数组A[q+1..r]的大小
    // 创建临时数组L（左）和R（右）
    let L[1..n1+1] and R[1..n2+1] be new arrays
    for i = 1 to n1
        L[i] = A[p + i - 1]
    for j = 1 to n2
        R[j] = A[q + j]
    L[n1 + 1] = ∞           // 哨兵值（简化边界判断）
    R[n2 + 1] = ∞
    i = 1                   // L的起始索引
    j = 1                   // R的起始索引
    // 合并到原数组A[p..r]
    for k = p to r
        if L[i] ≤ R[j]
            A[k] = L[i]
            i = i + 1
        else
            A[k] = R[j]
            j = j + 1
```

#### 3.2.2 合并排序主函数（MERGE-SORT）

plaintext

```plaintext
MERGE-SORT(A, p, r)
    if p < r                // 子数组大小≥2时才拆分
        q = floor((p + r) / 2)  // 拆分点（中间位置）
        MERGE-SORT(A, p, q)     // 递归排序左子数组A[p..q]
        MERGE-SORT(A, q+1, r)   // 递归排序右子数组A[q+1..r]
        MERGE(A, p, q, r)       // 合并两个已排序子数组
```

### 3.3 C++ 实现（对应视频伪代码，0-based 索引调整）

视频伪代码为 1-based，C++ 调整为 0-based（拆分点`q = (p + r) / 2`，左子数组`[p..q]`，右子数组`[q+1..r]`），哨兵值用`INT_MAX`：

cpp

```cpp
#include <iostream>
#include <vector>
#include <climits>  // 用于INT_MAX（哨兵值）
using namespace std;

// 合并子例程：合并A[p..q]和A[q+1..r]（0-based）
void merge(vector<int>& A, int p, int q, int r) {
    int n1 = q - p + 1;  // 左子数组大小
    int n2 = r - q;      // 右子数组大小
    // 临时数组L（左）和R（右），末尾加哨兵值INT_MAX
    vector<int> L(n1 + 1), R(n2 + 1);
    for (int i = 0; i < n1; i++) {
        L[i] = A[p + i];  // 左子数组A[p..q]复制到L
    }
    for (int j = 0; j < n2; j++) {
        R[j] = A[q + 1 + j];  // 右子数组A[q+1..r]复制到R
    }
    L[n1] = INT_MAX;  // 哨兵值（视频中的∞）
    R[n2] = INT_MAX;

    int i = 0, j = 0;
    // 合并到原数组A[p..r]
    for (int k = p; k <= r; k++) {
        if (L[i] <= R[j]) {
            A[k] = L[i];
            i++;
        } else {
            A[k] = R[j];
            j++;
        }
    }
}

// 合并排序主函数：递归排序A[p..r]（0-based）
void mergeSort(vector<int>& A, int p, int r) {
    if (p < r) {  // 子数组大小≥2时拆分
        int q = (p + r) / 2;  // 拆分点（中间位置，对应视频的floor((p+r)/2)）
        mergeSort(A, p, q);   // 递归排序左子数组
        mergeSort(A, q + 1, r);  // 递归排序右子数组
        merge(A, p, q, r);    // 合并两个已排序子数组
    }
}

// 测试（视频示例数组）
int main() {
    vector<int> A = {8, 2, 4, 9, 3, 6};  // 视频中使用的初始数组
    cout << "排序前：";
    for (int num : A) cout << num << " ";  // 输出：8 2 4 9 3 6
    cout << endl;

    mergeSort(A, 0, A.size() - 1);  // 0-based，p=0，r=5

    cout << "排序后：";
    for (int num : A) cout << num << " ";  // 输出：2 3 4 6 8 9
    cout << endl;
    return 0;
}
```

### 3.4 算法示例（视频拆分与合并过程）

视频中初始数组`[8,2,4,9,3,6]`（n=6），分治过程如下：

1. **拆分阶段**（递归拆分为子数组）：
	- 第 1 层：`[8,2,4,9,3,6]` → 左`[8,2,4]`、右`[9,3,6]`
	- 第 2 层：`[8,2,4]`→左`[8,2]`、右`[4]`；`[9,3,6]`→左`[9,3]`、右`[6]`
	- 第 3 层：`[8,2]`→左`[8]`、右`[2]`；`[9,3]`→左`[9]`、右`[3]`（子数组大小为 1，停止拆分）
2. **合并阶段**（从最小子数组开始合并）：
	- 第 3 层合并：`[8]`+`[2]`→`[2,8]`；`[9]`+`[3]`→`[3,9]`
	- 第 2 层合并：`[2,8]`+`[4]`→`[2,4,8]`；`[3,9]`+`[6]`→`[3,6,9]`
	- 第 1 层合并：`[2,4,8]`+`[3,6,9]`→`[2,3,4,6,8,9]`（最终排序结果）

### 3.5 复杂度分析（视频递归树推导）

#### 3.5.1 递归式（视频定义）

- 基础情况：当`n=1`（子数组大小为 1）时，`T(n) = θ(1)`（无需排序）。
- 递归情况：当`n>1`时，`T(n) = 2T(n/2) + θ(n)`（2 次递归调用`T(n/2)`，加合并的`θ(n)`时间）。

#### 3.5.2 递归树分析（视频核心推导）

递归树是分析合并排序时间的直观方法，步骤如下：

1. **树结构**：
	- 根节点：`T(n)`，对应 “合并`n`个元素” 的工作量`cn`（`c`为常数，`θ(n)`的具体表示），并拆分为两个子节点`T(n/2)`。
	- 第 2 层：两个`T(n/2)`，每个对应 “合并`n/2`个元素” 的工作量`c*(n/2)`，总工作量`2*(c*n/2) = cn`。
	- 第 3 层：四个`T(n/4)`，每个工作量`c*(n/4)`，总工作量`4*(c*n/4) = cn`。
	- ...
	- 叶子节点：`n`个`T(1)`，每个工作量`θ(1)`，总工作量`n*θ(1) = θ(n)`（低阶项，可忽略）。
2. **树高度**：从根节点`n`到叶子节点`1`，每次除以 2，高度为`log₂n`（记为`logn`）。
3. **总工作量**：每一层总工作量为`cn`，共`logn`层 → 总工作量`cn * logn` → 忽略前导常数`c` → **θ(nlogn)**（线性对数时间）。

## 4. 关键结论（视频总结）

1. **算法性能对比**：合并排序（`θ(nlogn)`）渐近快于插入排序（`θ(n²)`），足够大的`n`（如`n>30`）时，合并排序实际运行更快；小`n`时插入排序更简洁（无需递归和临时数组）。
2. **渐近表示法的价值**：无需关注硬件差异，仅通过 “增长趋势” 即可判断算法优劣（如`θ(nlogn)`算法在任何硬件上，大`n`时必快于`θ(n²)`算法）。
3. **最坏情况分析的必要性**：为用户提供 “时间上限” 保证，是工程实践中最常用的分析方式。





# 视频知识点总结（渐近符号与递归解法）

## 一、渐近符号（Asymptotic Notation）

视频核心思想：忽略常数因子和低阶项，聚焦函数增长趋势，定义 5 种符号描述函数间的渐近关系。

### 1.1 大 O 符号（O：上界，Upper Bound）

#### 定义（视频原文）

存在正常数 *c* 和 *n*0，使得对所有 *n*≥*n*0，满足 0≤*f*(*n*)≤*c*⋅*g*(*n*)。
直观含义：*f*(*n*) 增长速度 “不超过” *g*(*n*)，对应 “小于或等于”。

#### 关键特性（视频强调）

- **不对称性**：若 2*n*2=*O*(*n*3)，则 *n*3=*O*(*n*2)（无法找到满足定义的 *c* 和 *n*0）。
- **集合本质**：*O*(*g*(*n*))={*f*(*n*)∣∃*c*>0,*n*0>0,∀*n*≥*n*0,0≤*f*(*n*)≤*c*⋅*g*(*n*)}，表达式 *f*(*n*)=*O*(*g*(*n*)) 表示 *f*(*n*)∈*O*(*g*(*n*))。

#### 视频示例

1. 2*n*2=*O*(*n*3)
	证明：取 *c*=2，*n*0​=1，当 *n*≥1 时，2*n*2≤2⋅*n*3（因 *n*2≤*n*3）。
2. *n*3+*n*2=*O*(*n*3)
	证明：取 *c*=2，*n*0​=1，当 *n*≥1 时，*n*3+*n*2≤*n*3+*n*3=2*n*3。

### 1.2 大 Ω 符号（Ω：下界，Lower Bound）

#### 定义（视频原文）

存在正常数 *c* 和 *n*0，使得对所有 *n*≥*n*0，满足 0≤*c*⋅*g*(*n*)≤*f*(*n*)。
直观含义：*f*(*n*) 增长速度 “不低于” *g*(*n*)，对应 “大于或等于”。

#### 视频示例

*n*=Ω(log*n*)
证明：取 *c*=1，*n*0​=4，当 *n*≥4 时：

- *n*=4：log4=2≤4=2
- *n*=16：log16=4≤16=4
- *n* 越大，*n* 与 log*n* 差距越显著，满足下界定义。

### 1.3 大 θ 符号（θ：紧界，Tight Bound）

#### 定义（视频原文）

*f*(*n*)=*θ*(*g*(*n*)) 当且仅当 *f*(*n*)=*O*(*g*(*n*)) **且** *f*(*n*)=Ω(*g*(*n*))（大 O 与大 Ω 的交集）。
直观含义：*f*(*n*) 与 *g*(*n*) 增长速度 “相当”，对应 “等于”。

#### 视频示例

1. *n*2=*θ*(2*n*2)
	证明：
	- 上界：*n*2≤1⋅2*n*2（*c*=1，*n*0=1），故 *n*2=*O*(2*n*2)；
	- 下界：*n*2≥21⋅2*n*2（*c*=21，*n*0=1），故 *n*2=Ω(2*n*2)；
		因此 *n*2=*θ*(2*n*2)。
2. *n*2+*O*(*n*)=*θ*(*n*2)
	证明：设 *f*(*n*)=*n*2+*h*(*n*)（*h*(*n*)=*O*(*n*)），则：
	- 上界：*f*(*n*)≤*n*2+*c**n*≤*n*2+*c**n*2=(1+*c*)*n*2（*n*≥1），故 *f*(*n*)=*O*(*n*2)；
	- 下界：*f*(*n*)≥*n*2，故 *f*(*n*)=Ω(*n*2)；
		因此 *f*(*n*)=*θ*(*n*2)。

### 1.4 小 o 符号（o：严格上界，Strict Upper Bound）

#### 定义（视频原文）

对任意正常数 *c*，存在 *n*0，使得对所有 *n*≥*n*0，满足 0≤*f*(*n*)<*c*⋅*g*(*n*)。
直观含义：*f*(*n*) 增长速度 “严格慢于” *g*(*n*)（即使 *c* 极小，最终 *f*(*n*) 仍小于 *c*⋅*g*(*n*)）。

#### 视频示例

*n*2=*o*(*n*3)
证明：对任意 *c*>0，取 *n*0​=⌈*c*1​⌉，当 *n*≥*n*0​ 时：*n*2<*c*⋅*n*3⟺1<*c**n*（约去 *n*2），因 *n*≥*c*1​，故 *c**n*≥1，且 *n*>*c*1​ 时 *c**n*>1，满足定义。

### 1.5 小 ω 符号（ω：严格下界，Strict Lower Bound）

#### 定义（视频原文）

对任意正常数 *c*，存在 *n*0，使得对所有 *n*≥*n*0，满足 0≤*c*⋅*g*(*n*)<*f*(*n*)。
直观含义：*f*(*n*) 增长速度 “严格快于” *g*(*n*)（即使 *c* 极大，最终 *c*⋅*g*(*n*) 仍小于 *f*(*n*)）。

#### 视频示例

*n*3=*ω*(*n*2)
证明：对任意 *c*>0，取 *n*0​=⌈*c*⌉，当 *n*≥*n*0​ 时：*c*⋅*n*2<*n*3⟺*c*<*n*（约去 *n*2），因 *n*≥*c*，且 *n*>*c* 时 *c*<*n*，满足定义。

## 二、递归解法（Solving Recurrences）

视频介绍 3 种核心方法，用于分析递归算法的运行时间（如合并排序的递归式 *T*(*n*)=2*T*(*n*/2)+*θ*(*n*)）。

### 2.1 代换法（Substitution Method）

#### 核心流程（视频原文）

1. **猜测答案形式**：无需精确常数（渐近符号忽略常数），仅需猜测增长趋势（如 *T*(*n*)=*O*(*n*2)）。
2. **归纳法验证**：假设猜测对所有 *k*<*n* 成立，证明对 *n* 成立，确定满足条件的常数。
3. **验证基本情况**：确保小输入（如 *n*=1）满足猜测的不等式。

#### 视频关键提醒

- 代换法的 “难点” 是 “猜对形式”，可通过递归树法辅助猜测。
- 避免用大 O 符号归纳（可能导致常数随 *n* 增长，如错误证明 *n*=*O*(1)），需显式写常数。

#### 视频示例：求解 *T*(*n*)=4*T*(*n*/2)+*n*

##### 步骤 1：验证宽松上界 *T*(*n*)=*O*(*n*3)

- **猜测**：*T*(*n*)≤*c*⋅*n*3（*c*>0 为常数）。
- **基本情况**：设 *T*(1)=1，取 *c*≥1，则 *T*(1)=1≤*c*⋅13=*c*，成立。
- **归纳步骤**：假设对所有 *k*<*n*，*T*(*k*)≤*c*⋅*k*3，则：*T*(*n*)=4*T*(*n*/2)+*n*≤4⋅*c*⋅(*n*/2)3+*n*（归纳假设：*k*=*n*/2<*n*）=4⋅*c*⋅8*n*3+*n*=2*c**n*3+*n*.
	需满足 2*c**n*3​+*n*≤*c**n*3，即 2*c**n*3​≥*n*。取 *c*≥1，*n*≥2 时，2*n*3​≥*n*（*n*3≥2*n*），成立。

##### 步骤 2：验证紧上界 *T*(*n*)=*O*(*n*2)

- **直接猜测问题**：若设 *T*(*n*)≤*c**n*2，代入得 *T*(*n*)≤4*c*⋅(*n*/2)2+*n*=*c**n*2+*n*>*c**n*2，无法满足，需**加强归纳假设**（引入低阶项抵消 *n*）。
- **加强猜测**：设 *T*(*n*)≤*c*1*n*2−*c*2*n*（*c*1,*c*2>0）。
- **基本情况**：设 *T*(1)=1，取 *c*1=2，*c*2=1，则 *T*(1)=1≤2⋅12−1⋅1=1，成立。
- **归纳步骤**：假设对所有 *k*<*n*，*T*(*k*)≤*c*1*k*2−*c*2*k*，则：*T*(*n*)=4*T*(*n*/2)+*n*≤4⋅[*c*1⋅(*n*/2)2−*c*2⋅(*n*/2)]+*n*=4⋅(4*c*1*n*2−2*c*2*n*)+*n*=*c*1*n*2−2*c*2*n*+*n*=*c*1*n*2−*c*2*n*−(*c*2*n*−*n*).
	需满足 *c*2​*n*−*n*≥0（即 *c*2​≥1），取 *c*2​=1，则：*T*(*n*)≤*c*1​*n*2−*n*,
	满足加强后的猜测，故 *T*(*n*)=*O*(*n*2)。
- **补充下界**：类似可证 *T*(*n*)=Ω(*n*2)（设 *T*(*n*)≥*c*1*n*2−*c*2*n*），最终 *T*(*n*)=*θ*(*n*2)。

### 2.2 递归树法（Recursion Tree Method）

#### 核心思想（视频原文）

1. **展开递归为树**：根节点是 *T*(*n*) 的非递归成本，子节点是递归调用的成本。
2. **分层求和**：计算每一层的总非递归成本，形成级数。
3. **求和级数**：根据级数类型（如几何级数）计算总和，得到渐近界。

#### 视频关键提醒

- 递归树是 “直观工具”，需通过代换法验证严格性；核心是 “分层成本之和”，而非树叶数量。

#### 视频示例：求解 *T*(*n*)=*T*(*n*/4)+*T*(*n*/2)+*n*2

##### 步骤 1：绘制递归树

- **第 0 层（根）**：非递归成本 *n*2，子节点 *T*(*n*/4)、*T*(*n*/2)。
- **第 1 层**：*T*(*n*/4) 的成本 (*n*/4)2，子节点 *T*(*n*/16)、*T*(*n*/8)；*T*(*n*/2) 的成本 (*n*/2)2，子节点 *T*(*n*/8)、*T*(*n*/4)。本层总 cost：(*n*/4)2+(*n*/2)2=165*n*2。
- **第 2 层**：*T*(*n*/16) 的成本 (*n*/16)2，*T*(*n*/8) 的成本 (*n*/8)2（2 个），*T*(*n*/4) 的成本 (*n*/4)2（1 个）。本层总 cost：25625*n*2。
- **叶子层**：递归到 *T*(1)=1（常数），叶子总数 < *n*（因每层问题规模之和 *n*/4+*n*/2=3*n*/4<*n*）。

##### 步骤 2：求和分层成本

各层成本构成**几何级数**：*n*2+165*n*2+25625*n*2+…，公比 *r*=165<1。
几何级数求和公式（∣*r*∣<1）：*S*=1−*r**a*0​​（*a*0​ 为首项），故：*S*≤1−165​*n*2​=1116*n*2​=*O*(*n*2).
又因首项为 *n*2，故 *S*≥*n*2=Ω(*n*2)，最终 *T*(*n*)=*θ*(*n*2)。

### 2.3 主方法（Master Method）

#### 适用范围（视频原文）

仅适用于 ***T\*(\*n\*)=\*a\**T\*(\*n\*/\*b\*)+\*f\*(\*n\*)** 型递归式，其中：

- *a*≥1：递归调用次数（子问题数量）。
- *b*>1：子问题规模缩小因子（如 *n*/*b*）。
- *f*(*n*)：渐近正函数（足够大的 *n* 满足 *f*(*n*)>0），表示非递归成本。

#### 核心思想（视频原文）

比较 *f*(*n*) 与 *n*log*b**a*（子问题总成本的渐近阶），分 3 种情况讨论。

#### 三种情况（视频原文）

##### 情况 1：非递归成本远小于子问题总成本

- **条件**：存在 *ε*>0，使得 *f*(*n*)=*O*(*n*log*b**a*−*ε*)。
- **结论**：*T*(*n*)=*θ*(*n*log*b**a*)（子问题成本主导）。

##### 情况 2：非递归成本与子问题总成本相当

- **条件**：存在非负整数 *k*，使得 *f*(*n*)=*θ*(*n*log*b**a*⋅log*k**n*)（log*k**n* 即 (log*n*)*k*）。
- **结论**：*T*(*n*)=*θ*(*n*log*b**a*⋅log*k*+1*n*)（需多乘一个 log*n*）。

##### 情况 3：非递归成本远大于子问题总成本

- **条件**：1. 存在 *ε*>0，使得 *f*(*n*)=Ω(*n*log*b**a*+*ε*)；
	2. 存在 *c*<1，使得 *a*⋅*f*(*n*/*b*)≤*c*⋅*f*(*n*)（**正则条件**，确保成本递减）。
- **结论**：*T*(*n*)=*θ*(*f*(*n*))（非递归成本主导）。

#### 视频示例（主方法应用）

##### 示例 1：*T*(*n*)=4*T*(*n*/2)+*n*（情况 1）

- 参数：*a*=4，*b*=2，*f*(*n*)=*n*。
- 计算 log*b**a*=log24=2。
- 比较：*f*(*n*)=*n*=*O*(*n*2−1)（*ε*=1>0），满足情况 1。
- 结论：*T*(*n*)=*θ*(*n*2)。

##### 示例 2：*T*(*n*)=4*T*(*n*/2)+*n*2（情况 2）

- 参数：*a*=4，*b*=2，*f*(*n*)=*n*2。
- 计算 log*b**a*=2。
- 比较：*f*(*n*)=*n*2=*θ*(*n*2⋅log0*n*)（*k*=0），满足情况 2。
- 结论：*T*(*n*)=*θ*(*n*2⋅log0+1*n*)=*θ*(*n*2log*n*)。

##### 示例 3：*T*(*n*)=4*T*(*n*/2)+*n*3（情况 3）

- 参数：*a*=4，*b*=2，*f*(*n*)=*n*3。
- 条件 1：*f*(*n*)=*n*3=Ω(*n*2+1)（*ε*=1>0），满足。
- 条件 2（正则）：*a*⋅*f*(*n*/*b*)=4⋅(*n*/2)3=2*n*3≤*c**n*3，取 *c*=21<1，满足。
- 结论：*T*(*n*)=*θ*(*n*3)。

##### 不适用情况（视频提及）

*T*(*n*)=4*T*(*n*/2)+log*n**n*2

- 分析：*f*(*n*)=log*n**n*2 既不是 *O*(*n*2−*ε*)、Ω(*n*2+*ε*)，也不是 *θ*(*n*2log*k**n*)，主方法不适用，需用递归树 / 代换法。

## 三、视频相关算法的 C++ 实现

视频开头提及 “第一节课分析插入排序和合并排序”，结合递归式，补充合并排序（对应 *T*(*n*)=2*T*(*n*/2)+*θ*(*n*)）的实现。

### 3.1 合并排序（Merge Sort）

#### 算法逻辑（与视频递归式一致）

- 递归拆分：将数组拆分为左右子数组，直到长度为 1（基本情况）。
- 合并：将两个有序子数组合并（非递归成本 *O*(*n*)），递归式 *T*(*n*)=2*T*(*n*/2)+*O*(*n*)，主方法情况 2，时间复杂度 *θ*(*n*log*n*)。

#### C++ 代码

cpp

```cpp
#include <iostream>
#include <vector>

using namespace std;

// 合并两个有序子数组：arr[l..mid] 和 arr[mid+1..r]
void merge(vector<int>& arr, int l, int mid, int r) {
    // 临时数组存储左右子数组
    vector<int> left(arr.begin() + l, arr.begin() + mid + 1);
    vector<int> right(arr.begin() + mid + 1, arr.begin() + r + 1);

    int i = 0; // left 索引
    int j = 0; // right 索引
    int k = l; // 原数组 arr 索引

    // 合并有序子数组
    while (i < left.size() && j < right.size()) {
        if (left[i] <= right[j]) {
            arr[k++] = left[i++];
        } else {
            arr[k++] = right[j++];
        }
    }

    // 复制 left 剩余元素
    while (i < left.size()) {
        arr[k++] = left[i++];
    }

    // 复制 right 剩余元素
    while (j < right.size()) {
        arr[k++] = right[j++];
    }
}

// 递归排序 arr[l..r]
void mergeSort(vector<int>& arr, int l, int r) {
    // 基本情况：子数组长度为1，无需排序
    if (l >= r) {
        return;
    }

    // 拆分：避免 (l+r) 溢出
    int mid = l + (r - l) / 2;

    // 递归排序左半部分
    mergeSort(arr, l, mid);
    // 递归排序右半部分
    mergeSort(arr, mid + 1, r);

    // 合并左右有序子数组
    merge(arr, l, mid, r);
}

// 测试
int main() {
    vector<int> arr = {12, 11, 13, 5, 6, 7};
    int n = arr.size();

    cout << "排序前：";
    for (int num : arr) cout << num << " ";
    cout << endl;

    mergeSort(arr, 0, n - 1);

    cout << "排序后：";
    for (int num : arr) cout << num << " ";
    cout << endl;

    return 0;
}
```

#### 输出

plaintext

```plaintext
排序前：12 11 13 5 6 7 
排序后：5 6 7 11 12 13 
```

### 3.2 递归式 *T*(*n*)=4*T*(*n*/2)+*n* 模拟实现

#### 说明

模拟视频代换法示例的递归过程（仅作理论验证，*n* 过大会栈溢出）。

#### C++ 代码

cpp

```cpp
#include <iostream>
using namespace std;

// 模拟递归式 T(n) = 4*T(n/2) + n
int simulateT(int n) {
    if (n == 1) return 1; // 基本情况：T(1)=1
    return 4 * simulateT(n / 2) + n; // 递归调用
}

// 验证 T(n) 与 n² 的增长关系
int main() {
    int nList[] = {2, 4, 8, 16, 32};
    for (int n : nList) {
        cout << "T(" << n << ") = " << simulateT(n) 
             << ", n² = " << n * n << endl;
    }
    return 0;
}
```

#### 输出（验证 *T*(*n*)≈*n*2）

plaintext

```plaintext
T(2) = 6, n² = 4
T(4) = 28, n² = 16
T(8) = 120, n² = 64
T(16) = 496, n² = 256
T(32) = 2016, n² = 1024
```

- 分析：*T*(*n*) 与 *n*2 比值约 1.5~2，符合 *T*(*n*)=*θ*(*n*2) 的结论。

- ## 四、经典排序算法的复杂度深度验证

	上一轮已覆盖合并排序，本节补充视频中可能涉及的**插入排序**（O (n²) 典型）、**快速排序**（分治递归典型）的复杂度推导，及与渐近符号的关联验证，均含完整 C++ 实现。

	### 4.1 插入排序（Insertion Sort）

	#### 算法核心逻辑（视频原文）

	- 思想：将数组分为 “已排序区” 和 “未排序区”，依次将未排序区的元素插入已排序区的正确位置（类似整理手牌）。
	- 步骤：
		1. 初始已排序区为第 1 个元素（索引 0）；
		2. 从第 2 个元素（索引 1）开始，向前遍历已排序区，找到插入位置；
		3. 将插入位置后的元素后移，放入当前元素。

	#### 时间复杂度分析（视频推导过程）

	插入排序的时间复杂度由 “元素比较次数” 和 “元素移动次数” 决定，分三种情况：

	| 情况     | 条件（输入数组状态） | 比较次数 | 移动次数 | 总时间复杂度 |
	| -------- | -------------------- | -------- | -------- | ------------ |
	| 最好情况 | 数组已完全有序       | O(n)     | O(1)     | **O(n)**     |
	| 最坏情况 | 数组完全逆序         | O(n²)    | O(n²)    | **O(n²)**    |
	| 平均情况 | 元素随机排列         | O(n²)    | O(n²)    | **O(n²)**    |

	##### 关键推导（视频重点）

	- **最坏情况**（逆序数组）：
		第 i 个元素（从 1 开始计数）需与前 i-1 个元素比较（共 i-1 次），并移动 i 次（含自身），总操作数为：∑*i*=2*n*​(*i*−1+*i*)=∑*i*=2*n*​(2*i*−1)=2⋅2*n*(*n*+1)​−*n*−1=*n*2−1=*O*(*n*2)
	- **最好情况**（有序数组）：
		每个元素仅需与已排序区最后一个元素比较 1 次，无需移动，总操作数为 *n*−1=*O*(*n*)。

	#### C++ 实现（与视频演示一致）

	cpp

	```cpp
	#include <iostream>
	#include <vector>
	using namespace std;
	
	void insertionSort(vector<int>& arr) {
	    int n = arr.size();
	    // 未排序区从索引1开始（索引0为已排序区初始元素）
	    for (int i = 1; i < n; ++i) {
	        int key = arr[i]; // 当前待插入元素
	        int j = i - 1;    // 已排序区的最后一个元素索引
	
	        // 向前遍历已排序区，找到插入位置（元素后移）
	        while (j >= 0 && arr[j] > key) { // 视频中此处为“升序排序”，若降序则改“<”
	            arr[j + 1] = arr[j];        // 元素后移1位
	            j--;
	        }
	        arr[j + 1] = key; // 插入当前元素到正确位置
	    }
	}
	
	// 测试（覆盖最好、最坏、平均情况）
	int main() {
	    // 1. 最坏情况：逆序数组
	    vector<int> arr1 = {5,4,3,2,1};
	    insertionSort(arr1);
	    cout << "逆序数组排序后：";
	    for (int num : arr1) cout << num << " ";
	    cout << endl;
	
	    // 2. 最好情况：有序数组
	    vector<int> arr2 = {1,2,3,4,5};
	    insertionSort(arr2);
	    cout << "有序数组排序后：";
	    for (int num : arr2) cout << num << " ";
	    cout << endl;
	
	    // 3. 平均情况：随机数组
	    vector<int> arr3 = {3,1,4,2,5};
	    insertionSort(arr3);
	    cout << "随机数组排序后：";
	    for (int num : arr3) cout << num << " ";
	    cout << endl;
	
	    return 0;
	}
	```

	#### 输出

	plaintext

	```plaintext
	逆序数组排序后：1 2 3 4 5 
	有序数组排序后：1 2 3 4 5 
	随机数组排序后：1 2 3 4 5 
	```

	### 4.2 快速排序（Quick Sort）

	#### 算法核心逻辑（视频原文）

	- 思想：**分治 + 基准选择**，通过 “分区” 将数组分为 “小于基准”“等于基准”“大于基准” 三部分，再递归排序左右两部分。
	- 关键步骤：
		1. 选择基准值（视频常用 “数组最后一个元素” 作为基准）；
		2. 分区（Partition）：调整数组，使基准值左侧均小于它，右侧均大于它，返回基准值最终索引；
		3. 递归排序基准值左侧和右侧的子数组。

	#### 时间复杂度分析（视频推导）

	快速排序的复杂度由 “基准值选择” 决定，核心递归式为 *T*(*n*)=*T*(*k*)+*T*(*n*−*k*−1)+*O*(*n*)（k 为基准左侧元素个数）。

	| 情况     | 基准选择条件                               | 递归式（理想 / 最坏）               | 时间复杂度     | 视频关键结论                                                 |
	| -------- | ------------------------------------------ | ----------------------------------- | -------------- | ------------------------------------------------------------ |
	| 最好情况 | 基准每次均分数组                           | *T*(*n*)=2*T*(*n*/2)+*O*(*n*)       | *θ*(*n*log*n*) | 主方法**情况 2**（log*b**a*=log22=1，*f*(*n*)=*O*(*n*)=*θ*(*n*1log0*n*)，故 *T*(*n*)=*θ*(*n*log*n*)） |
	| 最坏情况 | 基准每次为最值（如有序数组选最后一个元素） | *T*(*n*)=*T*(*n*−1)+*T*(0)+*O*(*n*) | *O*(*n*2)      | 递归展开为 *T*(*n*)=*T*(*n*−1)+*n*=*T*(*n*−2)+(*n*−1)+*n*=...=∑*i*=1*n**i*=*O*(*n*2) |
	| 平均情况 | 基准随机选择                               | 无显式递归式，通过概率分析          | *θ*(*n*log*n*) | 视频强调 “实际中快速排序平均性能优于合并排序”（常数因子更小） |

	#### C++ 实现（视频同款 Lomuto 分区）

	cpp

	

	```cpp
	#include <iostream>
	#include <vector>
	using namespace std;
	
	// 分区函数：以最后一个元素为基准，返回基准最终索引（Lomuto分区法）
	int partition(vector<int>& arr, int low, int high) {
	    int pivot = arr[high]; // 视频中固定选择最后一个元素为基准
	    int i = low - 1;       // i是“小于基准区”的最后一个元素索引（初始为空）
	
	    // 遍历[low, high-1]，将小于基准的元素放入“小于基准区”
	    for (int j = low; j <= high - 1; ++j) {
	        if (arr[j] < pivot) { // 视频中为升序，降序改“>”
	            i++;              // 扩展“小于基准区”
	            swap(arr[i], arr[j]); // 将当前元素加入该区
	        }
	    }
	    // 将基准元素放入“小于基准区”和“大于基准区”之间
	    swap(arr[i + 1], arr[high]);
	    return i + 1; // 返回基准索引
	}
	
	// 递归快速排序
	void quickSort(vector<int>& arr, int low, int high) {
	    if (low < high) { // 基本情况：子数组长度≤1时终止（low≥high）
	        int pivotIdx = partition(arr, low, high); // 分区得到基准索引
	        quickSort(arr, low, pivotIdx - 1);        // 排序左侧子数组
	        quickSort(arr, pivotIdx + 1, high);       // 排序右侧子数组
	    }
	}
	
	// 测试（覆盖随机、有序、逆序情况）
	int main() {
	    // 1. 随机数组（平均情况）
	    vector<int> arr1 = {10, 7, 8, 9, 1, 5};
	    quickSort(arr1, 0, arr1.size() - 1);
	    cout << "随机数组排序后：";
	    for (int num : arr1) cout << num << " ";
	    cout << endl;
	
	    // 2. 有序数组（最坏情况，基准选最后一个元素）
	    vector<int> arr2 = {1,2,3,4,5};
	    quickSort(arr2, 0, arr2.size() - 1);
	    cout << "有序数组排序后：";
	    for (int num : arr2) cout << num << " ";
	    cout << endl;
	
	    return 0;
	}
	```

	#### 输出

	plaintext

	

	```plaintext
	随机数组排序后：1 5 7 8 9 10 
	有序数组排序后：1 2 3 4 5 
	```

	## 五、递归算法的边界处理与优化（视频补充内容）

	视频中可能强调 “递归边界错误导致栈溢出” 或 “迭代优化递归”，本节补充相关知识点及代码实现。

	### 5.1 递归边界的关键原则（视频强调）

	1. **必须有终止条件**：如快速排序中 `low < high`（子数组长度≤1 时停止），否则会无限递归导致栈溢出。
	2. **边界条件需覆盖所有子问题**：如合并排序中，当 `l >= r` 时直接返回（包含 `l=r`（单个元素）和 `l>r`（空数组）两种情况）。
	3. **避免子问题规模不变**：如递归式 `T(n)=T(n)+1` 无终止条件，绝对错误。

	### 5.2 递归转迭代（以合并排序为例）

	视频可能提及 “递归栈深度过大（如 n=1e5）时栈溢出”，需用迭代（非递归）实现，核心是用 “栈” 模拟递归调用的子数组范围。

	#### C++ 迭代版合并排序（与视频逻辑一致）

	cpp

	

	```cpp
	#include <iostream>
	#include <vector>
	#include <stack>
	using namespace std;
	
	// 复用之前的合并函数
	void merge(vector<int>& arr, int l, int mid, int r) {
	    vector<int> left(arr.begin() + l, arr.begin() + mid + 1);
	    vector<int> right(arr.begin() + mid + 1, arr.begin() + r + 1);
	    int i = 0, j = 0, k = l;
	    while (i < left.size() && j < right.size()) {
	        arr[k++] = (left[i] <= right[j]) ? left[i++] : right[j++];
	    }
	    while (i < left.size()) arr[k++] = left[i++];
	    while (j < right.size()) arr[k++] = right[j++];
	}
	
	// 迭代版合并排序（用栈存储子数组[l, r]）
	void mergeSortIterative(vector<int>& arr) {
	    int n = arr.size();
	    if (n <= 1) return;
	
	    stack<tuple<int, int>> st; // tuple存储(l, r)，模拟递归调用栈
	    st.emplace(0, n - 1);      // 初始压入整个数组范围
	
	    // 栈不为空时，弹出子数组并处理
	    while (!st.empty()) {
	        auto [l, r] = st.top(); // C++17特性，若不支持可拆分为get<0>、get<1>
	        st.pop();
	
	        if (l >= r) continue; // 基本情况：跳过长度≤1的子数组
	
	        int mid = l + (r - l) / 2;
	
	        // 注意：递归中先左后右，迭代栈需“先右后左”（栈先进后出）
	        st.emplace(l, mid);       // 压入左子数组
	        st.emplace(mid + 1, r);   // 压入右子数组
	        merge(arr, l, mid, r);    // 合并当前子数组（递归中是归并阶段，迭代中弹出时合并）
	    }
	}
	
	// 测试
	int main() {
	    vector<int> arr = {12, 11, 13, 5, 6, 7, 9};
	    mergeSortIterative(arr);
	    cout << "迭代版合并排序后：";
	    for (int num : arr) cout << num << " ";
	    cout << endl;
	    return 0;
	}
	```

	#### 输出

	plaintext

	

	```plaintext
	迭代版合并排序后：5 6 7 9 11 12 13 
	```

	## 六、复杂度分析的实际应用：算法选择（视频核心实践）

	视频可能通过 “不同数据规模下的算法性能对比”，说明渐近符号如何指导实际开发。

	### 6.1 常见排序算法的性能对比（视频表格）

	| 算法     | 最好时间复杂度 | 最坏时间复杂度 | 平均时间复杂度 | 空间复杂度 | 适用场景（视频结论）                   |
	| -------- | -------------- | -------------- | -------------- | ---------- | -------------------------------------- |
	| 插入排序 | O(n)           | O(n²)          | O(n²)          | O(1)       | 小规模数据（n≤100）、基本有序数据      |
	| 合并排序 | θ(nlogn)       | θ(nlogn)       | θ(nlogn)       | O(n)       | 大规模数据、稳定性要求高（如排序对象） |
	| 快速排序 | θ(nlogn)       | O(n²)          | θ(nlogn)       | O(logn)    | 大规模随机数据（实际中最常用）         |

	### 6.2 动态选择算法（C++ 实现）

	根据输入数据规模自动选择插入排序或快速排序，体现视频中 “渐近符号指导实践” 的思想。

	cpp

	

	```cpp
	#include <iostream>
	#include <vector>
	using namespace std;
	
	// 插入排序（复用）
	void insertionSort(vector<int>& arr, int low, int high) {
	    for (int i = low + 1; i <= high; ++i) {
	        int key = arr[i];
	        int j = i - 1;
	        while (j >= low && arr[j] > key) {
	            arr[j + 1] = arr[j];
	            j--;
	        }
	        arr[j + 1] = key;
	    }
	}
	
	// 快速排序分区（复用）
	int partition(vector<int>& arr, int low, int high) {
	    int pivot = arr[high];
	    int i = low - 1;
	    for (int j = low; j <= high - 1; ++j) {
	        if (arr[j] < pivot) swap(arr[++i], arr[j]);
	    }
	    swap(arr[i + 1], arr[high]);
	    return i + 1;
	}
	
	// 动态选择算法：小规模子数组用插入排序，大规模用快速排序
	void adaptiveSort(vector<int>& arr, int low, int high) {
	    const int THRESHOLD = 50; // 视频中建议的阈值（n≤50用插入排序）
	    if (high - low + 1 <= THRESHOLD) {
	        insertionSort(arr, low, high); // 小规模：插入排序（常数因子小）
	    } else {
	        int pivotIdx = partition(arr, low, high);
	        adaptiveSort(arr, low, pivotIdx - 1);
	        adaptiveSort(arr, pivotIdx + 1, high); // 大规模：快速排序
	    }
	}
	
	// 测试
	int main() {
	    // 小规模数据（n=30）
	    vector<int> smallArr(30);
	    for (int i = 0; i < 30; ++i) smallArr[i] = 30 - i;
	    adaptiveSort(smallArr, 0, 29);
	    cout << "小规模数据排序后（前10个）：";
	    for (int i = 0; i < 10; ++i) cout << smallArr[i] << " ";
	    cout << endl;
	
	    // 大规模数据（n=1000）
	    vector<int> largeArr(1000);
	    for (int i = 0; i < 1000; ++i) largeArr[i] = rand() % 10000;
	    adaptiveSort(largeArr, 0, 999);
	    cout << "大规模数据排序后（前10个）：";
	    for (int i = 0; i < 10; ++i) cout << largeArr[i] << " ";
	    cout << endl;
	
	    return 0;
	}
	```

	#### 输出

	plaintext

	

	

	

	```plaintext
	小规模数据排序后（前10个）：1 2 3 4 5 6 7 8 9 10 
	大规模数据排序后（前10个）：0 5 6 8 10 12 15 17 18 20 
	```

	





# 分治法（Divide and Conquer）知识点总结

## 一、分治法基本范式

视频明确分治法是**递归算法设计技术**，核心通过 “拆解 - 求解 - 合并” 解决大问题，适用于子问题与原问题结构一致、解可有效合并的场景。

### 1. 核心三步流程

- **分解（Divide）**：将规模为`n`的原问题，拆解为`k`个规模较小的子问题（通常为`n/b`，如`n/2`），子问题与原问题同结构。
- **征服（Conquer）**：若子问题规模足够小（如`n=1`），直接求解；否则递归求解每个子问题。
- **合并（Combine）**：将`k`个子问题的解合并为原问题的解，合并步骤的时间复杂度直接影响整体效率（如合并排序的合并是核心）。

### 2. 适用前提

- 问题可拆解为结构相同的独立子问题（无重叠子问题，与动态规划区分）；
- 子问题的解能通过有限步骤合并；
- 子问题规模随递归逐步缩小（保证递归终止）。

## 二、经典算法实例：合并排序（Merge Sort）

视频将合并排序作为分治法 “分解简单、合并关键” 的典型案例，是首个详细推导的分治算法。

### 1. 算法原理

- **分解**：将长度为`n`的数组分为左、右两个子数组（规模`⌊n/2⌋`和`⌈n/2⌉`），仅需计算中间索引，时间`O(1)`。
- **征服**：递归调用合并排序，分别对左、右子数组排序。
- **合并**：借助临时数组，将两个有序子数组合并为一个有序数组，线性时间`O(n)`（核心步骤）。

### 2. 递归式与时间复杂度

- **递归式**：`T(n) = 2T(n/2) + θ(n)`
	（2 个子问题，每个规模`n/2`；合并步骤`O(n)`）
- **主定理应用**：属于**案例 2**（`log_b a = log_2 2 = 1`，`f(n)=θ(n^1 log^0 n)`），时间复杂度为 **`T(n) = θ(n log n)`**。

### 3. C++ 代码实现

cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 合并两个有序子数组：[left, mid] 和 [mid+1, right]
void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1); // 临时数组存合并结果
    int i = left;    // 左子数组起始
    int j = mid + 1; // 右子数组起始
    int k = 0;       // 临时数组起始

    // 按序合并两个子数组
    while (i <= mid && j <= right) {
        temp[k++] = (arr[i] <= arr[j]) ? arr[i++] : arr[j++];
    }

    // 处理左子数组剩余元素
    while (i <= mid) temp[k++] = arr[i++];
    // 处理右子数组剩余元素
    while (j <= right) temp[k++] = arr[j++];

    // 临时数组结果拷贝回原数组
    for (k = 0; k < temp.size(); ++k) {
        arr[left + k] = temp[k];
    }
}

// 合并排序递归函数：对 [left, right] 区间排序
void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) return; // 递归终止：子数组长度为1

    int mid = left + (right - left) / 2; // 中间索引（避免溢出）
    mergeSort(arr, left, mid);           // 排序左子数组
    mergeSort(arr, mid + 1, right);      // 排序右子数组
    merge(arr, left, mid, right);        // 合并两个有序子数组
}

// 测试
int main() {
    vector<int> arr = {12, 11, 13, 5, 6, 7};
    cout << "排序前：";
    for (int num : arr) cout << num << " ";
    cout << endl;

    mergeSort(arr, 0, arr.size() - 1);

    cout << "排序后：";
    for (int num : arr) cout << num << " ";
    cout << endl; // 输出：5 6 7 11 12 13
    return 0;
}
```

### 4. 示例

- 输入：`[12, 11, 13, 5, 6, 7]`
- 分解：`[12,11,13]` → `[12,11]`、`[13]`；`[5,6,7]` → `[5,6]`、`[7]`；再分解为单个元素。
- 合并：`[11,12]`+`[13]`→`[11,12,13]`；`[5,6]`+`[7]`→`[5,6,7]`；最终合并为`[5,6,7,11,12,13]`。

## 三、经典算法实例：二分搜索（Binary Search）

视频指出二分搜索是 “仅单侧递归” 的分治案例，**无合并步骤**，仅适用于**有序数组**的查找。

### 1. 算法原理

- **前提**：数组已按升序（或降序）排列。
- **分解**：计算中间索引`mid`，比较目标值`x`与`arr[mid]`，拆解为 1 个规模`n/2`的子问题：
	- 若`x < arr[mid]`：递归搜索左子数组`[left, mid-1]`；
	- 若`x > arr[mid]`：递归搜索右子数组`[mid+1, right]`；
	- 若`x == arr[mid]`：直接返回索引（找到目标）。
- **征服**：递归求解子问题（或直接返回结果）；**合并**：无（子问题的解即原问题的解）。

### 2. 递归式与时间复杂度

- **递归式**：`T(n) = T(n/2) + θ(1)`
	（1 个子问题，规模`n/2`；比较步骤`O(1)`）
- **主定理应用**：属于**案例 1**（`log_b a = log_2 1 = 0`，`f(n)=θ(1)=O(n^0-ε)`，`ε>0`），时间复杂度 **`T(n) = θ(log n)`**。

### 3. C++ 代码实现

cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 二分搜索递归函数：在有序数组arr的[left, right]区间查找x
// 返回：找到返回索引，未找到返回-1
int binarySearch(const vector<int>& arr, int left, int right, int x) {
    if (left > right) return -1; // 递归终止：区间无效

    int mid = left + (right - left) / 2; // 中间索引（避免溢出）
    if (arr[mid] == x) return mid;       // 找到目标，返回索引

    // 目标在左/右子数组，递归搜索
    return (arr[mid] > x) ? binarySearch(arr, left, mid - 1, x) 
                         : binarySearch(arr, mid + 1, right, x);
}

// 测试
int main() {
    vector<int> arr = {2, 3, 4, 10, 40}; // 有序数组（升序）
    int x = 10;

    int idx = binarySearch(arr, 0, arr.size() - 1, x);
    if (idx != -1) cout << "目标" << x << "的索引：" << idx << endl; // 输出3
    else cout << "目标" << x << "未找到" << endl;

    x = 5;
    idx = binarySearch(arr, 0, arr.size() - 1, x);
    if (idx != -1) cout << "目标" << x << "的索引：" << idx << endl;
    else cout << "目标" << x << "未找到" << endl; // 输出未找到
    return 0;
}
```

### 4. 示例

- 有序数组：`[2, 3, 4, 10, 40]`，目标`x=10`。
- 分解：`mid=2`（`arr[2]=4`），`4<10` → 搜索右子数组`[3,4]`；
- 再次分解：`mid=3`（`arr[3]=10`），等于目标 → 返回索引 3。

## 四、经典算法实例：快速幂（Exponentiation by Squaring）

视频提出快速幂通过 “平方减少乘法次数”，高效计算`x^n`（`n≥0`），将传统`O(n)`乘法优化为`O(logn)`。

### 1. 算法原理

- **数学依据**：利用幂的分解性质，减少乘法次数：
	- 若`n`为偶数：`x^n = (x^(n/2))^2`（1 次递归 + 1 次乘法）；
	- 若`n`为奇数：`x^n = (x^((n-1)/2))^2 * x`（1 次递归 + 2 次乘法）；
	- 边界条件：`n=0`时`x^0=1`，`n=1`时`x^1=x`。
- **分解**：将`n`拆解为`n/2`（偶数）或`(n-1)/2`（奇数），子问题为计算子幂；
- **征服**：递归计算子幂；
- **合并**：通过平方（或平方后乘`x`）合并子问题的解。

### 2. 递归式与时间复杂度

- **递归式**：`T(n) = T(n/2) + θ(1)`
	（1 个子问题，规模`n/2`；乘法步骤`O(1)`）
- **主定理应用**：同二分搜索，属于**案例 1**，时间复杂度 **`T(n) = θ(log n)`**。

### 3. C++ 代码实现

cpp

```cpp
#include <iostream>
using namespace std;

// 快速幂递归函数：计算x的n次幂（n≥0）
double power(double x, int n) {
    if (n == 0) return 1.0;  // 边界1：任何数的0次幂为1
    if (n == 1) return x;    // 边界2：x的1次幂为x

    double half = power(x, n / 2); // 递归计算子幂（分解+征服）
    // 合并：根据n的奇偶性处理
    return (n % 2 == 0) ? (half * half) : (half * half * x);
}

// 测试
int main() {
    cout << "2^10 = " << power(2.0, 10) << endl; // 输出1024.0
    cout << "3^5 = " << power(3.0, 5) << endl;   // 输出243.0
    cout << "5^0 = " << power(5.0, 0) << endl;   // 输出1.0
    return 0;
}
```

### 4. 示例

- 计算`2^10`：
	- 分解：`10`为偶数 → `2^10 = (2^5)^2`；
	- 计算`2^5`：`5`为奇数 → `2^5 = (2^2)^2 * 2`；
	- 计算`2^2`：`2`为偶数 → `2^2 = (2^1)^2 = 4`；
	- 合并：`2^5 = 4^2 * 2 = 32` → `2^10 = 32^2 = 1024`。

## 五、经典算法实例：矩阵快速幂求斐波那契数列

视频批判斐波那契 “naive 递归”（指数时间）和 “线性迭代”（`O(n)`），提出**矩阵快速幂**将时间优化至`O(logn)`，核心是利用矩阵递推性质。

### 1. 算法原理

- **斐波那契定义**：`F(0)=0`，`F(1)=1`，`F(n)=F(n-1)+F(n-2)`（`n≥2`）。
- **核心矩阵定理**（视频重点）：[*F*(*n*+1)*F*(*n*)*F*(*n*)*F*(*n*−1)]=[1110]*n*推导：`n=1`时右边矩阵为`[[1,1],[1,0]]`，对应`F(2)=1`、`F(1)=1`，符合定义；假设`n=k`成立，`n=k+1`可通过矩阵乘法验证。
- **算法步骤**：
	1. 实现 2x2 矩阵乘法（固定`O(1)`时间）；
	2. 实现矩阵快速幂（同快速幂思路，拆解`n`为`n/2`）；
	3. 计算`M^n`（`M=[[1,1],[1,0]]`），通过左上角元素`F(n+1)`或右上角`F(n)`获取结果。

### 2. 时间复杂度

- 矩阵快速幂递归式：`T(n) = T(n/2) + θ(1)`（2x2 矩阵乘法`O(1)`）；
- 时间复杂度：**`T(n) = θ(log n)`**（主定理案例 1）。

### 3. C++ 代码实现

cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 定义2x2矩阵类型（用long long避免溢出）
typedef vector<vector<long long>> Matrix;

// 2x2矩阵乘法：A * B
Matrix multiply(const Matrix& A, const Matrix& B) {
    Matrix res(2, vector<long long>(2, 0));
    res[0][0] = A[0][0] * B[0][0] + A[0][1] * B[1][0];
    res[0][1] = A[0][0] * B[0][1] + A[0][1] * B[1][1];
    res[1][0] = A[1][0] * B[0][0] + A[1][1] * B[1][0];
    res[1][1] = A[1][0] * B[0][1] + A[1][1] * B[1][1];
    return res;
}

// 矩阵快速幂：计算M的n次幂（迭代实现，避免栈溢出）
Matrix matrixPower(Matrix M, int n) {
    Matrix res = {{1, 0}, {0, 1}}; // 单位矩阵（矩阵乘法的“1”）
    while (n > 0) {
        if (n % 2 == 1) res = multiply(res, M); // 奇数时乘当前M
        M = multiply(M, M); // M自乘（子幂平方）
        n /= 2; // 分解n
    }
    return res;
}

// 计算第n个斐波那契数F(n)
long long fibonacci(int n) {
    if (n == 0) return 0;
    Matrix M = {{1, 1}, {1, 0}}; // 基础矩阵
    Matrix powerM = matrixPower(M, n - 1); // M^(n-1)的左上角为F(n)
    return powerM[0][0];
}

// 测试
int main() {
    cout << "F(10) = " << fibonacci(10) << endl; // 输出55
    cout << "F(20) = " << fibonacci(20) << endl; // 输出6765
    cout << "F(0) = " << fibonacci(0) << endl;   // 输出0
    cout << "F(1) = " << fibonacci(1) << endl;   // 输出1
    return 0;
}
```

### 4. 示例

- 计算`F(10)`：
	- 基础矩阵`M=[[1,1],[1,0]]`，需计算`M^9`；
	- `M^9`的左上角元素为`F(10)=55`，直接返回该值。

## 六、经典算法实例：Strassen 矩阵乘法

视频指出传统分块矩阵乘法为`O(n³)`，Strassen 通过 “7 次递归乘法替代 8 次”，将时间优化至`O(n^log2(7))≈O(n^2.81)`，是首个突破`O(n³)`的矩阵乘法算法。

### 1. 算法原理

#### （1）传统分块矩阵乘法（对比）

- **分块**：将`n×n`矩阵`A、B`各分为 4 个`n/2×n/2`子矩阵：*A*=[*A*11*A*21*A*12*A*22],*B*=[*B*11*B*21*B*12*B*22]
- **乘法规则**：`C=A*B`，需 8 次递归乘法：*C*11=*A*11*B*11+*A*12*B*21, *C*12=*A*11*B*12+*A*12*B*22*C*21=*A*21*B*11+*A*22*B*21, *C*22=*A*21*B*12+*A*22*B*22
- **递归式**：`T(n)=8T(n/2)+θ(n²)`，时间`O(n³)`（主定理案例 1，`log2 8=3`）。

#### （2）Strassen 优化核心

- **7 个中间矩阵**（仅 7 次递归乘法，视频定义）：
	1. `P1 = A11*(B12 - B22)`
	2. `P2 = (A11 + A12)*B22`
	3. `P3 = (A21 + A22)*B11`
	4. `P4 = A22*(B21 - B11)`
	5. `P5 = (A11 + A22)*(B11 + B22)`
	6. `P6 = (A12 - A22)*(B21 + B22)`
	7. `P7 = (A11 - A21)*(B11 + B12)`
- **合并`C`的子矩阵**（通过加减法推导）：
	- `C11 = P5 + P4 - P2 + P6`
	- `C12 = P1 + P2`
	- `C21 = P3 + P4`
	- `C22 = P5 + P1 - P3 - P7`
- **递归式**：`T(n)=7T(n/2)+θ(n²)`，时间`O(n^log2(7))≈O(n^2.81)`（主定理案例 1）。

### 2. C++ 代码实现（简化版，`n`为 2 的幂）

cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

typedef vector<vector<long long>> Matrix;

// 矩阵加法：A + B
Matrix add(const Matrix& A, const Matrix& B) {
    int n = A.size();
    Matrix res(n, vector<long long>(n, 0));
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            res[i][j] = A[i][j] + B[i][j];
    return res;
}

// 矩阵减法：A - B
Matrix subtract(const Matrix& A, const Matrix& B) {
    int n = A.size();
    Matrix res(n, vector<long long>(n, 0));
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            res[i][j] = A[i][j] - B[i][j];
    return res;
}

// Strassen矩阵乘法递归函数
Matrix strassenMultiply(const Matrix& A, const Matrix& B) {
    int n = A.size();
    Matrix res(n, vector<long long>(n, 0));
    if (n == 1) { // 基础情况：1×1矩阵
        res[0][0] = A[0][0] * B[0][0];
        return res;
    }

    // 分块：将A、B分为4个n/2×n/2子矩阵
    int half = n / 2;
    Matrix A11(half, vector<long long>(half, 0)), A12(half, vector<long long>(half, 0));
    Matrix A21(half, vector<long long>(half, 0)), A22(half, vector<long long>(half, 0));
    Matrix B11(half, vector<long long>(half, 0)), B12(half, vector<long long>(half, 0));
    Matrix B21(half, vector<long long>(half, 0)), B22(half, vector<long long>(half, 0));

    // 填充子矩阵
    for (int i = 0; i < half; ++i) {
        for (int j = 0; j < half; ++j) {
            A11[i][j] = A[i][j];
            A12[i][j] = A[i][j + half];
            A21[i][j] = A[i + half][j];
            A22[i][j] = A[i + half][j + half];

            B11[i][j] = B[i][j];
            B12[i][j] = B[i][j + half];
            B21[i][j] = B[i + half][j];
            B22[i][j] = B[i + half][j + half];
        }
    }

    // 计算7个中间矩阵P1-P7
    Matrix P1 = strassenMultiply(A11, subtract(B12, B22));
    Matrix P2 = strassenMultiply(add(A11, A12), B22);
    Matrix P3 = strassenMultiply(add(A21, A22), B11);
    Matrix P4 = strassenMultiply(A22, subtract(B21, B11));
    Matrix P5 = strassenMultiply(add(A11, A22), add(B11, B22));
    Matrix P6 = strassenMultiply(subtract(A12, A22), add(B21, B22));
    Matrix P7 = strassenMultiply(subtract(A11, A21), add(B11, B12));

    // 推导C的子矩阵
    Matrix C11 = add(subtract(add(P5, P4), P2), P6);
    Matrix C12 = add(P1, P2);
    Matrix C21 = add(P3, P4);
    Matrix C22 = subtract(subtract(add(P5, P1), P3), P7);

    // 合并子矩阵为结果C
    for (int i = 0; i < half; ++i) {
        for (int j = 0; j < half; ++j) {
            C[i][j] = C11[i][j];
            C[i][j + half] = C12[i][j];
            C[i + half][j] = C21[i][j];
            C[i + half][j + half] = C22[i][j];
        }
    }

    return res;
}

// 打印矩阵（辅助）
void printMatrix(const Matrix& mat) {
    for (auto& row : mat) {
        for (long long val : row) cout << val << " ";
        cout << endl;
    }
}

// 测试
int main() {
    // 4×4矩阵（n=4，2的幂）
    Matrix A = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
        {13, 14, 15, 16}
    };
    Matrix B = {
        {17, 18, 19, 20},
        {21, 22, 23, 24},
        {25, 26, 27, 28},
        {29, 30, 31, 32}
    };

    cout << "A*B（Strassen）：" << endl;
    Matrix C = strassenMultiply(A, B);
    printMatrix(C);
    return 0;
}
```

## 七、主定理（Master Theorem）总结（视频核心工具）

视频反复强调主定理是分析分治算法时间复杂度的核心，用于求解递归式 **`T(n) = aT(n/b) + f(n)`**（`a≥1`，`b>1`，`f(n)`为正函数）。

### 1. 主定理三案例

| 案例 | 条件                                                         | 时间复杂度结论                    | 视频应用场景                                                 |
| ---- | ------------------------------------------------------------ | --------------------------------- | ------------------------------------------------------------ |
| 1    | `f(n) = O(n^log_b a - ε)`（存在`ε>0`）                       | `T(n) = θ(n^log_b a)`             | 二分搜索、快速幂、矩阵快速幂（`log2 1=0`）；Strassen 算法（`log2 7≈2.81`） |
| 2    | `f(n) = θ(n^log_b a log^k n)`（`k≥0`）                       | `T(n) = θ(n^log_b a log^(k+1) n)` | 合并排序（`log2 2=1`，`f(n)=θ(n)` → `T(n)=θ(n logn)`）       |
| 3    | `f(n) = Ω(n^log_b a + ε)`（`ε>0`），且`af(n/b) ≤ cf(n)`（`c<1`） | `T(n) = θ(f(n))`                  | 视频未直接应用，例：`T(n)=2T(n/2)+n²` → `T(n)=θ(n²)`         |

### 2. 关键参数含义

- `a`：子问题数量（如合并排序`a=2`，Strassen`a=7`）；
- `b`：子问题规模缩小比例（均为`b=2`，子问题规模`n/2`）；
- `log_b a`：递归主导复杂度（决定递归部分是否占优）；
- `f(n)`：合并步骤时间复杂度（如合并排序`f(n)=θ(n)`）。



# 快速排序及随机化算法知识点总结

## 1. 快速排序基础

### 1.1 发明背景与核心定位

- 由**托尼・霍尔（Tony Hoare）于 1962 年发明**，是实践中高效的排序算法，被称为 “既硬又快” 的算法（“硬” 指逻辑紧凑，“快” 指实际运行效率高）。
- 核心范式：**分而治之（Divide and Conquer）**，与归并排序的 “递归合并” 相反，快排的核心是 “递归分区”。

### 1.2 快速排序的关键特点

| 特点                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| 原地排序（In-place） | 仅通过元素交换实现排序，无需额外存储（归并排序需额外空间合并，快排更省内存）。 |
| 常数因子优秀         | 渐近分析中忽略常数，但实际工程中快排的常数因子小，比同复杂度的归并排序更快。 |
| 实用性强             | 基础版本效率一般，但经简单优化（如小数据用直接排序、尾递归优化）后实用性极高。 |

## 2. 快速排序的分治流程

快排通过 “分区 - 递归 - 合并” 三步实现，其中 “合并” 步骤可忽略，核心是 “分区”。

### 2.1 分治三步骤

1. **除法（Divide）：分区操作**
	选择数组中一个元素作为**枢轴（Pivot）**，将数组划分为两部分：
	- 左子数组：所有元素 ≤ 枢轴
	- 右子数组：所有元素 ≥ 枢轴
		（注：视频中假设元素可重复，分区后左右子数组允许包含等于枢轴的元素）
2. **征服（Conquer）：递归排序**
	递归调用快排，分别对左子数组和右子数组排序。
3. **合并（Combine）：无需操作**
	由于分区后左子数组 ≤ 枢轴 ≤ 右子数组，递归排序后整个数组自然有序，无需额外合并步骤。

### 2.2 核心结论

- 快速排序的效率完全取决于**分区步骤**：分区越均衡，递归深度越小，运行时间越短。
- 分区步骤的时间复杂度为 **Θ(n)**（仅遍历数组一次，每次操作是常数时间交换）。

## 3. 分区步骤详解

### 3.1 分区的循环不变量

视频中定义的循环不变量（确保分区逻辑正确的核心条件）：
**在分区循环的任意时刻**：

- 对于子数组 `A[p..q]`（当前处理的子数组，`p` 为起始索引，`q` 为结束索引）：
	- 枢轴 `x = A[p]`（视频中选择子数组第一个元素作为枢轴）。
	- 索引 `i` 满足：`A[p..i]` 中所有元素 ≤ `x`。
	- 索引 `j` 满足：`A[i+1..j-1]` 中所有元素 ≥ `x`。
	- `A[j..q]` 为未处理元素（待判断与 `x` 的大小关系）。

### 3.2 分区伪代码

plaintext

```plaintext
// 输入：子数组A[p..q]，枢轴为A[p]
// 输出：枢轴最终位置r（满足A[p..r-1] ≤ A[r] ≤ A[r+1..q]）
Partition(A, p, q):
    x = A[p]          // 选择第一个元素作为枢轴
    i = p             // 初始化i为子数组起始位置
    for j = p+1 to q: // j从p+1开始遍历未处理元素
        if A[j] ≤ x:  // 若当前元素≤枢轴，需归入左子数组
            i = i + 1 // 扩展左子数组边界
            swap A[i] and A[j] // 交换当前元素到左子数组
    swap A[p] and A[i] // 最后将枢轴放到左、右子数组的中间（i位置）
    return i          // 返回枢轴位置
```

### 3.3 分区 C++ 实现

cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 分区函数：返回枢轴最终位置，逻辑与视频伪代码一致
int partition(vector<int>& A, int p, int q) {
    int x = A[p]; // 枢轴为子数组第一个元素
    int i = p;    // 初始化i为子数组起始索引
    for (int j = p + 1; j <= q; j++) {
        // 若当前元素≤枢轴，扩展左子数组并交换
        if (A[j] <= x) {
            i++;
            swap(A[i], A[j]);
        }
    }
    // 将枢轴放到左、右子数组中间
    swap(A[p], A[i]);
    return i; // 返回枢轴位置
}
```

### 3.4 分区示例

视频中使用的示例数组：`A = [6, 10, 13, 5, 8, 3, 2, 1]`（子数组 `p=0, q=7`，枢轴 `x=6`），步骤如下：

1. 初始状态：`i=0`，`j=1`，未处理元素 `A[1..7] = [10,13,5,8,3,2,1]`
	- `A[1]=10 > 6`：j++（j=2）
	- `A[2]=13 > 6`：j++（j=3）
	- `A[3]=5 ≤ 6`：i++（i=1），交换 `A[1]` 与 `A[3]` → 数组变为 `[6,5,13,10,8,3,2,1]`
2. 继续遍历：j=4
	- `A[4]=8 > 6`：j++（j=5）
	- `A[5]=3 ≤ 6`：i++（i=2），交换 `A[2]` 与 `A[5]` → 数组变为 `[6,5,3,10,8,13,2,1]`
3. 继续遍历：j=6
	- `A[6]=2 ≤ 6`：i++（i=3），交换 `A[3]` 与 `A[6]` → 数组变为 `[6,5,3,2,8,13,10,1]`
4. 继续遍历：j=7
	- `A[7]=1 ≤ 6`：i++（i=4），交换 `A[4]` 与 `A[7]` → 数组变为 `[6,5,3,2,1,13,10,8]`
5. 循环结束：交换 `A[p=0]` 与 `A[i=4]` → 最终数组 `[1,5,3,2,6,13,10,8]`
	- 枢轴位置 `i=4`，左子数组 `A[0..3] = [1,5,3,2]`（均 ≤6），右子数组 `A[5..7] = [13,10,8]`（均 ≥6）。

## 4. 快速排序完整实现

### 4.1 快速排序递归逻辑

基于分区函数，递归排序左、右子数组，终止条件：子数组元素个数 ≤1（无需排序）。

### 4.2 快速排序 C++ 代码

cpp

```cpp
// 快速排序主函数：排序子数组A[p..q]
void quickSort(vector<int>& A, int p, int q) {
    if (p < q) { // 终止条件：p >= q（子数组元素≤1）
        int r = partition(A, p, q); // 分区，获取枢轴位置r
        quickSort(A, p, r - 1);     // 递归排序左子数组A[p..r-1]
        quickSort(A, r + 1, q);     // 递归排序右子数组A[r+1..q]
    }
}

// 测试代码
int main() {
    vector<int> A = {6, 10, 13, 5, 8, 3, 2, 1}; // 视频示例数组
    cout << "排序前：";
    for (int num : A) cout << num << " ";
    cout << endl;

    quickSort(A, 0, A.size() - 1);

    cout << "排序后：";
    for (int num : A) cout << num << " ";
    cout << endl;
    // 输出：排序后：1 2 3 5 6 8 10 13
    return 0;
}
```

## 5. 快速排序时间复杂度分析

### 5.1 最坏情况时间复杂度（O (n²)）

#### 5.1.1 触发条件

当每次分区都极度不均衡：**一侧子数组为空，另一侧子数组含 n-1 个元素**（即枢轴是当前子数组的最值）。

- 典型场景：输入数组已排序（如 `[1,2,3,4,5]`）或逆序排序（如 `[5,4,3,2,1]`），且枢轴选择子数组第一个元素。

#### 5.1.2 递归式与推导

- 递归式：`T(n) = T(n-1) + T(0) + Θ(n)`（`T(0)` 为常数，因空数组无需排序）。
- 展开递归：`T(n) = T(n-1) + Θ(n) = T(n-2) + Θ(n-1) + Θ(n) = ... = Θ(1) + Θ(2) + ... + Θ(n) = Θ(n²)`。
- 递归树特征：高度为 n，每一层的时间和为 Θ(n) + Θ(n-1) + ... + Θ(1) = Θ(n²)。

### 5.2 最好情况时间复杂度（O (nlogn)）

#### 5.2.1 触发条件

每次分区都**绝对均衡**：枢轴是当前子数组的中位数，左、右子数组各含 `⌊n/2⌋` 和 `⌈n/2⌉` 个元素。

#### 5.2.2 递归式与推导

- 递归式：`T(n) = 2T(n/2) + Θ(n)`（与归并排序递归式一致）。
- 用主定理（Master Theorem）求解：属于主定理 Case 2（`a=2, b=2, f(n)=Θ(n)`，满足 `f(n)=Θ(n^log_b a)`），故 `T(n)=Θ(nlogn)`。

### 5.3 非极端倾斜分区的时间复杂度（仍为 O (nlogn)）

视频中举例：若每次分区为 **1:9 倾斜**（左子数组占 10%，右子数组占 90%），时间复杂度仍为 O (nlogn)。

- 递归树特征：最左侧路径深度为 `log_10 n`（每次缩小 10 倍），最右侧路径深度为 `log_(10/9) n`（每次缩小 9/10 倍），每层总时间均为 Θ(n)，总时间为 Θ(n × logn)。
- 结论：只要分区不是 “极端倾斜”（如 1:n-1），快排时间复杂度均为 O (nlogn)。

## 6. 随机化快速排序（解决最坏情况问题）

### 6.1 核心问题：固定枢轴的缺陷

基础快排的最坏情况由**输入数据分布**决定（如有序数组），若输入是 “敌对” 的（如故意传入有序数组），算法效率骤降。

### 6.2 随机化策略

- 核心思想：**随机选择枢轴**，使分区结果与输入数据分布无关，最坏情况仅由随机数生成决定（概率极低）。
- 实现方式：在分区前，随机选择子数组 `A[p..q]` 中的一个元素，与 `A[p]`（原枢轴位置）交换，再执行原分区逻辑。

### 6.3 随机化快速排序 C++ 实现

cp



```cpp
#include <cstdlib>  // 用于rand()和srand()
#include <ctime>    // 用于time()初始化随机种子

// 随机分区函数：先随机选枢轴，再分区
int randomPartition(vector<int>& A, int p, int q) {
    // 1. 随机生成枢轴索引：范围[p, q]
    srand(time(0)); // 初始化随机种子（实际工程中建议只初始化一次）
    int randIdx = p + rand() % (q - p + 1); // 生成[p, q]内的随机整数
    // 2. 交换随机选中的元素与A[p]，将随机元素作为新枢轴
    swap(A[p], A[randIdx]);
    // 3. 执行原分区逻辑
    return partition(A, p, q);
}

// 随机化快速排序主函数
void randomQuickSort(vector<int>& A, int p, int q) {
    if (p < q) {
        int r = randomPartition(A, p, q); // 随机分区
        randomQuickSort(A, p, r - 1);     // 递归排序左子数组
        randomQuickSort(A, r + 1, q);     // 递归排序右子数组
    }
}

// 测试代码
int main() {
    vector<int> A = {1,2,3,4,5}; // 原最坏情况输入（有序数组）
    cout << "排序前（有序数组）：";
    for (int num : A) cout << num << " ";
    cout << endl;

    randomQuickSort(A, 0, A.size() - 1);

    cout << "排序后：";
    for (int num : A) cout << num << " ";
    cout << endl;
    // 输出：排序后：1 2 3 4 5（仍正确，且避免O(n²)时间）
    return 0;
}
```

### 6.4 随机化快排的期望时间复杂度（Θ(nlogn)）

视频中通过**指示随机变量**和**线性期望**推导，核心步骤如下：

#### 6.4.1 定义随机变量

- 设 `T(n)` 为随机化快排排序 n 个元素的运行时间（随机变量），目标是求 `E[T(n)]`（期望运行时间）。
- 定义指示随机变量 `X_k`：若分区后左子数组含 k 个元素、右子数组含 n-k-1 个元素，则 `X_k=1`，否则 `X_k=0`（`k=0,1,...,n-1`）。
	所有 `X_k` 中仅一个为 1，其余为 0，故 `T(n) = sum_{k=0}^{n-1} X_k * [T(k) + T(n-k-1) + Θ(n)]`。

#### 6.4.2 计算期望（线性期望性质）

- 线性期望：`E[T(n)] = sum_{k=0}^{n-1} E[X_k] * [E[T(k)] + E[T(n-k-1)] + Θ(n)]`。
- 由于枢轴随机选择，每个元素被选为枢轴的概率为 `1/n`，故 `E[X_k] = 1/n`（每个分区结果的概率均等）。
- 代入化简：`E[T(n)] = (2/n) * sum_{k=0}^{n-1} E[T(k)] + Θ(n)`（因 `sum_{k=0}^{n-1} E[T(k)] = sum_{k=0}^{n-1} E[T(n-k-1)]`）。

#### 6.4.3 归纳证明期望为 Θ(nlogn)

- 假设对所有 `m < n`，`E[T(m)] ≤ a*m*logm`（a 为常数），代入递归式：
	`E[T(n)] ≤ (2a/n) * sum_{k=2}^{n-1} k*logk + Θ(n)`（忽略 k=0 和 k=1 的常数项）。
- 利用求和界 `sum_{k=2}^{n-1} k*logk ≤ (1/2)n²logn - (1/8)n²`，化简得 `E[T(n)] ≤ a*n*logn`（选择足够大的 a 吸收常数项）。
- 结论：`E[T(n)] = Θ(nlogn)`，即随机化快排的期望时间复杂度为线性对数级。

## 7. 快速排序的工程优化（视频提及）

1. **小数据优化**：当子数组元素个数较小时（如 n ≤ 5），改用插入排序（避免递归开销，插入排序在小数据上常数因子更优）。
2. **尾递归优化**：对较大的子数组递归，较小的子数组用循环处理（减少递归栈深度，避免栈溢出）。
3. **缓存友好**：原地排序减少内存访问，与虚拟内存的缓存机制兼容，实际运行效率更高。





# 线性时间排序知识点总结

## 1. 比较排序的时间复杂度下界

视频核心结论：**在比较排序模型中，任何排序算法的最坏时间复杂度下界为 Ω(n log n)，合并排序、堆排序是渐近最优的比较排序算法**。该结论通过「决策树模型」证明。

### 1.1 决策树模型定义

决策树是比较排序算法的图形化表示，满足以下规则：

- **内部节点**：表示一次元素比较，标签为 `i:j`（比较第 i 个元素 `a[i]` 和第 j 个元素 `a[j]`），有两个分支：
	- 左分支：`a[i] ≤ a[j]`
	- 右分支：`a[i] > a[j]`
- **叶子节点**：表示排序后的一个「元素排列」（即输入数组的一种有序结果）。
- **路径与时间复杂度**：从根节点到叶子节点的路径长度 = 该输入对应的排序比较次数；决策树的「高度」（最长根到叶路径）= 算法的最坏情况比较次数。

### 1.2 核心定理

对 n 个元素的排序，任何比较排序对应的决策树高度 **h ≥ Ω(n log n)**。

### 1.3 定理证明步骤

1. **决策树的叶子数 ≥ n!**
	输入数组有 `n!` 种不同的排列（所有可能的输入情况），算法需对每种排列输出正确结果，因此叶子数必须至少为 `n!`（每个叶子对应一种排列）。

2. **二叉树的叶子数上限**
	高度为 h 的二叉树，最多有 `2^h` 个叶子节点（每一层分支数翻倍）。

3. **联立不等式推导**
	由步骤 1 和 2 得：`n! ≤ 2^h`。
	对两边取以 2 为底的对数：`h ≥ log₂(n!)`。

4. **斯特林公式近似 log₂(n!)**
	斯特林公式：`n! ≈ n^n e^(-n) √(2πn)`（n 较大时）。
	取对数：

	plaintext

	```plaintext
	log₂(n!) ≈ log₂(n^n e^(-n) √(2πn)) = n log₂n - n log₂e + 0.5 log₂(2πn)
	```

	其中，`-n log₂e` 和 `0.5 log₂(2πn)` 是低阶项，可忽略，因此 `log₂(n!) ≈ n log₂n`。

5. **结论**
	`h ≥ Ω(n log n)`，即比较排序的最坏时间复杂度下界为 Ω(n log n)。

### 1.4 关键推论

- 合并排序（时间复杂度 θ(n log n)）、堆排序（时间复杂度 θ(n log n)）是「渐近最优」的比较排序算法；
- 快速排序（平均 θ(n log n)，最坏 θ(n²)）、插入排序（θ(n²)）虽不是最坏最优，但仍受限于 Ω(n log n) 下界。

## 2. 计数排序（Counting Sort）

视频指出：**突破 Ω(n log n) 下界的核心是跳出比较模型，利用元素的「整数特性」直接操作。计数排序是首个线性时间排序算法，适用于元素范围较小的整数排序**。

### 2.1 算法假设

- 输入数组 `A[0..n-1]` 中的所有元素均为 **1 到 k 的整数**（k 是元素的最大取值，且 k 较小时算法效率高）；
- 输出数组 `B[0..n-1]` 存储排序结果；
- 辅助数组 `C[0..k]` 用于计数和前缀和计算。

### 2.2 核心思想

通过「计数每个元素的出现次数」→「计算前缀和确定元素在结果中的位置」→「将元素分配到结果数组」，避免元素间的比较。

### 2.3 算法步骤

1. **初始化计数数组 C**：将 `C[0..k]` 全部设为 0（C [0] 未使用，因元素从 1 开始）；
2. **计数元素出现次数**：遍历输入数组 A，对每个 `A[j]`，执行 `C[A[j]] += 1`（C [x] 表示元素 x 出现的次数）；
3. **计算前缀和**：遍历 C 从 1 到 k，执行 `C[i] += C[i-1]`（C [x] 表示「≤ x 的元素总数」，即 x 在 B 中的最后一个位置 + 1）；
4. **分配元素到结果数组**：从后往前遍历 A（保证稳定性），对每个 `A[j]`：
	- `B[C[A[j]] - 1] = A[j]`（根据前缀和确定位置）；
	- `C[A[j]] -= 1`（更新该元素下一次出现的位置）。

### 2.4 稳定性分析

- 视频强调：**计数排序是稳定排序**（相等元素的相对顺序与输入一致），原因是「从后往前遍历输入数组」—— 后出现的相等元素会被分配到更靠后的位置，保留原顺序。
- 稳定性是基数排序依赖计数排序的关键。

### 2.5 时间复杂度

- 步骤 1（初始化 C）：O (k)；
- 步骤 2（计数）：O (n)；
- 步骤 3（前缀和）：O (k)；
- 步骤 4（分配）：O (n)；
- 总时间复杂度：**O(n + k)**。
	当 `k = O(n)` 时（元素范围与数组长度相当），计数排序是 **线性时间 O (n)**。

### 2.6 视频中的示例

输入数组 `A = [4, 1, 3, 4, 3]`（n=5，k=4，元素范围 1~4），步骤如下：

1. 初始化 C：`C = [0, 0, 0, 0, 0]`（索引 0~4）；
2. 计数后 C：`C[1]=1, C[2]=0, C[3]=2, C[4]=2`（1 出现 1 次，3 出现 2 次，4 出现 2 次）；
3. 前缀和后 C：`C[1]=1, C[2]=1, C[3]=3, C[4]=5`（≤1 的有 1 个，≤3 的有 3 个，≤4 的有 5 个）；
4. 分配（从后往前遍历 A）：
	- A[4]=3 → B[3-1=2] = 3，C[3] = 2；
	- A[3]=4 → B[5-1=4] = 4，C[4] = 4；
	- A[2]=3 → B[2-1=1] = 3，C[3] = 1；
	- A[1]=1 → B[1-1=0] = 1，C[1] = 0；
	- A[0]=4 → B[4-1=3] = 4，C[4] = 3；
5. 最终结果 B：`[1, 3, 3, 4, 4]`。

### 2.7 C++ 代码

cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 计数排序：A为输入，B为输出，n为元素个数，k为元素最大值（1<=A[j]<=k）
void countingSort(vector<int>& A, vector<int>& B, int n, int k) {
    // 步骤1：初始化计数数组C（大小k+1，索引0~k，0未使用）
    vector<int> C(k + 1, 0);
    
    // 步骤2：计数每个元素的出现次数
    for (int j = 0; j < n; ++j) {
        C[A[j]]++;
    }
    
    // 步骤3：计算前缀和（C[i] = 小于等于i的元素总数）
    for (int i = 1; i <= k; ++i) {
        C[i] += C[i - 1];
    }
    
    // 步骤4：从后往前分配元素（保证稳定性）
    for (int j = n - 1; j >= 0; --j) {
        B[C[A[j]] - 1] = A[j];  // C[A[j]]是元素A[j]的最后位置+1，减1得索引
        C[A[j]]--;              // 更新下一次出现的位置
    }
}

int main() {
    // 视频中的示例输入
    vector<int> A = {4, 1, 3, 4, 3};
    int n = A.size();
    int k = 4;  // 元素最大值
    vector<int> B(n);  // 输出数组
    
    countingSort(A, B, n, k);
    
    // 输出排序结果
    cout << "排序后结果：";
    for (int num : B) {
        cout << num << " ";
    }
    // 输出：1 3 3 4 4
    return 0;
}
```

## 3. 基数排序（Radix Sort）

视频指出：**计数排序仅适用于小范围元素，基数排序通过「按位拆分元素」+「稳定排序每一位」，将线性时间排序扩展到更大范围的整数**。

### 3.1 历史背景

- 1890 年由霍勒瑞斯（Hollerith）发明，用于美国人口普查数据排序（基于穿孔卡技术）；
- 霍勒瑞斯后续创立的公司合并为 IBM，基数排序是最早的实用排序算法之一。

### 3.2 核心思想

- **按位排序顺序**：从「最低有效位（LSB）」到「最高有效位（MSB）」依次排序（视频强调：若按 MSB 排序会产生大量 “桶”，效率低）；
- **稳定排序依赖**：每一位的排序必须使用「稳定排序算法」（视频中选用计数排序，因它是线性时间且稳定）；
- 核心逻辑：前一轮排序已保证「低位有序」，当前轮稳定排序「高位」后，整体仍保持有序。

### 3.3 正确性证明

- **归纳假设**：对元素的前 t-1 个低位（从 LSB 开始）排序后，数组已按这 t-1 位有序；
- **归纳步骤**：对第 t 位（当前高位）进行稳定排序：
	- 若两个元素的第 t 位不同：排序后高位有序，且低位已有序，整体有序；
	- 若两个元素的第 t 位相同：稳定排序会保留它们在前 t-1 位的相对顺序（即低位有序），整体仍有序；
- **基础情况**：t=1（仅排序 LSB），数组按 LSB 有序，假设成立。

### 3.4 时间复杂度分析

设元素为 **d 位整数**（如 3 位十进制数 d=3），每一位排序用计数排序（时间 O (n + k)，k 为每一位的最大值，十进制 k=9）：

- 总时间复杂度：**O(d \* (n + k))**；
- 关键优化：将元素按「r 位一组」拆分（如 32 位整数拆为 4 组 8 位），r 取 log₂n 时，d = 32 /r = O (32 /log n)，此时 k=2^r = O (n)，总时间 O (n)（当元素范围为 n^c，c 为常数时）。

### 3.5 视频中的示例

输入数组（7 个 3 位十进制数）：`A = [329, 457, 657, 839, 355, 720, 643]`，步骤如下：

1. **第 1 轮：按个位（LSB）排序**（计数排序，k=9）：
	- 个位提取：9,7,7,9,5,0,3 → 排序后个位顺序：0,5,3,7,7,9,9；
	- 结果：`[720, 355, 643, 457, 657, 329, 839]`；
2. **第 2 轮：按十位排序**（稳定计数排序，k=9）：
	- 十位提取：2,5,4,5,5,2,3 → 排序后十位顺序：2,2,3,4,5,5,5；
	- 结果：`[720, 329, 839, 643, 355, 457, 657]`；
3. **第 3 轮：按百位（MSB）排序**（稳定计数排序，k=9）：
	- 百位提取：7,3,8,6,3,4,6 → 排序后百位顺序：3,3,4,6,6,7,8；
	- 最终结果：`[329, 355, 457, 643, 657, 720, 839]`。

### 3.6 C++ 代码

cpp

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 辅助函数：提取数字x的第d位（d=1→个位，d=10→十位，d=100→百位...）
int getDigit(int x, int d) {
    return (x / d) % 10;
}

// 基于计数排序的按位排序（稳定）：按第d位排序数组A
void countingSortByDigit(vector<int>& A, int n, int d) {
    vector<int> B(n);  // 输出数组
    vector<int> C(10, 0);  // 十进制每一位0~9，计数数组C大小10
    
    // 步骤1：计数第d位的出现次数
    for (int j = 0; j < n; ++j) {
        int digit = getDigit(A[j], d);
        C[digit]++;
    }
    
    // 步骤2：计算前缀和
    for (int i = 1; i < 10; ++i) {
        C[i] += C[i - 1];
    }
    
    // 步骤3：从后往前分配（保证稳定性）
    for (int j = n - 1; j >= 0; --j) {
        int digit = getDigit(A[j], d);
        B[C[digit] - 1] = A[j];
        C[digit]--;
    }
    
    // 将排序结果复制回原数组A
    A = B;
}

// 基数排序：对n个整数排序，d为最高位数（如3位数字d=100）
void radixSort(vector<int>& A, int n, int maxDigit) {
    // 从最低有效位（d=1，个位）到最高有效位（d=maxDigit）排序
    for (int d = 1; d <= maxDigit; d *= 10) {
        countingSortByDigit(A, n, d);
    }
}

int main() {
    // 视频中的示例输入（3位十进制数，maxDigit=100）
    vector<int> A = {329, 457, 657, 839, 355, 720, 643};
    int n = A.size();
    int maxDigit = 100;  // 最高位是百位，d=100
    
    radixSort(A, n, maxDigit);
    
    // 输出排序结果
    cout << "排序后结果：";
    for (int num : A) {
        cout << num << " ";
    }
    // 输出：329 355 457 643 657 720 839
    return 0;
}
```

## 关键总结

1. 比较排序受限于 Ω(n log n) 下界，线性排序需跳出比较模型；
2. 计数排序：O (n + k)，适用于小范围整数，稳定；
3. 基数排序：O (d*(n + k))，通过按位拆分扩展到大范围整数，依赖稳定排序；
4. 线性排序的适用场景：元素为整数且范围可控（如字节数据、固定位数整数）。

编辑



# 顺序统计与中值

## 1. 核心概念

### 1.1 顺序统计量（Order Statistic）

- **定义**：给定未排序数组 `A[0..n-1]`，第 `k` 阶顺序统计量是数组中第 `k` 小的元素（`1 ≤ k ≤ n`）。
	- 当 `k=1` 时：数组的**最小值**；
	- 当 `k=n` 时：数组的**最大值**；
	- 当 `k` 为中间值时：数组的**中位数**。
- **关键需求**：不排序数组，在线性时间内找到第 `k` 小元素（避免排序的 `O(n log n)` 时间）。

### 1.2 中位数（Median）

- **定义**：数组的 “中间元素”，分两种情况：
	- 若 `n` 为**奇数**：中位数是第 `(n+1)/2` 小的元素（如 `n=7` 时，第 4 小元素）；
	- 若 `n` 为**偶数**：中位数是第 `n/2` 小和第 `n/2 + 1` 小的两个元素（如 `n=8` 时，第 4、5 小元素）；
- **核心挑战**：未排序数组中找中位数是顺序统计的典型难题，需特殊算法保证线性时间。

## 2. 随机选择算法（Randomized Select）

### 2.1 算法原理

- **核心思想**：基于 “分治” 与 “随机化”，借鉴随机快速排序的分区（Partition）操作，仅递归处理包含目标元素的子区间（避免快速排序的双区间递归，降低时间复杂度）。
- **时间复杂度**：
	- 预期时间：`O(n)`（大多数情况分区均衡）；
	- 最坏时间：`O(n²)`（极端情况每次分区选到最小 / 最大值作为 pivot，概率极低）。

### 2.2 算法步骤

给定数组 `A`、区间左端点 `p`、右端点 `q`、目标秩 `i`（第 `i` 小元素），步骤如下：

1. **基本情况**：若 `p == q`（区间仅 1 个元素），直接返回 `A[p]`；
2. **随机分区**：
	- 随机选择 `p ≤ r ≤ q` 作为 pivot 索引，交换 `A[p]` 与 `A[r]`（将 pivot 移到区间头部）；
	- 调用分区函数 `Partition(A, p, q)`，返回 pivot 最终位置 `r`（此时 `A[p..r-1] ≤ A[r] ≤ A[r+1..q]`）；
3. **计算 pivot 秩**：`k = r - p + 1`（pivot 在当前区间 `[p..q]` 中的秩，即第 `k` 小）；
4. **递归判断**：
	- 若 `i == k`：pivot 就是目标元素，返回 `A[r]`；
	- 若 `i < k`：目标在左区间 `[p..r-1]`，递归调用 `RandomizedSelect(A, p, r-1, i)`；
	- 若 `i > k`：目标在右区间 `[r+1..q]`，递归调用 `RandomizedSelect(A, r+1, q, i - k)`（右区间需调整秩：已排除左区间 `k` 个元素）。

### 2.3 示例

#### 案例输入

数组 `A = [6, 2, 5, 3, 8, 13, 10, 11]`（`n=8`），找第 `7` 小元素（`i=7`）。

#### 步骤拆解

1. 初始区间 `p=0, q=7`，随机选择 pivot 为 `A[0]=6`，调用 `Partition` 后数组变为 `[2, 5, 3, 6, 8, 13, 10, 11]`，pivot 位置 `r=3`；
2. 计算 pivot 秩 `k = 3 - 0 + 1 = 4`（6 是第 4 小元素）；
3. 目标秩 `i=7 > 4`，需递归右区间 `[4..7]`（元素 `[8,13,10,11]`），调整目标秩为 `i - k = 7 - 4 = 3`（找右区间第 3 小元素）；
4. 右区间 `p=4, q=7`，随机选择 pivot （如 `A[4]=8`），分区后数组变为 `[8, 10, 11, 13]`，pivot 位置 `r=4`，秩 `k=1`；
5. 目标秩 `3 > 1`，递归右区间 `[5..7]`（元素 `[10,11,13]`），调整目标秩为 `3 - 1 = 2`；
6. 右区间 `p=5, q=7`，随机选择 pivot （如 `A[5]=10`），分区后数组变为 `[10, 11, 13]`，pivot 位置 `r=5`，秩 `k=1`；
7. 目标秩 `2 > 1`，递归右区间 `[6..7]`（元素 `[11,13]`），调整目标秩为 `2 - 1 = 1`；
8. 右区间 `p=6, q=7`，随机选择 pivot （如 `A[6]=11`），分区后 pivot 位置 `r=6`，秩 `k=1`，与目标秩 `1` 相等，返回 `11`。

### 2.4 C++ 代码实现（与视频逻辑完全一致）

cpp







```cpp
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
using namespace std;

// 分区函数（Lomuto 分区，与随机快排一致）
// 返回 pivot 最终位置，左区间 <= pivot，右区间 >= pivot
int Partition(vector<int>& A, int p, int q) {
    int pivot = A[p];  // pivot 已通过随机交换移到 A[p]
    int i = p;         // i 记录小于 pivot 区域的右边界

    for (int j = p + 1; j <= q; j++) {
        if (A[j] <= pivot) {
            i++;
            swap(A[i], A[j]);  // 扩展小于 pivot 区域
        }
    }
    swap(A[p], A[i]);  // 将 pivot 放到最终位置
    return i;
}

// 随机选择 pivot 并分区
int RandomizedPartition(vector<int>& A, int p, int q) {
    // 随机生成 [p, q] 范围内的索引
    int r = p + rand() % (q - p + 1);
    swap(A[p], A[r]);  // 将随机 pivot 移到区间头部
    return Partition(A, p, q);
}

// 随机选择算法：找 A[p..q] 中第 i 小元素
int RandomizedSelect(vector<int>& A, int p, int q, int i) {
    // 基本情况：区间仅1个元素
    if (p == q) {
        return A[p];
    }

    // 随机分区，获取 pivot 位置 r
    int r = RandomizedPartition(A, p, q);
    // 计算 pivot 在当前区间的秩 k
    int k = r - p + 1;

    // 递归判断目标位置
    if (i == k) {
        return A[r];          // 目标是 pivot
    } else if (i < k) {
        return RandomizedSelect(A, p, r - 1, i);  // 目标在左区间
    } else {
        return RandomizedSelect(A, r + 1, q, i - k);  // 目标在右区间，调整秩
    }
}

// 测试函数
int main() {
    srand(time(0));  // 初始化随机种子（保证每次运行随机 pivot 不同）
    vector<int> A = {6, 2, 5, 3, 8, 13, 10, 11};
    int n = A.size();
    int k = 7;  // 找第 7 小元素（视频案例）

    int result = RandomizedSelect(A, 0, n - 1, k);
    cout << "数组第 " << k << " 小元素是：" << result << endl;  // 输出：11

    return 0;
}
```

## 3. 最坏情况线性时间 SELECT 算法

### 3.1 算法原理

- **核心痛点**：随机选择算法存在 `O(n²)` 最坏情况，需通过 “确定性分区” 避免随机化的极端情况。
- **关键创新**：通过 “5 个元素一组找中位数” 的策略，确定性地选择一个**均衡 pivot**（保证 pivot 至少比 3n/10 个元素大、至多比 7n/10 个元素小），从而使递归子问题大小可控。
- **时间复杂度**：最坏情况 `O(n)`（递归式 `T(n) = T(n/5) + T(7n/10) + O(n)`，解为线性）。

### 3.2 算法步骤

给定数组 `A`、区间左端点 `p`、右端点 `q`、目标秩 `i`，步骤如下：

1. **分组**：将 `A[p..q]` 分成 `m = ceil((q-p+1)/5)` 组，每组 5 个元素（最后一组不足 5 个也保留）；
2. **找组中位数**：
	- 对每组排序（5 个元素排序为常数时间 `O(1)`）；
	- 取每组的中位数（第 3 小元素，0 索引为 2），组成中位数数组 `M`；
3. **找中位数的中位数（pivot）**：递归调用 `SELECT(M, 0, m-1, ceil(m/2))`，得到 `x`（`x` 是所有组中位数的中位数，作为确定性 pivot）；
4. **分区**：用 `x` 作为 pivot 对 `A[p..q]` 分区，返回 pivot 位置 `r`，计算秩 `k = r - p + 1`；
5. **递归判断**：与随机选择一致：
	- 若 `i == k`：返回 `x`；
	- 若 `i < k`：递归左区间 `[p..r-1]`；
	- 若 `i > k`：递归右区间 `[r+1..q]`，调整目标秩为 `i - k`。

### 3.3 示例

#### 案例输入

数组 `A = [12, 3, 5, 7, 19, 26, 2, 4, 21, 13, 18]`（`n=11`），找中位数（第 6 小元素，`i=6`）。

#### 步骤拆解

1. **分组**：分成 3 组（前两组 5 个元素，最后一组 1 个）：
	- 组 1：`[12, 3, 5, 7, 19]` → 排序后 `[3,5,7,12,19]` → 中位数 `7`；
	- 组 2：`[26, 2, 4, 21, 13]` → 排序后 `[2,4,13,21,26]` → 中位数 `13`；
	- 组 3：`[18]` → 中位数 `18`；
2. **中位数数组**：`M = [7, 13, 18]`；
3. **找 pivot x**：递归找 `M` 的中位数（第 2 小元素），得到 `x=13`；
4. **分区**：用 `13` 分区原数组，得到 `A = [3,5,7,2,4,13,12,19,26,21,18]`，pivot 位置 `r=5`，秩 `k=6`；
5. 目标秩 `i=6 == k`，直接返回 `13`（即数组中位数）。

### 3.4 C++ 代码实现（与视频逻辑完全一致）

cpp

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 分区函数（Lomuto 分区，与随机选择一致）
int Partition(vector<int>& A, int p, int q, int pivot_val) {
    // 先找到 pivot_val 的位置并移到区间头部
    int pivot_idx = p;
    for (; pivot_idx <= q; pivot_idx++) {
        if (A[pivot_idx] == pivot_val) {
            break;
        }
    }
    swap(A[p], A[pivot_idx]);

    // 标准 Lomuto 分区
    int pivot = A[p];
    int i = p;
    for (int j = p + 1; j <= q; j++) {
        if (A[j] <= pivot) {
            i++;
            swap(A[i], A[j]);
        }
    }
    swap(A[p], A[i]);
    return i;
}

// 最坏情况线性时间 SELECT 算法
int SELECT(vector<int>& A, int p, int q, int i) {
    // 基本情况：区间仅1个元素
    if (p == q) {
        return A[p];
    }

    // 步骤1：分组（5个元素一组），步骤2：找每组中位数
    int m = 0;  // 中位数数组 M 的大小
    vector<int> M;
    for (int j = p; j <= q; j += 5) {
        // 当前组的右边界（不足5个取 q）
        int end = min(j + 4, q);
        // 步骤2.1：每组排序（5个元素，O(1) 时间）
        sort(A.begin() + j, A.begin() + end + 1);
        // 步骤2.2：取组中位数（第3小元素，索引 j+2；若组大小<5，取中间位置）
        int mid_idx = j + (end - j) / 2;
        M.push_back(A[mid_idx]);
        m++;
    }

    // 步骤3：递归找 M 的中位数（pivot x）
    int x = SELECT(M, 0, m - 1, (m + 1) / 2);  // ceil(m/2) = (m+1)/2（整数除法）

    // 步骤4：用 x 分区，得到 pivot 位置 r
    int r = Partition(A, p, q, x);
    // 步骤5：计算 pivot 秩 k
    int k = r - p + 1;

    // 递归判断
    if (i == k) {
        return x;
    } else if (i < k) {
        return SELECT(A, p, r - 1, i);
    } else {
        return SELECT(A, r + 1, q, i - k);
    }
}

// 测试函数
int main() {
    vector<int> A = {12, 3, 5, 7, 19, 26, 2, 4, 21, 13, 18};
    int n = A.size();
    int k = 6;  // 找第 6 小元素（中位数，n=11 为奇数）

    int result = SELECT(A, 0, n - 1, k);
    cout << "数组第 " << k << " 小元素（中位数）是：" << result << endl;  // 输出：13

    return 0;
}
```

## 4. 两种算法对比（视频核心结论）

| 特性               | 随机选择算法（Randomized Select） | 最坏情况 SELECT 算法               |
| ------------------ | --------------------------------- | ---------------------------------- |
| 时间复杂度（预期） | `O(n)`                            | `O(n)`                             |
| 时间复杂度（最坏） | `O(n²)`（概率极低）               | `O(n)`（确定性）                   |
| 实现复杂度         | 简单（依赖随机分区）              | 复杂（分组、多轮递归）             |
| 实际应用           | 常用（常数因子小，极端情况罕见）  | 理论价值高（实际少用，常数因子大） |
| pivot 选择方式     | 随机选择                          | 确定性（中位数的中位数）           |

## 5. 关键应用（视频提及）

- 快速排序优化：用中位数作为 pivot，避免最坏情况；
- 数据划分：线性时间内将数组分成 “小于中位数”“等于中位数”“大于中位数” 三部分；
- Top-K 问题：高效找到前 K 大 / 小元素（无需排序）。





# 哈希表

## 一、符号表与动态集

### 1. 符号表问题背景

视频中以**编译器符号表**为例，说明符号表的核心需求：存储 “键 - 值（卫星数据）” 对，支持对键的快速插入、删除和搜索。

- 每条记录包含：`键（Key）` + `卫星数据（Satellite Data）`（如变量的内存地址、类型等），记录通常用指针指向实际数据。

### 2. 动态集的基本操作

动态集是指支持 “修改集合成员” 的数据集（区别于仅支持查询的静态集），核心操作如下：

| 操作           | 功能描述                                                     |
| -------------- | ------------------------------------------------------------ |
| 插入（Insert） | 将记录 X 加入表中，更新表的成员                              |
| 删除（Delete） | 从表中移除记录 X（需传入记录指针；若仅知键，需先搜索再删除） |
| 搜索（Search） | 给定键 k，返回键为 k 的记录 X；若不存在，返回`NULL`          |

## 二、直接访问表（Direct Access Table）

### 1. 原理与适用条件

直接访问表是哈希表的 “雏形”，利用数组索引直接映射键，实现 O (1) 操作效率，但存在严格限制：

- **适用条件**：键的取值范围是**小而连续的整数集**（如键 ∈ {0, 1, 2, ..., m-1}），且所有键互不相同。
- **核心思想**：创建大小为 m 的数组 T，数组索引对应键值。若记录 X 的键为 k，则`T[k] = X`；若槽 k 无记录，则`T[k] = NULL`。

### 2. 优缺点

- **优点**：操作极高效（插入 / 删除 / 搜索均为 O (1)），实现简单。
- **缺点**：键空间过大时无法使用（如 64 位整数键需数组大小为 2^64，内存不可承受）；不支持非整数键（如字符串、人名）。

### 3. C++ 实现示例

cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 直接访问表：键范围0~m-1，存储int类型卫星数据
class DirectAccessTable {
private:
    vector<int*> table;  // 数组存储指针，NULL表示空槽
    int m;               // 表大小（键的最大范围）

public:
    // 初始化：键范围0~size-1
    DirectAccessTable(int size) : m(size) {
        table.resize(m, nullptr);  // 所有槽初始化为NULL
    }

    // 插入：键k，卫星数据data
    void insert(int k, int data) {
        if (k < 0 || k >= m) {
            cout << "键超出范围！" << endl;
            return;
        }
        if (table[k] != nullptr) {
            cout << "键" << k << "已存在，无法重复插入！" << endl;
            return;
        }
        table[k] = new int(data);  // 分配内存存储卫星数据
    }

    // 搜索：给定键k，返回卫星数据；不存在返回NULL
    int* search(int k) {
        if (k < 0 || k >= m) {
            cout << "键超出范围！" << endl;
            return nullptr;
        }
        return table[k];  // 直接索引，O(1)
    }

    // 删除：给定键k
    void remove(int k) {
        if (k < 0 || k >= m) {
            cout << "键超出范围！" << endl;
            return;
        }
        if (table[k] != nullptr) {
            delete table[k];  // 释放内存
            table[k] = nullptr;  // 标记为空槽
        } else {
            cout << "键" << k << "不存在，无法删除！" << endl;
        }
    }

    ~DirectAccessTable() {
        // 析构：释放所有非空槽的内存
        for (int i = 0; i < m; ++i) {
            if (table[i] != nullptr) {
                delete table[i];
            }
        }
    }
};

// 测试
int main() {
    DirectAccessTable dat(10);  // 键范围0~9
    dat.insert(3, 100);         // 键3，数据100
    dat.insert(5, 200);         // 键5，数据200

    int* res1 = dat.search(3);
    if (res1 != nullptr) cout << "键3的卫星数据：" << *res1 << endl;  // 输出100

    dat.remove(3);
    int* res2 = dat.search(3);
    if (res2 == nullptr) cout << "键3已删除，搜索结果为空" << endl;  // 输出空提示

    return 0;
}
```

## 三、哈希表核心概念

### 1. 哈希表的定义

为解决直接访问表的 “键空间过大” 问题，引入**哈希表**：

- 利用**哈希函数 h**将 “大键空间 U”（如 64 位整数、字符串）映射到 “小槽位集合 T”（大小为 m），即`h: U → {0, 1, ..., m-1}`。
- 哈希表存储动态集 S（S 是 U 的子集，且 | S| ≪ |U|），记录 X 的键 k 通过 h (k) 映射到槽 h (k)。

### 2. 碰撞（Collision）

- **定义**：两个不同的键 k1 ≠ k2，经哈希函数映射后得到相同槽位（即`h(k1) = h(k2)`），称为碰撞。
- **必然性**：因 | S | 可能大于 m（或键空间远大于 m），碰撞无法完全避免，需设计碰撞解决策略。

## 四、哈希函数设计

视频中介绍了两种实用的哈希函数，核心目标是 “均匀分布键到槽位，减少碰撞”。

### 1. 除法哈希（Division Method）

#### 原理

哈希函数为 `h(k) = k mod m`，其中 m 是哈希表的槽位数量。

- **关键优化**：m 需选择**质数**，且避免接近 2 的幂或 10 的幂（防止键的低阶位重复导致分布不均）。
	例：若 m 为偶数，所有偶数键会映射到偶数槽，奇数键映射到奇数槽，浪费一半槽位；若 m 为 2^r，哈希结果仅依赖 k 的低 r 位，分布不均。

#### C++ 实现示例

cpp

```cpp
// 除法哈希：k mod m（m为质数）
int divisionHash(int k, int m) {
    // 处理负键：确保结果非负
    return (k % m + m) % m;
}

// 测试：m=11（质数）
int main() {
    int m = 11;
    cout << divisionHash(49, m) << endl;  // 49 mod11=5
    cout << divisionHash(86, m) << endl;  // 86 mod11=9
    cout << divisionHash(52, m) << endl;  // 52 mod11=8
    return 0;
}
```

### 2. 乘法哈希（Multiplication Method）

#### 原理

适用于 m 为 2 的幂（如 m=2^r），步骤如下：

1. 设计算机字长为 w 位（如 32 位、64 位），选择一个**奇数 a**（满足 `2^(w-1) < a < 2^w`，确保分布均匀）。
2. 计算 `k * a`，得到一个 2w 位的结果（高 w 位 H，低 w 位 L）。
3. 取低 w 位 L 的**高 r 位**作为哈希结果，即 `h(k) = (L >> (w - r))`（因 m=2^r，r 位可覆盖所有槽位）。

#### 示例（视频中的 7 位字长案例）

- 条件：w=7（字长 7 位），r=3（m=2^3=8），a=11（二进制 1011，奇数），k=5（二进制 000101）。
- 计算：
	1. `k*a = 5*11=55`，二进制为 `00110111`（2w=14 位，高 7 位 0000110，低 7 位 110111）。
	2. 取低 7 位 L=110111，右移 `w-r=4` 位，得到高 3 位 `110`（十进制 6）。
	3. 哈希结果 `h(5)=6`。

#### C++ 实现示例（32 位字长）

cpp

```cpp
// 乘法哈希：w=32位，m=2^r（r=10 → m=1024）
int multiplicationHash(int k, int r) {
    const int w = 32;                // 计算机字长（32位）
    const unsigned int a = 1664525;  // 推荐奇数（接近(√5-1)/2 * 2^w）
    unsigned int product = (unsigned int)k * a;  // 计算k*a（32位*32位=64位，取低32位）
    // 取低w位的高r位：右移(w - r)位
    return (product >> (w - r));
}

// 测试：r=10（m=1024）
int main() {
    int r = 10;
    cout << multiplicationHash(496, r) << endl;  // 496的哈希结果（示例值）
    cout << multiplicationHash(123, r) << endl;  // 123的哈希结果（示例值）
    return 0;
}
```

## 五、碰撞解决策略一：链接法（Chaining）

### 1. 原理

每个槽位存储一个**链表**，所有哈希到同一槽位的记录依次插入链表中。

- 插入：计算 h (k)，将记录插入对应槽的链表头部（O (1)，若链表无排序）。
- 搜索：计算 h (k)，遍历对应槽的链表，查找键为 k 的记录。
- 删除：先搜索到记录，再从链表中移除（需链表支持节点删除）。

### 2. 复杂度分析

- **负载因子 α**：定义为 `α = n/m`（n 为记录数，m 为槽位数量），表示 “平均每个槽的链表长度”。
- **最坏情况**：所有记录哈希到同一槽，链表退化为线性表，插入 / 搜索 / 删除均为 O (n)。
- **平均情况**（理想哈希函数，键均匀分布）：
	- 成功搜索：O (1 + α)（1 为计算哈希的时间，α 为遍历链表的平均长度）。
	- 不成功搜索：O (1 + α)（需遍历满一个平均长度的链表）。
	- 插入 / 删除：O (1 + α)（同搜索）。

### 3. C++ 实现示例（链表版）

cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 哈希表节点：存储键、卫星数据、下一个节点指针
struct HashNode {
    int key;          // 键
    int satelliteData;// 卫星数据
    HashNode* next;   // 指向下一个节点

    HashNode(int k, int data) : key(k), satelliteData(data), next(nullptr) {}
};

// 链接法哈希表
class ChainedHashTable {
private:
    vector<HashNode*> table;  // 数组存储链表头指针
    int m;                    // 槽位数量（m为质数，除法哈希）
    int n;                    // 记录总数（用于计算α）

    // 除法哈希函数
    int hash(int k) {
        return (k % m + m) % m;  // 处理负键
    }

public:
    // 初始化：m为槽位数量（需传入质数）
    ChainedHashTable(int slotCount) : m(slotCount), n(0) {
        table.resize(m, nullptr);  // 所有槽初始化为空链表（头指针为NULL）
    }

    // 插入：键k，卫星数据data
    void insert(int k, int data) {
        int slot = hash(k);
        // 检查键是否已存在（避免重复插入）
        HashNode* curr = table[slot];
        while (curr != nullptr) {
            if (curr->key == k) {
                cout << "键" << k << "已存在，无法重复插入！" << endl;
                return;
            }
            curr = curr->next;
        }
        // 插入到链表头部（O(1)）
        HashNode* newNode = new HashNode(k, data);
        newNode->next = table[slot];
        table[slot] = newNode;
        n++;  // 记录数+1
    }

    // 搜索：给定键k，返回卫星数据；不存在返回NULL
    int* search(int k) {
        int slot = hash(k);
        HashNode* curr = table[slot];
        // 遍历链表查找键
        while (curr != nullptr) {
            if (curr->key == k) {
                return &(curr->satelliteData);  // 找到，返回卫星数据地址
            }
            curr = curr->next;
        }
        return nullptr;  // 未找到
    }

    // 删除：给定键k
    void remove(int k) {
        int slot = hash(k);
        HashNode* curr = table[slot];
        HashNode* prev = nullptr;

        // 遍历链表查找待删除节点
        while (curr != nullptr && curr->key != k) {
            prev = curr;
            curr = curr->next;
        }

        if (curr == nullptr) {
            cout << "键" << k << "不存在，无法删除！" << endl;
            return;
        }

        // 移除节点
        if (prev == nullptr) {
            // 待删除节点是链表头
            table[slot] = curr->next;
        } else {
            // 待删除节点是中间或尾部
            prev->next = curr->next;
        }

        delete curr;  // 释放内存
        n--;          // 记录数-1
    }

    // 打印哈希表（用于调试）
    void printTable() {
        for (int i = 0; i < m; ++i) {
            cout << "槽" << i << ": ";
            HashNode* curr = table[i];
            while (curr != nullptr) {
                cout << "(" << curr->key << "," << curr->satelliteData << ") → ";
                curr = curr->next;
            }
            cout << "NULL" << endl;
        }
    }

    ~ChainedHashTable() {
        // 析构：释放所有链表节点
        for (int i = 0; i < m; ++i) {
            HashNode* curr = table[i];
            while (curr != nullptr) {
                HashNode* temp = curr;
                curr = curr->next;
                delete temp;
            }
        }
    }
};

// 测试：m=11（质数），模拟视频中碰撞案例
int main() {
    ChainedHashTable cht(11);  // 11个槽位

    // 插入3个键，其中49、20、60哈希到同一槽（49 mod11=5，20 mod11=9？调整为49、60、71均mod11=5）
    cht.insert(49, 100);   // 键49 → 槽5
    cht.insert(60, 200);   // 键60 → 60 mod11=5（碰撞）
    cht.insert(71, 300);   // 键71 → 71 mod11=5（碰撞）
    cht.insert(86, 400);   // 键86 → 86 mod11=9（无碰撞）

    cout << "哈希表初始状态：" << endl;
    cht.printTable();
    // 输出：槽5: (71,300) → (60,200) → (49,100) → NULL（头部插入，顺序逆序）

    // 搜索
    int* res1 = cht.search(60);
    if (res1 != nullptr) cout << "搜索键60：" << *res1 << endl;  // 输出200

    // 删除
    cht.remove(60);
    cout << "删除键60后：" << endl;
    cht.printTable();
    // 输出：槽5: (71,300) → (49,100) → NULL

    return 0;
}
```

## 六、碰撞解决策略二：开放寻址法（Open Addressing）

### 1. 原理

不使用链表，所有记录直接存储在哈希表的槽位中。若槽 h (k) 已占用（碰撞），则通过**探针序列（Probe Sequence）** 依次检查后续槽位，直到找到空槽（插入）或目标记录（搜索）。

- **核心要求**：探针序列必须是`{0, 1, ..., m-1}`的一个排列（确保遍历所有槽位，避免死循环）。
- **限制**：负载因子 α 必须小于 1（α = n/m < 1），否则表满无法插入。
- **删除问题**：不能直接将槽位设为`NULL`（会断裂后续探针序列），需用 “已删除标记” 标记槽位（搜索时跳过标记，插入时可复用标记槽）。

### 2. 探针序列设计（视频重点）

#### （1）线性探测（Linear Probing）

- 探针序列：`h(k, i) = (h1(k) + i) mod m`（i=0,1,...,m-1），其中 h1 (k) 是基础哈希函数（如除法哈希）。
- 问题：**主聚集（Primary Clustering）** —— 碰撞的记录会形成连续的 “占用块”，后续插入需遍历整个块，效率下降。

#### （2）二次探测（Quadratic Probing）

- 探针序列：`h(k, i) = (h1(k) + c1*i + c2*i²) mod m`（c1、c2 为常数）。
- 问题：**次聚集（Secondary Clustering）** —— 不同键若 h1 (k) 相同，探针序列完全相同，仍会聚集。

#### （3）双重哈希（Double Hashing，视频推荐）

- 探针序列：`h(k, i) = (h1(k) + i*h2(k)) mod m`（i=0,1,...,m-1），其中 h2 (k) 是第二个哈希函数。
- **关键优化**：h2 (k) 需与 m 互质（如 m 为 2 的幂时，h2 (k) 取奇数；m 为质数时，h2 (k) 取 1~m-1 的整数），确保探针序列是全排列。
- 优点：无聚集问题，分布最均匀。

### 3. 复杂度分析

- **最坏情况**：O (m)（需遍历所有槽位）。
- **平均情况**（理想探针序列）：
	- 成功搜索：O (1/(1-α))。
	- 不成功搜索：O (1/(1-α))。
- 示例：α=0.5（表半满）时，平均探针数为 2；α=0.9（表 90% 满）时，平均探针数为 10，效率显著下降（视频强调 “避免表过满”）。

### 4. C++ 实现示例（双重哈希）

cpp

```cpp
#include <iostream>
#include <vector>
#include <climits>  // 用于INT_MIN（标记已删除槽位）
using namespace std;

// 开放寻址法哈希表（双重哈希）
class OpenAddressHashTable {
private:
    vector<int> keys;       // 存储键（INT_MIN=已删除，INT_MAX=空槽）
    vector<int> satellite;  // 存储卫星数据
    int m;                  // 槽位数量（m为质数）
    int n;                  // 记录总数

    // 基础哈希函数h1：除法哈希
    int h1(int k) {
        return (k % m + m) % m;
    }

    // 第二个哈希函数h2：与m互质（m为质数时，h2(k) = k mod (m-1) + 1，确保1<=h2(k)<=m-1）
    int h2(int k) {
        return (k % (m - 1) + (m - 1)) % (m - 1) + 1;
    }

    // 双重哈希探针序列：h(k,i) = (h1(k) + i*h2(k)) mod m
    int probe(int k, int i) {
        return (h1(k) + i * h2(k)) % m;
    }

public:
    // 初始化：m为槽位数量（需传入质数）
    OpenAddressHashTable(int slotCount) : m(slotCount), n(0) {
        keys.resize(m, INT_MAX);       // 初始所有槽为空（INT_MAX）
        satellite.resize(m, 0);        // 卫星数据初始为0（无意义）
    }

    // 插入：键k，卫星数据data（返回插入的槽位；表满返回-1）
    int insert(int k, int data) {
        if (α() >= 1.0) {  // α = n/m >=1，表满
            cout << "哈希表已满，无法插入！" << endl;
            return -1;
        }

        for (int i = 0; i < m; ++i) {
            int slot = probe(k, i);
            if (keys[slot] == INT_MAX || keys[slot] == INT_MIN) {  // 空槽或已删除槽
                keys[slot] = k;
                satellite[slot] = data;
                n++;
                return slot;
            }
            if (keys[slot] == k) {  // 键已存在
                cout << "键" << k << "已存在，无法重复插入！" << endl;
                return -1;
            }
        }
        return -1;  // 遍历所有槽仍未找到位置（理论上α<1时不会发生）
    }

    // 搜索：给定键k，返回卫星数据；不存在返回NULL
    int* search(int k) {
        for (int i = 0; i < m; ++i) {
            int slot = probe(k, i);
            if (keys[slot] == INT_MAX) {  // 遇到空槽，停止搜索（键不存在）
                return nullptr;
            }
            if (keys[slot] == k) {        // 找到键
                return &(satellite[slot]);
            }
            // 遇到已删除槽，继续搜索（探针序列未结束）
        }
        return nullptr;  // 遍历所有槽未找到
    }

    // 删除：给定键k（用INT_MIN标记已删除）
    void remove(int k) {
        for (int i = 0; i < m; ++i) {
            int slot = probe(k, i);
            if (keys[slot] == INT_MAX) {  // 键不存在
                cout << "键" << k << "不存在，无法删除！" << endl;
                return;
            }
            if (keys[slot] == k) {        // 找到键，标记为已删除
                keys[slot] = INT_MIN;
                n--;
                return;
            }
        }
        cout << "键" << k << "不存在，无法删除！" << endl;
    }

    // 计算负载因子α
    double α() {
        return (double)n / m;
    }

    // 打印哈希表（用于调试）
    void printTable() {
        cout << "哈希表（INT_MAX=空，INT_MIN=已删除）：" << endl;
        for (int i = 0; i < m; ++i) {
            cout << "槽" << i << ": ";
            if (keys[i] == INT_MAX) {
                cout << "空";
            } else if (keys[i] == INT_MIN) {
                cout << "已删除";
            } else {
                cout << "键=" << keys[i] << ", 数据=" << satellite[i];
            }
            cout << endl;
        }
    }
};

// 测试：模拟视频中496插入案例（m=11，质数）
int main() {
    OpenAddressHashTable oaht(11);  // 11个槽位

    // 先插入两个键，占用槽1和槽3（模拟视频中“槽1和3已占用”）
    oaht.insert(10, 500);  // 键10：h1=10 mod11=1，h2=10 mod10+1=1 → 槽1
    oaht.insert(12, 600);  // 键12：h1=12 mod11=1，h2=12 mod10+1=3 → 槽(1+1*3)=4？调整为键14：h1=14 mod11=3，插入槽3

    cout << "插入前状态（槽1和3已占用）：" << endl;
    oaht.printTable();

    // 插入键496（视频示例）
    int slot496 = oaht.insert(496, 700);
    cout << "键496插入到槽" << slot496 << endl;  // 计算：h1=496 mod11=1，h2=496 mod10+1=7 → 探针序列：1（占用）→ 1+1*7=8（空）→ 插入槽8

    // 搜索键496
    int* res = oaht.search(496);
    if (res != nullptr) cout << "搜索键496：" << *res << endl;  // 输出700

    // 删除键496
    oaht.remove(496);
    cout << "删除键496后：" << endl;
    oaht.printTable();  // 槽8标记为“已删除”

    return 0;
}
```

## 七、核心总结

1. **哈希表目标**：解决直接访问表 “键空间过大” 问题，通过哈希函数将大键映射到小槽位，实现高效操作。
2. **哈希函数**：除法哈希（m 选质数）、乘法哈希（m 选 2 的幂，a 选奇数），核心是 “均匀分布”。
3. **碰撞解决**：
	- 链接法：槽位存链表，支持 α>1，实现简单，删除无副作用。
	- 开放寻址法：无链表，α<1，删除需标记，推荐双重哈希（无聚集）。
4. **负载因子 α**：决定平均操作效率，α 越小效率越高，开放寻址法需 α<1。

编辑



# 全域哈希与完全哈希知识点总结

## 1. 哈希函数的核心痛点

### 1.1 问题背景

- **场景**：为编译器设计符号表（存储变量名、函数名等），核心需求是**查询速度快**（保证编译效率）。
- **风险**：若使用**固定哈希函数**，对手（竞品开发者）可通过分析哈希函数逻辑，构造一组键（如变量名），使其全部哈希到同一个槽（碰撞）。
- **后果**：查询时需遍历槽对应的链表，时间复杂度从期望 O (1) 退化为 O (n)，编译速度骤降。

### 1.2 解决方案动机

需让哈希函数具备**运行时不可预测性**：随机选择哈希函数，即使对手查看代码，也无法提前预测实际使用的哈希函数，从而无法构造针对性碰撞键 —— 这是全域哈希的核心设计目标。

## 2. 全域哈希（Universal Hashing）

### 2.1 全域哈希的定义

设哈希表槽数为`m`，哈希函数集合为`H`。若对**任意两个不同的键`x`、`y`**，满足以下条件，则`H`是**全域哈希函数集合**：
H的总函数数量满足 *h*(*x*)=*h*(*y*) 的哈希函数数量​=*m*1​

- 本质：从`H`中随机选择一个哈希函数`h`，`x`与`y`发生碰撞的概率为`1/m`（与随机哈希到同一槽的概率一致）。

### 2.2 全域哈希的关键定理（碰撞次数期望）

#### 2.2.1 定理陈述

若`H`是全域哈希函数集合，哈希表存储`n`个键，负载系数`α = n/m`（`α`为每个槽的平均键数），则对任意键`x`，其与其他键的**碰撞次数期望***E*[*C**x*]≤*α*。

#### 2.2.2 定理证明

1. **定义随机变量**：

	- 设`C_x`为键`x`与其他键的碰撞次数（依赖哈希函数`h`的选择）。
	- 定义指示变量`c_{x,y}`：若`h(x)=h(y)`，则`c_{x,y}=1`；否则`c_{x,y}=0`（`y`是除`x`外的任意键）。
	- 显然：*C**x*=∑*y*∈键集合*y*=*x**c**x*,*y*。

2. **应用线性期望性质**：
	线性期望不依赖变量独立性，因此：
	*E*[*C**x*​]=*E*[∑*y*=*x*​​*c**x*,*y*​]=∑*y*=*x*​​*E*[*c**x*,*y*​]

3. **代入全域哈希定义**：
	由全域哈希定义，对任意`y≠x`，*E*[*c**x*,*y*​]=*P*(*h*(*x*)=*h*(*y*))=1/*m*。
	总共有`n-1`个这样的`y`，故：
	*E*[*C**x*​]=(*n*−1)⋅*m*1​≈*m**n*​=*α*

	结论：任意键的碰撞次数期望不超过负载系数`α`，保证了期望查询效率。

### 2.3 全域哈希的构造

视频中给出**当`m`为质数**时的工程化构造方法，是全域哈希的核心实现方式。

#### 2.3.1 构造步骤

1. **键的基`m`分解**：
	对任意键`k`，将其表示为基`m`的`r+1`位数字（`0 ≤ k_i < m`），即：
	*k*=*k*0​+*k*1​⋅*m*+*k*2​⋅*m*2+⋯+*k**r*​⋅*m**r*
	- 示例：`m=7`（质数），`k=10` → `10 = 3 + 1×7` → `k_0=3`，`k_1=1`，`r=1`（`k_0`是最低位）。
2. **随机选择哈希函数参数**：
	随机生成`r+1`维向量`a = (a_0, a_1, ..., a_r)`，其中`0 ≤ a_i < m`（`a`唯一决定一个哈希函数）。
3. **哈希函数计算**：
	键`k`的哈希值为向量`a`与`(k_0,k_1,...,k_r)`的**点积模`m`**：
	*h**a*​(*k*)=(*a*0​⋅*k*0​+*a*1​⋅*k*1​+⋯+*a**r*​⋅*k**r*​)mod*m*

#### 2.3.2 构造正确性证明

需证明上述`H`（所有`a`对应的`h_a`）是全域的：

1. 任取不同键`x`、`y`，其基`m`分解必有至少一位不同（否则`x=y`），不妨设`x_0 ≠ y_0`（对称性）。
2. 碰撞条件：`h_a(x) = h_a(y)` → 点积模`m`相等：
	∑*i*=0*r*​*a**i*​(*x**i*​−*y**i*​)≡0(mod*m*)
3. 整理方程：分离`i=0`项与其他项：
	*a*0​(*x*0​−*y*0​)≡−∑*i*=1*r*​*a**i*​(*x**i*​−*y**i*​)(mod*m*)
4. **质数逆元性质**：
	因`m`是质数，且`x_0 ≠ y_0`（`x_0 - y_0`不被`m`整除），存在`x_0 - y_0`的**乘法逆元`inv`**，满足：
	(*x*0​−*y*0​)⋅*in**v*≡1(mod*m*)
	因此`a_0`可唯一表示为：
	*a*0​≡−*in**v*⋅∑*i*=1*r*​*a**i*​(*x**i*​−*y**i*​)(mod*m*)
5. **计数碰撞函数数量**：
	- `a_1~a_r`可任意选择（共`m^r`种选择），`a_0`由上式唯一确定（1 种选择）。
	- 碰撞函数总数为`m^r`，`H`总函数数为`m^(r+1)`，比例为`1/m`，满足全域定义。

### 2.4 全域哈希的 C++ 实现

#### 2.4.1 完整代码

cpp

```cpp
#include <iostream>
#include <vector>
#include <random>
using namespace std;

// 全域哈希类（严格遵循视频中质数m的构造）
class UniversalHash {
private:
    int m;                  // 哈希表槽数（必须是质数）
    vector<int> a;          // 随机参数向量a = (a0, a1, ..., ar)
    int r;                  // 键的基m分解位数-1（r+1位，此处取5覆盖常见键范围）

    // 功能：将键k分解为基m的各位（返回k0, k1, ..., kr）
    vector<int> decomposeKey(int k) const {
        vector<int> bits;
        if (k == 0) {
            bits.push_back(0);
            return bits;
        }
        // 分解逻辑：反复取模m得到低位，除以m推进高位
        while (k > 0) {
            bits.push_back(k % m);
            k = k / m;
        }
        return bits;
    }

    // 功能：计算x在模m下的乘法逆元（m是质数，x≠0 mod m）
    int modInverse(int x) const {
        int m = this->m;
        int m0 = m;
        int y = 0, x0 = 1;

        if (m == 1) return 0;

        while (x > 1) {
            int q = x / m; // 商
            int t = m;

            m = x % m;     // 新m = 余数
            x = t;         // 新x = 旧m
            t = y;         // 临时存储旧y

            y = x0 - q * y; // 更新y
            x0 = t;         // 更新x0
        }

        // 确保逆元为正
        if (x0 < 0) x0 += m0;
        return x0;
    }

public:
    // 构造函数：传入质数槽数m，初始化随机参数a
    UniversalHash(int prime_m) : m(prime_m), r(5) {
        // 生成随机参数a：0 ≤ a_i < m
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> dis(0, m - 1);

        a.resize(r + 1);
        for (int i = 0; i <= r; ++i) {
            a[i] = dis(gen);
        }
    }

    // 功能：计算键k的哈希值（视频中的点积模m公式）
    int hash(int k) const {
        vector<int> bits = decomposeKey(k);
        int dot_product = 0;

        // 计算点积（bits长度不足时高位补0）
        for (int i = 0; i <= r; ++i) {
            int ki = (i < bits.size()) ? bits[i] : 0;
            dot_product += a[i] * ki;
        }

        // 模m确保结果在[0, m-1]
        return (dot_product % m + m) % m;
    }

    // 调试用：打印哈希函数参数a
    void printParams() const {
        cout << "哈希函数参数a = [";
        for (int i = 0; i <= r; ++i) {
            cout << a[i];
            if (i != r) cout << ", ";
        }
        cout << "]" << endl;
    }
};

// 示例：视频编译器符号表场景模拟
int main() {
    // 1. 初始化全域哈希（m=7，质数槽数）
    UniversalHash uh(7);
    cout << "第一组哈希函数参数：";
    uh.printParams();

    // 2. 模拟符号表中的变量ID（如x=10, y=17, z=24）
    vector<int> variables = {10, 17, 24, 31, 38};
    cout << "\n变量ID -> 哈希槽号：" << endl;
    for (int var : variables) {
        cout << var << " -> " << uh.hash(var) << endl;
    }

    // 3. 模拟对手无法预测：生成另一组随机哈希函数
    UniversalHash uh2(7);
    cout << "\n第二组哈希函数参数：";
    uh2.printParams();
    cout << "同一批变量的哈希槽号（对手无法提前构造碰撞）：" << endl;
    for (int var : variables) {
        cout << var << " -> " << uh2.hash(var) << endl;
    }

    return 0;
}
```

#### 2.4.2 代码说明

- **质数依赖**：构造函数要求传入质数`prime_m`，确保乘法逆元存在（视频核心条件）。
- **键分解**：`decomposeKey`按视频逻辑，通过 “取模 + 除法” 获取基`m`的各位（`k0`为最低位）。
- **随机参数**：用`mt19937`生成`a`向量，实现 “运行时随机选择哈希函数”，对抗对手构造碰撞。
- **示例场景**：模拟编译器符号表的变量哈希，展示不同随机函数下的槽分配，验证不可预测性。

## 3. 完全哈希（Perfect Hashing）

### 3.1 完全哈希的动机

- **全域哈希局限**：仅保证**期望查询时间 O (1)**，最坏情况下仍可能有碰撞（如所有键哈希到同一槽）。
- **目标场景**：**静态键集合**（无插入 / 删除，如英语常用词表、固定符号表），需**最坏情况下查询时间 O (1)**，且总空间 O (n)。
- **核心目标**：构造无碰撞的哈希结构（仅针对静态键），彻底消除最坏情况的性能退化。

### 3.2 完全哈希的两级结构

视频提出**两级哈希方案**，通过 “全域哈希 + 无碰撞哈希” 的组合，实现最坏情况 O (1) 查询。

#### 3.2.1 结构定义

1. **第一级哈希（全域哈希）**：
	- 槽数`m1 = n`（`n`为键总数），使用全域哈希函数`h1 ∈ H1`。
	- 将`n`个键分配到`m1`个槽，设第`i`个槽包含`n_i`个键（满足`sum(n_i) = n`）。
2. **第二级哈希（完全哈希）**：
	- 对每个第一级槽`i`，分配独立哈希表，槽数`m_i = n_i²`（视频明确要求`m_i = n_i²`）。
	- 为该槽选择无碰撞的哈希函数`h_i ∈ H2_i`，确保`n_i`个键在`h_i`下无碰撞（每个键对应唯一槽）。
	- 第二级表无链表，直接通过槽访问键。

#### 3.2.2 结构示意图

plaintext

```plaintext
第一级哈希表（m1 = n 个槽）
┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐
│槽0  │  │槽1  │  │槽2  │  │槽n-1│
│n0个键│  │n1个键│  │n2个键│  │nn-1个键│
├─────┤  ├─────┤  ├─────┤  ├─────┤
│h0→  │  │h1→  │  │h2→  │  │hn-1→│
│第二级表│  │第二级表│  │第二级表│  │第二级表│
│m0=n0²槽│  │m1=n1²槽│  │m2=n2²槽│  │mn-1=nn-1²槽│
└─────┘  └─────┘  └─────┘  └─────┘
```

#### 3.2.3 查询流程

1. 对查询键`k`，计算第一级哈希值`i = h1(k)`，定位第一级槽`i`。
2. 计算第二级哈希值`j = h_i(k)`，定位第二级槽`j`。
3. 直接访问第二级槽`j`：若存储`k`则存在，否则不存在（无碰撞，无需遍历）。
4. 时间复杂度：两次哈希计算（O (1)）+ 两次数组访问（O (1)），最坏情况 O (1)。

### 3.3 完全哈希的关键定理

#### 3.3.1 定理 1：第二级无碰撞函数的存在性

对`n_i`个键，若第二级槽数`m_i = n_i²`，则从全域哈希集合`H2_i`中随机选择`h_i`，`h_i`无碰撞的概率≥1/2。

##### 证明过程（视频推导）

1. **定义碰撞次数`X`**：`X`为`n_i`个键在`h_i`下的碰撞键对数量。
2. **计算期望`E[X]`**：
	- 键对总数：`C(n_i, 2) = n_i(n_i - 1)/2`。
	- 全域哈希下，任意键对碰撞概率：`1/m_i = 1/n_i²`。
	- 线性期望：`E[X] = C(n_i, 2) * (1/n_i²) = (n_i - 1)/(2n_i) < 1/2`。
3. **应用马尔可夫不等式**：
	马尔可夫不等式：对非负随机变量`X`，`P(X ≥ t) ≤ E[X]/t`（视频推导）。
	取`t=1`，则`P(X ≥ 1) ≤ E[X]/1 < 1/2`。
	因此，`P(X = 0) = 1 - P(X ≥ 1) ≥ 1/2`。
	结论：随机选`h_i`，无碰撞概率≥1/2，尝试 1-2 次即可找到有效函数。

#### 3.3.2 定理 2：总空间复杂度 O (n)

两级哈希总空间`S = m1 + sum(m_i) = n + sum(n_i²)`，其期望`E[S] = O(n)`。

##### 证明过程（视频引用桶排序分析）

1. 第一级哈希`m1 = n`，负载系数`α = 1`，故`E[n_i] = 1`（每个槽平均 1 个键）。
2. 由全域哈希性质，`Var(n_i) = E[n_i²] - (E[n_i])² ≤ 1`（类似桶排序方差分析）。
3. 计算`E[sum(n_i²)]`：
	*E*[∑*i*=1*n*​*n**i*2​]=∑*i*=1*n*​*E*[*n**i*2​]=∑*i*=1*n*​[*Va**r*(*n**i*​)+(*E*[*n**i*​])2]≤∑*i*=1*n*​(1+1)=2*n*
4. 总空间期望：`E[S] = n + 2n = 3n = O(n)`，满足空间高效要求。

### 3.4 完全哈希的 C++ 实现

#### 3.4.1 完整代码

cpp

```cpp
#include <iostream>
#include <vector>
#include <random>
#include <unordered_set>
#include <optional>
using namespace std;

// 复用全域哈希类（完全哈希依赖全域哈希）
class UniversalHash {
private:
    int m;
    vector<int> a;
    int r;

    vector<int> decomposeKey(int k) const {
        vector<int> bits;
        if (k == 0) {
            bits.push_back(0);
            return bits;
        }
        while (k > 0) {
            bits.push_back(k % m);
            k = k / m;
        }
        return bits;
    }

    int modInverse(int x) const {
        int m = this->m;
        int m0 = m;
        int y = 0, x0 = 1;
        if (m == 1) return 0;
        while (x > 1) {
            int q = x / m;
            int t = m;
            m = x % m;
            x = t;
            t = y;
            y = x0 - q * y;
            x0 = t;
        }
        if (x0 < 0) x0 += m0;
        return x0;
    }

public:
    UniversalHash(int prime_m) : m(prime_m), r(5) {
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> dis(0, m - 1);
        a.resize(r + 1);
        for (int i = 0; i <= r; ++i) {
            a[i] = dis(gen);
        }
    }

    int hash(int k) const {
        vector<int> bits = decomposeKey(k);
        int dot_product = 0;
        for (int i = 0; i <= r; ++i) {
            int ki = (i < bits.size()) ? bits[i] : 0;
            dot_product += a[i] * ki;
        }
        return (dot_product % m + m) % m;
    }

    // 新增：验证一组键在该函数下是否无碰撞（视频定理1应用）
    bool isCollisionFree(const vector<int>& keys) const {
        unordered_set<int> slots;
        for (int k : keys) {
            int s = hash(k);
            if (slots.count(s)) return false; // 有碰撞
            slots.insert(s);
        }
        return true; // 无碰撞
    }

    // 新增：重新生成参数a（寻找无碰撞函数）
    void regenerateParams() {
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> dis(0, m - 1);
        for (int i = 0; i <= r; ++i) {
            a[i] = dis(gen);
        }
    }

    // 暴露槽数m（供外部访问）
    int getM() const { return m; }
};

// 第二级哈希表结构（视频中每个第一级槽对应独立表）
struct SecondLevelHash {
    UniversalHash uh;               // 该级的全域哈希函数
    vector<optional<int>> table;    // 哈希表槽（存储键，empty为空）

    // 构造函数：传入键集合，自动找到无碰撞函数
    SecondLevelHash(const vector<int>& keys) {
        if (keys.empty()) {
            uh = UniversalHash(2); // 空表用最小质数
            table.resize(0);
            return;
        }

        // 第二级槽数m_i = n_i²，找≥n_i²的最小质数（视频要求）
        int n_i = keys.size();
        int target_m = n_i * n_i;
        int prime_m = findPrime(target_m);

        // 初始化全域哈希，寻找无碰撞函数（最多尝试10次，视频概率≥1/2）
        uh = UniversalHash(prime_m);
        int max_tries = 10;
        for (int i = 0; i < max_tries; ++i) {
            if (uh.isCollisionFree(keys)) break;
            uh.regenerateParams();
        }

        // 填充第二级哈希表
        int m = uh.getM();
        table.resize(m, nullopt);
        for (int k : keys) {
            int slot = uh.hash(k);
            table[slot] = k;
        }
    }

    // 辅助：找到≥x的最小质数
    int findPrime(int x) {
        if (x <= 2) return 2;
        int p = (x % 2 == 0) ? x + 1 : x;
        while (true) {
            if (isPrime(p)) return p;
            p += 2;
        }
    }

    // 辅助：判断是否为质数
    bool isPrime(int p) {
        if (p <= 1) return false;
        if (p == 2) return true;
        if (p % 2 == 0) return false;
        for (int i = 3; i * i <= p; i += 2) {
            if (p % i == 0) return false;
        }
        return true;
    }

    // 查询键k是否存在（O(1)）
    bool query(int k) const {
        if (table.empty()) return false;
        int slot = uh.hash(k);
        if (slot < 0 || slot >= table.size()) return false;
        return table[slot] == k;
    }
};

// 完全哈希类（两级结构，视频定义）
class PerfectHash {
private:
    UniversalHash first_level_uh;          // 第一级全域哈希
    vector<vector<int>> first_level_slots; // 第一级槽（存储每个槽的键）
    vector<SecondLevelHash> second_level;  // 第二级哈希表数组

    // 辅助：找到≥x的最小质数（第一级槽数m1 = n，需质数）
    int findPrime(int x) {
        if (x <= 2) return 2;
        int p = (x % 2 == 0) ? x + 1 : x;
        while (true) {
            if (isPrime(p)) return p;
            p += 2;
        }
    }

    bool isPrime(int p) {
        if (p <= 1) return false;
        if (p == 2) return true;
        if (p % 2 == 0) return false;
        for (int i = 3; i * i <= p; i += 2) {
            if (p % i == 0) return false;
        }
        return true;
    }

public:
    // 构造函数：传入静态键集合，构建两级哈希
    PerfectHash(const vector<int>& keys) {
        int n = keys.size();
        if (n == 0) return;

        // 1. 初始化第一级哈希（m1 = n，质数槽数）
        int prime_m1 = findPrime(n);
        first_level_uh = UniversalHash(prime_m1);
        first_level_slots.resize(prime_m1);

        // 2. 填充第一级槽（用全域哈希分配键）
        for (int k : keys) {
            int slot = first_level_uh.hash(k);
            first_level_slots[slot].push_back(k);
        }

        // 3. 为每个第一级槽构建第二级哈希表
        second_level.reserve(prime_m1);
        for (const auto& slot_keys : first_level_slots) {
            second_level.emplace_back(slot_keys);
        }
    }

    // 公开查询接口（最坏情况O(1)）
    bool query(int k) const {
        if (first_level_slots.empty()) return false;

        // 1. 第一级哈希定位槽
        int first_slot = first_level_uh.hash(k);
        if (first_slot < 0 || first_slot >= second_level.size()) return false;

        // 2. 第二级哈希查询
        const auto& slh = second_level[first_slot];
        return slh.query(k);
    }

    // 调试用：打印第一级槽分布（验证视频结构）
    void printFirstLevelDist() const {
        cout << "第一级槽分布（槽号：键列表，n_i：键数，m_i：第二级槽数）：" << endl;
        for (int i = 0; i < first_level_slots.size(); ++i) {
            const auto& keys = first_level_slots[i];
            if (keys.empty()) continue;

            cout << "槽" << i << "：";
            for (size_t j = 0; j < keys.size(); ++j) {
                cout << keys[j];
                if (j != keys.size() - 1) cout << ", ";
            }
            int n_i = keys.size();
            int m_i = second_level[i].uh.getM();
            cout << "（n_i=" << n_i << "，m_i=" << m_i << "≈" << n_i * n_i << "）" << endl;
        }
    }
};

// 示例：视频静态键集合查询（如英语常用词ID）
int main() {
    // 1. 静态键集合（模拟10个常用词ID）
    vector<int> static_keys = {5, 12, 19, 26, 33, 40, 47, 54, 61, 68};
    cout << "静态键集合：";
    for (int k : static_keys) cout << k << " ";
    cout << endl << endl;

    // 2. 构建完全哈希表
    PerfectHash ph(static_keys);

    // 3. 打印第一级槽分布（验证视频两级结构）
    ph.printFirstLevelDist();

    // 4. 测试查询（最坏情况O(1)）
    cout << "\n查询测试：" << endl;
    vector<int> test_keys = {12, 33, 50, 68, 75};
    for (int k : test_keys) {
        bool exists = ph.query(k);
        cout << "键" << k << "：" << (exists ? "存在" : "不存在") << endl;
    }

    return 0;
}
```

#### 3.4.2 代码说明

- **两级依赖**：第一级用全域哈希分配键，第二级为每个槽寻找无碰撞函数（视频核心逻辑）。
- **槽数计算**：第二级槽数`m_i = n_i²`，代码中用`findPrime`找≥`n_i²`的最小质数（符合视频质数构造要求）。
- **无碰撞保障**：按视频定理 1，最多尝试 10 次生成参数，确保找到无碰撞函数（概率≥1/2）。
- **查询效率**：严格遵循视频两级查询步骤，最坏情况 O (1)，无链表遍历。

## 4. 视频核心数学工具

### 4.1 线性期望性质

- **内容**：对任意随机变量`X1, X2, ..., Xk`，无论是否独立，均有：
	*E*[*X*1+*X*2+...+*X**k*]=*E*[*X*1]+*E*[*X*2]+...+*E*[*X**k*]
- **应用**：全域哈希碰撞次数期望、完全哈希第二级碰撞次数期望的





# 二叉搜索树（BST）核心知识点总结

## 1. BST 基础概念与操作

视频中明确二叉搜索树（Binary Search Tree，简称 BST）是后续内容的核心，首先梳理其基础定义、插入逻辑和遍历方式。

### 1.1 BST 定义与核心性质

- **定义**：一种满足 “左小右大” 规则的二叉树，对任意节点`x`：
	1. 左子树中所有节点的值 **小于** `x` 的值；
	2. 右子树中所有节点的值 **大于** `x` 的值；
	3. 左、右子树本身也需满足 BST 性质。
- **核心作用**：通过该性质，中序遍历可输出**有序序列**。

### 1.2 BST 插入操作（递归实现）

视频中插入逻辑描述为：“搜索元素直到找到它应该在的位置，若已存在则添加新叶，否则直接作为新叶插入”，具体步骤：

1. 若当前树为空（根为`null`），创建新节点作为根；
2. 若插入值`val` **小于** 当前根节点值，递归插入左子树；
3. 若插入值`val` **大于** 当前根节点值，递归插入右子树；
4. （视频未提去重，默认允许重复值或按 “大于等于插入右子树” 处理，此处按 “严格大于 / 小于” 实现）。

### 1.3 BST 中序遍历（有序输出）

视频中遍历逻辑：“递归遍历左子树 → 打印根节点 → 递归遍历右子树”，即**左→根→右**顺序，核心特点：

- 遍历结果必然是**升序序列**（由 BST “左小右大” 性质推导）；
- 时间复杂度`O(n)`（每个节点访问一次）。

### 1.4 基础操作示例

视频以数组`[3, 1, 8, 2, 6, 7, 5]`为例演示插入与遍历，步骤如下：

1. **插入 3**：空树 → 3 作为根；
2. **插入 1**：1 < 3 → 作为 3 的左子节点；
3. **插入 8**：8 > 3 → 作为 3 的右子节点；
4. **插入 2**：2 > 1（3 的左子）且 2 < 3 → 作为 1 的右子节点；
5. **插入 6**：6 > 3 且 6 < 8 → 作为 8 的左子节点；
6. **插入 7**：7 > 3 且 7 <8 且 7> 6 → 作为 6 的右子节点；
7. **插入 5**：5 > 3 且 5 < 8 且 5 < 6 → 作为 6 的左子节点。

最终树结构：

plaintext

```plaintext
    3
   / \
  1   8
   \ /
    2 6
     / \
    5   7
```

**中序遍历结果**：1 → 2 → 3 → 5 → 6 → 7 → 8（与视频一致）。

## 2. BST 排序（BST Sort）

视频通过 BST 插入与遍历结合，提出 “BST 排序” 算法，核心是利用 BST 中序遍历的有序性。

### 2.1 BST 排序原理

视频明确步骤：

1. **初始化**：创建空 BST；
2. **插入阶段**：遍历待排序数组，将每个元素按 BST 规则插入树中；
3. **遍历阶段**：对 BST 执行中序遍历，输出结果即为**升序数组**。

### 2.2 BST 排序时间复杂度分析

视频从 “节点深度总和” 角度分析（插入每个元素的时间 = 元素所在节点的深度，总时间 = 所有节点深度之和）：

#### 2.2.1 最坏情况（O (n²)）

- **触发条件**：待排序数组已升序或降序（如`[1,2,3,4]`或`[4,3,2,1]`）；
- **树结构**：BST 退化为**单链表**（每个新节点作为最右 / 最左子节点）；
- **时间计算**：节点深度之和为`1+2+...+(n-1) = n(n-1)/2 = O(n²)`（视频举例：n=4 时，深度和为 1+2+3=6）。

#### 2.2.2 理想情况（O (n log n)）

- **触发条件**：BST 为**平衡树**（左右子树高度差≤1，如完全二叉树）；
- **树高度**：平衡树高度为`log₂n`（n 个节点）；
- **时间计算**：每个节点深度≤`log₂n`，总深度和≤`n·log₂n = O(n log n)`；
- **理论下界**：视频提到 “基于比较的排序算法最坏情况下界为 Ω(n log n)”，BST 排序理想情况达到该下界。

## 3. BST 排序与快速排序（Quick Sort）的等价性

视频核心结论：“BST 排序与快速排序做完全相同的比较，仅比较顺序不同，本质是同一算法的不同表现形式”。

### 3.1 核心联系：比较操作的一致性

- **快速排序逻辑**：选`pivot`（视频用 “第一个元素作为分区元素”），将数组分为 “小于 pivot”“大于 pivot” 两部分，递归处理子数组；
- **BST 排序逻辑**：插入元素时，与当前根（对应快排的`pivot`）比较，进入左子树（小于根）或右子树（大于根），递归插入子树；
- **关键等价**：两种算法比较的 “元素对” 完全一致（如视频数组`[3,1,8,2,6,7,5]`，两者均需比较`(3,1)、(3,8)、(3,2)、(3,6)、(3,7)、(3,5)、(1,2)、(8,6)、(8,7)、(8,5)、(6,5)、(6,7)`）。

### 3.2 等价性示例

以视频数组`[3,1,8,2,6,7,5]`为例：

#### 3.2.1 快速排序分区过程

1. 选`3`为`pivot` → 分区为`[1,2]`（小于 3）和`[8,6,7,5]`（大于 3）；
2. 左分区`[1,2]`选`1`为`pivot` → 分区为`[]`和`[2]`；
3. 右分区`[8,6,7,5]`选`8`为`pivot` → 分区为`[6,7,5]`和`[]`；
4. 子分区`[6,7,5]`选`6`为`pivot` → 分区为`[5]`和`[7]`。

#### 3.2.2 BST 插入与快排分区的对应关系

- 快排的`pivot`对应 BST 的**根节点**；
- 快排的 “左分区” 对应 BST 的**左子树**；
- 快排的 “右分区” 对应 BST 的**右子树**；
- 最终快排的 “分区树” 与 BST 的 “节点结构” 完全一致（如`pivot=3`对应 BST 根 3，`pivot=1`对应 BST 左子树根 1）。

## 4. 随机构建 BST（Randomly Built BST）

视频核心目标：通过 “随机化” 让 BST 大概率平衡，重点分析 “随机构建 BST 的期望高度”。

### 4.1 随机构建 BST 的构建方式

视频明确步骤：

1. **随机排列数组**：对输入数组进行**均匀随机排列**（所有排列等概率）；
2. **插入构建 BST**：将随机排列后的数组元素，按 BST 基础插入规则逐个插入空树，得到 “随机构建 BST”。

- 核心目的：避免 “有序数组导致 BST 退化为链表” 的最坏情况，使 BST 大概率平衡。

### 4.2 随机构建 BST 的期望高度分析

视频通过 “凸函数 + Jensen 不等式 + 随机变量转换” 推导期望高度，步骤如下：

#### 4.2.1 凸函数定义与性质

- **定义**（视频表述）：对函数`f: R→R`，若对任意`x,y ∈ R`，及`α≥0、β≥0`且`α+β=1`，满足：
	`f(αx + βy) ≤ αf(x) + βf(y)`
	几何意义：曲线上任意两点的连线在曲线**上方**。
- **推广到 n 点**：对任意`x₁,x₂,...,xₙ ∈ R`，及`α₁,...,αₙ ≥0`且`Σαᵢ=1`，满足：
	`f(Σαᵢxᵢ) ≤ Σαᵢf(xᵢ)`（仿射组合性质，视频通过数学归纳法证明）。

#### 4.2.2 Jensen 不等式（离散情况）

视频核心工具，用于关联 “随机变量函数的期望” 与 “期望的函数”。

##### 4.2.2.1 Jensen 不等式陈述

- 若`f`是**凸函数**，`X`是离散整数随机变量，则：
	`E[f(X)] ≥ f(E[X])`
	（视频强调：凸函数的 Jensen 不等式方向为 “≥”，凹函数相反）。

##### 4.2.2.2 Jensen 不等式证明（离散整数随机变量）

1. **期望定义**：对离散整数随机变量`X`，其期望为：
	`E[X] = Σ（x∈整数）x·P(X=x)`，其中`P(X=x)`是`X`取`x`的概率，且`ΣP(X=x)=1`、`P(X=x)≥0`。
2. **应用凸函数 n 点性质**：令`αₓ = P(X=x)`（满足`Σαₓ=1`、`αₓ≥0`），则：
	`f(Σx·αₓ) ≤ Σαₓ·f(x)`
	左边即`f(E[X])`，右边即`Σf(x)·P(X=x) = E[f(X)]`。
3. **结论**：`f(E[X]) ≤ E[f(X)]`，即`E[f(X)] ≥ f(E[X])`。

#### 4.2.3 随机变量转换：Yₙ = 2^Xₙ

视频为简化高度分析，定义新随机变量：

- `Xₙ`：n 个节点随机构建 BST 的**高度**（根节点高度为 0，单节点树`X₁=0`）；
- `Yₙ`：`Yₙ = 2^Xₙ`（视频选择`2^x`的原因：`2^x`是**凸函数**，可应用 Jensen 不等式；且`Yₙ`的递归关系更易处理）。

#### 4.2.4 递归关系推导（E [Yₙ] 的约束）

视频通过 “根节点的秩” 推导`Yₙ`的递归关系：

1. **根的秩**：随机排列数组后，第一个插入的元素（根）在原数组中的 “排序名次” 称为 “秩`k`”（`k=1~n`，等概率`P(k)=1/n`）；
	- 左子树节点数：`k-1`（所有小于根的元素）；
	- 右子树节点数：`n-k`（所有大于根的元素）。
2. **高度递归关系**：BST 的高度 = 1 + 左右子树高度的最大值，即：
	`Xₙ = 1 + max(Xₖ₋₁, Xₙ₋ₖ)`
	（`X₀`为空树高度，视频默认`X₀=-1`，对应`Y₀=2^(-1)=1/2`）。
3. **Yₙ的递归关系**：对高度公式两边取`2^x`：
	`Yₙ = 2^Xₙ = 2^(1 + max(Xₖ₋₁, Xₙ₋ₖ)) = 2 · 2^max(Xₖ₋₁, Xₙ₋ₖ) = 2 · max(Yₖ₋₁, Yₙ₋ₖ)`。
4. **取期望并放缩**：
	- 对`Yₙ`取期望：`E[Yₙ] = E[2 · max(Yₖ₋₁, Yₙ₋ₖ)]`；
	- 因`k`等概率，`E[Yₙ] = (2/n) · Σ（k=1到n）E[max(Yₖ₋₁, Yₙ₋ₖ)]`；
	- 视频用 “`max(a,b) ≤ a + b`”（`a,b≥0`）放缩：`E[max(Yₖ₋₁, Yₙ₋ₖ)] ≤ E[Yₖ₋₁ + Yₙ₋ₖ] = E[Yₖ₋₁] + E[Yₙ₋ₖ]`；
	- 代入得：`E[Yₙ] ≤ (2/n) · Σ（k=1到n）[E[Yₖ₋₁] + E[Yₙ₋ₖ]]`；
	- 求和化简：`Σ（k=1到n）E[Yₖ₋₁] = Σ（m=0到n-1）E[Yₘ]`，`Σ（k=1到n）E[Yₙ₋ₖ] = Σ（m=0到n-1）E[Yₘ]`，故总和为`2·Σ（m=0到n-1）E[Yₘ]`；
	- 最终递归约束：`E[Yₙ] ≤ (4/n) · Σ（m=0到n-1）E[Yₘ]`。

#### 4.2.5 替代法证明 E [Yₙ] = O (n³)

视频用 “替代法”（数学归纳法）证明`E[Yₙ]`的上界：

1. **归纳假设**：对所有`m < n`，存在常数`C`，使得`E[Yₘ] ≤ C·m³`；
2. **基础情况**：`n=0`时`E[Y₀] = 1/2 ≤ C·0³=0`（需`C`足够大，或调整基础情况为`n≥1`，`n=1`时`E[Y₁]=1 ≤ C·1³`，取`C≥1`）；
3. **归纳步骤**：
	`Σ（m=0到n-1）E[Yₘ] ≤ C·Σ（m=0到n-1）m³`
	视频用 “积分近似求和”（`m³`单调递增，求和≤积分）：
	`Σ（m=0到n-1）m³ ≤ ∫（x=0到n）x³dx = n⁴/4`
	代入递归约束：
	`E[Yₙ] ≤ (4/n) · C · (n⁴/4) = C·n³`
	满足归纳假设，故`E[Yₙ] = O(n³)`。

#### 4.2.6 最终结论：随机构建 BST 的期望高度为 O (log n)

结合 Jensen 不等式推导：

1. 由 Jensen 不等式（`f(x)=2^x`是凸函数）：`E[Yₙ] = E[2^Xₙ] ≥ 2^E[Xₙ]`；
2. 由`E[Yₙ] ≤ C·n³`，得`2^E[Xₙ] ≤ C·n³`；
3. 两边取以 2 为底的对数：
	`E[Xₙ] ≤ log₂(C·n³) = log₂C + 3·log₂n = O(log n)`；
4. **核心结论**：n 个节点随机构建 BST 的**期望高度为 O (log n)**，意味着插入和搜索的期望时间均为 O (log n)。

## 5. 视频对应逻辑的 C++ 实现代码

基于视频中 BST 的插入、遍历、排序及随机构建逻辑，实现 C++ 代码。

### 5.1 BST 节点结构定义

cpp

```cpp
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>  // for shuffle

using namespace std;

// BST节点结构（视频中无显式定义，按基础逻辑实现）
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;

    // 构造函数
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

### 5.2 BST 插入函数（递归实现）

cpp

```cpp
// 递归插入：将val插入以root为根的BST（root需传引用，因可能修改根节点）
void insertBST(TreeNode*& root, int val) {
    // 情况1：当前树为空，创建新节点作为根
    if (root == nullptr) {
        root = new TreeNode(val);
        return;
    }
    // 情况2：val小于当前根，插入左子树
    if (val < root->val) {
        insertBST(root->left, val);
    }
    // 情况3：val大于当前根，插入右子树（视频未提重复值，默认忽略或插入右子树）
    else if (val > root->val) {
        insertBST(root->right, val);
    }
    // （可选）若需处理重复值，可增加else分支（如计数或插入左/右子树）
}
```

### 5.3 BST 中序遍历函数（输出有序序列）

cpp

```cpp
// 中序遍历：左→根→右，结果存入res（视频核心遍历逻辑）
void inorderTraversal(TreeNode* root, vector<int>& res) {
    if (root == nullptr) {
        return;
    }
    // 1. 递归遍历左子树
    inorderTraversal(root->left, res);
    // 2. 访问根节点（存入结果）
    res.push_back(root->val);
    // 3. 递归遍历右子树
    inorderTraversal(root->right, res);
}
```

### 5.4 BST 排序函数（含随机排列）

cpp

```cpp
// BST排序：输入数组→随机排列→插入BST→中序遍历→输出有序数组
void bstSort(vector<int>& arr) {
    // 步骤1：随机排列数组（视频随机构建BST的核心步骤）
    // C++11+ 推荐用shuffle（结合随机种子），替代旧的random_shuffle
    random_device rd;          // 随机种子生成器
    mt19937 g(rd());           // 梅森旋转算法伪随机数生成器
    shuffle(arr.begin(), arr.end(), g);  // 均匀随机排列数组

    // 步骤2：构建BST（逐个插入随机排列后的元素）
    TreeNode* root = nullptr;
    for (int val : arr) {
        insertBST(root, val);
    }

    // 步骤3：中序遍历BST，得到有序数组
    vector<int> sortedArr;
    inorderTraversal(root, sortedArr);

    // 步骤4：将排序结果写回原数组
    arr.swap(sortedArr);

    // （可选）释放BST内存，避免内存泄漏
    // 实现destroy函数（后附）
    function<void(TreeNode*)> destroy = [&](TreeNode* node) {
        if (node == nullptr) return;
        destroy(node->left);
        destroy(node->right);
        delete node;
    };
    destroy(root);
}
```

### 5.5 完整测试代码

cpp

```cpp
int main() {
    // 视频示例数组：[3, 1, 8, 2, 6, 7, 5]
    vector<int> arr = {3, 1, 8, 2, 6, 7, 5};

    cout << "原始数组（随机排列前）：";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;

    // 调用BST排序
    bstSort(arr);

    cout << "BST排序后数组（升序）：";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;

    // 输出结果应与视频一致：1 2 3 5 6 7 8
    return 0;
}
```

### 5.6 代码说明

1. **随机排列**：使用`random_device`和`mt19937`保证 “均匀随机排列”，贴合视频 “随机构建 BST” 的要求；
2. **插入逻辑**：严格遵循视频 “递归搜索插入位置” 的规则，无额外扩展；
3. **遍历逻辑**：左→根→右的中序遍历，确保输出有序序列；
4. **内存管理**：通过递归`destroy`函数释放 BST 节点，避免内存泄漏；
5. **测试验证**：输入视频示例数组，输出结果为`1 2 3 5 6 7 8`，与视频中序遍历结果完全一致。

编辑



# 平衡搜索树（红黑树）知识点总结

## 1. 平衡搜索树概述

### 1.1 核心目标

平衡搜索树的核心是**保证树的高度为 O (log n)**（n 为内部节点数），从而使 **插入、删除、搜索** 等操作的时间复杂度均为 O (log n)，解决普通二叉搜索树在极端情况下（如有序插入）退化为链表（O (n) 复杂度）的问题。

### 1.2 常见平衡搜索树类型

视频中提及的主流平衡搜索树及其关键信息如下：

| 数据结构      | 发明时间 | 核心特点                                                     |
| ------------- | -------- | ------------------------------------------------------------ |
| AVL 树        | 1962 年  | 最早的平衡搜索树，通过 “平衡因子”（左右子树高度差 ≤1）维持平衡，旋转频繁 |
| 2-3 树        | 1970 年  | 霍普克罗夫特发明，非二叉树（节点可含 1-2 个键、2-3 个子节点），叶子同深度 |
| 红黑树        | 重点讲解 | 基于二叉搜索树，通过 “颜色属性” 维持平衡，旋转次数少于 AVL 树，工业界常用 |
| 跳表          | 后续讲解 | 非树结构（多层链表），依赖随机化，实现简单，性能接近红黑树   |
| Treap（树堆） | 1996 年  | 结合二叉搜索树与堆的特性，通过 “优先级” 随机维持平衡，实现简单 |

## 2. 红黑树定义与核心属性

红黑树是**二叉搜索树的扩展**，每个节点额外存储一个 “颜色” 属性（红色或黑色），通过严格遵守四大属性保证平衡性。

### 2.1 基础定义

- **内部节点**：存储实际键值的节点（视频中称为 “有数据的节点”）。
- **外部节点（叶子）**：视频中定义为 “空指针的替代节点”（NIL 节点），所有外部节点均为黑色，无实际键值，仅用于简化边界处理（避免空指针判断）。
- 红黑树的结构：每个内部节点的左 / 右子树要么是内部节点，要么是外部节点（NIL），即 “所有空指针均替换为 NIL 叶子”。

### 2.2 四大红黑属性

视频中明确的红黑树必须满足的四个属性（缺一不可）：

1. **颜色属性**：每个节点的颜色要么是红色，要么是黑色。
2. **根与叶子属性**：树的根节点和所有外部节点（NIL 叶子）必须是黑色。
3. **连续红节点禁止**：若一个节点是红色，则其**父节点必须是黑色**（即无连续两个红色节点）。
4. **黑高一致性**：从任一内部节点到其所有后代外部节点的路径中，**黑色节点的数量相同**（该数量称为该节点的 “黑高”，记为 bh (x)）。

### 2.3 黑高的定义

- 外部节点（NIL）的黑高为 0（无黑色节点）。
- 内部节点 x 的黑高：若 x 是黑色，则 bh (x) = bh (左子树) + 1；若 x 是红色，则 bh (x) = bh (左子树)（因红色节点不贡献黑高）。
- 示例：若根节点的黑高为 2，则从根到所有叶子的路径中，黑色节点数均为 2（含根节点）。

## 3. 红黑树高度证明

视频中通过 “红节点合并为黑节点” 的思路，证明红黑树的高度上限为 **h ≤ 2log₂(n+1)**（n 为内部节点数），具体步骤如下：

### 3.1 第一步：红黑树转 2-3-4 树

根据红黑树的属性 3（红节点父节点必为黑），可将**每个红色节点与其黑色父节点合并**，形成一个 “复合节点”，最终得到一棵 **2-3-4 树**（非二叉树）。

- 2-3-4 树的节点类型：
	- 2 节点：原黑节点（无红孩子），含 1 个键、2 个子节点。
	- 3 节点：原黑节点 + 1 个红孩子，含 2 个键、3 个子节点。
	- 4 节点：原黑节点 + 2 个红孩子，含 3 个键、4 个子节点。

### 3.2 第二步：2-3-4 树的高度约束

2-3-4 树的核心属性是**所有叶子节点深度相同**（与红黑树的属性 4 等价），且满足：

- 设 2-3-4 树的高度为 h'（根到叶子的层数），则叶子总数为 n+1（与二叉搜索树一致：n 个内部节点对应 n+1 个叶子）。
- 2-3-4 树的每个节点至少有 2 个子节点，因此叶子数 ≥ 2^h' → n+1 ≥ 2^h' → h' ≤ log₂(n+1)。

### 3.3 第三步：红黑树与 2-3-4 树的高度关联

红黑树的高度 h 与 2-3-4 树的高度 h' 满足：**h ≤ 2h'**（因红黑树中最多连续 1 个红节点，即每 2 层红黑节点对应 2-3-4 树的 1 层）。

### 3.4 最终结论

结合 h' ≤ log₂(n+1)，可得红黑树的高度上限：
**h ≤ 2log₂(n+1)**，即高度为 O (log n)。

## 4. 红黑树的查询操作

红黑树是**二叉搜索树**，因此查询操作与普通二叉搜索树完全一致，仅因高度为 O (log n)，复杂度降至 O (log n)。

### 4.1 常见查询操作

| 操作                | 逻辑                                                         |
| ------------------- | ------------------------------------------------------------ |
| 查找（Search）      | 从根出发，键值小于当前节点则向左，大于则向右，等于则返回节点（或 NIL） |
| 最小值（Minimum）   | 从根出发，沿左子树一直向下，直到左子树为 NIL，当前节点即为最小值 |
| 最大值（Maximum）   | 从根出发，沿右子树一直向下，直到右子树为 NIL，当前节点即为最大值 |
| 前驱（Predecessor） | 节点 x 的前驱是 “小于 x 且最大的节点”：若 x 有左子树，取左子树的最大值；否则向上找父节点，直到 x 是父节点的右孩子，父节点即为前驱 |
| 后继（Successor）   | 节点 x 的后继是 “大于 x 且最小的节点”：若 x 有右子树，取右子树的最小值；否则向上找父节点，直到 x 是父节点的左孩子，父节点即为后继 |

### 4.2 查询操作 C++ 代码示例

cpp

```cpp
#include <iostream>
using namespace std;

// 颜色定义
enum Color { RED, BLACK };

// 红黑树节点结构（含 NIL 节点）
struct Node {
    int key;
    Color color;
    Node* left;
    Node* right;
    Node* parent;

    // 构造函数：普通节点（默认红色，左/右/父为 NIL）
    Node(int k) : key(k), color(RED), left(nullptr), right(nullptr), parent(nullptr) {}
    // 构造函数：NIL 节点（黑色）
    Node() : key(-1), color(BLACK), left(nullptr), right(nullptr), parent(nullptr) {}
};

// 红黑树类
class RedBlackTree {
private:
    Node* root;
    Node* NIL; // 共享的 NIL 叶子节点

    // 最小值辅助函数（递归）
    Node* minimum(Node* x) {
        if (x->left == NIL) return x;
        return minimum(x->left);
    }

    // 最大值辅助函数（递归）
    Node* maximum(Node* x) {
        if (x->right == NIL) return x;
        return maximum(x->right);
    }

public:
    // 初始化：创建 NIL 节点，根指向 NIL
    RedBlackTree() {
        NIL = new Node();
        root = NIL;
    }

    // 1. 查找操作
    Node* search(int key) {
        Node* curr = root;
        while (curr != NIL && curr->key != key) {
            if (key < curr->key) curr = curr->left;
            else curr = curr->right;
        }
        return curr; // 找到返回节点，未找到返回 NIL
    }

    // 2. 公开最小值接口
    Node* getMinimum() {
        if (root == NIL) return NIL;
        return minimum(root);
    }

    // 3. 公开最大值接口
    Node* getMaximum() {
        if (root == NIL) return NIL;
        return maximum(root);
    }

    // 4. 前驱操作
    Node* predecessor(Node* x) {
        if (x->left != NIL) return maximum(x->left); // 左子树的最大值

        // 无左子树：向上找父节点
        Node* y = x->parent;
        while (y != NIL && x == y->left) {
            x = y;
            y = y->parent;
        }
        return y;
    }

    // 5. 后继操作
    Node* successor(Node* x) {
        if (x->right != NIL) return minimum(x->right); // 右子树的最小值

        // 无右子树：向上找父节点
        Node* y = x->parent;
        while (y != NIL && x == y->right) {
            x = y;
            y = y->parent;
        }
        return y;
    }

    // 后续旋转、插入等函数将在下文实现...
};
```

## 5. 红黑树的旋转操作

旋转是红黑树维持平衡的核心手段，分为**左旋**和**右旋**，二者是对称操作，均为 **O (1) 时间复杂度**（仅修改指针，不改变节点键值和二叉搜索树属性）。

### 5.1 右旋（Right Rotate）

#### 逻辑（视频定义）

对节点 `y` 进行右旋（`y` 是 `x` 的父节点，`x` 是 `y` 的左孩子）：

1. 将 `x` 的右子树 `β` 判给 `y` 作为左子树（若 `β` 非 NIL，更新 `β` 的父节点为 `y`）；
2. 将 `y` 的父节点 `p` 判给 `x` 作为父节点（若 `p` 是根，则 `x` 成为新根；否则根据 `y` 是 `p` 的左 / 右孩子，更新 `p` 的左 / 右子树为 `x`）；
3. 将 `x` 的右子树设为 `y`，`y` 的父节点设为 `x`。

#### 右旋示意图（文字描述）

plaintext

```plaintext
旋转前：          旋转后：
   p                p
   |                |
   y (黑)           x (黑)
  / \              / \
 x   β    →       α   y
/ \                  / \
α  γ                γ  β
```

#### 右旋 C++ 代码

cpp

```cpp
// 右旋操作：参数为待旋转的节点 y
void rightRotate(Node* y) {
    Node* x = y->left;    // x 是 y 的左孩子
    y->left = x->right;   // 步骤1：x 的右子树 β 判给 y 作为左子树

    if (x->right != NIL) { // 若 β 非 NIL，更新其父节点
        x->right->parent = y;
    }

    x->parent = y->parent; // 步骤2：y 的父节点 p 判给 x

    if (y->parent == NIL) { // 若 y 是根，x 成为新根
        root = x;
    } else if (y == y->parent->left) { // 若 y 是 p 的左孩子
        y->parent->left = x;
    } else { // 若 y 是 p 的右孩子
        y->parent->right = x;
    }

    x->right = y;         // 步骤3：x 的右子树设为 y
    y->parent = x;        // y 的父节点设为 x
}
```

### 5.2 左旋（Left Rotate）

#### 逻辑（视频定义）

对节点 `x` 进行左旋（`x` 是 `y` 的父节点，`y` 是 `x` 的右孩子），与右旋对称：

1. 将 `y` 的左子树 `γ` 判给 `x` 作为右子树（若 `γ` 非 NIL，更新 `γ` 的父节点为 `x`）；
2. 将 `x` 的父节点 `p` 判给 `y` 作为父节点（若 `p` 是根，则 `y` 成为新根；否则根据 `x` 是 `p` 的左 / 右孩子，更新 `p` 的左 / 右子树为 `y`）；
3. 将 `y` 的左子树设为 `x`，`x` 的父节点设为 `y`。

#### 左旋示意图（文字描述）

plaintext

```plaintext
旋转前：          旋转后：
   p                p
   |                |
   x (黑)           y (黑)
  / \              / \
 α   y    →       x   β
    / \          / \
   γ  β          α  γ
```

#### 左旋 C++ 代码

cpp

```cpp
// 左旋操作：参数为待旋转的节点 x
void leftRotate(Node* x) {
    Node* y = x->right;   // y 是 x 的右孩子
    x->right = y->left;   // 步骤1：y 的左子树 γ 判给 x 作为右子树

    if (y->left != NIL) { // 若 γ 非 NIL，更新其父节点
        y->left->parent = x;
    }

    y->parent = x->parent; // 步骤2：x 的父节点 p 判给 y

    if (x->parent == NIL) { // 若 x 是根，y 成为新根
        root = y;
    } else if (x == x->parent->left) { // 若 x 是 p 的左孩子
        x->parent->left = y;
    } else { // 若 x 是 p 的右孩子
        x->parent->right = y;
    }

    y->left = x;          // 步骤3：y 的左子树设为 x
    x->parent = y;        // x 的父节点设为 y
}
```

## 6. 红黑树的插入操作

红黑树的插入分为**两步**：先按普通二叉搜索树插入节点，再修复红黑属性（仅可能破坏属性 3：连续红节点）。

### 6.1 插入核心步骤

1. **二叉搜索树插入**：找到新节点的父节点，按 “左小右大” 规则插入，新节点默认设为**红色**（原因：若设为黑色，会直接破坏属性 4 的黑高一致性；设为红色仅可能破坏属性 3，修复更简单）。
2. **属性修复（insertFixup）**：若新节点的父节点是红色（破坏属性 3），通过 “重新着色” 和 “旋转” 修复，修复逻辑分 **A 类（父是祖父左孩子）** 和 **B 类（父是祖父右孩子）**，二者对称，视频重点讲解 A 类。

### 6.2 插入修复的三大案例（A 类）

A 类定义：新节点 `x` 的父节点 `p` 是祖父节点 `g` 的**左孩子**（B 类为右孩子，逻辑对称，仅需替换 “左 / 右” 和 “左旋 / 右旋”）。

#### 案例 1：`x` 的叔叔 `y`（`g` 的右孩子）是红色

- **场景**：`p`（红）、`y`（红）、`g`（黑），`x` 是 `p` 的左 / 右孩子均可。
- **问题**：`x` 与 `p` 连续红（破坏属性 3）。
- **修复逻辑**（视频核心）：
	1. 将 `p` 和 `y` 设为黑色（消除连续红，恢复属性 3）；
	2. 将 `g` 设为红色（维持黑高一致性，因 `g` 原是黑色，`p`/`y` 原是红色，修改后路径黑节点数不变）；
	3. 将 `x` 指向 `g`（`g` 变红后可能与 `g` 的父节点冲突，需向上继续修复）。

#### 案例 2：`x` 的叔叔 `y` 是黑色，且 `x` 是 `p` 的右孩子

- **场景**：`p`（红）、`y`（黑）、`g`（黑），`x` 是 `p` 的右孩子（之字形结构：`g → p → x` 为 “左→右”）。
- **问题**：`x` 与 `p` 连续红（破坏属性 3），且无法通过单纯着色修复（`y` 是黑色，着色会破坏黑高）。
- **修复逻辑**（视频核心）：
	1. 将 `x` 指向 `p`（切换修复对象）；
	2. 对 `x`（原 `p`）执行左旋，将 “之字形” 转为 “直线形”（`g → x → 原 x` 为 “左→左”），此时进入案例 3。

#### 案例 3：`x` 的叔叔 `y` 是黑色，且 `x` 是 `p` 的左孩子

- **场景**：`p`（红）、`y`（黑）、`g`（黑），`x` 是 `p` 的左孩子（直线形结构：`g → p → x` 为 “左→左”）。
- **问题**：`x` 与 `p` 连续红（破坏属性 3）。
- **修复逻辑**（视频核心）：
	1. 将 `p` 设为黑色（消除连续红，恢复属性 3）；
	2. 将 `g` 设为红色（维持黑高一致性）；
	3. 对 `g` 执行右旋（将 `p` 提升为 `g` 的父节点，确保黑高不被破坏）；
	4. 修复结束（此时 `p` 为黑色，无连续红节点，黑高一致）。

### 6.3 插入示例（视频中的实例）

#### 初始红黑树结构（内部节点）

根节点 `7`（黑），左子树 `3`（黑），右子树 `18`（红）；
`18` 的左子树 `10`（黑），右子树 `22`（黑）；
`10` 的左子树 `8`（红），右子树 `11`（红）；
`22` 的右子树 `26`（红）；
所有空指针均为 NIL 黑节点。

#### 插入步骤：插入键值 `15`

1. **二叉搜索树插入**：
	`15` 大于 `11`，插入为 `11` 的右孩子，设为红色。此时 `11`（红）与 `15`（红）连续，破坏属性 3，进入修复流程（`x = 15`）。
2. **修复案例 1**：
	- `x=15` 的父 `p=11`（红），祖父 `g=10`（黑），叔叔 `y=8`（红）→ 符合案例 1。
	- 操作：`p=11` 设黑，`y=8` 设黑，`g=10` 设红，`x` 指向 `10`。
	- 此时 `x=10`（红）的父 `p=18`（红），连续红，继续修复。
3. **修复案例 2 + 案例 3**：
	- `x=10` 的父 `p=18`（红），祖父 `g=7`（黑），叔叔 `y=3`（黑）→ `p=18` 是 `g=7` 的右孩子（B 类），`x=10` 是 `p=18` 的左孩子（之字形）→ 符合 B 类案例 2。
	- 操作 1（案例 2）：`x` 指向 `18`，对 `x=18` 执行右旋，转为直线形（`g=7 → 18 → 10` 为 “右→左”）。
	- 操作 2（案例 3）：`p=18` 设黑，`g=7` 设红，对 `g=7` 执行左旋，`18` 成为新根（设黑，因根必须为黑）。
4. **最终结果**：
	所有红黑属性恢复，树高度仍为 O (log n)，插入操作完成。

### 6.4 插入操作 C++ 代码

cpp

```cpp
// 红黑树类中补充插入相关函数
class RedBlackTree {
private:
    // 前文已定义的成员变量和函数（root、NIL、旋转、查询等）...

    // 插入修复函数（核心）
    void insertFixup(Node* z) {
        // 循环：仅当 z 的父节点是红色时，才需要修复（破坏属性3）
        while (z->parent->color == RED) {
            // A 类：z 的父是祖父的左孩子
            if (z->parent == z->parent->parent->left) {
                Node* y = z->parent->parent->right; // 叔叔 y（祖父的右孩子）

                // 案例 1：叔叔 y 是红色
                if (y->color == RED) {
                    z->parent->color = BLACK;       // 父设黑
                    y->color = BLACK;               // 叔叔设黑
                    z->parent->parent->color = RED; // 祖父设红
                    z = z->parent->parent;          // z 上移到祖父，继续修复
                } 
                // 叔叔 y 是黑色（案例 2 或 3）
                else {
                    // 案例 2：z 是父的右孩子
                    if (z == z->parent->right) {
                        z = z->parent;              // z 指向父
                        leftRotate(z);              // 对 z 左旋，转案例3
                    }
                    // 案例 3：z 是父的左孩子
                    z->parent->color = BLACK;       // 父设黑
                    z->parent->parent->color = RED; // 祖父设红
                    rightRotate(z->parent->parent); // 对祖父右旋，修复结束
                }
            } 
            // B 类：z 的父是祖父的右孩子（与 A 类对称）
            else {
                Node* y = z->parent->parent->left; // 叔叔 y（祖父的左孩子）

                // 案例 1：叔叔 y 是红色
                if (y->color == RED) {
                    z->parent->color = BLACK;       // 父设黑
                    y->color = BLACK;               // 叔叔设黑
                    z->parent->parent->color = RED; // 祖父设红
                    z = z->parent->parent;          // z 上移到祖父，继续修复
                } 
                // 叔叔 y 是黑色（案例 2 或 3）
                else {
                    // 案例 2：z 是父的左孩子
                    if (z == z->parent->left) {
                        z = z->parent;              // z 指向父
                        rightRotate(z);             // 对 z 右旋，转案例3
                    }
                    // 案例 3：z 是父的右孩子
                    z->parent->color = BLACK;       // 父设黑
                    z->parent->parent->color = RED; // 祖父设红
                    leftRotate(z->parent->parent);  // 对祖父左旋，修复结束
                }
            }
        }
        // 确保根节点始终为黑色（修复可能导致根变红）
        root->color = BLACK;
    }

public:
    // 公开插入接口
    void insert(int key) {
        // 步骤1：创建新节点（红色，左/右/父为 NIL）
        Node* z = new Node(key);
        z->left = NIL;
        z->right = NIL;
        z->parent = NIL;

        // 步骤2：按二叉搜索树找到插入位置（p 是 z 的父节点）
        Node* p = NIL;    // 父节点
        Node* curr = root; // 当前节点
        while (curr != NIL) {
            p = curr;
            if (z->key < curr->key) curr = curr->left;
            else curr = curr->right;
        }
        z->parent = p;

        // 步骤3：插入 z 到树中
        if (p == NIL) {          // 树为空，z 成为根
            root = z;
        } else if (z->key < p->key) { // z 是 p 的左孩子
            p->left = z;
        } else {                  // z 是 p 的右孩子
            p->right = z;
        }

        // 步骤4：修复红黑属性（若需要）
        insertFixup(z);
    }

    // 辅助函数：中序遍历（验证二叉搜索树属性）
    void inorderTraversal(Node* x) {
        if (x != NIL) {
            inorderTraversal(x->left);
            cout << x->key << "(" << (x->color == RED ? "红" : "黑") << ") ";
            inorderTraversal(x->right);
        }
    }

    // 公开中序遍历接口
    void printInorder() {
        inorderTraversal(root);
        cout << endl;
    }
};

// 测试代码（视频插入示例）
int main() {
    RedBlackTree rbt;

    // 插入初始节点（视频中的初始树）
    int initKeys[] = {7, 3, 18, 10, 22, 8, 11, 26};
    for (int key : initKeys) {
        rbt.insert(key);
    }

    cout << "初始树中序遍历（键值+颜色）：" << endl;
    rbt.printInorder(); // 输出：3(黑) 7(黑) 8(红) 10(黑) 11(红) 18(红) 22(黑) 26(红)

    // 插入 15（视频示例）
    rbt.insert(15);
    cout << "插入 15 后中序遍历：" << endl;
    rbt.printInorder(); // 输出：3(黑) 7(红) 8(黑) 10(黑) 11(黑) 15(红) 18(黑) 22(黑) 26(红)

    // 测试查询
    Node* find15 = rbt.search(15);
    if (find15 != rbt.NIL) {
        cout << "找到 " << find15->key << "，颜色：" << (find15->color == RED ? "红" : "黑") << endl;
    }

    return 0;
}
```

## 7. 总结

1. **红黑树的核心价值**：通过 “颜色属性” 和 “旋转” 维持 O (log n) 高度，兼顾性能与实现复杂度（旋转次数少于 AVL 树，工业界广泛应用，如 C++ STL 的 `map`/`set`）。
2. **关键操作复杂度**：所有操作（插入、搜索、最小值 / 最大值、前驱 / 后继）均为 O (log n)，源于树高的严格约束。
3. **核心思想**：通过 “黑高一致性” 间接保证平衡，通过 “旋转 + 着色” 修复属性违规，避免普通二叉搜索树的性能退化。



# 数据结构增强与高级数据结构

## 一、数据结构增强的核心思想与方法论

### 1.1 核心思想

视频明确 “数据结构增强” 的本质：**不从头设计新结构，而是基于现有高效数据结构（如红黑树），添加额外信息以支持新功能**，复用底层结构的动态操作（插入 / 删除）和时间复杂度优势（如 O (logn)）。

### 1.2 四步标准化方法论（视频重点提出）

视频以 “顺序统计树” 和 “区间树” 为案例，提炼数据结构增强的通用流程，确保功能正确性和效率：

1. **选择底层数据结构**：优先选择 “平衡、支持动态操作、时间复杂度低” 的结构（如红黑树，高度 O (logn)，插入 / 删除 / 查找均为 O (logn)）；
2. **定义额外存储信息**：新增属性需满足两个条件：① 可通过子节点信息递归计算（如子树大小 = 左子树大小 + 右子树大小 + 1）；② 维护成本低（修改操作时仅需局部更新）；
3. **验证修改操作的可维护性**：确保底层结构的修改操作（如红黑树的旋转、插入后再平衡）能正确更新额外信息，且维护时间仍为 O (logn)；
4. **开发新功能接口**：基于底层操作 + 额外信息，实现目标功能（如顺序统计树的 “查第 k 小”，区间树的 “区间重叠查询”）。

## 二、动态有序统计与顺序统计树（红黑树增强）

### 2.1 问题背景（视频提出的动态需求）

- 动态集合支持**插入、删除**操作；
- 需支持两种查询：① 第 k 小元素（k 阶统计）；② 给定元素的排名（比该元素小的元素个数 + 1）；
- 静态集合可通过排序解决，但动态集合需 “顺序统计树”（红黑树 + 子树大小）实现 O (logn) 操作。

### 2.2 顺序统计树的设计（红黑树 + 子树大小）

#### 2.2.1 底层结构：红黑树

视频回顾红黑树核心特性（确保平衡）：

- 节点颜色为红 / 黑，满足：① 根节点为黑；② 叶子节点（哨兵）为黑；③ 红节点的子节点必为黑；④ 任一节点到所有叶子的 “黑节点数” 相等；
- 树高 h=O (logn)，保证所有动态操作的时间复杂度为 O (logn)。

#### 2.2.2 额外存储信息：子树大小（size）

- **定义**：对节点 x，`x.size = x.left.size + x.right.size + 1`（“1” 代表节点 x 自身，左 / 右子树大小为子节点的 size）；
- **哨兵节点**（视频强调的编程技巧）：用 “假节点（哨兵）” 替代 NULL，哨兵的`size=0`，避免空指针检查（如访问`x.left.size`时无需判断`x.left是否为NULL`）；
- **作用**：通过子树大小计算节点排名，进而实现 “第 k 小查询”。

#### 2.2.3 哨兵节点的实现（视频指定逻辑）

cpp

```cpp
#include <iostream>
using namespace std;

// 全局哨兵节点（所有叶子指向同一哨兵，避免NULL判断）
struct Node;
Node* NIL;

struct Node {
    int key;        // 节点关键字（用于红黑树排序）
    Node* left;     // 左子树
    Node* right;    // 右子树
    Node* parent;   // 父节点
    bool color;     // 颜色：true=红，false=黑
    int size;       // 子树大小（左+右+1）

    // 构造函数（默认初始化为哨兵关联状态）
    Node(int k = 0) : key(k), left(NIL), right(NIL), parent(NIL), 
                     color(true), size(1) {}
};

// 初始化哨兵节点（程序启动时调用）
void initSentinel() {
    NIL = new Node();
    NIL->color = false;  // 哨兵必为黑色
    NIL->size = 0;       // 哨兵子树大小为0
    NIL->left = NIL;     // 哨兵的子节点指向自身（避免野指针）
    NIL->right = NIL;
    NIL->parent = NIL;
}
```

### 2.3 核心操作：OS-SELECT（查询第 k 小元素）

#### 2.3.1 算法逻辑（视频逐步讲解）

- **功能**：在以 x 为根的子树中，找到 “第 k 小” 的节点（k≥1）；
- **核心原理**：
	1. 计算当前节点 x 的排名：`rank = x.left.size + 1`（左子树所有元素比 x 小，故排名为左子树大小 + 1）；
	2. 若`k == rank`：返回 x（找到目标）；
	3. 若`k < rank`：目标在左子树，递归查询`x.left`，k 不变；
	4. 若`k > rank`：目标在右子树，递归查询`x.right`，k 更新为`k - rank`（右子树中需找 “第 k-rank 小” 元素）；
- **时间复杂度**：O (logn)（红黑树高度 O (logn)，每步递归仅遍历一层）。

#### 2.3.2 C++ 代码（与视频伪码完全一致）

cpp

```cpp
// OS-SELECT：在以x为根的子树中查询第k小节点（k≥1）
Node* osSelect(Node* x, int k) {
    if (x == NIL) return NIL;  // 边界：子树为空，无结果
    
    int rank = x->left->size + 1;  // 当前节点的排名（左子树大小+1）
    if (k == rank) {
        return x;  // 找到第k小元素，返回节点
    } else if (k < rank) {
        return osSelect(x->left, k);  // 左子树中找第k小
    } else {
        return osSelect(x->right, k - rank);  // 右子树中找第k-rank小
    }
}
```

#### 2.3.3 示例：OS-SELECT 查询过程（视频画图演示）

假设红黑树结构（节点 key 为字母，按字典序排序，size 标注在节点旁，哨兵省略）：

plaintext

```plaintext
        D (size=9)  // rank = 3+1=4
       / \
      B(3) F(5)    // B的rank=1+1=2；F的rank=1+1=2
     / \   / \
    A(1)C(1)E(1)G(3)  // A/C/E的rank=0+1=1；G的rank=1+1=2
               / \
              H(1)I(1)  // H/I的rank=0+1=1
```

**需求：查询第 5 小元素（k=5）**：

1. 根节点 D，rank=4 → k=5>4，递归右子树 F，k 更新为 5-4=1；
2. 节点 F，rank=2 → k=1<2，递归左子树 E，k=1；
3. 节点 E，rank=1 → k=1==1，返回 E → 第 5 小元素为 E。

### 2.4 动态操作的维护（插入 / 删除 / 旋转）

#### 2.4.1 插入操作的维护（视频步骤）

1. **普通二叉搜索树插入**：按 key 找到插入位置，新建节点（颜色设为红），接入树中；
2. **更新子树大小**：从新节点向上遍历至根，每个途经节点的`size += 1`（新节点加入该节点的子树）；
3. **红黑树再平衡**：通过颜色调整和旋转修复红黑树特性（视频强调 “不可遗漏再平衡”，否则树可能失衡）；
4. **旋转时的 size 维护**：旋转仅改变节点父子关系，子树成员不变，需重新计算旋转节点的 size（先更新子节点，再更新父节点）。

#### 2.4.2 旋转操作的 size 维护（视频关键细节）

以**右旋（RIGHT-ROTATE (x)）** 为例，旋转后需先更新子节点 x 的 size，再更新父节点 y 的 size：

cpp

```cpp
// 右旋操作（x为旋转节点），同时维护size
void rightRotate(Node*& root, Node* x) {
    Node* y = x->left;       // y是x的左子节点
    x->left = y->right;      // y的右子树（T2）变为x的左子树
    if (y->right != NIL) {
        y->right->parent = x;
    }
    y->parent = x->parent;   // y继承x的父节点
    if (x->parent == NIL) {  // x是根时，y成为新根
        root = y;
    } else if (x == x->parent->right) {  // x是右子节点时，y替代x
        x->parent->right = y;
    } else {
        x->parent->left = y;
    }
    y->right = x;            // x成为y的右子节点
    x->parent = y;

    // 维护size：先更新x（子节点变化），再更新y（依赖x的新size）
    x->size = x->left->size + x->right->size + 1;
    y->size = y->left->size + y->right->size + 1;
}

// 左旋操作（与右旋对称，维护size逻辑一致）
void leftRotate(Node*& root, Node* y) {
    Node* x = y->right;      // x是y的右子节点
    y->right = x->left;      // x的左子树（T2）变为y的右子树
    if (x->left != NIL) {
        x->left->parent = y;
    }
    x->parent = y->parent;   // x继承y的父节点
    if (y->parent == NIL) {  // y是根时，x成为新根
        root = x;
    } else if (y == y->parent->left) {  // y是左子节点时，x替代y
        y->parent->left = x;
    } else {
        y->parent->right = x;
    }
    x->left = y;             // y成为x的左子节点
    y->parent = x;

    // 维护size：先更新y，再更新x
    y->size = y->left->size + y->right->size + 1;
    x->size = x->left->size + x->right->size + 1;
}
```

#### 2.4.3 删除操作的维护

1. **普通红黑树删除**：找到待删节点，用后继 / 前驱节点替换，标记待删节点；
2. **更新子树大小**：从替换节点向上遍历至根，每个途经节点的`size -= 1`（待删节点移除该节点的子树）；
3. **红黑树再平衡**：修复颜色和结构，旋转时维护 size（同插入操作）；

- 时间复杂度：O (logn)（删除路径长度 O (logn)，size 更新和旋转均为局部操作）。

## 三、区间树（红黑树增强）

### 3.1 问题背景（区间管理需求）

- 动态集合存储**区间（low, high）**（如时间区间、数值范围）；
- 支持操作：① 插入 / 删除区间；② 区间重叠查询（给定查询区间 q，返回任意一个与 q 重叠的区间）；
- **重叠判定（视频定义）**：区间 a=(a_low,a_high) 与 b=(b_low,b_high) 重叠 ⇨ 不满足 “a_high < b_low 或 b_high < a_low”（即两个区间无 “完全左 / 右分离”）。

### 3.2 区间树的设计（红黑树 + 区间 + 子树最大高点）

#### 3.2.1 底层结构：红黑树

- 排序关键字：以区间的**低端点 low**作为红黑树的 key（视频选择 low 而非 high / 中位数，因 low 符合二叉搜索树的有序性，便于定位区间）；
- 红黑树特性不变，高度 O (logn)，保证动态操作 O (logn)。

#### 3.2.2 额外存储信息

1. **区间属性**：每个节点存储`low`（低端点）和`high`（高端点）；
2. **子树最大高点 m**：节点 x 的`m`表示 “以 x 为根的子树中，所有区间的 high 的最大值”，即`x.m = max(x.high, x.left.m, x.right.m)`；

- **作用**：快速判断 “左子树是否可能存在与查询区间重叠的区间”，避免无效遍历（如左子树 m < q.low，则左子树所有区间的 high < q.low，必不重叠）。

### 3.3 核心操作：区间重叠查询

#### 3.3.1 算法逻辑（视频命名为 INTERVAL-SEARCH）

- **功能**：给定根节点 root 和查询区间 q=(q_low, q_high)，返回任意一个与 q 重叠的区间节点（无则返回哨兵）；
- **核心步骤（视频逐步讲解）**：
	1. 初始化当前节点 x = root；
	2. 循环：当 x != 哨兵且 x 的区间与 q 不重叠时：
		a. 若 x 的左子树非哨兵，且`x.left.m >= q.low`（左子树存在区间的 high≥q.low，可能重叠）→ 遍历左子树（x = x.left）；
		b. 否则 → 遍历右子树（x = x.right）；
	3. 循环结束，返回 x（重叠节点或哨兵）。

#### 3.3.2 C++ 代码

cpp

```cpp
// 区间树节点结构（基于红黑树，扩展区间和m属性）
struct IntervalNode;
IntervalNode* IntervalNIL;

struct IntervalNode {
    int low;         // 区间低端点（红黑树排序key）
    int high;        // 区间高端点
    int m;           // 子树最大高点（max(high, left.m, right.m)）
    IntervalNode* left;
    IntervalNode* right;
    IntervalNode* parent;
    bool color;      // 颜色：true=红，false=黑

    // 构造函数
    IntervalNode(int l = 0, int h = 0) : low(l), high(h), m(max(h, 0)), 
                                         left(IntervalNIL), right(IntervalNIL), 
                                         parent(IntervalNIL), color(true) {}
};

// 初始化区间树哨兵
void initIntervalSentinel() {
    IntervalNIL = new IntervalNode();
    IntervalNIL->color = false;  // 哨兵为黑
    IntervalNIL->m = 0;          // 哨兵无区间，m=0
    IntervalNIL->left = IntervalNIL;
    IntervalNIL->right = IntervalNIL;
    IntervalNIL->parent = IntervalNIL;
}

// 区间重叠判定（视频定义）
bool isOverlap(IntervalNode* a, int q_low, int q_high) {
    // 不满足“a.high < q.low 或 q.high < a.low”即为重叠
    return !(a->high < q_low || q_high < a->low);
}

// 区间重叠查询：返回任意与q重叠的节点（无则返回IntervalNIL）
IntervalNode* intervalSearch(IntervalNode* root, int q_low, int q_high) {
    IntervalNode* x = root;
    while (x != IntervalNIL && !isOverlap(x, q_low, q_high)) {
        // 左子树非空且左子树最大高点≥q.low → 遍历左子树
        if (x->left != IntervalNIL && x->left->m >= q_low) {
            x = x->left;
        } else {
            // 左子树无可能重叠 → 遍历右子树
            x = x->right;
        }
    }
    return x;
}
```

#### 3.3.3 示例：区间查询过程

假设区间树存储以下区间（红黑树按 low 排序，节点标注 (low, high, m)，哨兵省略）：

plaintext

```plaintext
        (7, 10, 23)  // m = max(10, 8, 23) = 23
       /          \
(4, 8, 8)        (17, 19, 23)  // m = max(19, 23, 0) = 23
                   \
                  (21, 23, 23)  // m = max(23, 0, 0) = 23
```

**需求 1：查询 q=(14, 16)**：

1. x = 根节点 (7,10,23)，10<14 → 无重叠；
2. 左子树 m=8<14 → 遍历右子树 x=(17,19,23)；
3. 17>16 → 无重叠；
4. 左子树为哨兵 → 遍历右子树 x=(21,23,23)；
5. 21>16 → 无重叠；
6. 右子树为哨兵 → 循环结束，返回哨兵 → 无重叠区间。

**需求 2：查询 q=(15, 18)**：

1. x = 根节点 (7,10,23)，10<15 → 无重叠，左子树 m=8<15 → 右子树 x=(17,19,23)；
2. 检查重叠：17<18 且 15<19 → 重叠，返回 (17,19) → 查询成功。

### 3.4 动态操作的维护（插入 / 删除 / 旋转）

#### 3.4.1 插入操作的维护

1. **红黑树插入**：按 low 为 key 插入新节点，颜色设为红；
2. **更新 m 值**：从新节点向上遍历至根，每个节点的`m = max(node.high, node.left.m, node.right.m)`（新节点可能提升子树的最大 high）；
3. **红黑树再平衡**：旋转时维护 m 值（先更新子节点 m，再更新父节点 m）。

#### 3.4.2 旋转操作的 m 维护

以右旋为例，旋转后需重新计算子节点 x 和父节点 y 的 m：

cpp

```cpp
// 区间树右旋操作（维护m值）
void intervalRightRotate(IntervalNode*& root, IntervalNode* x) {
    IntervalNode* y = x->left;
    x->left = y->right;
    if (y->right != IntervalNIL) {
        y->right->parent = x;
    }
    y->parent = x->parent;
    if (x->parent == IntervalNIL) {
        root = y;
    } else if (x == x->parent->right) {
        x->parent->right = y;
    } else {
        x->parent->left = y;
    }
    y->right = x;
    x->parent = y;

    // 维护m：先更新x（子节点变化），再更新y（依赖x的新m）
    x->m = max(x->high, max(x->left->m, x->right->m));
    y->m = max(y->high, max(y->left->m, y->right->m));
}
```

#### 3.4.3 删除操作的维护

- 步骤：普通红黑树删除（替换待删节点）→ 向上遍历更新 m 值（`node.m = max(node.high, node.left.m, node.right.m)`）→ 红黑树再平衡（旋转时维护 m）；
- 复杂度：O (logn)，与插入一致。

## 四、视频核心结论

1. **数据结构增强的核心原则**：额外信息的设计是关键，需满足 “可递归计算、维护成本低”，否则会破坏底层结构的效率；
2. **红黑树的通用性**：作为平衡二叉搜索树，是数据结构增强的 “最优底层选择”，支持动态操作且时间复杂度稳定为 O (logn)；
3. **顺序统计树 vs 区间树**：
	- 前者通过 “子树大小” 支持动态有序统计，解决 “第 k 小” 和 “排名” 问题；
	- 后者通过 “子树最大高点 m” 支持区间重叠查询，解决动态区间管理问题；
	- 两者均遵循 “四步方法论”，验证了数据结构增强的普适性。



# 跳跃表（Skip List）知识点总结

## 一、跳跃表的定位与核心优势

### 1. 动态搜索结构的对比

跳跃表是**动态随机搜索结构**，支持「搜索、插入、删除」三大操作，与其他经典动态搜索结构的对比如下：

| 数据结构       | 时间复杂度（搜索 / 插入 / 删除） | 实现难度 | 核心特点                                  |
| -------------- | -------------------------------- | -------- | ----------------------------------------- |
| 普通排序链表   | O(n)                             | 极低     | 仅支持顺序访问，无随机访问                |
| 二叉搜索树     | 期望 O (log n)，最坏 O (n)       | 中等     | 依赖树的平衡性                            |
| 红黑树         | 最坏 O (log n)                   | 高       | 通过颜色规则维持平衡，需记忆 3 种调整案例 |
| B 树（B - 树） | 最坏 O (log n)                   | 较高     | 多叉结构，删除需 “借节点”                 |
| **跳跃表**     | 期望 O (log n)，高概率 O (log n) | 极低     | 基于链表 + 随机分层，无需复杂平衡规则     |

### 2. 跳跃表的核心优势

- **实现简单**：仅依赖链表操作，无需复杂的树结构调整（如红黑树的旋转、B 树的节点合并 / 分裂），视频中提到 “1 小时可实现，调试仅需 30 分钟”。
- **高概率高效**：不仅期望时间复杂度为 O (log n)，且**高概率**（概率≥1-1/n^α，α 可任意设置）保证每次操作时间为 O (log n)，尾部误差极小。
- **动态适应性**：插入时通过随机 “抛硬币” 决定节点分层，自动维持结构平衡，无需人工干预。

## 二、跳跃表的核心原理

### 1. 本质：“分层链表” 与 “地铁快线模型”

跳跃表的灵感来自纽约地铁的 “快线 + 慢线” 系统：

- **慢线（最底层链表）**：包含所有元素，按顺序排列（类似地铁 “本地线”，每站都停）。
- **快线（上层链表）**：包含下层链表的子集（类似地铁 “快线”，只停关键站点），用于快速跳过大量元素，减少搜索步数。
- **分层逻辑**：上层链表的元素是下层的 “抽样”，抽样概率为 1/2（即每个元素有 50% 概率出现在上一层），最终形成 log n 层（n 为元素总数）。

#### 示例：分层结构示意

假设元素为 `[9,12,15,26,44,50,51,52,53,72,79]`，跳跃表分层如下（↑表示元素在多层出现）：

| 层级 3（顶层） | -∞ ↑ | 53 ↑ |      |      |      |      |      |      |      |      |      |      |
| -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 层级 2         | -∞ ↑ | 12 ↑ | 50 ↑ | 53 ↑ |      |      |      |      |      |      |      |      |
| 层级 1         | -∞ ↑ | 12 ↑ | 15 ↑ | 50 ↑ | 53 ↑ | 72 ↑ |      |      |      |      |      |      |
| 层级 0（底层） | -∞ ↑ | 9    | 12 ↑ | 15 ↑ | 26   | 44   | 50 ↑ | 51   | 52   | 53 ↑ | 72 ↑ | 79   |

- 注：`-∞` 是哨兵节点，始终存在于所有层级，作为搜索的起点（左上角），避免边界判断。

### 2. 关键概念：“节点高度” 与 “随机分层”

- **节点高度**：节点所在的最高层级（如示例中 53 的高度为 3，12 的高度为 2）。
- **分层规则（插入时）**：
	1. 新节点默认插入底层（层级 0）。
	2. 抛一枚公平硬币：若为 “正面”，则将节点提升到上一层；若为 “反面”，停止提升。
	3. 重复步骤 2，直到硬币出现 “反面” 或达到当前跳跃表的最大层级 + 1（此时扩展跳跃表层级）。
- **概率意义**：节点高度为 k 的概率为 (1/2)^k，保证上层元素数量是下层的 1/2，维持 O (log n) 的搜索步数。

## 三、跳跃表的核心操作（含示例）

所有操作均基于 “从顶层到低层，先右后下” 的逻辑，核心是先找到操作位置，再执行链表修改。

### 1. 搜索操作

#### 目标

查找元素 x，若存在则返回节点；若不存在则返回其应插入的前驱节点（为插入操作做准备）。

#### 步骤（以搜索 72 为例）

1. 从顶层（层级 3）的哨兵节点 `-∞` 开始。
2. 层级 3： `-∞` 的右节点是 53，53 < 72 → 尝试继续右移，但 53 右侧无节点 → 向下进入层级 2。
3. 层级 2： `-∞` 右移到 12（12<72）→ 再右移到 50（50<72）→ 再右移到 53（53<72）→ 右侧无节点 → 向下进入层级 1。
4. 层级 1： `-∞` 右移到 12→15→50→53（均 < 72）→ 右侧无节点 → 向下进入层级 0。
5. 层级 0： `-∞` 右移到 9→12→15→26→44→50→51→52→53（均 < 72）→ 右移到 72（等于目标）→ 搜索成功。

#### 时间复杂度

- 每一层最多移动 1 步（“先右后下”），层级数为 O (log n) → 总时间 O (log n)。

### 2. 插入操作

#### 步骤（以插入 80 为例）

1. **搜索定位**：按搜索逻辑查找 80，找到其在底层（层级 0）的前驱节点 72（80 应插入 72 和 79 之间），同时记录每一层的前驱节点（用于后续层级插入）。
2. **底层插入**：在层级 0 中，将 80 插入 72 和 79 之间（标准链表插入：72→80→79）。
3. **随机分层**：
	- 抛硬币：若为 “反面”，停止提升；若为 “正面”，则在上一层插入 80，并重复抛硬币。
	- 示例：若抛硬币 1 次为 “正面”，则在层级 1 插入 80（前驱为 53，后继为 72）；再抛 1 次为 “反面”，停止。
4. **层级扩展**：若提升到当前最大层级 + 1，则扩展跳跃表的层级（新增一层，包含哨兵节点和当前节点）。

### 3. 删除操作

#### 步骤（以删除 53 为例）

1. **搜索定位**：按搜索逻辑查找 53，找到其在所有层级的节点及前驱节点。
2. **层级删除**：在每个包含 53 的层级中，执行标准链表删除（如层级 3：-∞→53→null → 修改为 -∞→null；层级 2：50→53→null → 修改为 50→null，以此类推）。
3. **层级收缩**：若删除后顶层（非哨兵）无节点，则删除顶层（可选，仅优化空间）。

## 四、C++ 代码实现

### 1. 节点结构定义

每个节点包含：键值、当前层级的右指针数组（`forward[i]` 表示第 i 层的下一个节点）、节点高度。

cpp

```cpp
#include <iostream>
#include <vector>
#include <random>
#include <climits>
using namespace std;

// 跳跃表节点类
class SkipListNode {
public:
    int key;                          // 键值（假设为int，可扩展为其他类型）
    vector<SkipListNode*> forward;    // forward[i]：第i层的下一个节点
    int height;                       // 节点高度（所在的最大层级+1）

    // 构造函数：初始化键值和高度
    SkipListNode(int k, int h) : key(k), height(h) {
        forward.resize(h, nullptr);   // 初始化各层的右指针为null
    }
};
```

### 2. 跳跃表类定义

包含：最大层级（`max_level`）、当前层级（`current_level`）、哨兵节点（`head`，键值为 -∞）、随机数生成器（用于抛硬币）。

cpp

```cpp
class SkipList {
private:
    int max_level;            // 跳跃表的最大允许层级（通常设为log2(n_max)，如16）
    int current_level;        // 跳跃表当前的最大层级（初始为0）
    SkipListNode* head;       // 哨兵节点（键值-∞，存在于所有层级）
    mt19937 rng;              // 随机数生成器（C++11及以上）
    uniform_int_distribution<int> dist; // 0-1分布（模拟抛硬币）

    // 随机生成节点高度（抛硬币直到反面）
    int randomHeight() {
        int height = 1;       // 至少在第0层
        // 抛硬币：1为正面（继续提升），0为反面（停止），最多到max_level
        while (dist(rng) == 1 && height < max_level) {
            height++;
        }
        return height;
    }

public:
    // 构造函数：初始化最大层级、当前层级、哨兵节点、随机数生成器
    SkipList(int max_lvl = 16) : max_level(max_lvl), current_level(0) {
        // 哨兵节点：键值-∞，高度为max_level（覆盖所有可能层级）
        head = new SkipListNode(INT_MIN, max_level);
        // 初始化随机数生成器（种子为系统时间）
        random_device rd;
        rng = mt19937(rd());
        dist = uniform_int_distribution<int>(0, 1);
    }

    // 析构函数：释放所有节点内存
    ~SkipList() {
        SkipListNode* curr = head;
        while (curr != nullptr) {
            SkipListNode* next = curr->forward[0];
            delete curr;
            curr = next;
        }
    }

    // 1. 搜索操作：查找键值key，返回是否存在
    bool search(int key) {
        SkipListNode* curr = head;

        // 从顶层到底层：先右后下
        for (int i = current_level; i >= 0; i--) {
            // 右移直到下一个节点的键值>当前key
            while (curr->forward[i] != nullptr && curr->forward[i]->key < key) {
                curr = curr->forward[i];
            }
        }

        // 下到第0层，检查下一个节点是否为目标key
        curr = curr->forward[0];
        return (curr != nullptr && curr->key == key);
    }

    // 2. 插入操作：插入键值key
    void insert(int key) {
        // update数组：记录每一层的前驱节点（用于后续插入）
        vector<SkipListNode*> update(max_level, nullptr);
        SkipListNode* curr = head;

        // 步骤1：找到每一层的前驱节点
        for (int i = current_level; i >= 0; i--) {
            while (curr->forward[i] != nullptr && curr->forward[i]->key < key) {
                curr = curr->forward[i];
            }
            update[i] = curr; // 记录第i层的前驱节点
        }

        // 步骤2：检查key是否已存在（若存在则不插入）
        curr = curr->forward[0];
        if (curr != nullptr && curr->key == key) {
            cout << "Key " << key << " already exists, skip insertion." << endl;
            return;
        }

        // 步骤3：随机生成新节点的高度
        int new_height = randomHeight();

        // 步骤4：若新节点高度超过当前层级，更新update数组的上层前驱（哨兵节点）
        if (new_height > current_level) {
            for (int i = current_level + 1; i < new_height; i++) {
                update[i] = head;
            }
            current_level = new_height; // 更新跳跃表当前最大层级
        }

        // 步骤5：创建新节点，并在各层插入
        SkipListNode* new_node = new SkipListNode(key, new_height);
        for (int i = 0; i < new_height; i++) {
            // 链表插入：new_node的前驱为update[i]，后继为update[i]->forward[i]
            new_node->forward[i] = update[i]->forward[i];
            update[i]->forward[i] = new_node;
        }

        cout << "Insert key " << key << " with height " << new_height << endl;
    }

    // 3. 删除操作：删除键值key
    void remove(int key) {
        // update数组：记录每一层的前驱节点
        vector<SkipListNode*> update(max_level, nullptr);
        SkipListNode* curr = head;

        // 步骤1：找到每一层的前驱节点
        for (int i = current_level; i >= 0; i--) {
            while (curr->forward[i] != nullptr && curr->forward[i]->key < key) {
                curr = curr->forward[i];
            }
            update[i] = curr;
        }

        // 步骤2：检查key是否存在（若不存在则不删除）
        curr = curr->forward[0];
        if (curr == nullptr || curr->key != key) {
            cout << "Key " << key << " does not exist, skip deletion." << endl;
            return;
        }

        // 步骤3：在各层删除节点
        for (int i = 0; i < curr->height; i++) {
            // 若前驱节点的后继不是当前节点，说明当前层无该节点（跳过）
            if (update[i]->forward[i] != curr) {
                break;
            }
            // 链表删除：前驱节点的后继指向当前节点的后继
            update[i]->forward[i] = curr->forward[i];
        }

        // 步骤4：释放当前节点内存
        delete curr;

        // 步骤5：收缩层级（若顶层无节点，降低当前层级）
        while (current_level > 0 && head->forward[current_level] == nullptr) {
            current_level--;
        }

        cout << "Delete key " << key << " successfully." << endl;
    }

    // 辅助函数：打印跳跃表（从顶层到底层）
    void printSkipList() {
        cout << "\nSkip List Structure (level: " << current_level << "):" << endl;
        for (int i = current_level; i >= 0; i--) {
            SkipListNode* curr = head->forward[i];
            cout << "Level " << i << ": ";
            while (curr != nullptr) {
                cout << curr->key << " -> ";
                curr = curr->forward[i];
            }
            cout << "null" << endl;
        }
    }
};
```

### 3. 测试代码（示例）

cpp

```cpp
int main() {
    // 初始化跳跃表（最大层级16）
    SkipList sl(16);

    // 插入测试
    sl.insert(14);
    sl.insert(34);
    sl.insert(42);
    sl.insert(50);
    sl.insert(53);
    sl.insert(72);
    sl.insert(79);
    sl.printSkipList();

    // 搜索测试
    int key1 = 53, key2 = 100;
    cout << "\nSearch key " << key1 << ": " << (sl.search(key1) ? "Found" : "Not Found") << endl;
    cout << "Search key " << key2 << ": " << (sl.search(key2) ? "Found" : "Not Found") << endl;

    // 删除测试
    sl.remove(53);
    sl.remove(100); // 不存在的键
    sl.printSkipList();

    // 插入新键
    sl.insert(80);
    sl.printSkipList();

    return 0;
}
```

### 4. 代码说明

- **随机数生成**：使用`mt19937`（梅森旋转算法）生成高质量随机数，`uniform_int_distribution(0,1)`模拟抛硬币（0 = 反面，1 = 正面）。

- **哨兵节点**：键值为`INT_MIN`（-∞），高度为`max_level`，避免搜索 / 插入时的边界判断。

- **内存管理**：析构函数遍历底层链表，释放所有节点内存，避免内存泄漏。

- **层级收缩**：删除节点后，若顶层无有效节点，降低`current_level`，优化空间和后续操作效率。

- ## 五、关键定理与概率保证

	### 1. 层级数定理

	**定理**：n 个元素的跳跃表，其最大层级的期望为 **O(log n)**，且高概率（概率≥1-1/n^c，c 为任意正整数）不超过 **2log n**。

	- 推导依据：节点高度为 k 的概率是 (1/2)^k，层级 k 存在元素的概率为 n*(1/2)^k。当 k=2log n 时，n*(1/2)^{2log n}=n*(1/n²)=1/n，即高概率下无元素超过 2log n 层。
	- 意义：保证搜索、插入、删除操作的层级遍历次数为 O (log n)，奠定时间复杂度基础。

	### 2. 操作步数定理

	**定理**：跳跃表中单次搜索、插入或删除操作的期望步数为 **O(log n)**，且高概率（概率≥1-1/n^c）步数不超过 **4log n**。

	- 推导逻辑：每一层最多移动 1 步（“先右后下” 策略），层级数为 O (log n)，因此总步数为 O (log n)；通过概率不等式（如切尔诺夫界）可证明步数超过 4log n 的概率极低。
	- 对比优势：虽无红黑树 “最坏 O (log n)” 的绝对保证，但 “高概率 O (log n)” 在工程实践中与 “最坏 O (log n)” 等效，且实现成本远低。

	## 六、跳跃表的工程应用场景

	视频中明确提到跳跃表在工业界的核心应用，主要依托其 “高效 + 易实现” 的特性：

	1. **Redis 的有序集合（ZSet）**
		- Redis 中 ZSet 需支持 “按分数排序 + 快速插入 / 删除 / 查询”，跳跃表是核心实现之一（与哈希表配合，哈希表存 “值→分数” 映射，跳跃表存 “分数→值” 的有序结构）。
		- 选择原因：Redis 需支持分布式环境下的高效操作，红黑树实现复杂且调试难度高，跳跃表的代码简洁性可降低维护成本，同时满足性能需求。
	2. **LevelDB/RocksDB 的 MemTable**
		- LevelDB 是 LSM 树（日志结构合并树）的经典实现，MemTable（内存表）需支持有序插入和前缀查询，跳跃表是默认实现。
		- 选择原因：LSM 树的 MemTable 需高频写入，跳跃表的插入操作无需锁竞争优化（单线程场景下），且查询效率可满足 “内存级” 需求。
	3. **分布式系统的路由表**
		- 部分分布式 KV 存储（如 Etcd 早期版本）用跳跃表维护 “键范围→节点” 的路由映射，支持动态节点扩容 / 缩容时的快速路由更新。
		- 选择原因：分布式环境下节点状态动态变化，跳跃表的动态适应性无需复杂平衡操作，可快速响应路由表修改。

	## 七、常见问题与视频中提到的注意事项

	### 1. 为什么选择 “1/2” 的抽样概率？

	- 视频中解释：1/2 是 “效率与实现复杂度” 的平衡点。若抽样概率过高（如 1/3），上层元素过多，层级数减少但每层移动步数增加；若抽样概率过低（如 1/4），每层步数减少但层级数增加，最终都会导致总步数接近 O (log n)，但 1/2 的实现最简洁（抛硬币只需 0/1 判断）。

	### 2. 跳跃表的空间复杂度是多少？

	- 期望空间复杂度：**O(n)**。
		推导：每个元素的期望高度为 Σ（k=1 到∞）P (高度≥k) = Σ（k=1 到∞）(1/2)^{k-1} = 2，即 n 个元素的期望总指针数为 2n，因此总空间为 O (n)。
	- 对比：红黑树每个节点需存储颜色和 2 个指针（左 / 右），总空间也是 O (n)，二者空间效率相当。

	### 3. 如何处理 “重复键”？

	- 视频中提供两种方案：
		方案 1：允许跳跃表存储重复键，插入时直接按 “键值相等时插入到前驱节点右侧” 的规则处理（底层链表会形成重复键的有序序列）。
		方案 2：将 “键 + 唯一标识” 作为复合键（如 Redis 的 ZSet 中，相同分数的元素按 “值” 的字典序排序），保证键的唯一性，避免重复。

	### 4. 跳跃表是否支持 “范围查询”？

	- 支持，且效率极高。例如查询 “[10,50]” 的所有元素：
		1. 先通过搜索操作找到 10 的位置；
		2. 从 10 的底层节点开始，沿底层链表向右遍历，直到节点键值 > 50，遍历过程中收集所有节点。
	- 时间复杂度：O (log n + m)，其中 m 为范围内的元素个数，远优于普通排序链表的 O (n)。

	## 八、代码运行示例与输出解释

	### 1. 测试代码运行流程

	在`main`函数中，执行 “插入 7 个键→打印→搜索 2 个键→删除 2 个键→打印→插入 1 个键→打印” 的流程，典型输出如下（因随机分层，高度可能不同）：

	plaintext

	```plaintext
Insert key 14 with height 2
	Insert key 34 with height 1
Insert key 42 with height 3
	Insert key 50 with height 1
Insert key 53 with height 2
	Insert key 72 with height 1
	Insert key 79 with height 2
	
	Skip List Structure (level: 3):
	Level 3: 42 -> null
	Level 2: 14 -> 42 -> 53 -> 79 -> null
	Level 1: 14 -> 34 -> 42 -> 50 -> 53 -> 72 -> 79 -> null
	Level 0: 14 -> 34 -> 42 -> 50 -> 53 -> 72 -> 79 -> null
	
	Search key 53: Found
	Search key 100: Not Found
	
	Delete key 53 successfully.
	Key 100 does not exist, skip deletion.
	
	Skip List Structure (level: 3):
	Level 3: 42 -> null
	Level 2: 14 -> 42 -> 79 -> null
	Level 1: 14 -> 34 -> 42 -> 50 -> 72 -> 79 -> null
	Level 0: 14 -> 34 -> 42 -> 50 -> 72 -> 79 -> null
	
	Insert key 80 with height 1
	
	Skip List Structure (level: 3):
	Level 3: 42 -> null
	Level 2: 14 -> 42 -> 79 -> null
	Level 1: 14 -> 34 -> 42 -> 50 -> 72 -> 79 -> 80 -> null
	Level 0: 14 -> 34 -> 42 -> 50 -> 72 -> 79 -> 80 -> null
	```
	
	### 2. 输出解释
	
	- 插入阶段：42 的高度为 3（最高），因此跳跃表当前层级为 3；14、53、79 的高度为 2，其余键高度为 1，符合 “随机分层” 的概率特性。
	- 删除阶段：删除 53 后，各层级的 53 节点均被移除，且因顶层（Level3）仍有 42 节点，当前层级保持 3 不变。
	- 范围查询示例：若查询 “[34,72]”，从 Level0 的 34 开始向右遍历，可收集 34、42、50、72，无需遍历所有元素。

	
