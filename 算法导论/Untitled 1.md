# 摊销分析与动态表

## 1. 问题背景：动态表的必要性

### 1.1 哈希表大小的核心矛盾

哈希表的大小需在**空间效率**与**搜索性能**间平衡：

- 过大：浪费内存（无需的空闲空间多）
- 过小：链式哈希中链表变长，搜索时间从理想 O (1) 退化至 O (k)（k 为链表长度）
- 关键痛点：若提前未知元素数量，无法固定初始大小，需动态调整表容量。

### 1.2 动态表扩容策略

#### 1.2.1 触发条件

当表中元素个数`count`等于表大小`size`（即表 “满”）时，触发扩容。

#### 1.2.2 扩容规则

- 新表大小 = 旧表大小 × 2（翻倍扩容，确保表大小始终为 2 的幂）
- 操作流程：
	1. 分配大小为`2×size`的新数组；
	2. 将旧表中所有元素复制到新数组；
	3. 释放旧表内存；
	4. 插入新元素。

#### 1.2.3 视频示例

| 插入次数 | 插入元素 | 扩容前表大小 | 扩容后表大小 | 元素复制数    | 插入后元素数 |
| -------- | -------- | ------------ | ------------ | ------------- | ------------ |
| 1        | 1        | 1（初始）    | 不扩容       | 0             | 1            |
| 2        | 2        | 1（满）      | 2            | 1（复制 1）   | 2            |
| 3        | 3        | 2（满）      | 4            | 2（复制 1,2） | 3            |
| 4        | 4        | 4（未满）    | 不扩容       | 0             | 4            |
| 5        | 5        | 4（满）      | 8            | 4（复制 1-4） | 5            |
| 6        | 6        | 8（未满）    | 不扩容       | 0             | 6            |
| 7        | 7        | 8（未满）    | 不扩容       | 0             | 7            |
| 8        | 8        | 8（未满）    | 不扩容       | 0             | 8            |
| 9        | 9        | 8（满）      | 16           | 8（复制 1-8） | 9            |

## 2. 摊销分析（Amortized Analysis）三大方法

摊销分析的核心：不孤立看待单次操作的最坏成本，而是通过**n 次操作的总成本**，推导单次操作的 “均摊成本”，体现整体性能。

### 2.1 方法 1：聚合分析（Aggregate Analysis）

#### 2.1.1 核心思想

- 计算**n 次操作的总真实成本**，再除以 n 得到单次操作的均摊成本；
- 关键结论：即使单次操作（如扩容）最坏成本为 O (n)，若 n 次操作总成本为 O (n)，则单次均摊成本仍为 O (1)。

#### 2.1.2 动态表的聚合分析

1. **定义变量**：
	- `n`：总插入次数；
	- `size`：表大小（始终为 2 的幂，即`size=2^k`，`k`为非负整数）；
	- 第`i`次插入的真实成本`c_i`：
		- 无需扩容：`c_i=1`（仅插入新元素，无复制）；
		- 需扩容：`c_i=i`（复制`i-1`个旧元素 + 插入 1 个新元素）。
2. **总真实成本计算**：
	- 总成本 = 所有插入的基础成本（每次 1） + 扩容时的复制成本；
	- 基础成本总和：`n`（n 次插入，每次 1）；
	- 复制成本总和：扩容时复制的元素数为`1,2,4,...,2^{m-1}`（`m`为扩容次数，`2^{m-1} <n ≤2^m`），即几何级数求和：`1+2+4+...+2^{m-1}=2^m -1 ≤n`（因`2^m ≤2n`）；
	- 总真实成本 ≤ `n +n=2n ≤3n`（视频简化为≤3n）。
3. **结论**：n 次插入总真实成本为 O (n)，单次插入均摊成本为`O(n)/n=O(1)`。

### 2.2 方法 2：会计论证（Accounting Method）

#### 2.2.1 核心思想

- 为单次操作设定**均摊成本**（“收费标准”`ĉ_i`），真实成本为`c_i`；
- 成本差额处理：
	- 若`ĉ_i >c_i`：多余部分（`ĉ_i -c_i`）存入 “银行账户”，用于未来高成本操作；
	- 若`ĉ_i <c_i`：差额部分（`c_i -ĉ_i`）从银行账户支取；
- 约束：银行账户余额始终≥0（确保不透支，均摊成本可覆盖所有真实成本）。

#### 2.2.2 动态表的会计论证（视频方案）

1. **设定均摊成本**：每次插入的均摊成本`ĉ_i=3`（3 个 “货币单位”）。

2. **成本分配规则**：

	- 1 个单位：支付当前插入的基础成本（无需扩容时`c_i=1`，刚好覆盖）；
	- 2 个单位：存入银行，用于未来扩容时的元素复制成本。

3. **余额验证（视频示例）**：

	| 插入次数 | 插入元素 | 真实成本`c_i`        | 均摊收费`ĉ_i` | 余额变化（余额 = 上一轮余额 +`ĉ_i -c_i`） | 最终余额 |
	| -------- | -------- | -------------------- | ------------- | ----------------------------------------- | -------- |
	| 初始     | -        | -                    | -             | -                                         | 0        |
	| 1        | 1        | 1                    | 3             | 0 + (3-1)=2                               | 2        |
	| 2        | 2        | 2（复制 1 + 插入 1） | 3             | 2 + (3-2)=3                               | 3        |
	| 3        | 3        | 3（复制 2 + 插入 1） | 3             | 3 + (3-3)=3                               | 3        |
	| 4        | 4        | 1                    | 3             | 3 + (3-1)=5                               | 5        |
	| 5        | 5        | 5（复制 4 + 插入 1） | 3             | 5 + (3-5)=3                               | 3        |

4. **结论**：所有操作后余额非负，n 次插入总均摊成本 = 3n，覆盖总真实成本，单次均摊成本 O (1)。

### 2.3 方法 3：势能方法（Potential Method）

#### 2.3.1 核心思想

- 定义**势能函数**`φ(D)`：映射数据结构状态`D`到非负实数，代表 “储存的势能”（类似银行余额）；
- 均摊成本公式：`ĉ_i = c_i + φ(D_i) - φ(D_{i-1})`，其中：
	- `c_i`：第 i 次操作的真实成本；
	- `φ(D_i)`：操作后状态的势能；
	- `φ(D_{i-1})`：操作前状态的势能；
- 关键性质：
	1. 初始势能`φ(D_0)=0`（初始状态无势能）；
	2. 所有状态`D_i`的`φ(D_i)≥0`（势能不透支）；
- 总均摊成本（望远镜求和）：`Σ_{i=1}^n ĉ_i = Σ_{i=1}^n c_i + φ(D_n) - φ(D_0) ≥ Σ_{i=1}^n c_i`（因`φ(D_n)≥0`、`φ(D_0)=0`），即均摊成本覆盖真实成本。

#### 2.3.2 动态表的势能方法

1. **定义势能函数**：

	- 设`D_i`为第 i 次插入后的状态，`i`为当前元素个数（`count=i`）；
	- 表大小`size=2^{⌈log₂i⌉}`（≥i 的最小 2 的幂）；
	- 势能函数：`φ(D_i) = 2i - size`。

2. **验证势能函数性质**：

	- 初始状态`D_0`（i=0）：`φ(D_0)=2×0 - 2^{⌈log₂0⌉}=0`（视频定义`log₂0`极限为 -∞，`2^{-∞}=0`）；
	- 所有`D_i`的`φ(D_i)≥0`：因`size=2^{⌈log₂i⌉} ≤2i`（`⌈log₂i⌉≤log₂(2i)`），故`φ(D_i)=2i - size ≥0`。

3. **单次插入均摊成本计算（分情况）**：

	##### 情况 1：无需扩容（`i-1 < size_prev`，`size_prev=size_i`）

	- 真实成本`c_i=1`（仅插入）；
	- 操作前势能：`φ(D_{i-1})=2(i-1) - size_prev`；
	- 操作后势能：`φ(D_i)=2i - size_i`（`size_i=size_prev`）；
	- 均摊成本：`ĉ_i =1 + [2i - size_i - (2(i-1)-size_prev)] =1+2=3`。

	##### 情况 2：需扩容（`i-1=size_prev`，`size_new=2×size_prev`）

	- 真实成本`c_i=i`（复制`i-1`个旧元素 + 插入 1 个新元素）；
	- 操作前势能：`φ(D_{i-1})=2(i-1) - (i-1)=i-1`；
	- 操作后势能：`φ(D_i)=2i - 2(i-1)=2`；
	- 均摊成本：`ĉ_i =i + [2 - (i-1)] =3`。

4. **结论**：无论是否扩容，单次插入均摊成本恒为 3（常数），即均摊成本 O (1)。

## 3. 动态表的 C++ 实现

### 3.1 实现思路

- 模板类支持任意数据类型；
- 核心成员：`T* data`（动态数组）、`size_t size`（表大小）、`size_t count`（元素个数）；
- 核心方法：`insert`（插入元素，满则扩容）、`expand`（翻倍扩容 + 复制元素）。

### 3.2 完整代码

cpp

```cpp
#include <iostream>
#include <string>

// 动态表模板类（严格遵循视频翻倍扩容逻辑）
template <typename T>
class DynamicTable {
private:
    T* data;       // 存储元素的动态数组
    size_t size;   // 当前表大小（始终为2的幂）
    size_t count;  // 当前元素个数

    // 扩容操作：翻倍大小+复制旧元素+释放旧空间（视频核心逻辑）
    void expand() {
        size_t new_size = size * 2; // 翻倍扩容
        T* new_data = new T[new_size]; // 分配新数组

        // 复制旧元素（兼容非POD类型，调用T的赋值运算符）
        for (size_t i = 0; i < count; ++i) {
            new_data[i] = data[i];
        }

        // 释放旧数组内存
        delete[] data;

        // 更新指针和表大小
        data = new_data;
        size = new_size;

        // 打印扩容日志（验证视频逻辑）
        std::cout << "[扩容] 旧大小=" << size / 2 << " → 新大小=" << size << std::endl;
    }

public:
    // 构造函数：初始表大小=1，元素个数=0
    DynamicTable() : size(1), count(0) {
        data = new T[size];
        std::cout << "初始化动态表：初始大小=" << size << std::endl;
    }

    // 析构函数：释放动态数组
    ~DynamicTable() {
        delete[] data;
    }

    // 插入元素（视频逻辑：满则扩容，再插入）
    void insert(const T& val) {
        // 检查是否满（元素数==表大小），满则扩容
        if (count == size) {
            expand();
        }

        // 插入新元素
        data[count] = val;
        ++count;

        // 打印插入日志（验证视频逻辑）
        std::cout << "插入元素：" << val 
                  << " | 当前元素数=" << count 
                  << " | 表大小=" << size << std::endl;
    }

    // 打印表中所有元素（辅助查看）
    void printTable() const {
        std::cout << "当前表元素：";
        for (size_t i = 0; i < count; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }

    // 辅助接口：获取当前元素个数
    size_t getCount() const { return count; }
    // 辅助接口：获取当前表大小
    size_t getSize() const { return size; }
};

// 主函数：模拟视频中的插入示例
int main() {
    // 测试int类型动态表
    DynamicTable<int> int_table;

    std::cout << "\n===== 开始插入int元素（视频示例顺序：1,2,3,4,5,6,7,8,9）=====" << std::endl;
    int_table.insert(1);
    int_table.insert(2);
    int_table.insert(3);
    int_table.insert(4);
    int_table.insert(5);
    int_table.insert(6);
    int_table.insert(7);
    int_table.insert(8);
    int_table.insert(9);

    // 打印最终状态
    std::cout << "\n===== int表最终状态 =====" << std::endl;
    int_table.printTable();
    std::cout << "最终元素数：" << int_table.getCount() << std::endl;
    std::cout << "最终表大小：" << int_table.getSize() << std::endl;

    // （可选）测试string类型动态表
    DynamicTable<std::string> str_table;
    std::cout << "\n\n===== 测试string类型插入 =====" << std::endl;
    str_table.insert("a");
    str_table.insert("b");
    str_table.insert("c");
    str_table.printTable();

    return 0;
}
```

### 3.3 代码运行结果

plaintext

```plaintext
初始化动态表：初始大小=1

===== 开始插入int元素（视频示例顺序：1,2,3,4,5,6,7,8,9）=====
插入元素：1 | 当前元素数=1 | 表大小=1
[扩容] 旧大小=1 → 新大小=2
插入元素：2 | 当前元素数=2 | 表大小=2
[扩容] 旧大小=2 → 新大小=4
插入元素：3 | 当前元素数=3 | 表大小=4
插入元素：4 | 当前元素数=4 | 表大小=4
[扩容] 旧大小=4 → 新大小=8
插入元素：5 | 当前元素数=5 | 表大小=8
插入元素：6 | 当前元素数=6 | 表大小=8
插入元素：7 | 当前元素数=7 | 表大小=8
插入元素：8 | 当前元素数=8 | 表大小=8
[扩容] 旧大小=8 → 新大小=16
插入元素：9 | 当前元素数=9 | 表大小=16

===== int表最终状态 =====
当前表元素：1 2 3 4 5 6 7 8 9 
最终元素数：9
最终表大小：16


===== 测试string类型插入 =====
初始化动态表：初始大小=1
插入元素：a | 当前元素数=1 | 表大小=1
[扩容] 旧大小=1 → 新大小=2
插入元素：b | 当前元素数=2 | 表大小=2
[扩容] 旧大小=2 → 新大小=4
插入元素：c | 当前元素数=3 | 表大小=4
当前表元素：a b c 
```

## 4. 核心结论

1. **动态表策略有效性**：通过 “翻倍扩容”，解决了未知元素数量时的空间与性能权衡问题；
2. **摊销分析价值**：三种方法（聚合、会计、势能）均证明，动态表单次插入的均摊成本为 O (1)，整体性能可控；
3. **关键启示**：高成本操作（如扩容）可通过 “均摊” 到多次低成本操作中，避免整体复杂度退化。



#  竞争性分析与自组织表

## 1. 问题背景：自组织列表（Self-Organizing Lists）

### 1.1 问题定义

- 给定包含 **n 个元素** 的线性列表 `L`，用户会对列表中的元素发起一系列 **访问请求**（如搜索、读取）。
- 算法的目标是 **最小化总访问成本**：每次访问后可重新排序列表（如交换元素），但重新排序本身会产生额外成本。
- 核心矛盾：需在 “访问成本” 和 “重排序成本” 之间权衡，通过动态调整列表顺序降低长期总成本。

### 1.2 成本模型（视频明确定义）

1. **访问成本**：元素在列表中的 “排名”（即距离头部的步数）。
	- 例：列表头部元素排名为 1，访问成本为 1；第 k 位元素访问成本为 k。
2. **重排序成本**：采用 “相邻元素转置”（交换相邻元素），每次转置成本为 1。
	- 例：将第 4 位元素移到头部，需 3 次相邻转置（4→3、3→2、2→1），重排序成本为 3。
3. **单次操作总成本**：访问成本 + 重排序成本。
	- 例：访问第 4 位元素后移到头部，总成本 = 4（访问成本） + 3（转置成本） = 7。

## 2. 在线算法 vs 离线算法

### 2.1 定义与核心区别

| 类型     | 核心特征                                                     | 优势                       | 劣势                             |
| -------- | ------------------------------------------------------------ | -------------------------- | -------------------------------- |
| 在线算法 | 每次仅处理当前访问请求，**无法预知后续请求序列**，需立即决定是否重排序。 | 无需等待完整序列，实时响应 | 无法全局优化，易受 “坏序列” 影响 |
| 离线算法 | 可预先获取**完整访问序列**，再规划最优重排序策略。           | 能全局优化，总成本更低     | 需等待完整序列，无法实时响应     |

### 2.2 示例：俄罗斯方块类比

- 在线模式：每次仅能看到当前下落的方块，需立即决定旋转 / 移动，无法预知下一个方块，易出现 “卡缝” 问题。
- 离线模式：提前看到所有方块的下落顺序，可规划最优摆放位置，几乎不会产生垃圾行。

## 3. 静态排序的最优性（概率分布假设下）

### 3.1 问题假设

- 假设每个元素被访问的概率是固定的（如元素 x 的访问概率为 p (x)，所有元素概率和为 1）。
- 静态排序：列表顺序固定，不随访问动态调整，仅需确定初始排序以最小化**期望访问成本**。

### 3.2 最优静态排序策略

- 结论：按元素访问概率 **递减顺序** 排序（概率最高的元素在头部，最低的在尾部），可使期望访问成本最小。

### 3.3 简单证明

设列表中有两个元素 x 和 y，访问概率分别为 p (x) 和 p (y)，且 p (x) > p (y)。

- 若 x 在 y 前：x 的排名为 k，y 的排名为 k+1，期望成本贡献为 k・p (x) + (k+1)・p (y)。
- 若 y 在 x 前：y 的排名为 k，x 的排名为 k+1，期望成本贡献为 k・p (y) + (k+1)・p (x)。

两式差值为：
[k·p(y) + (k+1)·p(x)] - [k·p(x) + (k+1)·p(y)] = p(x) - p(y) > 0
→ 概率高的元素在前时，期望成本更低，故最优策略为按概率递减排序。

## 4. 自组织列表的启发式算法：Move-to-Front（MTF）

### 4.1 MTF 算法规则

每次访问一个元素后，**将该元素直接移到列表的最前端**（无需逐次相邻转置，若用链表可通过指针操作实现，重排序成本视为常数；视频中分析时仍按 “转置成本 = 排名 - 1” 计算）。

### 4.2 时间局部性优势

- 时间局部性：刚被访问过的元素，短期内被再次访问的概率更高（如循环访问、重复操作）。
- MTF 可利用这一特性：热门元素会被 “留在” 前端，后续访问成本大幅降低。

### 4.3 示例：MTF 执行过程

假设初始列表为 `[1, 2, 3, 4]`，访问序列为 `[3, 4, 3, 1]`，计算每次操作的成本和列表变化：

| 访问步骤 | 访问元素 | 初始列表     | 元素排名（访问成本） | 重排序成本（转置次数） | 单次总成本 | 重排序后列表 | 累计总费用 |
| -------- | -------- | ------------ | -------------------- | ---------------------- | ---------- | ------------ | ---------- |
| 1        | 3        | [1, 2, 3, 4] | 3                    | 2（3→2→1）             | 3+2=5      | [3, 1, 2, 4] | 5          |
| 2        | 4        | [3, 1, 2, 4] | 4                    | 3（4→3→2→1）           | 4+3=7      | [4, 3, 1, 2] | 12         |
| 3        | 3        | [4, 3, 1, 2] | 2                    | 1（3→1）               | 2+1=3      | [3, 4, 1, 2] | 15         |
| 4        | 1        | [3, 4, 1, 2] | 3                    | 2（1→2→1）             | 3+2=5      | [1, 3, 4, 2] | 20         |

## 5. 竞争分析（Competitive Analysis）

### 5.1 竞争比定义

设：

- `C_A(S)`：在线算法 A 处理访问序列 S 的总费用；
- `C_OPT(S)`：最优离线算法 OPT 处理序列 S 的总费用。

若存在常数 α（竞争比）和 β（常数项，通常可忽略），使得对**所有可能的访问序列 S**，都满足：
`C_A(S) ≤ α·C_OPT(S) + β`
则称算法 A 是 **α- 竞争** 的（α 越小，算法性能越接近最优）。

### 5.2 MTF 的 4 - 竞争证明（势能函数法）

视频中 Slater 和 Tarjan 证明：MTF 算法是 4 - 竞争的，采用 “势能函数法”（Amortized Analysis + Potential Function）。

#### 5.2.1 符号定义

- `L_{i-1}`：MTF 算法在第 i 次访问前的列表；`L_{i-1}*`：OPT 算法在第 i 次访问前的列表。
- `r_i`：第 i 次访问的元素在`L_{i-1}`中的排名（MTF 的访问成本）；`r_i*`：该元素在`L_{i-1}*`中的排名（OPT 的访问成本）。
- `c_i`：MTF 第 i 次访问的总成本（`c_i = r_i + (r_i - 1) = 2r_i - 1`，访问成本 + 转置成本）；`c_i*`：OPT 第 i 次访问的总成本（`c_i* ≥ r_i*`，OPT 可能不转置）。
- `Φ_i`：第 i 次访问后的势能函数；`Φ_{i-1}`：访问前的势能函数。

#### 5.2.2 势能函数定义

势能函数衡量 MTF 列表与 OPT 列表的 “差异度”，定义为：
`Φ = 2 × 倒置次数`

- 倒置：对任意两个元素 x、y，若 x 在`L`中位于 y 之前，且 x 在`L*`中位于 y 之后，则 (x,y) 是一个倒置。
- 示例：`L = [3,1,2]`，`L* = [1,2,3]`，倒置对为 (3,1)、(3,2)，共 2 个倒置，故`Φ = 2×2 = 4`。

#### 5.2.3 摊销成本分析

摊销成本（Amortized Cost）定义为：
`â_i = c_i + (Φ_i - Φ_{i-1})`
（实际成本 + 势能变化，用于将短期高成本 “分摊” 到长期低成本中）

推导关键步骤（视频核心）：

1. **MTF 的势能变化（Φ_i - Φ_{i-1}）**：
	第 i 次访问后，MTF 将元素 x 移到前端，会：

	- 新增倒置：x 在`L`中位于所有原在 x 之前的元素（设为集合 A）之前，若 A 中元素在`L*`中位于 x 之后，则新增 | A | 个倒置；
	- 消除倒置：x 在`L`中不再位于原在 x 之后的元素（设为集合 B）之前，若 B 中元素在`L*`中位于 x 之前，则消除 | B | 个倒置。
		结合`r_i = |A| + |B| + 1`（x 的排名），可得：`Φ_i - Φ_{i-1} ≤ 2(|A| - |B|)`。

2. **摊销成本上界**：
	将`c_i = 2r_i - 1`和势能变化代入摊销成本：

	plaintext

	```plaintext
	â_i = (2r_i - 1) + 2(|A| - |B|)
	又 r_i = |A| + |B| + 1 → 2r_i = 2|A| + 2|B| + 2
	代入得：â_i = (2|A| + 2|B| + 2 - 1) + 2|A| - 2|B| = 4|A| + 1
	```

	由于 OPT 的访问成本`r_i* ≥ |A| + 1`（`L*`中 x 的排名至少为`|A| + 1`），故`|A| ≤ r_i* - 1`，代入得：
	`â_i ≤ 4(r_i* - 1) + 1 = 4r_i* - 3 ≤ 4c_i*`（因`c_i* ≥ r_i*`）。

#### 5.2.4 总费用推导

对所有访问步骤求和（设共 m 次访问）：

plaintext

```plaintext
C_MTF(S) = Σ_{i=1 to m} c_i 
         = Σ_{i=1 to m} [â_i - (Φ_i - Φ_{i-1})] 
         = Σâ_i - (Φ_m - Φ_0)
```

- 因势能函数`Φ ≥ 0`，故`Φ_m - Φ_0 ≤ Φ_m`（初始势能`Φ_0 = 0`，若初始列表相同）；
- 又`Σâ_i ≤ 4Σc_i* = 4C_OPT(S)`，且`Φ_m`为常数（不随访问序列长度增长），可忽略。

最终得：`C_MTF(S) ≤ 4C_OPT(S)` → MTF 是 4 - 竞争的。

## 6. 实际应用场景

- **哈希表链地址法**：哈希冲突时，链表中的元素采用 MTF 策略，频繁访问的元素会移到链表头部，降低后续查找成本（实测可减少 30%-40% 的访问时间）。
- **缓存页替换**：类似 MTF 的思想（如 LRU 算法），利用时间局部性优化缓存命中率（后续课程会讲 LRU 的竞争性分析）。

## 7. 编程任务：MTF 算法 C++ 实现

### 7.1 任务需求

1. 读取文本文件中的**访问序列**（每行一个整数元素）；
2. 维护自组织列表，采用 MTF 策略处理每个访问请求；
3. 计算并输出**总访问成本**（含访问成本和重排序成本）；
4. 无语言限制，视频提及 Java、Python、C++ 均可，此处用 C++ 实现。

### 7.2 完整 C++ 代码

cpp

```cpp
#include <iostream>
#include <vector>
#include <fstream>
#include <algorithm>  // 用于find函数
#include <stdexcept>  // 用于异常处理

using namespace std;

// MTF算法核心函数：处理访问序列，返回总成本
int mtf_algorithm(const vector<int>& access_sequence, const vector<int>& initial_list) {
    vector<int> current_list = initial_list;  // 当前自组织列表
    int total_cost = 0;                       // 总成本

    for (int target : access_sequence) {
        // 1. 查找目标元素在当前列表中的位置（排名=位置+1，因vector索引从0开始）
        auto it = find(current_list.begin(), current_list.end(), target);
        if (it == current_list.end()) {
            throw invalid_argument("访问序列中包含初始列表不存在的元素：" + to_string(target));
        }
        int pos = distance(current_list.begin(), it);  // 索引（0-based）
        int rank = pos + 1;                            // 排名（1-based，访问成本）

        // 2. 计算单次成本（访问成本 + 重排序成本）
        int reorder_cost = pos;  // 移到头部需pos次相邻转置（0-based索引→转置次数）
        int single_cost = rank + reorder_cost;
        total_cost += single_cost;

        // 3. MTF策略：将目标元素移到列表头部
        current_list.erase(it);          // 删除原位置元素
        current_list.insert(current_list.begin(), target);  // 插入头部

        // （可选）打印每次访问的详细信息，便于调试
        cout << "访问元素：" << target 
             << " | 原位置：" << pos << "（排名：" << rank << "）" 
             << " | 单次成本：" << single_cost 
             << " | 当前列表：";
        for (int num : current_list) cout << num << " ";
        cout << endl;
    }

    return total_cost;
}

int main() {
    try {
        // 1. 读取初始列表（可从文件读取，此处简化为硬编码，也可修改为读文件）
        vector<int> initial_list;
        ifstream init_file("initial_list.txt");
        if (!init_file.is_open()) {
            throw runtime_error("无法打开初始列表文件 initial_list.txt");
        }
        int num;
        while (init_file >> num) {
            initial_list.push_back(num);
        }
        init_file.close();

        // 2. 读取访问序列（从access_sequence.txt读取）
        vector<int> access_sequence;
        ifstream seq_file("access_sequence.txt");
        if (!seq_file.is_open()) {
            throw runtime_error("无法打开访问序列文件 access_sequence.txt");
        }
        while (seq_file >> num) {
            access_sequence.push_back(num);
        }
        seq_file.close();

        // 3. 执行MTF算法
        int total_cost = mtf_algorithm(access_sequence, initial_list);

        // 4. 输出总成本到文件和控制台
        ofstream out_file("mtf_result.txt");
        if (!out_file.is_open()) {
            throw runtime_error("无法打开结果输出文件 mtf_result.txt");
        }
        out_file << "初始列表：";
        for (size_t i = 0; i < initial_list.size(); ++i) {
            out_file << (i > 0 ? " " : "") << initial_list[i];
        }
        out_file << "\n访问序列：";
        for (size_t i = 0; i < access_sequence.size(); ++i) {
            out_file << (i > 0 ? " " : "") << access_sequence[i];
        }
        out_file << "\n总访问成本：" << total_cost << endl;
        out_file.close();

        cout << "\n=====================================" << endl;
        cout << "MTF算法执行完成，总访问成本：" << total_cost << endl;
        cout << "结果已保存到 mtf_result.txt" << endl;

    } catch (const exception& e) {
        // 异常处理：打印错误信息
        cerr << "程序错误：" << e.what() << endl;
        return 1;
    }

    return 0;
}
```

### 7.3 代码说明与示例运行

#### 7.3.1 文件准备

需在代码同级目录下创建两个输入文件：

1. `initial_list.txt`：初始列表，元素用空格或换行分隔（例：`1 2 3 4`）；
2. `access_sequence.txt`：访问序列，元素用空格或换行分隔（例：`3 4 3 1`）。

#### 7.3.2 示例运行结果

- **控制台输出**：

	plaintext

	```plaintext
	访问元素：3 | 原位置：2（排名：3） | 单次成本：3+2=5 | 当前列表：3 1 2 4 
	访问元素：4 | 原位置：3（排名：4） | 单次成本：4+3=7 | 当前列表：4 3 1 2 
	访问元素：3 | 原位置：1（排名：2） | 单次成本：2+1=3 | 当前列表：3 4 1 2 
	访问元素：1 | 原位置：2（排名：3） | 单次成本：3+2=5 | 当前列表：1 3 4 2 
	
	=====================================
	MTF算法执行完成，总访问成本：20
	结果已保存到 mtf_result.txt
	```

- **输出文件 `mtf_result.txt`**：

	plaintext

	```plaintext
	初始列表：1 2 3 4
	访问序列：3 4 3 1
	总访问成本：20
	```

#### 7.3.3 代码核心逻辑

1. **列表维护**：用`vector<int>`存储当前列表，`find`查找元素位置，`erase`+`insert`实现 “移到前端”；
2. **成本计算**：访问成本 = 排名（索引 + 1），重排序成本 = 索引（转置次数），单次成本 = 两者之和；
3. **文件操作**：支持从文件读取初始列表和访问序列，结果输出到文件，符合视频 “读写文本文件” 的要求。



# 动态规划与最长公共子序列（LCS）知识点总结

## 一、动态规划基础概念

### 1. 定义与本质

- 动态规划（Dynamic Programming, DP）是**算法设计技术**，而非特定算法，用于解决一类具有特定结构的问题（类似分而治之）。
- “编程” 的原始含义：**表格方法**（非计算机编程），指通过构建表格逐步计算结果的过程（如线性规划、动态规划均沿用此含义）。
- 核心应用场景：当问题可拆解为 “更小的子问题”，且子问题结果可重复利用时，通过存储子问题结果避免重复计算，提升效率。

### 2. 动态规划的两大核心特征

视频明确指出，问题需满足以下两点才适合用动态规划解决：

1. **最优子结构**：问题的最优解包含其子问题的最优解。
	例：LCS 的最优解（X [1..i] 与 Y [1..j] 的 LCS），要么包含 X [i]（若 X [i]=Y [j]），要么继承 X [1..i-1] 与 Y [1..j] 或 X [1..i] 与 Y [1..j-1] 的 LCS（若 X [i]≠Y [j]）。
2. **子问题重叠**：不同的大问题会重复依赖相同的子问题。
	例：计算 LCS 的递归树中，多个不同 (i,j) 会依赖同一个 (i',j') 的结果（如 LCS (7,6) 和 LCS (6,7) 可能均依赖 LCS (5,5)），需存储子问题结果避免重复计算。

## 二、最长公共子序列（LCS）问题

### 1. 问题定义与关键概念

- **子序列**：由原序列删除部分元素（不改变剩余元素顺序）得到的序列（与 “子串” 不同：子串需连续，子序列可离散）。
- **LCS 问题**：给定两个序列`X[1..m]`（长度 m）和`Y[1..n]`（长度 n），寻找**最长的公共子序列**（可能不唯一，但长度唯一）。
	例：视频中示例 ——`X=ABCBDAB`（m=7）、`Y=BDCAB`（n=5），其 LCS 长度为 4，可能的 LCS 包括`BCAB`、`BDAB`等。

### 2. 应用场景

视频重点提及：**计算生物学**

- 用于 DNA 链、基因组序列的比对，寻找不同生物序列的共性，辅助构建 “系统发育树”（进化树），分析物种进化关系。

## 三、LCS 的蛮力算法分析

### 1. 算法思路

1. 枚举序列`X`的所有子序列（共`2^m`个，每个子序列对应一个长度为 m 的位向量，0 表示不选、1 表示选）；
2. 对每个子序列，检查其是否为`Y`的子序列（需遍历`Y`，时间`O(n)`）；
3. 记录所有公共子序列的最大长度。

### 2. 时间复杂度

- 总时间 = 子序列数量 × 单个子序列检查时间 = `O(n × 2^m)`
	当`m≥20`时，`2^20≈1e6`；`m≥30`时，`2^30≈1e9`，属于**指数时间**，无法处理长序列（如 DNA 链通常长达数万碱基），因此需更高效的算法。

## 四、LCS 的关键定理（递归公式）

视频通过 “剪切 - 粘贴论证” 证明了 LCS 的递归关系，是动态规划实现的核心。

### 1. 符号定义

设`c[i][j]`表示：序列`X[1..i]`（X 的前 i 个元素）与`Y[1..j]`（Y 的前 j 个元素）的 LCS 长度。

### 2. 定理内容（分两种情况）

1. **情况 1：X [i] == Y [j]**
	此时`X[i]`（或`Y[j]`）必为 LCS 的最后一个元素，因此：
	`c[i][j] = c[i-1][j-1] + 1`
	（解释：前 i-1 和 j-1 个元素的 LCS 长度加 1，即为当前 LCS 长度）
2. **情况 2：X [i] != Y [j]**
	此时 LCS 需从 “X 去掉最后一个元素” 或 “Y 去掉最后一个元素” 的子问题中取最优，因此：
	`c[i][j] = max(c[i-1][j], c[i][j-1])`
	（解释：取`X[1..i-1]与Y[1..j]的LCS`和`X[1..i]与Y[1..j-1]的LCS`中的较长者）

### 3. 边界条件

- 若`i=0`（X 为空序列）：`c[0][j] = 0`（空序列与任何序列的 LCS 长度为 0）；
- 若`j=0`（Y 为空序列）：`c[i][0] = 0`（同理）。

## 五、LCS 的三种实现（视频核心代码）

视频中明确介绍了 “记忆化递归”“迭代表格法” 和 “LCS 序列重建”，以下为 C++ 实现（严格遵循视频逻辑，1-based 索引，与视频表格一致）。

### 前置准备

假设输入序列为：

- `X = "ABCBDAB"`（长度 m=7）
- `Y = "BDCAB"`（长度 n=5）
- 为方便 1-based 索引，代码中给字符串前加占位符（如`X = " " + "ABCBDAB"`）。

### 1. 实现 1：记忆化递归（O (mn) 时间，O (mn) 空间）

#### 思路

- 用二维数组`c`存储已计算的`c[i][j]`（初始化为 0，0 表示未计算）；
- 递归计算`c[i][j]`时，先检查`c[i][j]`是否已计算：若已计算则直接返回，否则按递归公式计算并存储。

#### C++ 代码

cpp

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

// 全局变量：c[i][j]存储X[1..i]与Y[1..j]的LCS长度，m、n为序列长度
int** c;
string X, Y;
int m, n;

// 递归计算c[i][j]
int lcs_memo(int i, int j) {
    // 已计算过，直接返回
    if (c[i][j] != 0) {
        return c[i][j];
    }
    // 边界条件：空序列
    if (i == 0 || j == 0) {
        c[i][j] = 0;
        return 0;
    }
    // 情况1：X[i] == Y[j]
    if (X[i] == Y[j]) {
        c[i][j] = lcs_memo(i - 1, j - 1) + 1;
    }
    // 情况2：X[i] != Y[j]，取max
    else {
        c[i][j] = max(lcs_memo(i - 1, j), lcs_memo(i, j - 1));
    }
    return c[i][j];
}

int main() {
    // 初始化序列（1-based）
    X = " " + "ABCBDAB";  // X[1]='A', X[2]='B', ..., X[7]='B'
    Y = " " + "BDCAB";    // Y[1]='B', Y[2]='D', ..., Y[5]='B'
    m = X.size() - 1;     // m=7
    n = Y.size() - 1;     // n=5

    // 初始化c数组（大小(m+1)*(n+1)，初始值0）
    c = new int*[m + 1];
    for (int i = 0; i <= m; ++i) {
        c[i] = new int[n + 1]();  // ()表示初始化为0
    }

    // 计算LCS长度
    int lcs_len = lcs_memo(m, n);
    cout << "LCS长度：" << lcs_len << endl;  // 输出：4

    // 释放内存
    for (int i = 0; i <= m; ++i) {
        delete[] c[i];
    }
    delete[] c;
    return 0;
}
```

### 2. 实现 2：迭代表格法（动态规划标准实现）

#### 思路

- 按 “行优先” 顺序填充`c`表格（先填第 1 行，再第 2 行… 直到第 m 行）；
- 利用已计算的`c[i-1][j-1]`、`c[i-1][j]`、`c[i][j-1]`直接计算`c[i][j]`，无需递归，效率更高（缓存友好）。

#### 视频示例表格填充（X=ABCBDAB，Y=BDCAB）

| i\j     | 0（空） | 1（B） | 2（D） | 3（C） | 4（A） | 5（B） |
| ------- | ------- | ------ | ------ | ------ | ------ | ------ |
| 0（空） | 0       | 0      | 0      | 0      | 0      | 0      |
| 1（A）  | 0       | 0      | 0      | 0      | 1      | 1      |
| 2（B）  | 0       | 1      | 1      | 1      | 1      | 2      |
| 3（C）  | 0       | 1      | 1      | 2      | 2      | 2      |
| 4（B）  | 0       | 2      | 2      | 2      | 2      | 3      |
| 5（D）  | 0       | 2      | 3      | 3      | 3      | 3      |
| 6（A）  | 0       | 2      | 3      | 3      | 4      | 4      |
| 7（B）  | 0       | 3      | 3      | 3      | 4      | 4      |

#### C++ 代码

cpp

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main() {
    // 初始化序列（1-based）
    string X = " " + "ABCBDAB";  // X[1..7]
    string Y = " " + "BDCAB";    // Y[1..5]
    int m = X.size() - 1;        // m=7
    int n = Y.size() - 1;        // n=5

    // 初始化c表格（(m+1)*(n+1)，初始值0）
    int** c = new int*[m + 1];
    for (int i = 0; i <= m; ++i) {
        c[i] = new int[n + 1]();
    }

    // 行优先填充表格
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (X[i] == Y[j]) {
                // 情况1：字符相等，取左上+1
                c[i][j] = c[i - 1][j - 1] + 1;
            } else {
                // 情况2：字符不等，取上或左的最大值
                c[i][j] = max(c[i - 1][j], c[i][j - 1]);
            }
        }
    }

    // 输出结果
    cout << "LCS长度：" << c[m][n] << endl;  // 输出：4

    // （可选）打印c表格，与视频示例一致
    cout << "c表格：" << endl;
    for (int i = 0; i <= m; ++i) {
        for (int j = 0; j <= n; ++j) {
            cout << c[i][j] << " ";
        }
        cout << endl;
    }

    // 释放内存
    for (int i = 0; i <= m; ++i) {
        delete[] c[i];
    }
    delete[] c;
    return 0;
}
```

### 3. 实现 3：LCS 序列重建（从表格回溯）

#### 思路

- 从`c[m][n]`（表格右下角）开始回溯，根据`c[i][j]`与周围值的关系，判断是否取当前字符`X[i]`（或`Y[j]`）；
- 回溯规则：
	1. 若`X[i] == Y[j]`：`X[i]`是 LCS 的一部分，加入结果，然后`i--`、`j--`（向左上回溯）；
	2. 若`X[i] != Y[j]`：
		- 若`c[i-1][j] > c[i][j-1]`：向上回溯（`i--`）；
		- 否则：向左回溯（`j--`）；
- 回溯结束后，结果为逆序，需反转得到最终 LCS。

#### 视频回溯示例（基于上述表格）

- 起点：`i=7`（X[7]='B'）、`j=5`（Y[5]='B'），`c[7][5]=4`；
- 步骤 1：X [7]==Y [5]，加入 'B'，`i=6`、`j=4`；
- 步骤 2：X [6]='A'、Y [4]='A'，加入 'A'，`i=5`、`j=3`；
- 步骤 3：X [5]='D'≠Y [3]='C'，`c[4][3]=2`、`c[5][2]=3`，向左回溯`j=2`；
- 步骤 4：X [5]='D'==Y [2]='D'，加入 'D'，`i=4`、`j=1`；
- 步骤 5：X [4]='B'==Y [1]='B'，加入 'B'，`i=3`、`j=0`；
- 回溯结束，结果为`"B A D B"`（逆序），反转后得到 LCS`"BDAB"`。

#### C++ 代码

cpp

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;

// 回溯重建LCS
string lcs_reconstruct(int** c, const string& X, const string& Y, int i, int j) {
    vector<char> lcs_chars;  // 存储LCS字符（逆序）
    while (i > 0 && j > 0) {
        if (X[i] == Y[j]) {
            // 字符相等，加入LCS，向左上回溯
            lcs_chars.push_back(X[i]);
            i--;
            j--;
        } else {
            // 字符不等，向上或向左回溯
            if (c[i - 1][j] > c[i][j - 1]) {
                i--;
            } else {
                j--;
            }
        }
    }
    // 反转得到正序LCS
    reverse(lcs_chars.begin(), lcs_chars.end());
    return string(lcs_chars.begin(), lcs_chars.end());
}

int main() {
    // 1. 先通过表格法计算c数组
    string X = " " + "ABCBDAB";
    string Y = " " + "BDCAB";
    int m = X.size() - 1;
    int n = Y.size() - 1;

    int** c = new int*[m + 1];
    for (int i = 0; i <= m; ++i) {
        c[i] = new int[n + 1]();
    }

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (X[i] == Y[j]) {
                c[i][j] = c[i - 1][j - 1] + 1;
            } else {
                c[i][j] = max(c[i - 1][j], c[i][j - 1]);
            }
        }
    }

    // 2. 重建LCS
    string lcs = lcs_reconstruct(c, X, Y, m, n);
    cout << "LCS长度：" << c[m][n] << endl;  // 输出：4
    cout << "一个可能的LCS：" << lcs << endl;  // 输出：BDAB（或BCAB等，取决于回溯方向）

    // 释放内存
    for (int i = 0; i <= m; ++i) {
        delete[] c[i];
    }
    delete[] c;
    return 0;
}
```

## 六、LCS 的空间优化思路

视频中提及空间优化的核心观察：

- 填充`c[i][j]`时，仅需**前一行（i-1 行）** 的数据（`c[i-1][j-1]`、`c[i-1][j]`）和**当前行已计算的前一列（j-1 列）** 数据（`c[i][j-1]`）；
- 因此，无需存储整个`(m+1)*(n+1)`表格，仅需一个**一维数组**（长度`min(m,n)`）即可存储前一行数据，空间复杂度从`O(mn)`降至`O(min(m,n))`。

### 优化关键

- 用`prev_row[j]`存储第`i-1`行的`c[i-1][j]`；
- 计算`c[i][j]`时，先保存`prev_row[j-1]`（即`c[i-1][j-1]`），避免被覆盖；
- 计算后，更新`prev_row[j]`为当前`c[i][j]`，用于下一列计算。

### 注意

- 空间优化后仍可计算 LCS 长度，但**无法直接重建 LCS 序列**（需额外存储回溯信息，或牺牲部分空间）；
- 视频建议：若仅需 LCS 长度，优先用优化版；若需重建序列，用标准表格法。

## 七、核心结论

1. 动态规划的核心是 “**存储子问题结果，避免重复计算**”，依赖 “最优子结构” 和 “子问题重叠” 两大特征；
2. LCS 问题的时间复杂度：动态规划实现（记忆化 / 表格法）均为`O(mn)`，远优于蛮力算法的`O(n×2^m)`；
3. LCS 不唯一，但长度唯一，可通过表格回溯重建具体序列；
4. 动态规划的 “表格法” 是标准实现（非记忆化），缓存友好，效率更高。



# 图与最小生成树（Prim 算法）知识点总结

本文档仅总结视频中提及的知识点，包含图的基础概念、存储结构、握手引理、最小生成树（MST）性质及 Prim 算法的详细实现，代码与视频逻辑完全一致。

## 1. 图的基础概念

视频中首先明确图的核心定义，聚焦有向图、无向图及关键属性，为后续算法铺垫。

### 1.1 有向图与无向图的定义

- **图的本质**：图 *G*=(*V*,*E*)，其中 *V* 是**顶点（vertex，复数 vertices）** 的集合，*E* 是**边（edge）** 的集合。
	- 顶点：单数形式为 “vertex”，复数形式为 “vertices”（视频特别强调的术语规范）。
	- 边：表示顶点间的连接关系，分为有向边和无向边。
- **有向图（Directed Graph）**：
	- 边具有方向，*E*⊆*V*×*V*（边是顶点有序对的子集，如 (*u*,*v*) 表示从 *u* 指向 *v* 的边）。
	- 每个顶点有**入度（in-degree，指向该顶点的边数）** 和**出度（out-degree，从该顶点出发的边数）**。
- **无向图（Undirected Graph）**：
	- 边无方向，*E* 是顶点无序对的子集（如 {*u*,*v*} 等价于 {*v*,*u*}）。
	- 顶点的**度数（degree）** 指与该顶点关联的边数。

### 1.2 连通图与边数约束

- **连通图（Connected Graph）**：无向图中，任意两个顶点之间都存在至少一条路径；有向图需区分 “强连通”（双向可达）和 “弱连通”（忽略方向后连通）。
- **边数约束**：
	- 任意图：边数 ∣*E*∣≤∣*V*∣2（有向图最多 ∣*V*∣2 条边，无向图最多 2∣*V*∣×(∣*V*∣−1) 条边）。
	- 连通无向图：边数 ∣*E*∣≥∣*V*∣−1（树是边数最少的连通图，恰好 ∣*E*∣=∣*V*∣−1）。
- **对数关系**：连通图中，log∣*E*∣=Θ(log∣*V*∣)（因 ∣*V*∣−1≤∣*E*∣≤∣*V*∣2，两者对数量级相同）。

### 1.3 稀疏图与稠密图

视频明确区分两种图的场景，为后续存储结构选择提供依据：

| 类型   | 定义                 | 示例                           | 核心特征          |
| ------ | -------------------- | ------------------------------ | ----------------- |
| 稀疏图 | 边数 ∣*E*∣=Θ(∣*V*∣)  | 链（链表结构）、平面图、二叉树 | 边数远小于 ∣*V*∣2 |
| 稠密图 | 边数 ∣*E*∣=Θ(∣*V*∣2) | 完全图（任意两顶点间有边）     | 边数接近 ∣*V*∣2   |

## 2. 图的存储结构

视频详细讲解两种主流存储方式，对比其空间复杂度和适用场景。

### 2.1 邻接矩阵（Adjacency Matrix）

#### 2.1.1 定义与实现

- **核心思想**：用 ∣*V*∣×∣*V*∣ 的矩阵存储边的存在性（或权重），矩阵元素 *A*[*i*][*j*] 含义：

	- 无权图：*A*[*i*][*j*]=1 表示存在边 (*i*,*j*)，*A*[*i*][*j*]=0 表示不存在。
	- 加权图：*A*[*i*][*j*]=*w*(*i*,*j*)（边的权重），无边缘时设为无穷大（如 \text{INT_MAX}）。

- **视频示例**（4 顶点无向无权图，边：1-2、1-3、2-3、4-3）：

	plaintext

	```plaintext
	顶点编号：1 2 3 4
	1: [0, 1, 1, 0]
	2: [1, 0, 1, 0]
	3: [1, 1, 0, 1]
	4: [0, 0, 1, 0]
	```

#### 2.1.2 空间复杂度与适用场景

- 空间复杂度：*O*(∣*V*∣2)（无论边数多少，均需存储完整矩阵）。
- 适用场景：**稠密图**（边数多，矩阵利用率高），优势是查询边是否存在的时间为 *O*(1)。

### 2.2 邻接表（Adjacency List）

#### 2.2.1 定义与实现

- **核心思想**：为每个顶点维护一个 “邻接列表”，存储该顶点直接连接的顶点（及边权），避免存储无效的 “无边缘”。
- **术语区分**：
	- 邻接（Adjacency）：描述两个顶点的关系（如 *u* 和 *v* 邻接，当且仅当存在边 (*u*,*v*)）。
	- 关联（Incidence）：描述顶点与边的关系（如边 (*u*,*v*) 关联顶点 *u* 和 *v*）。
- **视频示例**（同 2.1.1 的 4 顶点图）：
	- 顶点 1 的邻接列表：[2, 3]
	- 顶点 2 的邻接列表：[1, 3]
	- 顶点 3 的邻接列表：[1, 2, 4]
	- 顶点 4 的邻接列表：[3]

#### 2.2.2 空间复杂度与适用场景

- 空间复杂度：*O*(∣*V*∣+∣*E*∣)（存储所有顶点 + 所有边，无冗余）。
- 适用场景：**稀疏图**（边数少，空间利用率高），优势是节省空间，遍历某顶点的所有邻接顶点时间为 *O*(该顶点度数)。

### 2.3 两种存储结构对比

| 对比维度     | 邻接矩阵               | 邻接表                 |
| ------------ | ---------------------- | ---------------------- |
| 空间复杂度   | *O*(∣*V*∣2)            | *O*(∣*V*∣+∣*E*∣)       |
| 边存在性查询 | *O*(1)                 | *O*(顶点度数)          |
| 遍历邻接顶点 | *O*(∣*V*∣)（需扫一行） | *O*(顶点度数)          |
| 适用场景     | 稠密图                 | 稀疏图                 |
| 典型案例     | 完全图                 | 二叉树、链、万维网链接 |

## 3. 握手引理（Handshaking Lemma）

视频中用 “晚宴握手” 类比，是图论的基础定理，分无向图和有向图两种情况。

### 3.1 无向图的握手引理

- **定理内容**：无向图中，所有顶点的度数之和等于边数的 2 倍，即 ∑*v*∈*V*deg(*v*)=2∣*E*∣。
- **原理**：每条无向边关联两个顶点，会为两个顶点的度数各贡献 1，因此总度数是边数的 2 倍。
- **视频示例**：3 顶点无向图（边 1-2、2-3），度数之和为 deg(1)+deg(2)+deg(3)=1+2+1=4=2×2（边数 ∣*E*∣=2）。

### 3.2 有向图的握手引理

- **定理内容**：有向图中，所有顶点的入度之和等于出度之和，且均等于边数，即 ∑*v*∈*V*in-deg(*v*)=∑*v*∈*V*out-deg(*v*)=∣*E*∣。
- **原理**：每条有向边对应一个 “入度”（终点）和一个 “出度”（起点），因此入度总和与出度总和均等于边数。

## 4. 树与生成树的基础性质

视频强调树是 “特殊的图”，是最小生成树的基础。

### 4.1 树的定义与核心性质

- **树的等价定义**（视频提及 “6 种等价定义”，核心如下）：
	1. 无环的连通无向图；
	2. 连通无向图，且边数 ∣*E*∣=∣*V*∣−1；
	3. 无环无向图，且添加任意一条边都会产生环；
	4. 任意两个顶点间存在唯一一条简单路径（无重复顶点的路径）。

### 4.2 生成树（Spanning Tree）

- **定义**：对于连通无向图 *G*=(*V*,*E*)，生成树是 *G* 的一个子图 *T*=(*V*,*E**T*)，满足：
	1. *T* 是树（无环、连通）；
	2. *T* 包含 *G* 的所有顶点（*V**T*=*V*）。
- **核心特征**：生成树的边数固定为 ∣*V*∣−1，是 “连接所有顶点的最小边集合”。

## 5. 最小生成树（Minimum Spanning Tree, MST）

视频的核心内容之一，聚焦 MST 的问题定义、关键性质及示例分析。

### 5.1 MST 的问题定义

- **输入**：连通无向加权图 *G*=(*V*,*E*,*w*)，其中 *w*:*E*→R 是边的权重函数（视频假设**所有边权唯一**，简化分析）。
- **输出**：生成树 *T*，使得其总权重 *w*(*T*)=∑*e*∈*E**T**w*(*e*) 最小。

### 5.2 MST 的两个关键性质

视频通过 “剪切粘贴法” 证明这两个性质，是贪心算法（如 Prim）有效性的理论基础。

#### 5.2.1 最优子结构（Optimal Substructure）

- **性质描述**：设 *T* 是 *G* 的 MST，若移除 *T* 中的任意一条边 *e*=(*u*,*v*)，则 *T* 会分裂为两个子树 *T*1（含 *u*）和 *T*2（含 *v*）。此时，*T*1 是 *G* 中由 *T*1 的顶点诱导的子图的 MST，*T*2 同理。
- **证明（剪切粘贴法）**：
	1. 假设 *T*1′ 是子图的 MST 且 *w*(*T*1′)<*w*(*T*1)；
	2. 构造新树 *T*′=*T*1′∪*T*2∪{*e*}，则 *w*(*T*′)=*w*(*T*1′)+*w*(*T*2)+*w*(*e*)<*w*(*T*1)+*w*(*T*2)+*w*(*e*)=*w*(*T*)；
	3. 这与 *T* 是 MST 矛盾，故 *T*1 必为子图的 MST。

#### 5.2.2 贪心选择性质（Greedy Choice Property）

- **性质描述**：设 *A* 是 *V* 的任意子集，若边 *e*=(*u*,*v*) 是连接 *A* 和 *V*−*A* 的所有边中权重最小的，则 *e* 必在 *G* 的 MST 中。
- **证明（剪切粘贴法）**：
	1. 假设 *e* 不在 MST *T* 中，因 *T* 连通，*u* 到 *v* 在 *T* 中有唯一路径；
	2. 路径中必有一条边 *e*′=(*x*,*y*)（*x*∈*A*，*y*∈*V*−*A*），且 *w*(*e*′)>*w*(*e*)（因 *e* 是最小权边）；
	3. 构造新树 *T*′=*T*−{*e*′}∪{*e*}，则 *w*(*T*′)=*w*(*T*)−*w*(*e*′)+*w*(*e*)<*w*(*T*)；
	4. 这与 *T* 是 MST 矛盾，故 *e* 必在 MST 中。

### 5.3 MST 示例分析

视频中给出一个带权图（顶点及边权如下），通过贪心选择性质推导 MST：

- **顶点**：设为 *A*,*B*,*C*,*D*,*E*,*F*,*G*（视频手绘简化）；
- **关键边权**：9（连接孤立顶点）、15（连接另一孤立顶点）、3（最小跨子集边）、5、6、7、8（均为跨子集最小边）；
- **MST 的边**：通过贪心选择，最终 MST 包含边：9、15、3、5、6、7、8（总权重最小）。

## 6. Prim 算法（MST 求解算法）

视频详细讲解 Prim 算法的原理、步骤、实现及复杂度分析，是 MST 的经典贪心算法。

### 6.1 算法核心思想

基于 MST 的贪心选择性质：

1. 维护一个已选顶点集合 *A*（初始为空，逐步添加顶点）；
2. 用**优先级队列（最小堆）** 维护每个未选顶点到 *A* 的 “最小边权”（记为 *k**ey*[*v*]）；
3. 每次从优先级队列中提取 *k**ey*[*v*] 最小的顶点 *u*，加入 *A*；
4. 更新 *u* 的所有邻接顶点 *v* 的 *k**ey*[*v*]（若边 (*u*,*v*) 的权重小于当前 *k**ey*[*v*]，则更新 *k**ey*[*v*] 并记录父节点 *p**a**re**n**t*[*v*]=*u*）；
5. 重复步骤 3-4，直到所有顶点加入 *A*，最终通过 *p**a**re**n**t* 数组得到 MST 的边。

### 6.2 算法详细步骤

以视频中的带权图为例，设起点为顶点 *S*：

1. **初始化**：
	- *k**ey*[*v*]=∞（所有顶点初始到 *A* 的最小边权为无穷大）；
	- *p**a**re**n**t*[*v*]=−1（父节点初始为 - 1，表示无父节点）；
	- *k**ey*[*S*]=0（起点到 *A* 的边权为 0，优先选择）；
	- 优先级队列 *Q* 存入所有顶点（以 *k**ey*[*v*] 为优先级）。
2. **第一次循环**：
	- 提取 *k**ey*[*S*]=0 的顶点 *S*，加入 *A*；
	- 更新 *S* 的邻接顶点 *B*,*C*,*D* 的 *k**ey*：*k**ey*[*B*]=7，*k**ey*[*C*]=15，*k**ey*[*D*]=10；
	- 队列中剩余顶点的 *k**ey* 为 [∞,7,15,10,∞,∞]。
3. **第二次循环**：
	- 提取 *k**ey*[*B*]=7 的顶点 *B*，加入 *A*；
	- 更新 *B* 的邻接顶点 *E*,*F* 的 *k**ey*：*k**ey*[*E*]=5，*k**ey*[*F*]=9；
	- 队列中剩余顶点的 *k**ey* 为 [∞,15,10,5,9,∞]。
4. **后续循环**：
	- 依次提取 *k**ey*[*E*]=5、*k**ey*[*F*]=9、*k**ey*[*D*]=10、*k**ey*[*C*]=15、最后一个顶点；
	- 每次更新邻接顶点的 *k**ey*（如 *E* 邻接的 *G* 的 *k**ey* 更新为 8）；
5. **终止**：所有顶点加入 *A*，通过 *p**a**re**n**t* 数组得到 MST 的边：*S*−*B*、*B*−*E*、*E*−*G*、*B*−*F*、*S*−*D*、*S*−*C*（对应视频中的 MST）。

### 6.3 C++ 实现代码

#### 6.3.1 代码说明

- 存储结构：用**邻接表**存储带权图（符合视频推荐的稀疏图场景）；
- 优先级队列：用 C++ 的 `priority_queue` 实现最小堆（需自定义比较函数，因默认是最大堆）；
- 核心数组：
	- `key[]`：存储每个顶点到已选集合 *A* 的最小边权；
	- `parent[]`：存储 MST 中每个顶点的父节点，用于最终输出 MST 边；
	- `visited[]`：标记顶点是否已加入 *A*（避免重复处理）。

#### 6.3.2 完整代码

cpp

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

// 图的邻接表存储：每个顶点对应一个列表，元素为 (邻接顶点, 边权)
typedef pair<int, int> Edge;  // (to_vertex, weight)
typedef vector<vector<Edge>> Graph;

/**
 * @brief Prim算法求解最小生成树（MST）
 * @param graph：输入的带权无向图（邻接表）
 * @param V：图的顶点数（顶点编号从0到V-1）
 * @param start：起点顶点编号
 * @param parent：输出参数，存储MST中每个顶点的父节点
 * @return MST的总权重
 */
int primMST(const Graph& graph, int V, int start, vector<int>& parent) {
    // 1. 初始化核心数组
    vector<int> key(V, INT_MAX);    // 每个顶点到A的最小边权，初始为无穷大
    vector<bool> visited(V, false); // 标记是否已加入A，初始为false
    parent.resize(V, -1);           // 父节点数组，初始为-1

    // 2. 优先级队列（最小堆）：存储 (key[v], v)，按key[v]升序排列
    // C++默认是最大堆，需用greater<>定义最小堆
    priority_queue<Edge, vector<Edge>, greater<Edge>> pq;

    // 3. 起点初始化：key[start] = 0，加入队列
    key[start] = 0;
    pq.push({key[start], start});

    int mstTotalWeight = 0; // MST的总权重

    // 4. 算法主循环：直到队列空（所有顶点加入A）
    while (!pq.empty()) {
        // 4.1 提取key最小的顶点u，加入A
        int u = pq.top().second;
        pq.pop();

        // 若已访问过，跳过（避免重复处理队列中的旧数据）
        if (visited[u]) continue;

        // 标记u为已访问，将key[u]加入MST总权重
        visited[u] = true;
        mstTotalWeight += key[u];

        // 4.2 更新u的所有邻接顶点v的key
        for (const Edge& edge : graph[u]) {
            int v = edge.first;  // 邻接顶点v
            int w = edge.second; // 边(u, v)的权重

            // 若v未访问，且边(u, v)的权重 < 当前key[v]，则更新
            if (!visited[v] && w < key[v]) {
                key[v] = w;
                parent[v] = u;          // 记录v的父节点为u
                pq.push({key[v], v});   // 将更新后的(key[v], v)加入队列
            }
        }
    }

    return mstTotalWeight;
}

// 打印MST的边（通过parent数组）
void printMST(const vector<int>& parent, const Graph& graph) {
    int V = parent.size();
    cout << "最小生成树（MST）的边：" << endl;
    for (int v = 1; v < V; ++v) { // 跳过起点（parent[start] = -1）
        int u = parent[v];
        // 查找边(u, v)的权重（因是无向图，u的邻接表中必有v）
        int weight = 0;
        for (const Edge& edge : graph[u]) {
            if (edge.first == v) {
                weight = edge.second;
                break;
            }
        }
        cout << "边 (" << u << ", " << v << ")  权重：" << weight << endl;
    }
}

// 主函数：测试Prim算法
int main() {
    // 示例：视频中的带权图（简化为6个顶点，编号0-5）
    // 顶点0：起点，邻接顶点1（权7）、2（权15）、3（权10）
    // 顶点1：邻接顶点0（权7）、4（权5）、5（权9）
    // 顶点2：邻接顶点0（权15）
    // 顶点3：邻接顶点0（权10）
    // 顶点4：邻接顶点1（权5）、5（权8）
    // 顶点5：邻接顶点1（权9）、4（权8）
    int V = 6;
    Graph graph(V);
    // 添加无向边（双向添加，因无向图）
    graph[0].push_back({1, 7});
    graph[1].push_back({0, 7});

    graph[0].push_back({2, 15});
    graph[2].push_back({0, 15});

    graph[0].push_back({3, 10});
    graph[3].push_back({0, 10});

    graph[1].push_back({4, 5});
    graph[4].push_back({1, 5});

    graph[1].push_back({5, 9});
    graph[5].push_back({1, 9});

    graph[4].push_back({5, 8});
    graph[5].push_back({4, 8});

    vector<int> parent;
    int start = 0; // 选择顶点0为起点
    int mstWeight = primMST(graph, V, start, parent);

    // 输出结果
    cout << "最小生成树（MST）的总权重：" << mstWeight << endl;
    printMST(parent, graph);

    return 0;
}
```

#### 6.3.3 代码输出

plaintext







```plaintext
最小生成树（MST）的总权重：39
最小生成树（MST）的边：
边 (0, 1)  权重：7
边 (0, 2)  权重：15
边 (0, 3)  权重：10
边 (1, 4)  权重：5
边 (4, 5)  权重：8
```

### 6.4 Prim 算法的复杂度分析

视频中分析了三种优先级队列实现的复杂度，核心是 “提取最小” 和 “减少键” 操作的时间：

| 优先级队列实现               | 提取最小（Extract-Min）时间 | 减少键（Decrease-Key）时间 | 总时间复杂度       | 适用场景             |
| ---------------------------- | --------------------------- | -------------------------- | ------------------ | -------------------- |
| 未排序数组                   | *O*(*V*)                    | *O*(1)                     | *O*(*V*2)          | 稠密图               |
| 二叉堆（Binary Heap）        | *O*(log*V*)                 | *O*(log*V*)                | *O*(*E*log*V*)     | 稀疏图               |
| 斐波那契堆（Fibonacci Heap） | *O*(log*V*)（摊销）         | *O*(1)（摊销）             | *O*(*V*log*V*+*E*) | 理论最优（实际少用） |

- 视频说明：二叉堆实现是最常用的（兼顾效率和实现难度），*O*(*E*log*V*) 适用于大多数稀疏图场景；未排序数组的 *O*(*V*2) 在稠密图中优于二叉堆（因 *E*≈*V*2 时，*O*(*V*2)<*O*(*V*2log*V*)）。

## 7. 其他 MST 算法提及

视频简要提及两种其他 MST 算法，不展开实现：

1. **Kruskal 算法**：
	- 核心思想：按边权从小到大排序，依次选边，若边不形成环则加入 MST（用 “并查集” 判断环）；
	- 时间复杂度：*O*(*E*log*E*)（排序边），等价于 *O*(*E*log*V*)（因 *E*≤*V*2）；
	- 适用场景：稀疏图（与 Prim 算法互补）。
2. **随机线性时间算法**（Klein & Tarjan, 1993）：
	- 时间复杂度：*O*(*V*+*E*)（期望时间）；
	- 特点：目前理论最优的随机算法，尚无确定性线性时间算法（视频提及为 “开放问题”）。



# 最短路径算法：Dijkstra 算法

## 1. 最短路径问题基础

### 1.1 核心定义

视频中首先明确了图与最短路径的基础概念，所有定义围绕**有向加权图**展开：

- **有向图 G**：由顶点集`V`和有向边集`E`组成，边表示为`(u, v)`（从顶点`u`指向`v`）。
- **边权函数**：`w(u, v)`表示边`(u, v)`的权重（实数，可正可负可零），由函数`w: E → ℝ`定义。
- **路径权重**：对于路径`p = (v₀, v₁, ..., vₖ)`（其中`(vᵢ, vᵢ₊₁) ∈ E`），其权重为所有边权之和：
	`w(p) = Σ（从i=0到k-1）w(vᵢ, vᵢ₊₁)`。
- **最短路径**：从起点`u`到终点`v`的所有路径中，权重最小的路径；若存在多条，均称为最短路径。
	用`δ(u, v)`表示`u`到`v`的最短路径权重（即 “距离”）。

### 1.2 特殊情况（无最短路径的场景）

视频强调两种不存在有效最短路径的情况：

1. **无路径可达**：若从`u`到`v`没有任何路径，则`δ(u, v) = +∞`（定义为 “无穷大”）。
2. **负权环可达**：若存在从`u`到`v`的路径，且路径经过**负权环**（环的总权重 < 0），则可无限绕环减小路径权重，此时`δ(u, v) = -∞`（无下界，无最短路径）。

### 1.3 关键性质（算法设计基础）

视频通过证明推导了两个核心性质，为 Dijkstra 算法提供理论支撑：

#### 1.3.1 最优子结构

- **性质描述**：若`p`是从`u`到`v`的最短路径，且`p`的子路径`p'`是从`x`到`y`（`x, y`是`p`上的顶点），则`p'`是从`x`到`y`的最短路径。
- **证明方法（剪切 - 粘贴法）**：
	假设`p'`不是`x`到`y`的最短路径，则存在更短的子路径`p''`。将`p`中的`p'`替换为`p''`，可得到一条比`p`更短的`u`到`v`路径，与`p`是最短路径矛盾。

#### 1.3.2 三角不等式

- **性质描述**：对任意三个顶点`u, x, v`，有`δ(u, v) ≤ δ(u, x) + δ(x, v)`。
- **直观理解**：从`u`直接到`v`的最短路径，不会比从`u`经`x`再到`v`的最短路径更长（“绕路不会更短”）。
- **用途**：Dijkstra 算法的 “松弛操作” 本质是强制满足三角不等式。

### 1.4 单源最短路径问题

- **问题定义**：给定源顶点`s`，求`s`到图中所有其他顶点`v`的最短路径权重`δ(s, v)`（视频中明确这是 Dijkstra 算法的目标，且当前技术下 “单源问题” 与 “点对点问题” 复杂度相当）。
- **Dijkstra 算法适用条件**：**所有边权非负**（`w(u, v) ≥ 0`），此时无需担心负权环，若路径存在则`δ(s, v)`为有限值。

## 2. Dijkstra 算法原理与步骤

视频详细拆解了 Dijkstra 算法的核心思想、数据结构与执行流程，核心是**贪婪策略**与**松弛操作**。

### 2.1 核心思想

- 维护两个集合：
	1. `S`：已确定最短路径权重的顶点集合（“已解决” 顶点）。
	2. `V \ S`：未确定最短路径权重的顶点集合（“未解决” 顶点）。
- 维护距离估计数组`d[]`：`d[v]`表示当前从`s`到`v`的最短路径权重估计值（初始时为 “无穷大”，`d[s] = 0`）。
- 贪婪选择：每次从`V \ S`中选择`d[v]`最小的顶点`u`，加入`S`（此时`d[u]`即为`δ(s, u)`，因为边权非负，不会有更短路径）。
- 松弛操作：将`u`加入`S`后，更新所有从`u`出发的边`(u, v)`对应的`d[v]`（利用`u`的最短路径优化`v`的估计值）。

### 2.2 关键操作：松弛（Relax）

视频将 “松弛” 定义为算法的核心步骤，用于优化距离估计：

- **操作定义**：对边`(u, v)`，若当前`d[v] > d[u] + w(u, v)`，则更新`d[v] = d[u] + w(u, v)`。
- **直观意义**：发现一条从`s`经`u`到`v`的更短路径，因此修正`v`的距离估计。
- **性质**：松弛操作不会使`d[v]`小于`δ(s, v)`（即`d[v]`始终是`δ(s, v)`的上界）。

### 2.3 完整算法步骤

视频中给出的 Dijkstra 算法步骤（基于优先级队列优化）：

1. **初始化**：
	- 对所有`v ∈ V`，设`d[v] = +∞`，`d[s] = 0`（源点距离为 0）。
	- 初始化优先级队列`Q`（最小堆），将所有顶点入队，以`d[v]`为优先级。
	- 初始化已解决集合`S = ∅`，前驱数组`prev[]`（用于记录最短路径，`prev[v]`表示`v`的前一个顶点）。
2. **核心循环**（直至`Q`为空）：
	a. 提取`Q`中优先级最小的顶点`u`（即`d[u]`最小），将`u`从`Q`中删除并加入`S`。
	b. 对`u`的所有出边`(u, v)`（即`v`是`u`的邻接顶点）：
	i. 执行松弛操作：若`d[v] > d[u] + w(u, v)`，则更新`d[v] = d[u] + w(u, v)`，并设`prev[v] = u`。
	ii. 更新`Q`中`v`的优先级（因`d[v]`减小，需调整堆结构）。
3. **输出**：
	- `d[v]`即为`s`到`v`的最短路径权重`δ(s, v)`。
	- 通过`prev[]`回溯，可还原`s`到`v`的最短路径（从`v`反向找`prev[v]`，直至`s`）。

## 3. 算法正确性证明

视频通过两个引理和一个定理证明 Dijkstra 算法的正确性，前提是**边权非负**。

### 引理 1：距离估计的上界性质

- **结论**：对任意顶点`v`，在算法执行的任意时刻，`d[v] ≥ δ(s, v)`（`d[v]`始终是`δ(s, v)`的上界）。
- **证明**：
	1. **初始化阶段**：`d[s] = 0 = δ(s, s)`，其他`d[v] = +∞ ≥ δ(s, v)`，性质成立。
	2. **松弛阶段**（归纳法）：假设松弛前`d[u] ≥ δ(s, u)`且`d[v] ≥ δ(s, v)`。
		松弛时若更新`d[v] = d[u] + w(u, v)`，则由三角不等式`δ(s, v) ≤ δ(s, u) + w(u, v) ≤ d[u] + w(u, v) = d[v]`，因此更新后`d[v] ≥ δ(s, v)`，性质保持。

### 引理 2：松弛的正确性

- **结论**：若`δ(s, v) = δ(s, u) + w(u, v)`（即`(u, v)`是`s`到`v`最短路径的最后一条边），且`d[u] = δ(s, u)`（`u`已加入`S`），则松弛`(u, v)`后`d[v] = δ(s, v)`。
- **证明**：
	由引理 1，`d[v] ≥ δ(s, v)`。
	又因`d[u] = δ(s, u)`，松弛时`d[v] ≤ d[u] + w(u, v) = δ(s, u) + w(u, v) = δ(s, v)`。
	综上`d[v] = δ(s, v)`。

### 定理：算法最终正确性

- **结论**：算法结束时，对所有`v ∈ V`，`d[v] = δ(s, v)`。
- **证明**（反证法）：
	假设存在顶点`u`，算法结束时`d[u] ≠ δ(s, u)`。取第一个被加入`S`且`d[u] ≠ δ(s, u)`的顶点`u`（因`S`逐步扩大，第一个违规顶点存在）。
	由引理 1，`d[u] > δ(s, u)`。考虑`s`到`u`的最短路径`p`，设`p`中最后一个在`S`中的顶点为`x`，下一个顶点为`y`（`y ∉ S`）。
	因`x ∈ S`，`d[x] = δ(s, x)`（`u`是第一个违规顶点）；由最优子结构，`δ(s, y) = δ(s, x) + w(x, y)`，松弛`(x, y)`后`d[y] = δ(s, y)`。
	又因`y`在`p`上，`δ(s, y) ≤ δ(s, u)`，故`d[y] = δ(s, y) ≤ δ(s, u) < d[u]`。但算法选择`u`加入`S`时，`d[u]`是`V \ S`中最小的，与`d[y] < d[u]`矛盾。因此假设不成立，算法正确。

## 4. 视频中的示例演示

视频用具体图形演示 Dijkstra 算法执行过程，以下是完整示例：

### 4.1 示例图形

- **顶点**：`A`（源点`s`）、`B`、`C`、`D`、`E`。
- **边与权重**：
	- `A→B (10)`、`A→C (3)`
	- `C→B (4)`、`C→D (8)`、`C→E (2)`
	- `E→D (9)`
	- `B→C (1)`、`B→D (2)`
	- `D→E (7)`

### 4.2 算法执行步骤（逐步跟踪）

#### 初始化

- `d = [A:0, B:+∞, C:+∞, D:+∞, E:+∞]`，`S = ∅`，`Q = {A(0), B(∞), C(∞), D(∞), E(∞)}`。

#### 第 1 轮：提取`A`（`d[A]=0`）

- 加入`S`：`S = {A}`。
- 松弛`A`的出边：
	- `A→B`：`d[B] = min(∞, 0+10) = 10`，`prev[B] = A`。
	- `A→C`：`d[C] = min(∞, 0+3) = 3`，`prev[C] = A`。
- 此时`d = [A:0, B:10, C:3, D:∞, E:∞]`，`Q = {C(3), B(10), D(∞), E(∞)}`。

#### 第 2 轮：提取`C`（`d[C]=3`）

- 加入`S`：`S = {A, C}`。
- 松弛`C`的出边：
	- `C→B`：`d[B] = min(10, 3+4) = 7`，`prev[B] = C`。
	- `C→D`：`d[D] = min(∞, 3+8) = 11`，`prev[D] = C`。
	- `C→E`：`d[E] = min(∞, 3+2) = 5`，`prev[E] = C`。
- 此时`d = [A:0, B:7, C:3, D:11, E:5]`，`Q = {E(5), B(7), D(11)}`。

#### 第 3 轮：提取`E`（`d[E]=5`）

- 加入`S`：`S = {A, C, E}`。
- 松弛`E`的出边：
	- `E→D`：`d[D] = min(11, 5+9) = 11`（无更新）。
- 此时`d = [A:0, B:7, C:3, D:11, E:5]`，`Q = {B(7), D(11)}`。

#### 第 4 轮：提取`B`（`d[B]=7`）

- 加入`S`：`S = {A, C, E, B}`。
- 松弛`B`的出边：
	- `B→C`：`d[C] = 3`（已在`S`，无更新）。
	- `B→D`：`d[D] = min(11, 7+2) = 9`，`prev[D] = B`。
- 此时`d = [A:0, B:7, C:3, D:9, E:5]`，`Q = {D(9)}`。

#### 第 5 轮：提取`D`（`d[D]=9`）

- 加入`S`：`S = {A, C, E, B, D}`。
- 松弛`D`的出边：
	- `D→E`：`d[E] = 5`（已在`S`，无更新）。
- `Q`为空，算法结束。

#### 最终结果

- 最短路径权重：`A→A(0)`、`A→C→B(7)`、`A→C(3)`、`A→C→B→D(9)`、`A→C→E(5)`。
- 最短路径树（通过`prev`）：`A`是根，`C`（父 A）、`E`（父 C）、`B`（父 C）、`D`（父 B）。

## 5. Dijkstra 算法 C++ 实现

视频中明确使用**邻接表**存储图、**优先级队列（最小堆）** 优化选择步骤，以下是完整代码（含路径回溯）：

### 5.1 代码说明

- **图存储**：用`vector<vector<pair<int, int>>> adj`，`adj[u]`存储`u`的所有出边（`pair<v, w>`表示边`(u, v)`权重为`w`）。
- **优先级队列**：C++ 默认`priority_queue`是最大堆，通过`greater<pair<int, int>>`改为最小堆，存储`(d[u], u)`（优先级为`d[u]`）。
- **无穷大**：用`INT_MAX`（需包含`<climits>`），避免溢出（松弛时需判断`d[u]`是否为`INT_MAX`）。
- **前驱数组**：`vector<int> prev`记录路径，`prev[v] = -1`表示无前驱（源点）。

### 5.2 完整代码

cpp

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <algorithm>  // 用于reverse()回溯路径

using namespace std;

// Dijkstra算法：输入图(邻接表)、源点s，输出d(最短路径权重)和prev(前驱数组)
void dijkstra(const vector<vector<pair<int, int>>>& adj, int s, vector<int>& d, vector<int>& prev) {
    int n = adj.size();  // 顶点数（假设顶点编号为0~n-1，示例中A=0, B=1, C=2, D=3, E=4）
    d.assign(n, INT_MAX);  // 初始化距离为无穷大
    prev.assign(n, -1);    // 初始化前驱为-1（无）
    d[s] = 0;              // 源点距离为0

    // 优先级队列：最小堆，存储(d[u], u)，按d[u]升序排列
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.emplace(d[s], s);  // 源点入队

    while (!pq.empty()) {
        // 步骤1：提取d[u]最小的顶点u
        int u = pq.top().second;
        int current_d = pq.top().first;
        pq.pop();

        // 优化：若当前提取的d[u]大于已知的d[u]，说明是旧数据，跳过
        if (current_d > d[u]) {
            continue;
        }

        // 步骤2：松弛u的所有出边
        for (const auto& edge : adj[u]) {
            int v = edge.first;    // 邻接顶点v
            int w = edge.second;   // 边(u, v)的权重

            // 松弛操作：若经u到v的路径更短，更新d[v]和prev[v]
            if (d[u] != INT_MAX && d[v] > d[u] + w) {
                d[v] = d[u] + w;
                prev[v] = u;
                pq.emplace(d[v], v);  // 加入新的d[v]到队列（允许重复入队，靠current_d>d[u]跳过旧数据）
            }
        }
    }
}

// 回溯前驱数组，获取从源点s到顶点v的最短路径（逆序）
vector<int> getShortestPath(const vector<int>& prev, int s, int v) {
    vector<int> path;
    // 从v反向追溯到s
    for (int u = v; u != -1; u = prev[u]) {
        path.push_back(u);
    }
    reverse(path.begin(), path.end());  // 逆序转为正序（s→...→v）
    // 验证路径是否合法（若路径第一个顶点不是s，说明无路径）
    if (path[0] != s) {
        return {};  // 空路径表示无可达路径
    }
    return path;
}

int main() {
    // 示例图初始化（顶点编号：A=0, B=1, C=2, D=3, E=4）
    int n = 5;  // 5个顶点
    vector<vector<pair<int, int>>> adj(n);
    // 添加边（u, v, w）
    adj[0].emplace_back(1, 10);  // A→B (10)
    adj[0].emplace_back(2, 3);   // A→C (3)
    adj[2].emplace_back(1, 4);   // C→B (4)
    adj[2].emplace_back(3, 8);   // C→D (8)
    adj[2].emplace_back(4, 2);   // C→E (2)
    adj[4].emplace_back(3, 9);   // E→D (9)
    adj[1].emplace_back(2, 1);   // B→C (1)
    adj[1].emplace_back(3, 2);   // B→D (2)
    adj[3].emplace_back(4, 7);   // D→E (7)

    int source = 0;  // 源点A（编号0）
    vector<int> d;   // 存储最短路径权重
    vector<int> prev; // 存储前驱顶点

    // 执行Dijkstra算法
    dijkstra(adj, source, d, prev);

    // 输出结果
    cout << "=== Dijkstra算法结果（源点：A，编号0）===" << endl;
    vector<string> vertex_names = {"A", "B", "C", "D", "E"};  // 顶点名映射
    for (int v = 0; v < n; ++v) {
        cout << "从" << vertex_names[source] << "到" << vertex_names[v] << "：";
        if (d[v] == INT_MAX) {
            cout << "无路径" << endl;
        } else {
            cout << "最短路径权重 = " << d[v] << "，路径：";
            vector<int> path = getShortestPath(prev, source, v);
            for (size_t i = 0; i < path.size(); ++i) {
                cout << vertex_names[path[i]];
                if (i != path.size() - 1) {
                    cout << "→";
                }
            }
            cout << endl;
        }
    }

    return 0;
}
```

### 5.3 代码输出

plaintext

```plaintext
=== Dijkstra算法结果（源点：A，编号0）===
从A到A：最短路径权重 = 0，路径：A
从A到B：最短路径权重 = 7，路径：A→C→B
从A到C：最短路径权重 = 3，路径：A→C
从A到D：最短路径权重 = 9，路径：A→C→B→D
从A到E：最短路径权重 = 5，路径：A→C→E
```



# 知识点总结：Bellman-Ford 算法与差分约束系统

## 一、Bellman-Ford 算法

### 1. 算法定位与核心作用

- **适用场景**：解决**单源最短路径问题**，支持**负权边**（Dijkstra 算法无法处理负权边），且能**检测负权环**（存在负权环时，部分顶点的最短路径权重会趋近于负无穷，无有效最短路径）。
- **核心目标**：
	1. 计算从源点`s`到所有其他顶点`v`的最短路径权重`δ(s, v)`（无负权环时）；
	2. 若图中存在能从`s`到达的负权环，直接报告该环（此时无有效最短路径）。

### 2. 核心原理

#### （1）关键前提：简单路径的边数限制

任意无负权环的图中，从源点`s`到顶点`v`的最短路径一定是**简单路径**（无重复顶点），其边数最多为`V-1`（`V`为顶点总数）。因此，只需松弛`V-1`轮即可得到所有顶点的最短路径。

#### （2）松弛操作（Relaxation）

- **定义**：对边`(u, v)`（权重为`w`），若当前从`s`到`v`的估计距离`dist[v]`大于从`s`到`u`的估计距离`dist[u]`加上边权重`w`，则更新`dist[v]`：
	`if dist[u] != INF && dist[v] > dist[u] + w: dist[v] = dist[u] + w`
- **意义**：逐步缩小对最短路径的估计值，最终收敛到真实最短路径权重（无负权环时）。

### 3. 算法步骤（视频示例：V=5 个顶点，源点 A）

#### 步骤 1：初始化

- 源点`s`的估计距离`dist[s] = 0`；
- 其他所有顶点的估计距离`dist[v] = INF`（无穷大，避免溢出可用`INT_MAX/2`）。

#### 步骤 2：V-1 轮松弛（视频中 V=5，故松弛 4 轮）

- 每轮遍历**所有边**，对每条边执行松弛操作；
- 视频示例演算（源点 A，边顺序 1-8）：
	- **第 1 轮**：松弛边 4（A→B，w=-1）→`dist[B]=-1`；松弛边 5（A→C，w=4）→`dist[C]=4`；松弛边 7（B→C，w=3）→`dist[C] = -1+3=2`（更新）；
	- **第 2 轮**：松弛边 8（C→D，w=-3）→`dist[D] = 2-3=-2`（更新）；
	- **第 3-4 轮**：无更多更新（因最短路径已找到）。

#### 步骤 3：负权环检测

- 执行第`V`轮松弛（视频中 V=5，第 5 轮）；
- 若仍能对某条边`(u, v)`执行松弛操作，说明图中存在**能从源点到达的负权环**（此时`dist[v]`可无限减小，无最短路径）。

### 4. 时间复杂度

- 设顶点数为`V`，边数为`E`：
	- 初始化：`O(V)`；
	- V-1 轮松弛：`O(V*E)`；
	- 负权环检测：`O(E)`；
	- 总复杂度：`O(V*E)`（比 Dijkstra 算法慢，适合负权边场景）。

### 5. C++ 代码实现

cpp

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

// 边的结构体：起点u，终点v，权重w
struct Edge {
    int u, v, w;
    Edge(int u_, int v_, int w_) : u(u_), v(v_), w(w_) {}
};

/**
 * Bellman-Ford算法实现
 * @param V 顶点总数（视频中V=5，顶点编号0=A,1=B,2=C,3=D,4=E）
 * @param E 边集合（视频中8条边）
 * @param s 源点（视频中s=0，即A）
 * @param dist 输出参数：dist[v]为s到v的最短路径权重
 * @return 是否存在能从s到达的负权环
 */
bool bellmanFord(int V, const vector<Edge>& edges, int s, vector<int>& dist) {
    // 步骤1：初始化
    dist.assign(V, INT_MAX / 2);  // 用INT_MAX/2避免溢出
    dist[s] = 0;

    // 步骤2：V-1轮松弛
    for (int i = 0; i < V - 1; ++i) {
        bool updated = false;  // 优化：无更新则提前退出（视频提到的优化）
        for (const auto& e : edges) {
            int u = e.u, v = e.v, w = e.w;
            if (dist[u] != INT_MAX / 2 && dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                updated = true;
            }
        }
        if (!updated) break;  // 无更新，无需继续松弛
    }

    // 步骤3：检测负权环
    for (const auto& e : edges) {
        int u = e.u, v = e.v, w = e.w;
        if (dist[u] != INT_MAX / 2 && dist[v] > dist[u] + w) {
            return true;  // 存在负权环
        }
    }
    return false;  // 无负权环，dist数组为最短路径
}

// 视频示例：5个顶点（A=0,B=1,C=2,D=3,E=4），8条边
int main() {
    int V = 5;
    vector<Edge> edges = {
        Edge(0, 4, 2),   // 边1：A→E，w=2
        Edge(4, 1, 2),   // 边2：E→B，w=2
        Edge(1, 3, 2),   // 边3：B→D，w=2
        Edge(0, 1, -1),  // 边4：A→B，w=-1（视频中关键边）
        Edge(0, 2, 4),   // 边5：A→C，w=4（视频中关键边）
        Edge(4, 2, 5),   // 边6：E→C，w=5
        Edge(1, 2, 3),   // 边7：B→C，w=3（视频中关键边，更新C的dist）
        Edge(2, 3, -3)   // 边8：C→D，w=-3（视频中关键边，更新D的dist）
    };
    int s = 0;  // 源点A
    vector<int> dist;

    bool hasNegativeCycle = bellmanFord(V, edges, s, dist);

    // 输出结果
    if (hasNegativeCycle) {
        cout << "图中存在能从源点到达的负权环，无有效最短路径" << endl;
    } else {
        cout << "源点A（编号0）到各顶点的最短路径权重：" << endl;
        char vertices[] = {'A', 'B', 'C', 'D', 'E'};
        for (int i = 0; i < V; ++i) {
            cout << vertices[i] << ": " << dist[i] << endl;
        }
        // 预期输出（与视频一致）：
        // A: 0, B: -1, C: 2, D: -2, E: 2
    }

    return 0;
}
```

## 二、差分约束系统

### 1. 定义与约束形式

- **定位**：一种**线性可行性问题**（无目标函数，仅判断约束是否可满足），是线性规划的特殊形式。
- **约束形式**：所有约束均为`x_j - x_i ≤ w_ij`（`x_i, x_j`为变量，`w_ij`为常数），共`m`个约束、`n`个变量。

### 2. 核心思想：转化为图论问题

#### （1）约束图构建规则

- 每个变量`x_i`对应图中的一个顶点`v_i`；
- 每个约束`x_j - x_i ≤ w_ij`对应一条从`v_i`到`v_j`的有向边，权重为`w_ij`；
- 添加**超级源点`s`** ：向所有变量顶点`v_i`添加一条权重为`0`的有向边（`s→v_i, w=0`），确保从`s`能到达所有顶点。

#### （2）可行性判定（与 Bellman-Ford 关联）

- **定理 1**：若约束图中存在**负权环**，则差分约束系统**无解**（证明：负权环的约束相加会导致`0 ≤ 负数值`，矛盾）；
- **定理 2**：若约束图中**无负权环**，则差分约束系统**有解**，解为超级源点`s`到各顶点`v_i`的最短路径权重`dist[v_i]`（即`x_i = dist[v_i]`，满足所有`x_j - x_i ≤ w_ij`，因最短路径满足三角不等式）。

### 3. 视频示例（3 个变量，3 个约束）

#### 示例约束

1. `x₁ - x₂ ≤ 3`
2. `x₂ - x₃ ≤ -2`
3. `x₁ - x₃ ≤ 2`

#### 约束图构建

- 变量顶点：`v₁`（x₁）、`v₂`（x₂）、`v₃`（x₃）；
- 边：
	- `v₂→v₁`（w=3，对应约束 1）；
	- `v₃→v₂`（w=-2，对应约束 2）；
	- `v₃→v₁`（w=2，对应约束 3）；
- 超级源点`s`：添加`s→v₁`（w=0）、`s→v₂`（w=0）、`s→v₃`（w=0）。

#### 求解过程

- 调用 Bellman-Ford 算法（V=4，含超级源点`s`），检测无负权环；
- 最短路径权重（解）：`x₁=dist[v₁]`、`x₂=dist[v₂]`、`x₃=dist[v₃]`（视频中示例解：`x₁=1, x₂=-2, x₃=0`，满足所有约束）。

### 4. 应用场景

- **LSI 布局**：一维场景下，芯片元件需保持最小间距（约束`x_j - x_i ≥ d`，转化为`x_i - x_j ≤ -d`），通过差分约束求解元件坐标，最小化芯片尺寸（`max(x_i) - min(x_i)`）；
- **多媒体时序调度**：如 “音频在视频后至少播放 2 秒”（`x_音频 - x_视频 ≥ 2`，转化为`x_视频 - x_音频 ≤ -2`）。

### 5. C++ 代码实现

cpp

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

struct Edge {
    int u, v, w;
    Edge(int u_, int v_, int w_) : u(u_), v(v_), w(w_) {}
};

// Bellman-Ford算法（复用前文逻辑，用于差分约束检测）
bool bellmanFord(int V, const vector<Edge>& edges, int s, vector<int>& dist) {
    dist.assign(V, INT_MAX / 2);
    dist[s] = 0;

    // V-1轮松弛
    for (int i = 0; i < V - 1; ++i) {
        bool updated = false;
        for (const auto& e : edges) {
            if (dist[e.u] != INT_MAX / 2 && dist[e.v] > dist[e.u] + e.w) {
                dist[e.v] = dist[e.u] + e.w;
                updated = true;
            }
        }
        if (!updated) break;
    }

    // 检测负权环
    for (const auto& e : edges) {
        if (dist[e.u] != INT_MAX / 2 && dist[e.v] > dist[e.u] + e.w) {
            return true;
        }
    }
    return false;
}

/**
 * 求解差分约束系统
 * @param n 变量数（视频示例n=3：x1,x2,x3）
 * @param constraints 约束列表：每个约束为(x_j - x_i ≤ w)，存储为(i,j,w)
 * @param solution 输出参数：solution[i]为x_{i+1}的解（因变量从1开始）
 * @return 是否有解
 */
bool solveDifferenceConstraints(int n, const vector<tuple<int, int, int>>& constraints, vector<int>& solution) {
    int V = n + 1;  // V = 变量数 + 超级源点s（编号0）
    vector<Edge> edges;

    // 1. 添加约束对应的边（变量1~n对应顶点1~n）
    for (const auto& [i, j, w] : constraints) {
        edges.emplace_back(i, j, w);  // 约束x_j - x_i ≤ w → 边i→j，w
    }

    // 2. 添加超级源点s（0）到所有变量顶点的边（w=0）
    for (int i = 1; i <= n; ++i) {
        edges.emplace_back(0, i, 0);
    }

    // 3. 调用Bellman-Ford检测负权环并求最短路径（解）
    vector<int> dist;
    bool hasNegativeCycle = bellmanFord(V, edges, 0, dist);

    if (hasNegativeCycle) {
        return false;  // 无解
    } else {
        // 解为s到各变量顶点的最短路径（dist[1]~dist[n]对应x1~xn）
        solution.assign(dist.begin() + 1, dist.end());
        return true;
    }
}

// 视频示例：3个变量（x1,x2,x3），3个约束
int main() {
    int n = 3;  // 变量数：x1,x2,x3
    // 约束列表：(i,j,w) 对应 x_j - x_i ≤ w
    vector<tuple<int, int, int>> constraints = {
        {2, 1, 3},  // x1 - x2 ≤ 3 → i=2, j=1, w=3
        {3, 2, -2}, // x2 - x3 ≤ -2 → i=3, j=2, w=-2
        {3, 1, 2}   // x1 - x3 ≤ 2 → i=3, j=1, w=2
    };
    vector<int> solution;

    bool hasSolution = solveDifferenceConstraints(n, constraints, solution);

    if (hasSolution) {
        cout << "差分约束系统有解：" << endl;
        cout << "x1 = " << solution[0] << endl;
        cout << "x2 = " << solution[1] << endl;
        cout << "x3 = " << solution[2] << endl;
        // 验证约束（以视频示例解x1=1,x2=-2,x3=0为例）：
        // 1-(-2)=3 ≤3 ✔️；-2-0=-2 ≤-2 ✔️；1-0=1 ≤2 ✔️
    } else {
        cout << "差分约束系统无解（存在负权环）" << endl;
    }

    return 0;
}
```



# 最短路径算法知识点总结

## 一、单源最短路径（SSSP）

单源最短路径指从**一个源顶点**到图中所有其他顶点的最短路径，视频中根据边权特性分为 4 种场景，分别对应不同算法。

### 1.1 BFS（无权重图，边权均为 1）

#### 适用场景

- 无权重有向 / 无向图（所有边权 = 1）。

#### 核心思想

- 利用队列实现 “层次遍历”，从源点出发，依次访问距离为 1、2、3... 的顶点，确保首次访问时的距离即为最短距离。
- 时间复杂度：**O(V + E)**（V = 顶点数，E = 边数，线性时间）。

#### C++ 代码（邻接表实现）

cpp

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

// 无权重图的BFS单源最短路径
void BFS_SSSP(const vector<vector<int>>& adj, int start, vector<int>& dist) {
    int V = adj.size();
    dist.assign(V, INT_MAX); // 初始化距离为无穷大
    queue<int> q;

    // 起点初始化
    dist[start] = 0;
    q.push(start);

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        // 遍历所有邻接顶点
        for (int v : adj[u]) {
            if (dist[v] == INT_MAX) { // 未访问过
                dist[v] = dist[u] + 1; // 边权为1，距离+1
                q.push(v);
            }
        }
    }
}

// 示例：无向无权重图
int main() {
    int V = 5; // 顶点0-4
    vector<vector<int>> adj(V);
    // 构建边：0-1, 0-2, 1-3, 2-3, 3-4
    adj[0].push_back(1);
    adj[1].push_back(0);
    adj[0].push_back(2);
    adj[2].push_back(0);
    adj[1].push_back(3);
    adj[3].push_back(1);
    adj[2].push_back(3);
    adj[3].push_back(2);
    adj[3].push_back(4);
    adj[4].push_back(3);

    vector<int> dist;
    BFS_SSSP(adj, 0, dist); // 源点为0

    // 输出结果：0→0(0), 0→1(1), 0→2(1), 0→3(2), 0→4(3)
    for (int i = 0; i < V; ++i) {
        cout << "从0到" << i << "的最短距离：" << dist[i] << endl;
    }
    return 0;
}
```

### 1.2 Dijkstra 算法（非负边权）

#### 适用场景

- 边权非负的有向 / 无向图（无负边权，无负权循环）。

#### 核心思想

- 贪心策略：每次选择 “当前距离源点最近的未确定顶点”，松弛其所有出边，更新邻接顶点的距离。
- 数据结构：用**优先队列（最小堆）** 维护未确定顶点的距离，用邻接表存储图。
- 时间复杂度：**O(V log V + E)**（二叉堆实现，若用斐波那契堆为 O (V + E log V)，视频未提及后者）。

#### C++ 代码（邻接表 + 优先队列）

cpp

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <utility>
using namespace std;

typedef pair<int, int> PII; // 存储(距离, 顶点编号)

// 非负边权图的Dijkstra单源最短路径
void Dijkstra_SSSP(const vector<vector<PII>>& adj, int start, vector<int>& dist) {
    int V = adj.size();
    dist.assign(V, INT_MAX);
    priority_queue<PII, vector<PII>, greater<PII>> pq; // 最小堆

    // 起点初始化
    dist[start] = 0;
    pq.push({0, start});

    while (!pq.empty()) {
        auto [current_dist, u] = pq.top(); // C++17结构化绑定，若不支持则拆分为pq.top().first/second
        pq.pop();

        // 若当前距离大于已记录的最短距离，跳过（冗余节点）
        if (current_dist > dist[u]) continue;

        // 松弛所有出边
        for (auto [w, v] : adj[u]) { // w=边u→v的权值
            if (dist[v] > dist[u] + w) { // 满足松弛条件
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
}

// 示例：非负边权有向图
int main() {
    int V = 4; // 顶点0-3
    vector<vector<PII>> adj(V);
    // 构建边：0→1(2), 0→2(5), 1→2(1), 1→3(6), 2→3(3)
    adj[0].push_back({2, 1});
    adj[0].push_back({5, 2});
    adj[1].push_back({1, 2});
    adj[1].push_back({6, 3});
    adj[2].push_back({3, 3});

    vector<int> dist;
    Dijkstra_SSSP(adj, 0, dist); // 源点为0

    // 输出结果：0→0(0), 0→1(2), 0→2(3), 0→3(6)
    for (int i = 0; i < V; ++i) {
        cout << "从0到" << i << "的最短距离：" << dist[i] << endl;
    }
    return 0;
}
```

### 1.3 Bellman-Ford 算法（一般边权，含负边）

#### 适用场景

- 边权可负的有向 / 无向图（允许负边，但不允许**从源点可达的负权循环**）。
- 可检测 “从源点可达的负权循环”（若存在，最短路径无意义）。

#### 核心思想

- 松弛操作：对所有边重复松弛 V-1 次（最长简单路径的边数不超过 V-1），确保所有最短路径都被找到。
- 负权循环检测：第 V 轮若仍能松弛，则存在从源点可达的负权循环。
- 时间复杂度：**O(VE)**（V 轮松弛，每轮处理 E 条边）。

#### C++ 代码（边列表实现）

cpp

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

struct Edge {
    int u, v, w; // 边u→v，权值w
    Edge(int u_, int v_, int w_) : u(u_), v(v_), w(w_) {}
};

// 一般边权图的Bellman-Ford单源最短路径（含负权循环检测）
bool BellmanFord_SSSP(const vector<Edge>& edges, int V, int start, vector<int>& dist) {
    dist.assign(V, INT_MAX);
    dist[start] = 0;

    // 第1~V-轮松弛所有边
    for (int i = 0; i < V - 1; ++i) {
        bool updated = false; // 优化：若某轮无更新，提前退出
        for (const Edge& e : edges) {
            if (dist[e.u] != INT_MAX && dist[e.v] > dist[e.u] + e.w) {
                dist[e.v] = dist[e.u] + e.w;
                updated = true;
            }
        }
        if (!updated) break;
    }

    // 第V轮检测负权循环
    for (const Edge& e : edges) {
        if (dist[e.u] != INT_MAX && dist[e.v] > dist[e.u] + e.w) {
            return false; // 存在从源点可达的负权循环
        }
    }
    return true; // 无负权循环，dist数组有效
}

// 示例：含负边的有向图
int main() {
    int V = 4; // 顶点0-3
    vector<Edge> edges;
    // 构建边：0→1(1), 0→2(4), 1→2(-2), 1→3(2), 2→3(1)
    edges.emplace_back(0, 1, 1);
    edges.emplace_back(0, 2, 4);
    edges.emplace_back(1, 2, -2);
    edges.emplace_back(1, 3, 2);
    edges.emplace_back(2, 3, 1);

    vector<int> dist;
    bool hasNegativeCycle = !BellmanFord_SSSP(edges, V, 0, dist);

    if (hasNegativeCycle) {
        cout << "图中存在从源点可达的负权循环，最短路径无意义！" << endl;
    } else {
        // 输出结果：0→0(0), 0→1(1), 0→2(-1), 0→3(0)
        for (int i = 0; i < V; ++i) {
            cout << "从0到" << i << "的最短距离：" << dist[i] << endl;
        }
    }
    return 0;
}
```

### 1.4 拓扑排序优化 Bellman-Ford（有向无环图 DAG）

#### 适用场景

- 有向无环图（DAG），边权可负（无环则无负权循环）。

#### 核心思想

- 先对 DAG 进行**拓扑排序**（顶点顺序满足：所有边 u→v 的 u 在 v 之前）。
- 按拓扑序对每个顶点的所有出边执行**1 次松弛**（无需重复 V-1 次，因 DAG 无环，路径长度有限）。
- 时间复杂度：**O(V + E)**（拓扑排序 O (V+E) + 1 次松弛 O (E)）。

#### C++ 代码（邻接表 + 拓扑排序）

cpp

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

typedef pair<int, int> PII; // (边权, 邻接顶点)

// 对DAG进行拓扑排序，返回拓扑序（若有环返回空）
vector<int> TopologicalSort(const vector<vector<PII>>& adj, int V) {
    vector<int> inDegree(V, 0);
    queue<int> q;
    vector<int> topoOrder;

    // 统计入度
    for (int u = 0; u < V; ++u) {
        for (auto [w, v] : adj[u]) {
            inDegree[v]++;
        }
    }

    // 入度为0的顶点入队
    for (int u = 0; u < V; ++u) {
        if (inDegree[u] == 0) {
            q.push(u);
        }
    }

    // 拓扑排序
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        topoOrder.push_back(u);

        for (auto [w, v] : adj[u]) {
            inDegree[v]--;
            if (inDegree[v] == 0) {
                q.push(v);
            }
        }
    }

    return topoOrder.size() == V ? topoOrder : vector<int>(); // 无环返回拓扑序，有环返回空
}

// DAG的拓扑排序优化Bellman-Ford单源最短路径
void DAG_SSSP(const vector<vector<PII>>& adj, int start, vector<int>& dist) {
    int V = adj.size();
    vector<int> topoOrder = TopologicalSort(adj, V);
    if (topoOrder.empty()) {
        cout << "图不是DAG，无法使用该算法！" << endl;
        return;
    }

    // 初始化距离
    dist.assign(V, INT_MAX);
    dist[start] = 0;

    // 按拓扑序松弛所有出边
    for (int u : topoOrder) {
        if (dist[u] == INT_MAX) continue; // 源点不可达的顶点
        for (auto [w, v] : adj[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
            }
        }
    }
}

// 示例：DAG（含负边）
int main() {
    int V = 5; // 顶点0-4
    vector<vector<PII>> adj(V);
    // 构建DAG边：0→1(2), 0→2(-1), 1→3(3), 2→3(1), 3→4(-2)
    adj[0].push_back({2, 1});
    adj[0].push_back({-1, 2});
    adj[1].push_back({3, 3});
    adj[2].push_back({1, 3});
    adj[3].push_back({-2, 4});

    vector<int> dist;
    DAG_SSSP(adj, 0, dist); // 源点为0

    // 输出结果：0→0(0), 0→1(2), 0→2(-1), 0→3(0), 0→4(-2)
    for (int i = 0; i < V; ++i) {
        cout << "从0到" << i << "的最短距离：" << dist[i] << endl;
    }
    return 0;
}
```

## 二、所有对最短路径（APSP）

所有对最短路径指**任意两个顶点 (i,j)** 之间的最短路径，视频中介绍 4 种核心算法，重点对比时间复杂度和适用场景。

### 2.1 暴力扩展：对每个顶点运行单源算法

#### 核心思想

- 遍历所有顶点，将每个顶点作为 “源点”，调用对应的单源最短路径算法（根据边权特性选择 BFS/Dijkstra/Bellman-Ford）。
- 本质是 “单源算法的 V 次调用”，时间复杂度为 “单源算法时间 × V”。

#### 时间复杂度对比

| 边权特性           | 单源算法     | 单源时间复杂度 | APSP 时间复杂度   |
| ------------------ | ------------ | -------------- | ----------------- |
| 无权重（边权 = 1） | BFS          | O(V+E)         | O(V(V+E))         |
| 非负边权           | Dijkstra     | O(V log V + E) | O(V(V log V + E)) |
| 一般边权（含负）   | Bellman-Ford | O(VE)          | O(V²E)            |

#### C++ 代码（以非负边权为例，调用 Dijkstra V 次）

cpp

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <utility>
using namespace std;

typedef pair<int, int> PII;
const int INF = INT_MAX;

// 单次Dijkstra（同1.2）
void Dijkstra(const vector<vector<PII>>& adj, int start, vector<int>& dist) {
    int V = adj.size();
    dist.assign(V, INF);
    priority_queue<PII, vector<PII>, greater<PII>> pq;
    dist[start] = 0;
    pq.push({0, start});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        if (d > dist[u]) continue;
        for (auto [w, v] : adj[u]) {
            if (dist[v] > d + w) {
                dist[v] = d + w;
                pq.push({dist[v], v});
            }
        }
    }
}

// APSP：对每个顶点调用Dijkstra（非负边权）
vector<vector<int>> APSP_Dijkstra(const vector<vector<PII>>& adj) {
    int V = adj.size();
    vector<vector<int>> distMatrix(V, vector<int>(V, INF)); // 存储所有对最短距离

    for (int start = 0; start < V; ++start) {
        Dijkstra(adj, start, distMatrix[start]); // 每个start作为源点
    }

    return distMatrix;
}

// 示例：非负边权有向图
int main() {
    int V = 4; // 顶点0-3
    vector<vector<PII>> adj(V);
    adj[0].push_back({2, 1});
    adj[0].push_back({5, 2});
    adj[1].push_back({1, 2});
    adj[1].push_back({6, 3});
    adj[2].push_back({3, 3});
    adj[3].push_back({1, 0}); // 新增3→0，权值1

    vector<vector<int>> distMatrix = APSP_Dijkstra(adj);

    // 输出所有对最短距离矩阵
    cout << "所有对最短距离矩阵（行=源点，列=终点）：" << endl;
    for (int i = 0; i < V; ++i) {
        for (int j = 0; j < V; ++j) {
            if (distMatrix[i][j] == INF) cout << "INF ";
            else cout << distMatrix[i][j] << "   ";
        }
        cout << endl;
    }
    /* 输出结果：
    0   2   3   6   
    7   0   1   4   
    4   6   0   3   
    1   3   4   0   
    */
    return 0;
}
```

### 2.2 Floyd-Warshall 算法（动态规划，稠密图首选）

#### 适用场景

- 稠密图（E≈V²），边权可负（不允许负权循环）。
- 优点：代码简洁（三重循环），可检测所有负权循环（对角线元素为负）。

#### 核心思想

- 动态规划子问题定义：`d[k][i][j]` 表示 “仅使用顶点 1~k 作为中间顶点” 时，i 到 j 的最短路径距离（视频中顶点编号 1~n）。
- 状态转移：
	- 若不使用 k 作为中间顶点：`d[k][i][j] = d[k-1][i][j]`
	- 若使用 k 作为中间顶点：`d[k][i][j] = min(d[k-1][i][k] + d[k-1][k][j], d[k-1][i][j])`
- 空间优化：可压缩为二维数组（`d[i][j]`），因`d[k]`仅依赖`d[k-1]`。
- 时间复杂度：**O(V³)**（三重循环，V 为顶点数）。
- 负权循环检测：最终矩阵中若`d[i][i] < 0`，则存在包含 i 的负权循环。

#### C++ 代码（邻接矩阵实现）

cpp

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

const int INF = INT_MAX / 2; // 避免加法溢出

// Floyd-Warshall算法（APSP，含负权循环检测）
vector<vector<int>> FloydWarshall(vector<vector<int>> adjMatrix) {
    int V = adjMatrix.size();

    // 初始化：d[0][i][j] = 邻接矩阵（无中间顶点）
    // 自身到自身距离为0（若初始为INF，需修正）
    for (int i = 0; i < V; ++i) {
        adjMatrix[i][i] = 0;
    }

    // 三重循环：k=中间顶点，i=起点，j=终点
    for (int k = 0; k < V; ++k) { // 视频中k从1~n，此处0~V-1
        for (int i = 0; i < V; ++i) {
            for (int j = 0; j < V; ++j) {
                // 松弛：若i→k和k→j可达，且i→k→j更短
                if (adjMatrix[i][k] != INF && adjMatrix[k][j] != INF) {
                    adjMatrix[i][j] = min(adjMatrix[i][j], adjMatrix[i][k] + adjMatrix[k][j]);
                }
            }
        }
    }

    // 检测负权循环（对角线元素为负）
    bool hasNegativeCycle = false;
    for (int i = 0; i < V; ++i) {
        if (adjMatrix[i][i] < 0) {
            hasNegativeCycle = true;
            break;
        }
    }
    if (hasNegativeCycle) {
        cout << "图中存在负权循环！" << endl;
        return vector<vector<int>>(); // 返回空矩阵表示无效
    }

    return adjMatrix;
}

// 示例：含负边的稠密图
int main() {
    int V = 4; // 顶点0-3
    // 邻接矩阵初始化：INF表示无直接边，0表示自身
    vector<vector<int>> adjMatrix = {
        {0, 2, 5, INF},
        {INF, 0, 1, 6},
        {INF, INF, 0, 3},
        {1, INF, INF, 0} // 3→0，权值1
    };

    vector<vector<int>> distMatrix = FloydWarshall(adjMatrix);
    if (distMatrix.empty()) return 1;

    // 输出所有对最短距离矩阵
    cout << "Floyd-Warshall结果矩阵：" << endl;
    for (int i = 0; i < V; ++i) {
        for (int j = 0; j < V; ++j) {
            if (distMatrix[i][j] == INF) cout << "INF ";
            else cout << distMatrix[i][j] << "   ";
        }
        cout << endl;
    }
    /* 输出结果（同2.1示例）：
    0   2   3   6   
    7   0   1   4   
    4   6   0   3   
    1   3   4   0   
    */
    return 0;
}
```

### 2.3 Johnson 算法（稀疏图首选，处理一般边权）

#### 适用场景

- 稀疏图（E 远小于 V²），边权可负（不允许负权循环）。
- 优点：时间复杂度低于 “Bellman-Ford V 次调用”，高于 “Dijkstra V 次调用”，但支持负边。

#### 核心思想

- 解决 “负边无法用 Dijkstra” 的问题：通过**重加权**将负边转化为非负边，再调用 Dijkstra V 次。
- 步骤：
	1. **添加虚拟源点**：新增顶点 s，向所有原有顶点添加一条权值为 0 的边（s→i，w=0）。
	2. **跑 Bellman-Ford**：以 s 为源点，计算 s 到所有顶点的最短距离`h[i]`（若检测到负权循环，算法终止）。
	3. **重加权边权**：对原有边 u→v，新权值`w'(u→v) = w(u→v) + h[u] - h[v]`（确保`w' ≥ 0`，视频中证明其非负）。
	4. **跑 Dijkstra V 次**：对每个原有顶点 i，以 i 为源点，用重加权后的边权跑 Dijkstra，得到`d'[i][j]`。
	5. **恢复原距离**：原距离`d[i][j] = d'[i][j] - h[i] + h[j]`（视频中 “望远镜” 性质证明）。
- 时间复杂度：**O(VE + V² log V)**（Bellman-Ford O (VE) + Dijkstra V 次 O (V log V + E)）。

#### C++ 代码（邻接表实现）

cpp

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <utility>
using namespace std;

typedef pair<int, int> PII;
const int INF = INT_MAX / 2;

struct Edge {
    int u, v, w;
    Edge(int u_, int v_, int w_) : u(u_), v(v_), w(w_) {}
};

// 步骤1：Bellman-Ford（计算h[i]，虚拟源点s）
bool BellmanFordForJohnson(const vector<Edge>& allEdges, int V, int s, vector<int>& h) {
    h.assign(V + 1, INF); // V+1：原有V个顶点+虚拟源点s（编号V）
    h[s] = 0;

    // 松弛V次（V+1个顶点，最长路径不超过V条边）
    for (int i = 0; i < V; ++i) {
        bool updated = false;
        for (const Edge& e : allEdges) {
            if (h[e.u] != INF && h[e.v] > h[e.u] + e.w) {
                h[e.v] = h[e.u] + e.w;
                updated = true;
            }
        }
        if (!updated) break;
    }

    // 检测负权循环
    for (const Edge& e : allEdges) {
        if (h[e.u] != INF && h[e.v] > h[e.u] + e.w) {
            return false;
        }
    }
    return true;
}

// 步骤4：单次Dijkstra（重加权边权）
void DijkstraJohnson(const vector<vector<PII>>& adj, int start, const vector<int>& h, vector<int>& distPrime) {
    int V = adj.size() - 1; // 排除虚拟源点
    distPrime.assign(V, INF);
    priority_queue<PII, vector<PII>, greater<PII>> pq;

    distPrime[start] = 0;
    pq.push({0, start});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        if (d > distPrime[u]) continue;

        for (auto [wPrime, v] : adj[u]) { // wPrime是重加权后的边权
            if (distPrime[v] > d + wPrime) {
                distPrime[v] = d + wPrime;
                pq.push({distPrime[v], v});
            }
        }
    }
}

// Johnson算法（APSP，处理一般边权）
vector<vector<int>> Johnson(const vector<vector<PII>>& originalAdj) {
    int V = originalAdj.size(); // 原有顶点数（0~V-1）
    int s = V; // 虚拟源点编号（V）

    // 步骤1：构建含虚拟源点的边列表
    vector<Edge> allEdges;
    // 1.1 原有边（u→v，w）
    for (int u = 0; u < V; ++u) {
        for (auto [w, v] : originalAdj[u]) {
            allEdges.emplace_back(u, v, w);
        }
    }
    // 1.2 虚拟源点到原有顶点的边（s→u，w=0）
    for (int u = 0; u < V; ++u) {
        allEdges.emplace_back(s, u, 0);
    }

    // 步骤2：跑Bellman-Ford计算h[i]
    vector<int> h;
    if (!BellmanFordForJohnson(allEdges, V, s, h)) {
        cout << "图中存在负权循环！" << endl;
        return vector<vector<int>>();
    }

    // 步骤3：构建重加权后的邻接表
    vector<vector<PII>> adjPrime(V + 1); // 含虚拟源点（未使用）
    for (int u = 0; u < V; ++u) {
        for (auto [w, v] : originalAdj[u]) {
            int wPrime = w + h[u] - h[v]; // 重加权公式
            adjPrime[u].push_back({wPrime, v});
        }
    }

    // 步骤4：跑Dijkstra V次，得到distPrime[i][j]
    vector<vector<int>> distMatrix(V, vector<int>(V, INF));
    for (int i = 0; i < V; ++i) {
        vector<int> distPrime;
        DijkstraJohnson(adjPrime, i, h, distPrime);

        // 步骤5：恢复原距离d[i][j] = distPrime[i][j] - h[i] + h[j]
        for (int j = 0; j < V; ++j) {
            if (distPrime[j] != INF) {
                distMatrix[i][j] = distPrime[j] - h[i] + h[j];
            }
        }
    }

    return distMatrix;
}

// 示例：含负边的稀疏图
int main() {
    int V = 4; // 顶点0-3
    vector<vector<PII>> originalAdj(V);
    // 原有边：0→1(2), 0→2(-1), 1→3(3), 2→3(1), 3→0(-5)（含负边）
    originalAdj[0].push_back({2, 1});
    originalAdj[0].push_back({-1, 2});
    originalAdj[1].push_back({3, 3});
    originalAdj[2].push_back({1, 3});
    originalAdj[3].push_back({-5, 0});

    vector<vector<int>> distMatrix = Johnson(originalAdj);
    if (distMatrix.empty()) return 1;

    // 输出所有对最短距离矩阵
    cout << "Johnson算法结果矩阵：" << endl;
    for (int i = 0; i < V; ++i) {
        for (int j = 0; j < V; ++j) {
            if (distMatrix[i][j] == INF) cout << "INF ";
            else cout << distMatrix[i][j] << "   ";
        }
        cout << endl;
    }
    /* 输出结果（存在负边但无负权循环）：
    0   2   -1  0   
    -2  0   -3  -2  
    -4  -2  0   -4  
    -5  -3  -6  0   
    */
    return 0;
}
```

## 三、传递闭包

#### 定义

- 传递闭包是一个布尔矩阵`T`，其中`T[i][j] = 1`表示 “存在从 i 到 j 的路径”，`T[i][j] = 0`表示 “不存在路径”（不关心路径长度和权值）。

#### 核心思想

- 方法 1：对每个顶点跑 BFS/DFS，记录可达性（时间复杂度 O (V (V+E))）。
- 方法 2：Floyd-Warshall 改运算符（视频提及）：
	- 子问题：`T[k][i][j]` 表示 “仅用 1~k 作为中间顶点时，i 是否可达 j”。
	- 状态转移：`T[k][i][j] = T[k-1][i][j] OR (T[k-1][i][k] AND T[k-1][k][j])`（OR 表示 “或可达”，AND 表示 “i→k 且 k→j”）。
- 时间复杂度：方法 1 O (V (V+E))，方法 2 O (V³)。

#### C++ 代码（Floyd-Warshall 改运算符）

cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 传递闭包（Floyd-Warshall改运算符）
vector<vector<bool>> TransitiveClosure(const vector<vector<bool>>& adjMatrix) {
    int V = adjMatrix.size();
    vector<vector<bool>> T = adjMatrix;

    // 初始化：自身到自身可达（T[i][i] = 1）
    for (int i = 0; i < V; ++i) {
        T[i][i] = true;
    }

    // 三重循环：k=中间顶点，i=起点，j=终点
    for (int k = 0; k < V; ++k) {
        for (int i = 0; i < V; ++i) {
            for (int j = 0; j < V; ++j) {
                T[i][j] = T[i][j] || (T[i][k] && T[k][j]);
            }
        }
    }

    return T;
}

// 示例：有向图
int main() {
    int V = 4; // 顶点0-3
    // 邻接矩阵：true表示有直接边，false表示无
    vector<vector<bool>> adjMatrix = {
        {false, true, true, false},
        {false, false, true, true},
        {false, false, false, true},
        {true, false, false, false}
    };

    vector<vector<bool>> T = TransitiveClosure(adjMatrix);

    // 输出传递闭包矩阵
    cout << "传递闭包矩阵（1=可达，0=不可达）：" << endl;
    for (int i = 0; i < V; ++i) {
        for (int j = 0; j < V; ++j) {
            cout << T[i][j] << " ";
        }
        cout << endl;
    }
    /* 输出结果（所有顶点互相可达）：
    1 1 1 1 
    1 1 1 1 
    1 1 1 1 
    1 1 1 1 
    */
    return 0;
}
```

## 四、关键总结（视频核心对比）

| 算法                       | 适用场景      | 时间复杂度   | 支持负边 | 支持负权循环 | 适用图类型  |
| -------------------------- | ------------- | ------------ | -------- | ------------ | ----------- |
| BFS（SSSP）                | 无权重图      | O(V+E)       | 否       | 无意义       | 稀疏 / 稠密 |
| Dijkstra（SSSP）           | 非负边权      | O(V log V+E) | 否       | 无意义       | 稀疏        |
| Bellman-Ford（SSSP）       | 一般边权      | O(VE)        | 是       | 检测（可达） | 稀疏        |
| 拓扑排序 + Bellman（SSSP） | DAG，一般边权 | O(V+E)       | 是       | 无（DAG）    | 稀疏 / 稠密 |
| Floyd-Warshall（APSP）     | 一般边权      | O(V³)        | 是       | 检测（所有） | 稠密        |
| Johnson（APSP）            | 一般边权      | O(VE+V²logV) | 是       | 检测（所有） | 稀疏        |
| 传递闭包（Floyd 改）       | 可达性判断    | O(V³)        | 无意义   | 无意义       | 稠密        |



# 并行算法（一）核心知识点总结

## 1. 课程背景与主题范围

- **并行算法**（）：针对**多核共享内存模型**（非分布式内存），核心是多处理器协同执行任务，因当前芯片均为多核处理器，该主题具有强实用性。
- **缓存感知算法**（）：针对内存缓存层次结构，解决 “传统算法假设单层次内存，与实际硬件不符” 的问题，需设计利用缓存特性的算法。

## 2. 并行计算模型（共享内存多核）

### 2.1 核心概念：逻辑并行性与调度器

- **逻辑并行性**：通过`spawn`（生成子任务，与父任务并行执行）和`sync`（等待所有`spawn`的子任务完成后再继续）描述任务间的并行关系，不直接指定物理处理器数量（视频强调 “仅描述逻辑并行，不涉及实际处理器分配”）。
- **实际并行性**：需通过**调度器**（运行时系统组件）将逻辑并行任务映射到物理处理器，视频后续重点讨论 “贪婪调度器”。
- **模型适用范围**：仅适用于多核共享内存机器，不适用于分布式内存机器（分布式需考虑处理器间通信成本，模型更复杂）。

## 3. 并行算法示例：斐波那契数列（指数时间递归）

视频以 “计算第 n 个斐波那契数” 为例演示并行逻辑，明确该算法为**指数时间复杂度**（“非常糟糕的算法”），仅用于讲解`spawn`和`sync`的使用，而非高效斐波那契实现（已知 logn 时间的矩阵快速幂等方法）。

### 3.1 视频中的并行伪代码

plaintext

```plaintext
function fib(n):
    if n ≤ 1:
        return n  // 基线条件：n=0返回0，n=1返回1
    // spawn：生成子任务执行fib(n-1)，与父任务并行
    x = spawn fib(n-1)
    // 父任务不等待子任务，直接执行fib(n-2)
    y = fib(n-2)
    // sync：等待所有spawn的子任务完成（确保x已计算）
    sync
    // 返回结果：子任务结果+父任务结果
    return x + y
```

### 3.2 C++ 实现（模拟`spawn`与`sync`）

视频无原生 C++ 代码，根据伪代码逻辑，使用 C++11 及以上的`std::thread`（模拟`spawn`）和`std::thread::join`（模拟`sync`）实现，严格对应视频逻辑：

cpp

```cpp
#include <iostream>
#include <thread>  // 用于模拟spawn（线程创建）和sync（线程等待）

// 并行斐波那契函数（完全对应视频伪代码）
int fib(int n) {
    // 基线条件：n≤1时直接返回，无并行逻辑
    if (n <= 1) {
        return n;
    }

    int x, y;  // x存储spawn子任务结果，y存储父任务结果

    // 1. spawn fib(n-1)：创建子线程执行fib(n-1)，与父线程并行
    std::thread fib_thread([&x, n]() {
        x = fib(n - 1);  // 子线程计算fib(n-1)，结果存入x
    });

    // 2. 父线程并行执行fib(n-2)：不等待子线程，直接计算
    y = fib(n - 2);

    // 3. sync：等待子线程完成（join()对应sync，确保x已赋值）
    fib_thread.join();

    // 4. 返回最终结果：子任务结果x + 父任务结果y
    return x + y;
}

// 测试代码（按视频示例逻辑补充，验证并行逻辑正确性）
int main() {
    int test_nums[] = {0, 1, 2, 3, 4, 5};  // 测试用例
    for (int n : test_nums) {
        std::cout << "fib(" << n << ") = " << fib(n) << std::endl;
    }
    // 输出结果：fib(0)=0, fib(1)=1, fib(2)=1, fib(3)=2, fib(4)=3, fib(5)=5
    return 0;
}
```

代码说明：

- `std::thread fib_thread(...)`：完全模拟`spawn`，子线程与父线程同时执行（父线程执行`fib(n-2)`，子线程执行`fib(n-1)`）。
- `fib_thread.join()`：完全模拟`sync`，确保子线程计算完成后再执行`x+y`，避免 “使用未初始化的 x”（视频强调 “sync 前必须等子任务完成，否则结果错误”）。

## 4. 并行计算核心性能指标

视频定义三个关键指标，用于量化并行算法的效率和潜力，所有指标基于 “任务为单位时间” 的假设（简化分析）。

| 指标符号 | 名称                 | 定义与含义                                                   | 视频示例（fib (4)） |
| -------- | -------------------- | ------------------------------------------------------------ | ------------------- |
| T₁       | 单处理器时间（工作） | 单处理器串行执行的总时间，即 “总工作量”（Work），反映算法的计算总量。 | 17（所有任务总数）  |
| T_∞      | 关键路径长度         | 并行任务依赖图（DAG）中的最长路径长度，即使无限处理器也需至少 T_∞时间（依赖无法并行）。 | 8（最长依赖路径）   |
| T_P      | P 个处理器的运行时间 | 使用 P 个处理器时的实际运行时间，受调度算法影响，需满足下界约束。 | -                   |

## 5. T_P 的两个核心下界

视频证明：无论使用何种调度算法，P 个处理器的运行时间 T_P 必须满足以下两个下界（即 T_P 无法突破这些值）。

### 5.1 下界 1：T_P ≥ T₁ / P

- **推导逻辑**：P 个处理器每单位时间最多完成 P 单位工作（每个处理器 1 单位），总工作量为 T₁，因此最少需要`T₁/P`时间（若 T_P < T₁/P，则总工作量 < P*T_P < T₁，矛盾）。
- **视频示例**：fib (4) 中 T₁=17，若 P=2，则 T_P ≥ 17/2 = 8.5（即最少需要 9 个单位时间）。

### 5.2 下界 2：T_P ≥ T_∞

- **推导逻辑**：即使有无限多处理器（P→∞），也必须按关键路径的依赖顺序执行（前一步未完成，后一步无法开始），因此最少需要 T_∞时间。
- **视频示例**：fib (4) 中 T_∞=8，即使 P=100（远超并行性），T_P ≥ 8（无法更快）。

## 6. 并行性（Parallelism）定义

### 6.1 核心公式

视频定义 “并行性” 为算法的**固有并行能力**，公式如下：

plaintext

```plaintext
并行性（记为Π）= T₁ / T_∞
```

- **含义**：关键路径每一步平均可并行执行的任务数量，反映算法 “能有效利用的处理器数量上限”。
- **视频示例**：fib (4) 的 Π=17/8≈2.125，意味着：
	- 若 P≤2：增加处理器可线性提升速度（如 P=2 时，T_P≈8.5）。
	- 若 P>3：多余处理器闲置（如 P=4 时，T_P 仍≈8，因并行性仅≈2.125）。

### 6.2 并行性的实际意义

- **处理器数量与并行性匹配**：若 P ≤ Π，处理器可被充分利用，T_P≈T₁/P（线性加速）。
- **处理器数量超过并行性**：若 P > Π，多余处理器无法提升速度，T_P≈T_∞（处理器浪费）。

## 7. 贪婪调度器（Greedy Scheduler）

视频重点讨论 “贪婪调度器”（运行时系统常用），其核心是 “尽可能早地执行可运行任务”，无需预测未来任务。

### 7.1 调度规则

1. **任务可执行前提**：仅当任务的所有前驱任务（依赖）都完成时，任务才可执行。
2. **完整步骤（Full Step）**：若可执行任务数 ≥ P，选择任意 P 个任务执行（视频强调 “非确定性，执行任何 P 个均可”）。
3. **不完整步骤（Incomplete Step）**：若可执行任务数 <P，执行所有可执行任务（视频表述 “把它们全执行”）。

### 7.2 贪婪调度的性能定理

- **定理内容**：对于 P 个处理器，贪婪调度的运行时间满足：

	plaintext

	```plaintext
	T_P ≤ (T₁ / P) + T_∞
	```

- **定理意义**：贪婪调度的性能在 “2 倍最优” 内（最优 T_P ≥ max (T₁/P, T_∞)，而 (T₁/P)+T_∞ ≤ 2*max (T₁/P, T_∞)）。

- **证明思路（视频推导）**：

	1. 完整步骤数 ≤ T₁/P（每个完整步骤完成 P 单位工作，总工作 T₁）。
	2. 不完整步骤数 ≤ T_∞（每个不完整步骤会使剩余关键路径长度减少 1，初始长度为 T_∞）。
	3. 总运行时间 T_P = 完整步骤数 + 不完整步骤数 ≤ T₁/P + T_∞。

## 8. 实际案例：国际象棋程序的优化教训

视频提及作者团队开发国际象棋程序（如 Star Socrates）的案例，说明 “工作” 与 “关键路径” 需平衡，仅看单处理器性能无法预测多处理器表现。

### 8.1 案例核心数据

| 程序版本 | 工作 T₁ | 关键路径 T_∞ | 并行性 Π=T₁/T_∞ | 32 处理器时间 T₃₂ | 512 处理器时间 T₅₁₂（预测） |
| -------- | ------- | ------------ | --------------- | ----------------- | --------------------------- |
| 原始版本 | 2048    | 1            | 2048            | 2048/32 + 1 = 65  | 2048/512 + 1 = 5            |
| 优化版本 | 1024    | 8            | 128             | 1024/32 + 8 = 40  | 1024/512 + 8 = 10           |

### 8.2 关键教训

- **32 处理器场景**：优化版本更快（T₃₂=40 < 65），因 P=32 ≤ Π=128，减少工作 T₁的收益大于关键路径 T_∞增加的损失。
- **512 处理器场景**：优化版本更慢（T₅₁₂=10 > 5），因 P=512 > Π=128，关键路径 T_∞=8 成为瓶颈，多余处理器闲置，工作减少的收益消失。
- **结论**：并行算法设计需平衡 “减少工作” 和 “控制关键路径长度”，并行性 Π 是 “处理器数量上限” 的核心衡量标准。



# 麻省理工《算法导论》第 21 集：并行算法（二）知识点总结

## 1. 并行算法性能分析核心指标

视频中明确并行算法的性能通过以下三个指标衡量，用于预测任意处理器数量下的性能：

- **功（Work, T₁）**：算法在**单处理器**上的总运行时间（即串行时间），反映算法的总计算量。理想并行算法的 T₁应与最优串行算法一致。
- **临界路径长度（Critical Path Length, T∞）**：算法在**无限处理器**上的最小运行时间，反映算法的并行瓶颈（最长依赖链的时间）。
- **并行度（Parallelism）**：功与临界路径长度的比值（T₁/T∞），表示算法可有效利用的最大处理器数量。若处理器数超过并行度，性能提升会停滞。

## 2. 并行矩阵乘法（分治法）

视频以`n×n`矩阵乘法（`C = A × B`）为案例，假设`n是2的整数次幂`（简化分块逻辑），分两个版本实现：普通分治版（含临时矩阵）和优化空间的 Moadd 版（无临时矩阵）。

### 2.1 依赖：并行矩阵加法

矩阵乘法需并行矩阵加法（`C = C + T`），加法同样采用分治法，将矩阵分块后并行计算子矩阵加法。

#### 算法思路

1. 基本情况：若`n=1`，直接计算`C[0][0] += T[0][0]`；
2. 分块：将`C、T`各分为 4 个`(n/2)×(n/2)`的子矩阵（`C₁₁, C₁₂, C₂₁, C₂₂`；`T₁₁, T₁₂, T₂₁, T₂₂`）；
3. 并行产卵：为 4 个子矩阵加法任务创建并行任务；
4. 同步：等待所有子任务完成，确保加法无依赖冲突。

#### C++ 代码（并行矩阵加法）

cpp

```cpp
#include <vector>
#include <future>
using namespace std;

// 并行矩阵加法：C = C + T（子矩阵范围由行/列起始索引定义）
// 参数：C/T：目标/源矩阵；rowStart/rowEnd：行范围；colStart/colEnd：列范围
void parallelMatrixAdd(vector<vector<int>>& C, const vector<vector<int>>& T,
                       int rowStart, int rowEnd, int colStart, int colEnd) {
    int n = rowEnd - rowStart + 1;

    // 基本情况：n=1，直接加法
    if (n == 1) {
        C[rowStart][colStart] += T[rowStart][colStart];
        return;
    }

    // 分块：将矩阵分为4个(n/2)×(n/2)子矩阵
    int midRow = (rowStart + rowEnd) / 2;
    int midCol = (colStart + colEnd) / 2;

    // 并行产卵4个子矩阵加法任务
    auto task1 = async(launch::async, parallelMatrixAdd, ref(C), ref(T),
                       rowStart, midRow, colStart, midCol);   // C₁₁ += T₁₁
    auto task2 = async(launch::async, parallelMatrixAdd, ref(C), ref(T),
                       rowStart, midRow, midCol+1, colEnd);   // C₁₂ += T₁₂
    auto task3 = async(launch::async, parallelMatrixAdd, ref(C), ref(T),
                       midRow+1, rowEnd, colStart, midCol);   // C₂₁ += T₂₁
    auto task4 = async(launch::async, parallelMatrixAdd, ref(C), ref(T),
                       midRow+1, rowEnd, midCol+1, colEnd);   // C₂₂ += T₂₂

    // 同步：等待所有子任务完成
    task1.get();
    task2.get();
    task3.get();
    task4.get();
}

// 矩阵初始化（将矩阵所有元素设为0，用于Moadd版乘法）
void initMatrix(vector<vector<int>>& mat) {
    int n = mat.size();
    for (int i = 0; i < n; ++i) {
        fill(mat[i].begin(), mat[i].end(), 0);
    }
}
```

#### 性能分析

- **功（T₁）**：`θ(n²)`（与串行加法一致，需遍历所有`n²`个元素）；
- **临界路径长度（T∞）**：`θ(logn)`（每次分块后 4 个子任务并行，递归深度为`log₂n`）；
- **并行度**：`T₁/T∞ = θ(n²/logn)`（可有效利用大量处理器）。

### 2.2 普通分治版并行矩阵乘法（含临时矩阵 T）

#### 算法思路

1. 基本情况：若`n=1`，直接计算`C[0][0] = A[0][0] × B[0][0]`；
2. 分块：将`A、B、C、T`（临时矩阵）各分为 4 个`(n/2)×(n/2)`子矩阵；
3. 并行乘法：产卵 8 个并行任务，计算 8 次子矩阵乘法（对应`C`的 4 个分块的加法项），结果存入`T`；
4. 同步：等待所有乘法任务完成；
5. 并行加法：调用`parallelMatrixAdd`，将`T`的结果累加到`C`。

#### C++ 代码（普通分治版）

cpp

```cpp
// 普通分治版并行矩阵乘法：C = A × B（使用临时矩阵T）
void parallelMatrixMultiply(vector<vector<int>>& C, const vector<vector<int>>& A,
                            const vector<vector<int>>& B, int rowStartC, int rowEndC,
                            int colStartC, int colEndC, int rowStartA, int colEndA,
                            int rowStartB, int colEndB) {
    int n = rowEndC - rowStartC + 1;

    // 基本情况：n=1，直接乘法
    if (n == 1) {
        C[rowStartC][colStartC] = A[rowStartA][colStartA] * B[rowStartB][colStartB];
        return;
    }

    // 分块：计算各子矩阵的行/列边界
    int midRowC = (rowStartC + rowEndC) / 2;
    int midColC = (colStartC + colEndC) / 2;
    int midRowA = (rowStartA + (rowStartA + colEndA - rowStartA)) / 2;  // A的行范围与C一致
    int midColA = (rowStartA + colEndA - rowStartA) / 2;                // A的列中点（分块依据）
    int midRowB = (rowStartB + (rowStartB + colEndB - rowStartB)) / 2;  // B的行中点（分块依据）
    int midColB = (rowStartB + colEndB - rowStartB) / 2;                // B的列范围与C一致

    // 创建临时矩阵T（大小与C相同），存储乘法中间结果
    vector<vector<int>> T(n, vector<int>(n, 0));
    // 定义T的子矩阵行/列范围（相对于T的局部索引，映射到全局索引）
    auto getTGlobal = [&](int localRow, int localCol) {
        return make_pair(rowStartC + localRow, colStartC + localCol);
    };

    // 步骤1：并行产卵8个子矩阵乘法任务，结果存入T
    // T₁₁ = A₁₁×B₁₁
    auto t11 = async(launch::async, parallelMatrixMultiply, ref(T), ref(A), ref(B),
                     rowStartC, midRowC, colStartC, midColC,
                     rowStartA, midRowA, rowStartB, midRowB);
    // T₁₁ += A₁₂×B₂₁（后续加法统一处理，此处先存乘法结果）
    auto t11_2 = async(launch::async, parallelMatrixMultiply, ref(T), ref(A), ref(B),
                       rowStartC, midRowC, colStartC, midColC,
                       rowStartA, midRowA, midRowB+1, colEndB);
    // T₁₂ = A₁₁×B₁₂
    auto t12 = async(launch::async, parallelMatrixMultiply, ref(T), ref(A), ref(B),
                     rowStartC, midRowC, midColC+1, colEndC,
                     rowStartA, midRowA, rowStartB, midRowB);
    // T₁₂ += A₁₂×B₂₂
    auto t12_2 = async(launch::async, parallelMatrixMultiply, ref(T), ref(A), ref(B),
                       rowStartC, midRowC, midColC+1, colEndC,
                       rowStartA, midRowA, midRowB+1, colEndB);
    // T₂₁ = A₂₁×B₁₁
    auto t21 = async(launch::async, parallelMatrixMultiply, ref(T), ref(A), ref(B),
                     midRowC+1, rowEndC, colStartC, midColC,
                     midRowA+1, rowEndC, rowStartB, midRowB);
    // T₂₁ += A₂₂×B₂₁
    auto t21_2 = async(launch::async, parallelMatrixMultiply, ref(T), ref(A), ref(B),
                       midRowC+1, rowEndC, colStartC, midColC,
                       midRowA+1, rowEndC, midRowB+1, colEndB);
    // T₂₂ = A₂₁×B₁₂
    auto t22 = async(launch::async, parallelMatrixMultiply, ref(T), ref(A), ref(B),
                     midRowC+1, rowEndC, midColC+1, colEndC,
                     midRowA+1, rowEndC, rowStartB, midRowB);
    // T₂₂ += A₂₂×B₂₂
    auto t22_2 = async(launch::async, parallelMatrixMultiply, ref(T), ref(A), ref(B),
                       midRowC+1, rowEndC, midColC+1, colEndC,
                       midRowA+1, rowEndC, midRowB+1, colEndB);

    // 同步：等待所有乘法任务完成
    t11.get(); t11_2.get(); t12.get(); t12_2.get();
    t21.get(); t21_2.get(); t22.get(); t22_2.get();

    // 步骤2：并行加法，将T的结果累加到C
    parallelMatrixAdd(C, T, rowStartC, rowEndC, colStartC, colEndC);
}

// 对外接口：简化调用（假设矩阵为n×n，n是2的幂）
void matrixMultiply(vector<vector<int>>& C, const vector<vector<int>>& A, const vector<vector<int>>& B) {
    int n = A.size();
    C.resize(n, vector<int>(n, 0));
    parallelMatrixMultiply(C, A, B, 0, n-1, 0, n-1, 0, n-1, 0, n-1);
}
```

#### 示例（n=2 矩阵乘法）

设：

plaintext

```plaintext
A = [[1,2],  B = [[3,4],
     [3,4]]       [5,6]]
```

1. 分块为 4 个 1×1 子矩阵：`A₁₁=1, A₁₂=2, A₂₁=3, A₂₂=4`；`B₁₁=3, B₁₂=4, B₂₁=5, B₂₂=6`；
2. 8 次并行乘法：`A₁₁×B₁₁=3, A₁₂×B₂₁=10, A₁₁×B₁₂=4, A₁₂×B₂₂=12, A₂₁×B₁₁=9, A₂₂×B₂₁=20, A₂₁×B₁₂=12, A₂₂×B₂₂=24`；
3. 并行加法：`C₁₁=3+10=13, C₁₂=4+12=16, C₂₁=9+20=29, C₂₂=12+24=36`；
4. 结果：`C = [[13,16],[29,36]]`（与串行计算一致）。

#### 性能分析

- **功（T₁）**：`θ(n³)`（与串行矩阵乘法一致，8 次`(n/2)³`乘法 + 1 次`n²`加法，递归解为`θ(n³)`）；
- **临界路径长度（T∞）**：`θ((logn)²)`（乘法递归深度`logn`，每次乘法后需`logn`深度的加法，总深度`logn × logn`）；
- **并行度**：`T₁/T∞ = θ(n³/(logn)²)`（并行度极高，适合超大规模处理器）。

### 2.3 优化空间的 Moadd 版并行矩阵乘法（无临时矩阵 T）

普通版的临时矩阵`T`会带来空间开销，Moadd 版通过 “直接累加” 去掉`T`，但需牺牲部分并行度（仍足够高）。

#### 算法思路

1. 初始化：将`C`所有元素设为 0；
2. 基本情况：同普通版；
3. 分块：同普通版；
4. 第一组并行乘法：产卵 4 个任务，计算`C`的 4 个分块的第一个加法项（如`C₁₁ += A₁₁×B₁₁`）；
5. 同步：等待第一组任务完成；
6. 第二组并行乘法：产卵 4 个任务，计算`C`的 4 个分块的第二个加法项（如`C₁₁ += A₁₂×B₂₁`）；
7. 同步：等待第二组任务完成（无需临时矩阵，直接在`C`上累加）。

#### C++ 代码（Moadd 版）

cpp

```cpp
// Moadd版并行矩阵乘法：C += A × B（无临时矩阵，直接累加）
void parallelMatrixMoadd(vector<vector<int>>& C, const vector<vector<int>>& A,
                         const vector<vector<int>>& B, int rowStartC, int rowEndC,
                         int colStartC, int colEndC, int rowStartA, int colEndA,
                         int rowStartB, int colEndB) {
    int n = rowEndC - rowStartC + 1;

    // 基本情况：n=1，直接累加乘法结果
    if (n == 1) {
        C[rowStartC][colStartC] += A[rowStartA][colStartA] * B[rowStartB][colStartB];
        return;
    }

    // 分块：计算各子矩阵的行/列边界（同普通版）
    int midRowC = (rowStartC + rowEndC) / 2;
    int midColC = (colStartC + colEndC) / 2;
    int midRowA = (rowStartA + (rowStartA + colEndA - rowStartA)) / 2;
    int midColA = (rowStartA + colEndA - rowStartA) / 2;
    int midRowB = (rowStartB + (rowStartB + colEndB - rowStartB)) / 2;
    int midColB = (rowStartB + colEndB - rowStartB) / 2;

    // 步骤1：第一组并行乘法（累加第一个加法项）
    auto task1 = async(launch::async, parallelMatrixMoadd, ref(C), ref(A), ref(B),
                       rowStartC, midRowC, colStartC, midColC,  // C₁₁ += A₁₁×B₁₁
                       rowStartA, midRowA, rowStartB, midRowB);
    auto task2 = async(launch::async, parallelMatrixMoadd, ref(C), ref(A), ref(B),
                       rowStartC, midRowC, midColC+1, colEndC,  // C₁₂ += A₁₁×B₁₂
                       rowStartA, midRowA, rowStartB, midRowB);
    auto task3 = async(launch::async, parallelMatrixMoadd, ref(C), ref(A), ref(B),
                       midRowC+1, rowEndC, colStartC, midColC,  // C₂₁ += A₂₁×B₁₁
                       midRowA+1, rowEndC, rowStartB, midRowB);
    auto task4 = async(launch::async, parallelMatrixMoadd, ref(C), ref(A), ref(B),
                       midRowC+1, rowEndC, midColC+1, colEndC,  // C₂₂ += A₂₁×B₁₂
                       midRowA+1, rowEndC, rowStartB, midRowB);

    // 同步：等待第一组完成
    task1.get(); task2.get(); task3.get(); task4.get();

    // 步骤2：第二组并行乘法（累加第二个加法项）
    auto task5 = async(launch::async, parallelMatrixMoadd, ref(C), ref(A), ref(B),
                       rowStartC, midRowC, colStartC, midColC,  // C₁₁ += A₁₂×B₂₁
                       rowStartA, midRowA, midRowB+1, colEndB);
    auto task6 = async(launch::async, parallelMatrixMoadd, ref(C), ref(A), ref(B),
                       rowStartC, midRowC, midColC+1, colEndC,  // C₁₂ += A₁₂×B₂₂
                       rowStartA, midRowA, midRowB+1, colEndB);
    auto task7 = async(launch::async, parallelMatrixMoadd, ref(C), ref(A), ref(B),
                       midRowC+1, rowEndC, colStartC, midColC,  // C₂₁ += A₂₂×B₂₁
                       midRowA+1, rowEndC, midRowB+1, colEndB);
    auto task8 = async(launch::async, parallelMatrixMoadd, ref(C), ref(A), ref(B),
                       midRowC+1, rowEndC, midColC+1, colEndC,  // C₂₂ += A₂₂×B₂₂
                       midRowA+1, rowEndC, midRowB+1, colEndB);

    // 同步：等待第二组完成
    task5.get(); task6.get(); task7.get(); task8.get();
}

// 对外接口：Moadd版入口（需先初始化C为0）
void matrixMoadd(vector<vector<int>>& C, const vector<vector<int>>& A, const vector<vector<int>>& B) {
    int n = A.size();
    C.resize(n, vector<int>(n, 0));
    initMatrix(C);  // 确保C初始为0矩阵
    parallelMatrixMoadd(C, A, B, 0, n-1, 0, n-1, 0, n-1, 0, n-1);
}
```

#### 性能分析

- **功（T₁）**：`θ(n³)`（与普通版一致，无额外计算量）；
- **临界路径长度（T∞）**：`θ(n)`（两组乘法串行执行，每组递归深度`logn`，但分块后子问题依赖导致总深度`n`）；
- **并行度**：`T₁/T∞ = θ(n²)`（并行度仍很高，适合大规模处理器，且节省`O(n²)`空间）。

## 3. 并行合并排序

视频指出普通并行合并排序的瓶颈是**串行合并步骤**，需先实现并行合并，再优化合并排序。

### 3.1 普通并行合并排序的瓶颈

普通合并排序的并行化思路：

1. 并行递归排序左半数组（`A[0..mid]`）和右半数组（`A[mid+1..n-1]`）；
2. **串行合并**左右两个有序子数组。

瓶颈：合并步骤是串行的（`T₁=θ(n)`，`T∞=θ(n)`），导致整体并行度极低（`θ(logn)`），无法利用大量处理器。

### 3.2 并行合并算法（突破瓶颈）

#### 算法思路

合并两个有序数组`A`（长度`L`）和`B`（长度`M`）为有序数组`C`（长度`L+M`）：

1. 基本情况：若`L+M ≤ 32`（小数组），采用串行合并（避免并行开销）；
2. 选择大数组：假设`L ≥ M`（否则交换`A`和`B`），取`A`的中间元素`A[midA]`；
3. 二分查找：在`B`中找到位置`j`，使得`B[j-1] ≤ A[midA] < B[j]`（确保子数组有序）；
4. 并行合并：
	- 产卵任务 1：合并`A[0..midA]`和`B[0..j-1]`，结果存入`C[0..midA+j]`；
	- 产卵任务 2：合并`A[midA+1..L-1]`和`B[j..M-1]`，结果存入`C[midA+j+1..L+M-1]`；
5. 同步：等待两个任务完成。

#### C++ 代码（并行合并）

cpp

```cpp
#include <algorithm>
// 串行合并（小数组使用，避免并行开销）
void serialMerge(const vector<int>& A, const vector<int>& B, vector<int>& C) {
    int i = 0, j = 0, k = 0;
    int L = A.size(), M = B.size();
    while (i < L && j < M) {
        if (A[i] <= B[j]) C[k++] = A[i++];
        else C[k++] = B[j++];
    }
    while (i < L) C[k++] = A[i++];
    while (j < M) C[k++] = B[j++];
}

// 二分查找：在有序数组B中找到第一个大于x的元素索引
int binarySearch(const vector<int>& B, int x) {
    int low = 0, high = B.size();
    while (low < high) {
        int mid = (low + high) / 2;
        if (B[mid] > x) high = mid;
        else low = mid + 1;
    }
    return low;
}

// 并行合并：合并有序数组A和B，结果存入C
void parallelMerge(const vector<int>& A, const vector<int>& B, vector<int>& C) {
    int L = A.size(), M = B.size();
    int n = L + M;
    C.resize(n);

    // 基本情况：小数组串行合并（阈值32，可调整）
    if (n <= 32) {
        serialMerge(A, B, C);
        return;
    }

    // 确保A是较大数组（否则交换A和B）
    if (L < M) {
        parallelMerge(B, A, C);
        return;
    }

    // 步骤1：取A的中间元素
    int midA = L / 2;
    int x = A[midA];

    // 步骤2：二分查找x在B中的位置j
    int j = binarySearch(B, x);

    // 步骤3：拆分A、B、C为子数组
    vector<int> A1(A.begin(), A.begin() + midA + 1);    // A[0..midA]
    vector<int> A2(A.begin() + midA + 1, A.end());      // A[midA+1..L-1]
    vector<int> B1(B.begin(), B.begin() + j);           // B[0..j-1]
    vector<int> B2(B.begin() + j, B.end());             // B[j..M-1]
    vector<int> C1, C2;                                 // 子合并结果

    // 步骤4：并行产卵两个合并任务
    auto task1 = async(launch::async, parallelMerge, ref(A1), ref(B1), ref(C1));  // C1 = merge(A1,B1)
    auto task2 = async(launch::async, parallelMerge, ref(A2), ref(B2), ref(C2));  // C2 = merge(A2,B2)

    // 同步：等待任务完成
    task1.get();
    task2.get();

    // 步骤5：拼接C1和C2为最终结果C
    copy(C1.begin(), C1.end(), C.begin());
    copy(C2.begin(), C2.end(), C.begin() + C1.size());
}
```

#### 示例（并行合并）

设`A = [1,3,5,7]`（L=4），`B = [2,4,6]`（M=3）：

1. `A`是较大数组，`midA=2`，`A[midA]=5`；
2. 二分查找`5`在`B`中的位置`j=2`（`B[1]=4 ≤5 < B[2]=6`）；
3. 并行合并：
	- 任务 1：合并`A1=[1,3,5]`和`B1=[2,4]` → `C1=[1,2,3,4,5]`；
	- 任务 2：合并`A2=[7]`和`B2=[6]` → `C2=[6,7]`；
4. 拼接`C1`和`C2` → `C=[1,2,3,4,5,6,7]`。

#### 性能分析

- **功（T₁）**：`θ(n)`（与串行合并一致，二分查找`θ(logM)`可忽略）；
- **临界路径长度（T∞）**：`θ((logn)²)`（每次合并分两个子问题，子问题最小规模`n/4`，递归深度`log₄n`，每次递归含`θ(logn)`的二分查找，总深度`logn × logn`）；
- **并行度**：`T₁/T∞ = θ(n/(logn)²)`（并行度较高，突破串行瓶颈）。

### 3.3 完整并行合并排序

#### 算法思路

1. 基本情况：若`n ≤ 32`（小数组），采用串行排序（避免并行开销）；
2. 分治：计算中间索引`mid = n/2`；
3. 并行排序：产卵两个任务，分别排序左半数组（`A[0..mid]`）和右半数组（`A[mid+1..n-1]`）；
4. 同步：等待排序完成；
5. 并行合并：调用`parallelMerge`，合并左右两个有序子数组，结果存入`A`。

#### C++ 代码（并行合并排序）

cpp

```cpp
// 并行合并排序（原地排序，内部使用并行合并）
void parallelMergeSort(vector<int>& A) {
    int n = A.size();

    // 基本情况：小数组串行排序（阈值32）
    if (n <= 32) {
        sort(A.begin(), A.end());
        return;
    }

    // 步骤1：分治，拆分左右子数组
    int mid = n / 2;
    vector<int> left(A.begin(), A.begin() + mid);
    vector<int> right(A.begin() + mid, A.end());

    // 步骤2：并行产卵两个排序任务
    auto taskLeft = async(launch::async, parallelMergeSort, ref(left));
    auto taskRight = async(launch::async, parallelMergeSort, ref(right));

    // 同步：等待左右子数组排序完成
    taskLeft.get();
    taskRight.get();

    // 步骤3：并行合并左右有序子数组，结果存入A
    parallelMerge(left, right, A);
}
```

#### 示例（并行合并排序）

设`A = [5,3,8,1,2,7,6,4]`：

1. 分治为`left=[5,3,8,1]`和`right=[2,7,6,4]`；
2. 并行排序：`left`排序为`[1,3,5,8]`，`right`排序为`[2,4,6,7]`；
3. 并行合并：合并`[1,3,5,8]`和`[2,4,6,7]` → `[1,2,3,4,5,6,7,8]`。

#### 性能分析

- **功（T₁）**：`θ(nlogn)`（与串行合并排序一致，排序递归深度`logn`，每次合并`θ(n)`）；
- **临界路径长度（T∞）**：`θ((logn)²)`（排序递归深度`logn`，每次排序后需`θ((logn)²)`的并行合并，总深度`(logn)²`）；
- **并行度**：`T₁/T∞ = θ(nlogn/(logn)²) = θ(n/logn)`（并行度较高，适合中大规模处理器）。

## 4. 核心结论

1. 并行算法的性能核心是 “功” 与 “临界路径长度” 的平衡，需确保 T₁与最优串行算法一致，同时最小化 T∞；
2. 矩阵乘法的并行度极高（普通版`θ(n³/(logn)²)`，Moadd 版`θ(n²)`），适合超大规模并行计算；
3. 合并排序的并行瓶颈在合并步骤，并行合并可将并行度提升至`θ(n/logn)`，突破串行限制；
4. 空间与并行度存在权衡（如 Moadd 版矩阵乘法用空间换并行度），需根据硬件资源选择实现。

