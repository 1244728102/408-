# 整数与补码之间的转换知识点总结

（基于视频 “25. 整数与补码之间的转换_哔哩哔哩_bilibili” 内容，仅包含视频内提及的概念、规则及示例）

### 一、补码的核心前提：符号位规则

视频明确：**二进制补码的最左位为符号位**，用于判断原整数的正负，是转换的基础：

- 符号位为 `0`：原整数是**正数或零**
- 符号位为 `1`：原整数是**负数**

### 二、整数 → 二进制补码（存储逻辑）

视频核心逻辑：将整数存储为二进制补码时，需根据整数正负分情况处理，且需指定 “存储单元位数”（如 4 位、8 位，不足位数时左补符号位对应的数字）。

#### 1. 前提理解：负数的表述方式

视频强调：为避免混淆，将 “-X” 理解为 “X（正整数）的负数”，而非直接处理 “-X” 整体（如 “-7” 理解为 “7 的负数”，先处理正整数 7，再转换为其负数的补码）。

#### 2. 分情况转换步骤

| 整数类型         | 转换步骤                                                     | 视频示例（存储单元位数）                                     |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 正数或零         | 1. 将整数转为二进制原码；2. 按存储单元位数左补`0`（补至指定位数），结果即为补码。 | 7（4 位）：1. 7→二进制`111`；2. 左补 1 个`0`→`0111`（补码）  |
| 负数（X 的负数） | 1. 取 X（正整数）的二进制原码；2. 按存储单元位数左补`0`（补至指定位数）；3. 对补零后的二进制数 “按位取反”（`0`变`1`，`1`变`0`）；4. 取反结果加`1`，最终即为 “-X” 的补码。 | -7（4 位）：1. 7→`111`；2. 补零→`0111`；3. 取反→`1000`；4. 加 1→`1001`（补码） |

#### 3. 视频经典示例（8 位存储单元）

##### 示例 1：正整数 28 转 8 位补码（视频 3.12 案例）

- 步骤 1：28 的二进制原码→`11100`（5 位）
- 步骤 2：8 位存储需左补 3 个`0`→`00011100`
- 结果：28 的 8 位补码为 `00011100`

##### 示例 2：负整数 - 28 转 8 位补码（视频 3.13 案例）

- 步骤 1：取 28 的二进制原码→`11100`
- 步骤 2：8 位补零→`00011100`
- 步骤 3：按位取反→`11100011`
- 步骤 4：加 1→`11100100`
- 结果：-28 的 8 位补码为 `11100100`

### 三、二进制补码 → 整数（还原逻辑）

视频核心逻辑：根据补码的符号位（最左位）分情况处理，还原为原整数。

#### 分情况还原步骤

| 补码符号位               | 还原步骤                                                     | 视频示例（存储单元位数）                                     |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 符号位为`0`（正数 / 零） | 1. 直接将补码转为十进制数；2. 结果即为原整数（无需加符号）。 | 补码`0111`（4 位）：1. `0111`→十进制 7；2. 原整数 = 7        |
| 符号位为`1`（负数）      | 1. 对补码 “按位取反”；2. 取反结果加`1`，得到 “原负数绝对值的二进制”；3. 将步骤 2 结果转为十进制；4. 加负号，即为原整数。 | 补码`1001`（4 位）：1. 取反→`0110`；2. 加 1→`0111`；3. `0111`→7；4. 原整数 =-7 |

#### 视频经典示例（8 位存储单元）

##### 示例 1：补码`00011101`还原为整数（视频 3.14 案例）

- 步骤 1：符号位为`0`（正数），直接转十进制：`00011101` = 1×16 + 1×8 + 1×4 + 1×1 = 29？（注：视频口误 “13”，实际计算应为 29，此处按视频逻辑修正：若补码为`00001101`则为 13，推测视频笔误，核心逻辑为 “符号位 0 直接转十进制”）
- 结果：原整数 = 29（或按视频口误示例，补码`00001101`→13）

##### 示例 2：补码`11100110`还原为整数（视频案例）

- 步骤 1：符号位为`1`（负数），对补码取反→`00011001`
- 步骤 2：取反结果加 1→`00011010`
- 步骤 3：`00011010`转十进制 = 16 + 8 + 2 = 26
- 步骤 4：加负号→原整数 =-26

### 四、代码实现（与视频转换逻辑完全一致）

视频未直接给出代码，但根据视频规则，用 Python 实现 “整数转 n 位补码” 和 “n 位补码转整数”，测试案例均来自视频。

#### 1. 整数转 n 位二进制补码

python







```python
def int_to_twos_complement(num: int, bits: int) -> str:
    """
    整数转为n位二进制补码（符合视频逻辑）
    :param num: 输入整数（正数/负数）
    :param bits: 存储单元位数（如4、8）
    :return: n位二进制补码字符串
    """
    # 处理正数或零
    if num >= 0:
        # 转为二进制原码（去掉前缀'0b'）
        binary = bin(num)[2:]
        # 补零至指定位数（左补0）
        if len(binary) > bits:
            raise ValueError(f"整数{num}超出{bits}位存储范围")
        return binary.zfill(bits)
    # 处理负数（按视频逻辑：num = -X，先处理X）
    else:
        x = -num  # 取绝对值（X）
        # X转为二进制原码并补零至指定位数
        binary_x = bin(x)[2:].zfill(bits)
        # 按位取反（0变1，1变0）
        inverted = ''.join(['1' if c == '0' else '0' for c in binary_x])
        # 取反结果加1（二进制加法）
        # 先转为整数加1，再转回二进制并补零至指定位数
        complement = bin(int(inverted, 2) + 1)[2:].zfill(bits)
        # 确保结果不超出位数（若超出则溢出，视频未提溢出，此处简化）
        if len(complement) > bits:
            complement = complement[-bits:]
        return complement


# 视频示例测试
print(int_to_twos_complement(7, 4))      # 输出：0111（7的4位补码，视频示例）
print(int_to_twos_complement(-7, 4))     # 输出：1001（-7的4位补码，视频示例）
print(int_to_twos_complement(28, 8))     # 输出：00011100（28的8位补码，视频3.12）
print(int_to_twos_complement(-28, 8))    # 输出：11100100（-28的8位补码，视频3.13）
```

#### 2. n 位二进制补码转整数

python







```python
def twos_complement_to_int(complement: str) -> int:
    """
    n位二进制补码还原为整数（符合视频逻辑）
    :param complement: 二进制补码字符串（如'0111'、'11100100'）
    :return: 原整数
    """
    bits = len(complement)
    sign_bit = complement[0]  # 符号位（最左位）
    
    # 符号位为0：正数/零，直接转十进制
    if sign_bit == '0':
        return int(complement, 2)
    # 符号位为1：负数，按视频步骤还原
    else:
        # 步骤1：按位取反
        inverted = ''.join(['1' if c == '0' else '0' for c in complement])
        # 步骤2：取反结果加1
        abs_binary = bin(int(inverted, 2) + 1)[2:].zfill(bits)
        # 步骤3：转十进制（取绝对值）
        abs_value = int(abs_binary, 2)
        # 步骤4：加负号
        return -abs_value


# 视频示例测试
print(twos_complement_to_int('0111'))    # 输出：7（4位补码0111还原，视频示例）
print(twos_complement_to_int('1001'))    # 输出：-7（4位补码1001还原，视频示例）
print(twos_complement_to_int('00011100'))# 输出：28（8位补码00011100还原，视频3.12）
print(twos_complement_to_int('11100100'))# 输出：-28（8位补码11100100还原，视频3.13）
print(twos_complement_to_int('11100110'))# 输出：-26（8位补码还原，视频示例）
```

### 五、核心总结（视频重点回顾）

1. 补码符号位是转换的关键：`0`为正 / 零，`1`为负；
2. 整数转补码：正数补零，负数 “取绝对值→补零→取反→加 1”；
3. 补码转整数：符号位`0`直接转十进制，符号位`1`“取反→加 1→转十进制→加负号”；
4. 所有转换需基于 “指定存储单元位数”，不足时补符号位对应的数字（正数补`0`，负数补`1`）。



# 补码溢出知识点总结

### 一、补码基础回顾（视频前置复习内容）

视频中为讲解溢出先复习补码核心特性，重点围绕**4 位二进制补码**（视频明确 “四位的一个存储单元”）展开，核心内容如下：

1. **4 位补码的表示范围**

	视频明确：4 位二进制补码可表示的整数范围是 **-8 ~ +7**，所有补码均在该范围内循环，超出则溢出。

2. **正数的补码规则**

	视频强调：**正数的补码 = 其本身的二进制形式**（符号位为 0，数值位为原数），示例如下：

	| 十进制正数 | 4 位二进制补码 | 说明（视频表述） |
	| ---------- | -------------- | ---------------- |
	| +0         | 0000           | 补码为自身       |
	| +1         | 0001           | 补码为自身       |
	| +3         | 0011           | 补码为自身       |
	| +7         | 0111           | 4 位补码最大正数 |

3. **负数的补码规则与示例**

	视频指出：负数的补码需通过 “原数（正数）取反 + 1” 计算，且明确特殊补码的对应关系：

	| 十进制负数 | 4 位二进制补码 | 推导过程（视频提及）                                         |
	| ---------- | -------------- | ------------------------------------------------------------ |
	| -8         | 1000           | 视频直接明确 “1000 = -8”（4 位补码特殊值，无对应正数原数）   |
	| -7         | 1001           | 视频明确 “1001 = -7”（+7 补码 0111 → 取反 1000 → 加 1 1001） |
	| -3         | 1101           | +3 补码 0011 → 取反 1100 → 加 1 1101（视频 “-3 的补码是 110” 为口误，按 4 位补码修正） |
	| -1         | 1111           | +1 补码 0001 → 取反 1110 → 加 1 1111                         |

4. **补码的解读逻辑**

	视频强调：计算机处理补码时，**默认结果为补码形式**，需根据符号位（最高位）判断正负后转换为十进制：

	- 符号位为 0 → 正数，直接转换；
	- 符号位为 1 → 负数，通过 “补码取反 + 1” 转换为原数。

### 二、补码溢出的核心概念（视频定义）

1. **溢出的本质原因**

	视频明确：补码有固定表示范围（如 4 位补码为 - 8~+7），当计算结果**超出该范围**时，计算机因 “固定位数运算（高位截断）”，会将结果解读为错误的补码值，即发生 “补码溢出”。

2. **溢出的两种场景**

	视频将溢出分为两类，均以 4 位补码为例：

	- **正数溢出**：计算结果 > 补码最大正数（如 4 位中 > +7）；
	- **负数溢出**：计算结果 < 补码最小负数（如 4 位中 < -8）。

3. **关键特性**

	视频指出：计算机进行补码加法时，**不区分符号位，直接按二进制加法运算**，运算后仅保留固定位数（如 4 位），若结果超出范围则自动 “循环” 到错误值。

### 三、正数溢出的具体示例（视频核心案例）

视频通过两个案例讲解正数溢出，均基于 4 位补码，计算过程与视频完全一致：

#### 案例 1：7 + 1（视频提及的基础示例）

- 需求：计算十进制 `7 + 1` 的 4 位补码结果；

- 步骤 1：转换为 4 位补码

	

	7 的补码：

	```
	0111
	```

	（正数补码 = 自身）；

	

	1 的补码：

	```
	0001
	```

	（正数补码 = 自身）；

- 步骤 2：补码加法运算

	

	```
	0111 + 0001 = 1000
	```

	（二进制加法，无高位进位）；

- 步骤 3：解读结果

	

	运算结果

	```
	1000
	```

	为 4 位补码，按规则解读：符号位 1 → 负数，转换为十进制为

	```
	-8
	```

	；

- 结论：预期结果为`8`（>4 位补码最大正数 7），实际结果为`-8`，**发生正数溢出**（视频表述：“正 7+1 之后得的是 - 8”）。

#### 案例 2：5 + 6（视频重点讲解案例）

- 需求：计算十进制 `5 + 6` 的 4 位补码结果；

- 步骤 1：转换为 4 位补码

	

	5 的补码：

	```
	0101
	```

	（视频明确 “五的补码是 0101”）；

	

	6 的补码：

	```
	0110
	```

	（视频提及 “六的补码是 0110”）；

- 步骤 2：补码加法运算

	

	```
	0101 + 0110 = 1101
	```

	（二进制加法：0+0=0，1+1=10（进 1），0+1+1=10（进 1），0+0+1=1，结果为 1101）；

- 步骤 3：解读结果

	

	运算结果

	```
	1101
	```

	为 4 位补码，符号位 1 → 负数，转换为十进制：

	

	补码

	```
	1101
	```

	 

	→ 取反

	```
	0010
	```

	 

	→ 加 1

	```
	0011
	```

	（即 3） → 最终为

	```
	-3
	```

	？

	

	（注：视频字幕表述 “1101 是 - 5”，此处按视频原文记录：“他得到一个 1101…… 它是一个 - 5 对吧”）；

- 结论：预期结果为`11`（>4 位补码最大正数 7），实际结果为`-5`（视频表述），**发生正数溢出**。

### 四、负数溢出的具体示例（视频核心案例）

视频以 “-3 - 7” 为例讲解负数溢出，基于 4 位补码，步骤与视频一致：

#### 案例：-3 - 7（视频重点案例）

- 需求：计算十进制 `-3 - 7` 的 4 位补码结果（视频表述 “-3 解一个七” 即 “-3 减 7”）；

- 步骤 1：将减法转换为补码加法

	

	减法规则：

	```
	a - b = a + (-b)
	```

	，因此需先求

	 

	```
	-3
	```

	 

	和

	 

	```
	-7
	```

	 

	的 4 位补码：

	- `-3` 的补码：`1101`（视频提及 “-3 的补码是 110”，按 4 位补码修正为 1101，推导：+3 补码 0011 → 取反 1100 → 加 1 1101）；
	- `-7` 的补码：`1001`（推导：+7 补码 0111 → 取反 1000 → 加 1 1001）；

- 步骤 2：补码加法运算

	

	```
	1101 + 1001 = 10110
	```

	（二进制加法：1+1=10（进 1），0+0+1=1，1+0=1，1+1=10（进 1），结果为 10110）；

	

	因是 4 位补码，

	截断高位 1

	，保留低 4 位：

	```
	0110
	```

	；

- 步骤 3：解读结果

	

	运算结果

	```
	0110
	```

	为 4 位补码，符号位 0 → 正数，直接转换为十进制

	```
	6
	```

	；

- 结论：预期结果为`-10`（<4 位补码最小负数 - 8），实际结果为`6`，**发生负数溢出**（视频表述：“-3 减七本来想得一个 - 10，结果是个六”）。

### 五、视频总结的溢出关键结论

1. 补码溢出的判断依据：计算结果超出当前位数补码的表示范围（如 4 位为 - 8~+7）；
2. 计算机处理逻辑：固定位数运算，高位截断，结果按补码规则解读，超出范围则为错误值；
3. 核心示例验证：正数溢出（7+1=-8、5+6=-5）、负数溢出（-3-7=6）均证明溢出会导致结果与预期完全不符。





# 整数 3 种表示法比较（4 位存储单元）

本视频围绕**4 位存储单元**（二进制范围：`0000`~`1111`），对比整数的三种表示法（无符号表示法、符号加绝对值表示法、二进制补码表示法）的规则、计算方法及数值范围，以下是详细知识点总结：

## 一、核心前提：4 位存储单元

所有表示法的基础是**4 位二进制存储单元**，即二进制串长度固定为 4 位，范围从`0000`（二进制）到`1111`（二进制），共 16 种可能的二进制组合（`2^4 = 16`）。后续所有计算和数值映射均基于此前提。

## 二、三种表示法详细规则与示例

### 1. 无符号表示法

#### 核心规则

- **无符号位**：不区分 “符号” 和 “数值”，4 位二进制串全部表示数值（仅正数，无负数）。
- **计算方法**：直接将 4 位二进制串转换为十进制（加权求和）。
- **数值范围**：十进制 `0` ~ `15`（对应二进制 `0000` ~ `1111`）。

#### 示例（4 位二进制→十进制）

| 4 位二进制串 | 十进制计算过程              | 十进制结果 |
| ------------ | --------------------------- | ---------- |
| `0000`       | `0×2³ + 0×2² + 0×2¹ + 0×2⁰` | 0          |
| `0001`       | `0×2³ + 0×2² + 0×2¹ + 1×2⁰` | 1          |
| `0111`       | `0×2³ + 1×2² + 1×2¹ + 1×2⁰` | 7          |
| `1000`       | `1×2³ + 0×2² + 0×2¹ + 0×2⁰` | 8          |
| `1111`       | `1×2³ + 1×2² + 1×2¹ + 1×2⁰` | 15         |

### 2. 符号加绝对值表示法

#### 核心规则

- **拆分位功能**：4 位二进制串分为两部分：
	- 第 1 位（最高位）：**符号位**（`0`表示正数，`1`表示负数）；
	- 后 3 位（低 3 位）：**数值位**（存储整数的绝对值，仅表示正数）。
- **计算方法**：
	1. 判断符号位：`0`→正数，`1`→负数；
	2. 将后 3 位二进制串转换为十进制（绝对值）；
	3. 结合符号位得到最终十进制值（正数直接取绝对值，负数在绝对值前加 “-”）。
- **特殊情况**：存在 “正零”（`0000`）和 “负零”（`1000`），二者十进制均表示`0`，但二进制串不同。
- **数值范围**：十进制 `-7` ~ `7`（对应二进制 `1111` ~ `0111`）。

#### 示例（4 位二进制→十进制）

| 4 位二进制串 | 符号位  | 数值位（后 3 位） | 数值位十进制（绝对值） | 最终十进制结果 |
| ------------ | ------- | ----------------- | ---------------------- | -------------- |
| `0000`       | 0（正） | `000`             | 0                      | +0（即 0）     |
| `0001`       | 0（正） | `001`             | 1                      | +1（即 1）     |
| `0111`       | 0（正） | `111`             | 7                      | +7（即 7）     |
| `1000`       | 1（负） | `000`             | 0                      | -0（即 0）     |
| `1001`       | 1（负） | `001`             | 1                      | -1             |
| `1111`       | 1（负） | `111`             | 7                      | -7             |

### 3. 二进制补码表示法

#### 核心规则

- **拆分位功能**：4 位二进制串中，第 1 位（最高位）隐含符号（`0`表示正数，`1`表示负数），其余 3 位参与数值计算，无明确 “符号位” 与 “数值位” 的拆分（需通过规则转换）。
- **计算方法**：
	- **正数（符号隐含为正，即第 1 位为`0`）**：直接将 4 位二进制串转换为十进制（与无符号表示法计算一致）；
	- **负数（符号隐含为负，即第 1 位为`1`）**：需通过 “取反 + 加 1” 转换为绝对值，再取负：
		1. 对 4 位二进制串的每一位 “取反”（`0`变`1`，`1`变`0`）；
		2. 将取反后的二进制串转换为十进制，得到绝对值；
		3. 最终结果为 “- 绝对值”。
- **特殊情况**：仅存在 “唯一零”（`0000`），无 “正零”“负零” 之分（`1000`表示`-8`，非零）。
- **数值范围**：十进制 `-8` ~ `7`（对应二进制 `1000` ~ `0111`）。

#### 示例（4 位二进制→十进制）

##### （1）正数示例（第 1 位为`0`）

| 4 位二进制串 | 符号隐含 | 十进制计算过程              | 十进制结果 |
| ------------ | -------- | --------------------------- | ---------- |
| `0000`       | 正       | `0×2³ + 0×2² + 0×2¹ + 0×2⁰` | 0          |
| `0010`       | 正       | `0×2³ + 0×2² + 1×2¹ + 0×2⁰` | 2          |
| `0111`       | 正       | `0×2³ + 1×2² + 1×2¹ + 1×2⁰` | 7          |

##### （2）负数示例（第 1 位为`1`，需 “取反 + 加 1”）

| 4 位二进制串 | 符号隐含 | 步骤 1：4 位取反 | 步骤 2：取反后转十进制（绝对值） | 步骤 3：加负号（最终结果）                        |
| ------------ | -------- | ---------------- | -------------------------------- | ------------------------------------------------- |
| `1000`       | 负       | `0111`           | `0×2³ + 1×2² + 1×2¹ + 1×2⁰ = 7`  | -8（注：取反后`0111`加 1 得`1000`，转十进制为 8） |
| `1010`       | 负       | `0101`           | `0×2³ + 1×2² + 0×2¹ + 1×2⁰ = 5`  | -6（注：取反后`0101`加 1 得`0110`，转十进制为 6） |
| `1111`       | 负       | `0000`           | `0×2³ + 0×2² + 0×2¹ + 0×2⁰ = 0`  | -1（注：取反后`0000`加 1 得`0001`，转十进制为 1） |

> 视频中重点示例：`1010`（4 位二进制补码）→ 取反得`0101`→加 1 得`0110`（十进制 6）→ 最终结果`-6`。

## 三、三种表示法核心差异对比（4 位存储单元）

| 对比维度       | 无符号表示法         | 符号加绝对值表示法          | 二进制补码表示法               |
| -------------- | -------------------- | --------------------------- | ------------------------------ |
| 符号处理       | 无符号（仅正数）     | 显式符号位（0 正 1 负）     | 隐含符号（0 正 1 负）          |
| 数值位范围     | 4 位全部为数值位     | 后 3 位为数值位             | 4 位均参与数值计算             |
| 十进制范围     | 0 ~ 15               | -7 ~ 7                      | -8 ~ 7                         |
| “零” 的表示    | 唯一（0000→0）       | 两个（0000→0，1000→0）      | 唯一（0000→0）                 |
| 计算复杂度     | 直接转十进制（简单） | 符号位 + 数值位拆分（中等） | 负数需 “取反 + 加 1”（较复杂） |
| 典型二进制映射 | 1000→8               | 1000→-0（即 0）             | 1000→-8                        |



# 28. 实数 - 浮点表示法 知识点总结

## 1. 实数的定义

视频中明确：**实数是带有整数部分和小数部分的数字**，核心特征是包含小数点，例如 `1.00234`、`742500...000`（含整数部分和隐含小数部分）、`-0.000...0232` 等。

## 2. 定点表示法

### 2.1 定义

定点表示法是**预先固定小数点位置的实数存储方式**，需明确规定小数点左侧和右侧的数码位数（视频中以 “十进制系统” 为例讲解，非二进制）。

- 补充背景：视频提到 “之前讲过整数的定点表示法，是把小数点放在整数最右边”；而实数的定点表示法需额外定义小数点的具体位置（如 “左 14 位 + 右 2 位”“左 10 位 + 右 6 位”）。

### 2.2 核心特点

1. 小数点位置**固定不变**，存储前需提前定义；
2. 总数码位数固定（视频中示例均为 16 个十进制数码）；
3. 存储时需根据固定的小数点位置截断超出位数的数值，导致精度受损。

### 2.3 十进制示例（视频核心案例）

视频中通过两个十进制案例说明定点表示法的应用：

#### 案例 1：16 位数码（左 14 位 + 右 2 位）

- 规则：总 16 个十进制数码，小数点左侧保留 14 个数码，右侧保留 2 个数码；
- 存储场景：存储 `1.00234`；
- 结果：因小数点右侧仅能存 2 位，超出的 `0234` 被截断，最终存储为 `1.00`（仅保留小数点后 2 位）。

#### 案例 2：16 位数码（左 10 位 + 右 6 位）

- 规则：总 16 个十进制数码，小数点左侧保留 10 个数码，右侧保留 6 个数码；
- 存储场景：存储一个 “整数部分含 12 个数码的大数字”（如 `123456789012.000000`）；
- 结果：因小数点左侧仅能存 10 个数码，超出的前 2 个数码（如 `12`）被截断，最终存储的整数部分变为 `3456789012`，数据精度严重受损（视频举例：若为资产数据，会直接少两位数值）。

### 2.4 局限性

视频明确指出：**定点表示法不适合存储 “整数部分极大” 或 “小数部分极小” 的实数**。

- 原因：固定的小数点位置和总数码位数，会导致超出范围的数值被截断，无法保证精度（如上述案例 2 的大整数、极小小数如 `0.000000000123` 会因小数点右侧位数不足截断）。

## 3. 浮点表示法

### 3.1 定义

浮点表示法是**允许小数点 “浮动” 的实数存储方式**，核心目的是 “扩大实数的存储范围” 并 “维持数据精度”（解决定点表示法的局限性）。

- 视频关键解释：“浮点” 即 “小数点可以左右浮动”，通过调整小数点位置，适配极大或极小的实数。

### 3.2 核心组成（视频明确三部分）

无论十进制还是二进制，浮点表示法均由三部分构成：

| 组成部分 | 作用                                           | 视频示例                                                     |
| -------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 符号位   | 表示实数的正负（正 / 负）                      | 正用 “0” 表示，负用 “1” 表示（如 `-0.000...0232` 的符号位为 “1”） |
| 位移量   | 记录小数点浮动的位数（决定小数点的最终位置）   | 小数点左移 21 位，位移量为 “21”；右移 14 位，位移量为 “-14”  |
| 定点数   | 小数点浮动后，保留的核心数值（小数点位置固定） | `7.425`（对应位移量 21）、`2.32`（对应位移量 - 14）          |

### 3.3 与科学表示法的关系

视频强调：**科学表示法是 “特殊的浮点表示法”**，其额外规则是 “定点数的小数点左侧仅保留 1 个非零数码”。

- 底的区别：十进制科学表示法的底为 “10”，二进制科学表示法的底为 “2”（视频重点对比）。

### 3.4 十进制科学表示法示例（视频核心案例）

#### 案例 1：存储极大实数（如 `742500...000`，整数部分 12 位，小数部分全 0）

1. 步骤：将小数点**左移 21 位**，使小数点左侧仅保留 1 个非零数码（`7`）；
2. 符号位：正数，符号位为 “0”；
3. 定点数：`7.425`（小数点右侧保留有效数码，末尾的 0 可省略，不影响数值）；
4. 位移量：左移 21 位，位移量为 “21”；
5. 科学表示法：`0（符号） + 21（位移量） + 7.425（定点数）` → 完整表示为 `7.425 × 10²¹`。

#### 案例 2：存储极小实数（如 `-0.000...0232`，小数点后 13 个 0+232）

1. 步骤：将小数点**右移 14 位**，使小数点左侧仅保留 1 个非零数码（`2`）；
2. 符号位：负数，符号位为 “1”；
3. 定点数：`2.32`（末尾的 0 可省略）；
4. 位移量：右移 14 位，位移量为 “-14”；
5. 科学表示法：`1（符号） + (-14)（位移量） + 2.32（定点数）` → 完整表示为 `-2.32 × 10⁻¹⁴`。

### 3.5 二进制科学表示法示例（视频提及）

视频明确：二进制实数也可通过科学表示法（特殊浮点表示法）存储，核心区别是 “底为 2”，规则与十进制一致。

#### 案例 1：存储二进制大整数（如 `110100...000`）

1. 规则：小数点左侧仅保留 1 个非零数码（二进制非零数码为 “1”）；
2. 步骤：将小数点左移 `n` 位（如左移 32 位）；
3. 科学表示法：`符号位 + 32（位移量） + 1.101（定点数）` → 完整表示为 `1.101 × 2³²`（视频举例 “3.20 的二进制案例，幂为 32”）。

#### 案例 2：存储二进制小实数（如 `-0.000...01101`）

1. 步骤：将小数点右移 24 位，使左侧保留 “1”；
2. 科学表示法：`1（符号位） + (-24)（位移量） + 1.101（定点数）` → 完整表示为 `-1.101 × 2⁻²⁴`（视频举例 “3.21 的二进制案例，负数，幂为 - 24”）。

## 4. 定点表示法与浮点表示法的核心区别（视频隐含对比）

| 对比维度   | 定点表示法               | 浮点表示法                   |
| ---------- | ------------------------ | ---------------------------- |
| 小数点位置 | 固定（预先定义）         | 浮动（通过位移量调整）       |
| 存储范围   | 小（受固定位数限制）     | 大（适配极大 / 极小实数）    |
| 精度       | 易受损（超出位数截断）   | 易维持（有效数码不丢失）     |
| 适用场景   | 小数位数固定、范围小的数 | 大整数、极小小数、范围广的数 |



# 浮点表示法的规范化知识点总结

## 一、规范化的核心定义

视频明确：规范化是为了使实数的浮点表示法中 “固定部分（小数点位置）统一”，核心规则是**小数点左边必须存在唯一的非零数码**（即小数点左边仅 1 位非零数，无其他前置数字）。

该规则适用于十进制和二进制的浮点表示（科学计数法是浮点表示法的特殊形式），目的是保证数据表示的唯一性和计算机存储的效率。

## 二、十进制与二进制的规范化操作（含视频示例）

视频通过十进制与二进制对比，突出二进制规范化的特殊性，所有示例均来自视频原文表述。

### 1. 十进制规范化

- **规则**：小数点左边的数码必须是 `1~9`（唯一非零数码，且仅 1 位），小数点右边为 `0~9` 的任意组合。

- **视频示例**：

	

	十进制数

	 

	```
	123.456
	```

	 

	规范化时，需将小数点左移 2 位，使小数点左边仅保留 1 位非零数（1），最终形式为

	 

	```
	1.23456 × 10²
	```

	。

	- 反例：`12.3456 × 10¹` 不符合规范，因小数点左边有 2 位数字（1 和 2），未满足 “唯一 1 位非零数码” 要求。

### 2. 二进制规范化（计算机存储核心）

- **特殊规则**：二进制仅含 0 和 1，因此 “小数点左边的唯一非零数码” 只能是 `1`，即规范化二进制数的固定形式为 **`1.xxxx × 2ⁿ`**（其中 `x` 为 0 或 1，`n` 为整数，代表小数点移动的位数）。

- **视频示例**：

	

	二进制数

	 

	```
	0011
	```

	（视频中隐含小数位，推测完整形式为

	 

	```
	0011.0011
	```

	）规范化时，需将小数点左移 3 位，使小数点左边变为 1，最终形式为

	 

	```
	1.010011 × 2³
	```

	。

	- 反例：`0.101 × 2²` 不符合规范，因小数点左边是 0，非 “唯一非零数码”。

## 三、规范化后的三要素：符号、指数、尾数

视频指出，二进制数规范化后，可拆解为 “符号”“指数”“尾数” 三部分，这是计算机存储浮点数据的基础，三者定义与视频说明如下：

| 要素 | 核心含义                                                     | 视频补充说明                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 符号 | 表示实数的正负：正数用 `0` 表示，负数用 `1` 表示             | 符号位独立标识正负，无其他表示方式（如直接写正负号）         |
| 指数 | 表示小数点移动的位数：小数点左移 `n` 位，指数为 `n`；右移 `n` 位，指数为 `-n` | 视频示例：“移到六位，那个指数就是六”（即小数点左移 6 位，指数为 6） |
| 尾数 | 表示规范化后 `1.xxxx` 中 “小数点右边的 `xxxx` 部分”（仅保留小数部分） | 尾数不包含小数点左边的 `1`（后续会讲 “隐含存储” 优化）       |

### 视频完整示例拆解

以视频中 `1.010011 × 2³`（正数）为例：

- 符号：正数 → 符号位为 `0`
- 指数：小数点左移 3 位 → 指数为 `3`
- 尾数：小数点右边的 `010011` → 尾数为 `010011`

## 四、计算机中规范化浮点数据的存储优化

视频重点讲解了计算机存储的 “空间节约策略”，核心是 “隐含小数点左边的 1”，具体规则与注意事项如下：

### 1. 关键优化：隐含 `1` 的存储

- **优化原因**：计算机中存储的浮点数据均为规范化后的二进制数，而规范化二进制数的小数点左边必为 `1`（二进制规范化规则），因此无需额外存储该 `1`，仅需存储尾数的小数部分，可节约 1 位存储空间。
- **视频表述**：“小数点左边的这个一（1）没有存储，其实是为了节约计算机内部存储的空间，他默认就知道是一（1），因为计算机里存的都是规范化后的数据”。

### 2. 存储结构：分两部分存储

视频明确：计算机无需单独存储 “符号位”“指数”“尾数” 三部分，而是合并为 **“指数” + “带符号的尾数”** 两部分存储：

- 尾数：采用 “符号加绝对值表示法”—— 第一位为符号位（与实数符号一致：正为 `0`，负为 `1`），后续为尾数的小数部分。

	

	示例：上述

	 

	```
	1.010011 × 2³
	```

	 

	的尾数

	 

	```
	010011
	```

	，带符号后为

	 

	```
	0 010011
	```

	（前一个

	 

	```
	0
	```

	 

	是符号位，后一个

	 

	```
	010011
	```

	 

	是尾数小数部分）。

- 指数：单独存储，仅记录小数点移动的位数（无需额外符号位，后续 “余码系统” 会展开，本视频暂不涉及）。

### 3. 存储注意事项：尾数末尾零的处理

- 问题根源：小数末尾添加若干个 0，不改变小数实际值（如 `1.010011` 与 `1.01001100` 数值相等）；但如果将尾数视为整数用 “符号加绝对值” 存储，末尾加 0 会导致整数数值增大（如 `010011` 加 0 后变为 `01001100`，整数从 19 变为 76）。
- 视频解决方案：计算机存储时会**自动去掉尾数末尾的所有 0**，避免数值偏差，保证存储值与实际值一致。



# 余码系统知识点总结

## 1. 余码系统的核心定义与作用

- **定义**：余码系统是计算机中用于存储浮点数「指数部分」的一种表示方法，核心是通过**加偏移量**将有符号的指数（可正可负）转换为无符号数，从而简化指数的比较与运算。
- **作用**：替代二进制补码存储指数 —— 补码表示的指数存在正负符号位，运算时需处理符号；余码将指数统一转为正数，无需额外处理符号，提升效率。
- **关联概念**：浮点数存储的三部分（视频强调）：
	1. **符号位（s）**：1 位，0 表示正数，1 表示负数；
	2. **指数部分（E）**：用余码表示（无符号数）；
	3. **尾数部分（M）**：无符号数，存储规范化后的小数部分（隐藏整数位 “1”，视频重点强调）；
	4. 基础基数默认是二进制（视频默认前提）。

## 2. 偏移量的计算规则（余码核心）

### 2.1 偏移量公式

若存储指数的位数为 `n`（如单精度指数占 8 位，`n=8`），则偏移量 `Offset = 2^(n-1) - 1`。

- 原理：通过偏移量将指数的取值范围 “整体右移”，使所有指数转为非负整数。

### 2.2 视频中的偏移量示例

#### 示例 1：4 位存储指数（视频讲解案例）

- 指数存储位数 `n=4`，偏移量 `Offset = 2^(4-1) - 1 = 8 - 1 = 7`；
- 原指数范围（带符号）：`-7 ~ +8`（4 位二进制带符号数的范围）；
- 余码指数范围（无符号）：`-7 + 7 = 0 ~ +8 + 7 = 15`（对应 4 位无符号数范围），实现 “负指数转正数”。

#### 示例 2：单精度 8 位指数（IEEE 754 标准）

- 指数存储位数 `n=8`，偏移量 `Offset = 2^(8-1) - 1 = 128 - 1 = 127`；
- 原指数范围：`-126 ~ +127`（视频隐含，避免溢出）；
- 余码指数范围：`-126 + 127 = 1 ~ +127 + 127 = 254`（0 和 255 用于特殊值，如 0、无穷大）。

#### 示例 3：双精度 11 位指数（IEEE 754 标准）

- 指数存储位数 `n=11`，偏移量 `Offset = 2^(11-1) - 1 = 1024 - 1 = 1023`；
- 原指数范围：`-1022 ~ +1023`；
- 余码指数范围：`-1022 + 1023 = 1 ~ +1023 + 1023 = 2046`（0 和 2047 用于特殊值）。

## 3. IEEE 754 浮点数标准（视频重点讲解）

余码系统主要用于 IEEE 754 标准的浮点数存储，视频明确区分单精度和双精度两种格式，具体如下表：

| 格式   | 总位数 | 符号位（s） | 指数位（n）         | 尾数位（M）          | 偏移量（Offset） | 余码指数范围 | 尾数有效位（含隐藏位）        |
| ------ | ------ | ----------- | ------------------- | -------------------- | ---------------- | ------------ | ----------------------------- |
| 单精度 | 32     | 第 1 位     | 第 2-9 位（8 位）   | 第 10-32 位（23 位） | 127（2^7-1）     | 1~254        | 24 位（23 位存储 + 1 隐藏位） |
| 双精度 | 64     | 第 1 位     | 第 2-12 位（11 位） | 第 13-64 位（52 位） | 1023（2^10-1）   | 1~2046       | 53 位（52 位存储 + 1 隐藏位） |

- 关键说明（视频强调）：
	- 尾数 `M` 存储的是**规范化二进制数的小数部分**—— 规范化后二进制数的形式为 `1.xxxx × 2^e`（`e` 为原指数），整数位 “1” 默认隐藏，仅存储小数部分 “xxxx”，节省 1 位存储位；
	- 符号位 `s`：0→正数，1→负数，与指数、尾数独立。

## 4. 实数转余码（单精度为例）—— 视频步骤与示例

视频以 “十进制实数转单精度余码” 为例，明确分 6 步操作，以下结合视频中的**5.75（正数）**、**- 某个正数**、**-0.xxxx（负小数）** 三个案例展开。

### 4.1 通用步骤（单精度）

1. **确定符号位 `s`**：正数→0，负数→1；
2. **十进制转二进制**：分别转换整数部分（除 2 取余）和小数部分（乘 2 取整）；
3. **二进制规范化**：调整为 `1.xxxx × 2^e` 形式，记录原指数 `e`；
4. **计算余码指数**：`E_余码 = e + Offset（127）`，再转为 8 位二进制；
5. **处理尾数 `M`**：取规范化后小数部分 “xxxx”，补 0 至 23 位（因隐藏整数位 “1”）；
6. **拼接结果**：`s + E_余码（8位） + M（23位）`，形成 32 位余码。

### 4.2 示例 1：十进制 5.75 → 单精度余码（视频重点案例）

#### 步骤 1：确定符号位 `s`

5.75 是正数 → `s=0`。

#### 步骤 2：十进制 5.75 → 二进制

- 整数部分 5：`5 ÷ 2 = 2余1 → 2÷2=1余0 → 1÷2=0余1` → 倒序得 `101`；
- 小数部分 0.75：`0.75×2=1.5取1 → 0.5×2=1.0取1` → 得 `11`；
- 合并二进制：`101.11`。

#### 步骤 3：二进制规范化

- `101.11` 调整为 `1.0111 × 2^2`（小数点左移 2 位）→ 原指数 `e=2`。

#### 步骤 4：计算余码指数

- `E_余码 = 2 + 127 = 129`；
- 129 转为 8 位二进制：`10000001`（因 128+1=129，二进制为 10000001）。

#### 步骤 5：处理尾数 `M`

- 规范化后小数部分为 `0111`（来自 `1.0111`）；
- 补 0 至 23 位：`01110000000000000000000`（后补 19 个 0）。

#### 步骤 6：拼接结果

- 32 位余码：`0 10000001 01110000000000000000000`

	

	（符号位）（8 位余码指数）（23 位尾数）

### 4.3 示例 2：十进制 -X（负数，视频简化案例）

以 “- 某个正数” 为例（视频逻辑）：

1. 符号位 `s=1`；
2. 忽略负号，将 `X` 按示例 1 步骤 2-5 处理（转二进制→规范化→算余码指数→处理尾数）；
3. 拼接：`1 + E_余码 + M`。

例如：若 X = 某个数，二进制规范化后为 `1.xxx×2^e`，余码指数 `e+127`，尾数补 0 后，最终余码为 `1 + 余码指数二进制 + 尾数二进制`。

### 4.4 示例 3：十进制 -0.xxxx（负小数，视频案例）

以 “-0.xxxx” 为例（视频逻辑，假设具体值为 `-0.0001101` 类似）：

#### 步骤 1：符号位 `s=1`

#### 步骤 2：十进制 0.xxxx → 二进制

假设 0.xxxx 转二进制为 `0.0001101`。

#### 步骤 3：二进制规范化

- `0.0001101` 调整为 `1.101 × 2^-4`（小数点右移 4 位）→ 原指数 `e=-4`。

#### 步骤 4：计算余码指数

- `E_余码 = -4 + 127 = 123`；
- 123 转为 8 位二进制：`01111011`。

#### 步骤 5：处理尾数 `M`

- 规范化后小数部分为 `101`；
- 补 0 至 23 位：`10100000000000000000000`（后补 20 个 0）。

#### 步骤 6：拼接结果

- 32 位余码：`1 01111011 10100000000000000000000`。

## 5. 余码转实数（单精度为例）—— 视频逆过程步骤与示例

视频讲解如何将 32 位余码反向还原为十进制实数，分 5 步操作，结合 “32 位余码串” 案例展开。

### 5.1 通用步骤（单精度）

1. **拆分字段**：将 32 位余码拆分为 `s`（1 位）、`E_余码`（8 位）、`M`（23 位）；
2. **计算原指数 `e`**：`e = E_余码（十进制） - Offset（127）`；
3. **恢复规范化二进制**：在尾数 `M` 前加隐藏位 “1”，形成 `1.M`（即 `1.xxxx`）；
4. **去规范化**：将 `1.xxxx` 的小数点向右（`e>0`）或向左（`e<0`）移动 `|e|` 位，得到完整二进制数；
5. **二进制转十进制**：将去规范化后的二进制转为十进制，结合符号位 `s` 得到最终结果。

### 5.2 示例：32 位余码 → 十进制实数（视频案例）

假设视频中 32 位余码串为：`1 10010100 10100000000000000000000`（示例值，符合视频逻辑）。

#### 步骤 1：拆分字段

- 符号位 `s=1`（负数）；
- 余码指数 `E_余码`：`10010100`（8 位）；
- 尾数 `M`：`10100000000000000000000`（23 位）。

#### 步骤 2：计算原指数 `e`

- `E_余码` 转十进制：`10010100 = 128 + 16 + 4 = 148`；
- 原指数 `e = 148 - 127 = 21`。

#### 步骤 3：恢复规范化二进制

- 尾数 `M` 前加隐藏位 “1”：`1.101`（因 `M=101...`，即 `1.101`）。

#### 步骤 4：去规范化

- 原指数 `e=21>0`，小数点向右移 21 位：
	- `1.101 × 2^21 = 11010000000000000000000.0`（小数点右移 21 位，中间补 18 个 0）。

#### 步骤 5：二进制转十进制 + 加符号

- 二进制 `11010000000000000000000` 转十进制：`1×2^21 + 1×2^19 + 1×2^18 = 2097152 + 524288 + 262144 = 2883584`；
- 符号位 `s=1`（负）→ 最终十进制：`-2883584`（视频逻辑结果）。

## 6. 余码系统的优点（视频总结）

- 指数统一为无符号数：无需处理符号位，直接通过无符号数比较大小（如余码值越大，对应原指数越大），简化指数运算与浮点数比较逻辑；
- 与 IEEE 754 标准兼容：是浮点数存储的核心组成部分，保证跨设备浮点数表示的一致性。





# 计算机存储文本知识点总结

## 1. 存储文本的核心逻辑

计算机无法直接存储 “文本符号”（如字母、汉字、标点），需通过 **“符号 - 二进制串” 的一一对应关系** 实现存储，核心原理如下：

- 文本的本质是 “符号集合”：无论是英文的`a`、`B`，中文的 “我”“你”，还是标点 “，”“？”、控制符（空格、回车），都属于 “符号”。
- 编码表是关键：定义 “每个符号对应唯一二进制串” 的映射表，称为**编码表**。
- 存储与显示流程：
	1. 存储时：将文本中的每个符号，通过 “编码表” 转换为对应的二进制串（固定位数），存入计算机；
	2. 显示时：从计算机中读取二进制串，再通过 “编码表” 反向解析为对应的符号，在文本编辑器（如记事本）中展示。

## 2. ASCII 编码（英文及基础符号的早期编码）

由于计算机起源于美国，最初仅需处理英文及基础符号，因此诞生了 **ASCII 编码（美国信息交换标准代码，由 ANSI 发布）**。

### 2.1 ASCII 的核心特性

- 符号覆盖范围：包含英文小写字母（a-z）、大写字母（A-Z）、数字（0-9）、基础标点（逗号 “，”、问号 “？” 等）、控制符（空格、回车、换行等），共 **128 种符号**。
- 二进制位数设计：
	- 实际用 **7 位二进制** 即可表示 128 种符号（计算：`2^7 = 128`）；
	- 计算机存储时通常用 **8 位二进制** 承载（高位补 0，不改变符号对应关系），8 位二进制最大可表示 256 种符号（`2^8 = 256`），剩余的 128 个位置预留（早期未使用）。

### 2.2 ASCII 的映射示例（视频逻辑举例）

| 符号    | 对应的二进制串（8 位） | 说明                                                |
| ------- | ---------------------- | --------------------------------------------------- |
| 小写`a` | `01100001`             | 实际为 7 位`1100001`，高位补 0                      |
| 大写`A` | `01000001`             | 与小写`a`的二进制串有固定差异                       |
| 空格    | `00100000`             | 控制符，无可见图形                                  |
| 数字`1` | `00110001`             | 区别于数值 “1” 的存储（文本中是符号，数值中是数据） |

## 3. 多语言编码问题（以中文为例）

ASCII 仅能处理英文及基础符号，无法覆盖中文、日文、韩文等多语言符号，核心问题是 **“符号数量远超 ASCII 的承载能力”**。

### 3.1 中文符号的数量特点

- 中文符号总量庞大：常用汉字约 2-3 万个，生僻字及中文标点、控制符合计可达 10 万 +，远超过 ASCII 的 128 种符号上限。

- 所需二进制位数计算：

	

	若需存储

	```
	N
	```

	种符号，需满足 “二进制位数

	```
	n
	```

	的

	```
	2^n ≥ N
	```

	”（视频中用对数表述：

	```
	n = log₂N
	```

	）。

	

	示例：存储 2 万个中文符号时，

	```
	log₂(20000) ≈ 15
	```

	，因此需至少

	 

	16 位二进制

	；若考虑更多生僻字，实际会用

	 

	32 位二进制

	 

	确保覆盖（

	```
	2^32 = 4294967296
	```

	，可承载数十亿种符号）。

### 3.2 多语言编码的 “碎片化” 问题

为解决本国语言存储，各国独立开发了专属编码表：

- 中国：制定了中文专属编码表（如视频中提及的 “GB 系列”，如 GB2312、GBK），用 32 位二进制对应每个汉字 / 中文符号；
- 日本：开发了日文编码表（如 Shift_JIS）；
- 韩国：开发了韩文编码表（如 EUC-KR）。

问题：不同编码表的 “二进制串 - 符号” 映射关系完全独立（例如：中文编码表中`11000010 10100001`对应 “你”，但日文编码表中该二进制串可能对应某日文假名），导致 “跨语言存储 / 传输时符号无法识别”。

## 4. Unicode 编码（全球统一编码标准）

为解决多语言编码 “碎片化” 问题，硬件和软件制造商联合制定了 **Unicode 编码表**，实现全球符号的统一映射。

### 4.1 Unicode 的核心设计

- 二进制位数：固定用 **32 位二进制** 对应一个符号，可承载`2^32 = 4294967296`种符号，完全覆盖全球所有语言的符号（中文、英文、日文、韩文等）。
- 编码范围分配逻辑：将 32 位二进制的 “数值范围” 划分给不同国家 / 语言，示例：
	1. 某一段范围（如`00000000 00000000 00000000 00000000`至`00000000 00000000 00000000 01111111`）分配给美国，包含 ASCII 的 128 种符号（兼容早期 ASCII 编码）；
	2. 另一段范围分配给中国，用于映射所有中文汉字、中文标点；
	3. 再划分其他范围给日本、韩国等，分别映射其语言符号。

### 4.2 Unicode 的优势

- 统一标准：全球所有语言的符号都能在 Unicode 中找到唯一对应的 32 位二进制串，无需再使用本国专属编码表；
- 兼容 ASCII：由于 ASCII 先于 Unicode 诞生，Unicode 将 ASCII 的 128 种符号 “纳入自身编码范围”，确保早期英文文本可正常解析。

## 5. 乱码的产生原因（视频核心解释）

乱码的本质是 **“存储时使用的编码表 ≠ 读取 / 显示时使用的编码表”**，导致二进制串无法正确解析为原符号。

### 5.1 乱码示例（视频逻辑）

1. 存储阶段：用 “中文编码表（如 GB2312）” 存储 “你好”，将 “你” 转换为二进制串`11000010 10100001`，“好” 转换为`11000110 10100010`，存入计算机；
2. 读取阶段：若误将上述二进制串用 “日文编码表（如 Shift_JIS）” 解析，由于日文编码表中`11000010 10100001`对应 “あ”（日文假名），`11000110 10100010`对应 “お”，最终显示为 “あお”（无意义符号，即乱码）。

### 5.2 结论

只有当 “存储编码表” 与 “读取编码表” 完全一致时，二进制串才能正确解析为原文本符号，避免乱码。



# 计算机存储音频核心知识点总结

## 1. 音频与文本 / 数字的本质区别

视频明确指出，音频与计算机中存储的文本、数字存在根本差异，核心区别在于**数据连续性与有限性**：

- 文本 / 数字：数量有限，可通过固定编码表（如 ASCII）映射存储。例如单个字符 “a” 对应唯一编码，数字 “123” 的取值范围可明确界定，存储时无需处理 “连续变化” 问题。
- 音频：是 “随时间变化的连续实体”。例如说话声、音乐，在录制的时间范围内（即使静音或有杂音），声音信号始终连续变化，不存在 “有限个固定值” 的特性。

## 2. 音频的模拟数据特性及存储挑战

### 2.1 音频的模拟数据本质

视频强调，音频属于**模拟数据**，其核心特征是：

- 模拟数据在时间维度上具有 “无限个取值”。例如 1 秒内的音频，可细分为毫秒（ms，1 秒 = 1000ms）、微秒（μs，1 秒 = 1000000μs）等更小时间单位，每个极小时间单位内都有对应的声音信号值（如音量、频率相关值），理论上取值数量无限。

### 2.2 直接存储的挑战

若直接存储模拟音频的所有连续值：

- 需存储 “无限个数据点”，导致数据量极大，计算机无法实现完整存储。视频举例：1 秒音频若细分到微秒级，每个微秒都需存储一个值，数据量会远超计算机常规存储能力。

## 3. 解决存储挑战的核心技术：采样（Sampling）

为解决模拟音频 “无限数据点” 的存储问题，视频介绍**采样技术**，这是将模拟音频转换为数字信号的第一步。

### 3.1 采样的定义

采样是指：在连续的模拟音频信号上，**选择有限个时间点获取信号值**，用这些 “有限样本点” 替代无限连续的模拟信号，从而降低存储数据量。

### 3.2 采样的核心原理

- 核心逻辑：计算机无需记录一段时间内的所有音频信号，只需记录 “关键样本点”；播放时，通过这些样本点可模拟还原出接近原声音的信号。
- 人类听觉的辅助作用：人类听觉无法分辨极短时间间隔（如 0.0001 秒）内的信号差异，即使只存储样本点，播放时也无法察觉 “非连续” 的损耗（即感知不到采样后的 “有损” 特性）。

### 3.3 采样密度与声音效果的示例（视频原话）

视频通过具体采样数量对比，说明采样密度对声音还原的影响：

- 低采样密度：1 秒内仅采样 10 个样本，存储数据量小，但还原的声音 “断断续续”，人类可明显察觉不连续。
- 高采样密度：1 秒内采样 40000 个样本，样本点足够密集，还原的声音接近连续，人类听觉无法分辨采样痕迹。

## 4. 采样后的关键步骤：量化（Quantization）

采样获取 “有限个样本点的信号值” 后，视频介绍第二步核心技术 ——**量化**，目的是简化样本值的存储格式。

### 4.1 量化的定义

量化是指：将采样得到的 “样本信号值（可能为小数）”**截取为整数**，以便计算机用更简单的整数格式存储（避免存储小数带来的计算与存储复杂度）。

### 4.2 量化的核心原理

- 计算机存储偏好：视频指出，计算机存储音频时，更倾向用 “整数” 或 “无符号整数” 格式，而非小数 —— 小数存储需额外处理精度，计算效率低。
- 听觉容错性：量化过程中 “小数取整” 的误差极小，人类听觉无法分辨（例如样本值 17.7 取整为 18，对声音还原效果无明显影响）。

### 4.3 量化示例（视频原话）

- 原采样值（模拟信号）：17.7（小数）
- 量化后值（用于存储）：18（截取为整数）

## 5. 量化后的存储准备：编码（Encoding）

量化得到整数样本值后，视频介绍第三步 ——**编码**，即将整数转换为计算机可直接存储的二进制格式。

### 5.1 编码的定义

编码是指：将量化后的 “整数样本值” 转换为**二进制数**，使其符合计算机的二进制存储规则。

### 5.2 编码的核心处理：正负值问题

视频提到，音频信号的样本值可能包含正数（如高音）和负数（如低音），但计算机存储 “无符号整数” 更简便，因此采用**偏移量处理**解决正负值问题：

- 处理逻辑：给所有样本值（包括负数）加上一个固定 “偏移量”，使所有值转换为正数；播放或计算时，再减去该偏移量还原原始值（类似 “余码系统” 的处理思路）。
- 示例逻辑：若偏移量为 128，原始值 - 5 → 加 128 后为 123（正数），存储 123 的二进制；还原时 123-128=-5，恢复原始负值。

### 5.3 编码示例（视频原理推导）

- 量化后整数：18
- 编码后二进制（以 8 位存储为例）：00010010

## 6. 影响音频存储的关键参数：样本位（Sample Bit Depth）

视频定义 “样本位”（又称 “位深度”），是决定音频存储精度与数据量的核心参数。

### 6.1 样本位的定义

样本位是指：计算机为 “每个量化后的样本值” 分配的**二进制位数**，用于限定样本值的取值范围。

### 6.2 样本位的位数影响

视频明确不同位数的存储能力差异：

- 低位数（如 8 位）：取值范围小（8 位无符号整数范围 0-255）。若样本值超过该范围（如二进制 11001000，即十进制 200，若值更大则存不下），需缩小信号值才能存储，可能损失音频精度。
- 高位数（如 16 位、24 位、32 位）：取值范围更广（16 位无符号整数范围 0-65535），可存储更大的样本值，精度更高，能更好还原音频细节（如高音、低音的细微差异）。
- 视频结论：样本位的位数越多，样本值的取值范围越广，音频存储精度越高。

## 7. 音频存储容量计算：倍率（Bit Rate）

视频介绍 “倍率”（又称 “比特率”）的概念，用于计算每秒音频所需的存储容量，核心是 “样本数量” 与 “样本位” 的乘积。

### 7.1 倍率的定义

倍率是指：**每秒采样的样本数 × 每个样本的位数**，结果为 “每秒音频所需的二进制位数”，用于衡量音频的存储 / 传输开销。

### 7.2 倍率计算逻辑与示例（视频原话）

视频以 “常用采样率 40000 个 / 秒” 和 “样本位 16 位” 为例，详细计算：

1. 已知条件：
	- 每秒采样数：40000 个（1 秒内获取 40000 个样本点）
	- 每个样本位数：16 位（每个样本用 16 个二进制位存储）
2. 计算过程：
	- 每秒所需位数 = 每秒采样数 × 样本位 = 40000 × 16 = 640000 位 / 秒
	- 单位换算（视频简化计算）：640000 位 / 秒 ÷ 1000 = 640 KB / 秒（注：视频未严格按 1KB=1024 位换算，按视频原话计算）
3. 实际意义：
	- 若在线播放该音频，每秒需下载至少 640KB 数据（即需满足 640KB / 秒的网速），否则会卡顿；
	- 高音质音频（如未压缩的高清音乐）若样本位更高（如 24 位、32 位），则倍率更大，存储 / 传输开销更高。

## 8. 音频可视化与存储数据的对应关系

视频通过 “音频播放时的跳动波形”（如蓝色波形图），说明可视化效果与存储数据的关联：

- 波形的 “高低”：对应存储的 “样本值大小”。波形越高，说明该时间点的样本值越大（即声音音量越大、频率越高）；波形越低，样本值越小（音量越小、频率越低）。
- 波形的 “连续性”：本质是 “密集采样点” 的视觉呈现。虽然存储的是离散样本点，但因采样密度高（如 40000 个 / 秒），视觉上呈现为连续波形，与听觉感知的 “连续声音” 一致。



# 存储图像 - 光栅图核心知识点总结

## 一、图像存储的两大基础类型

计算机中存储的图像分为两类，本视频重点讲解第一类：

- **光栅图**：又称 “位图”（视频中明确别名），是通过采样和像素编码实现存储的图像类型（如照片、截图等）。
- 矢量图：本视频提及但未展开，说明 “放在下周讲”，暂不涉及。

## 二、光栅图的核心存储逻辑：采样与像素

由于图像是**空间变化的数据**（不随时间变化，与音频的 “时间变化数据” 本质区别），若存储所有空间点，数据量会异常庞大，因此需通过 “采样” 简化存储，具体流程如下：

### 1. 采样的定义与目的

- **定义**：通过 “扫描” 图像，从海量空间点中抽取部分点作为 “样本” 的过程（视频中强调 “扫描是采样的核心方式”）。
- **目的**：减少数据量，避免存储过载。
	- 示例（视频原文）：若图像有 50 万个空间点，采样后可能仅保留 5 万个点（或更少），大幅降低存储压力。

### 2. 采样的结果：像素（Pixel）

- **像素定义**：采样得到的 “样本点” 称为 “像素样本”，简称 “像素”，是光栅图的最小存储单元。
- **像素特性**：每个像素拥有 “单独的密度值”（视频原文），密度值决定该像素的颜色 / 亮度表现，大量像素组合形成完整图像。

## 三、光栅图的两个关键技术指标

### 1. 解析度（分辨率）

- **定义**：图像扫描处理时，“每英寸（或每单位空间）的方块 / 线条中记录的像素数量”（视频原文），本质是 “采样的密集程度”。
- **核心影响**：解析度越高，采样的像素数量越多，图像越清晰、无 “不连续感”；解析度越低，像素数量越少，图像易出现锯齿或模糊。
	- 示例（视频原文）：若对一张 “赵丽颖的图片” 仅采样 2 个像素，人眼完全无法识别图像内容；若采样点数足够多（如百万级），则能清晰呈现图像细节。

### 2. 色彩深度

- **定义**：表示单个像素颜色 / 亮度信息的 “二进制位数”（视频原文），即 “用多少位（bit）存储一个像素的色彩数据”。
- **常见位数**：8 位、16 位、24 位、32 位（视频中重点提及 24 位和 8 位，对应后续编码技术）。
- **核心影响**：位数越多，像素能表示的颜色范围越广；位数越少，颜色表现越单一。

## 四、RGB 三原色：光栅图的色彩基础

### 1. 原理（基于人眼感光特性）

- 视频明确：人眼的感光细胞仅对 “红（Red）、绿（Green）、蓝（Blue）” 三种颜色敏感，这三种颜色被称为 “三原色”。
- 核心规律：通过调整红、绿、蓝三种颜色的比例，可混合出 “人眼能感知的所有颜色”（如黄色、黑色、青色等，视频中举例 “青色由绿色 + 蓝色混合，红色为 0”）。

### 2. RGB 的取值范围（与色彩深度绑定）

- 当色彩深度为 “8 位 / 单颜色” 时（视频核心案例）：
	- 每种原色（R、G、B）的取值范围是 **0~255**（二进制 8 位的最大值为 2^8-1=255，视频原文强调 “0 到 255”）。
	- 示例（视频演示案例）：
		- 纯红色：R=255，G=0，B=0
		- 纯绿色：R=0，G=255，B=0
		- 青色：R=0，G=255，B=255
		- 纯黑色：R=0，G=0，B=0
		- 纯白色：R=255，G=255，B=255

## 五、光栅图的两种像素编码技术

### 1. 真彩色（True Color）：高质量色彩编码

- **定义**：用 24 位二进制数编码 1 个像素的色彩信息（视频原文 “24 位编码一个像素”），是光栅图的高质量编码方式。
- **位分配逻辑**：24 位均匀分配给 RGB 三原色，即 “R=8 位、G=8 位、B=8 位”（视频明确 “每三原色对应 8 位”）。
- **颜色总数计算**：每种原色有 2^8=256 种取值，因此总颜色数 = 256×256×256=16777216 种（约 1600 万种，视频原文 “超过 1600 万种颜色”）。
- **适用场景**：需要高质量色彩表现的图像（如数码相机照片、高清截图，视频举例 “高质量数码相机拍的 300 万像素照片”）。
- **存储量示例（视频计算）**：
	- 300 万像素的真彩色图像，总存储位数 = 300 万 × 24 位 = 7200 万位（或 900 万字节），存储占用较大。

### 2. 索映射（索引色，Indexed Color）：简化版色彩编码

- **定义**：真彩色的 “简化版”，从真彩色的 1600 万种颜色中 “抽取部分颜色” 组成 “颜色表”，像素仅存储 “颜色表中的索引” 而非完整 RGB 数据（视频原文 “从大的色彩集中选一部分”）。
- **核心特点**：
	- 颜色表规模：通常仅 256 种颜色（视频原文 “通常只需 256 种”），对应 8 位二进制数（2^8=256，视频强调 “8 位就能存 256 种颜色”）。
	- 存储优势：大幅减少存储量，仅为真彩色的 1/3（因 8 位是 24 位的 1/3）。
- **存储量示例（视频对比）**：
	- 同样 300 万像素的图像，索映射编码总存储位数 = 300 万 × 8 位 = 2400 万位（或 300 万字节），是真彩色存储量的 1/3。
- **适用场景**：对色彩要求不高的图像（如简单图标、低分辨率图形，视频提及 “满足部分应用程序的基本显示需求”）。

## 六、光栅图的常用编码标准

视频明确：光栅图的主流编码标准是 **JPG**（全称 “联合图像专家组”，视频原文 “用 JPG 编码标准对图像进行编码”），用于对采样后的像素数据进行压缩和存储（仅提及名称，未展开压缩细节）。



# 存储图像 - 矢量图核心知识点（基于视频内容）

## 1. 前提：光栅图（视频中口误提及 “关山图”“关东煮”，实际为光栅图）的缺点

视频通过分析光栅图的不足引出矢量图，明确其两大核心缺点：

- 缺点 1：文件体积大，存储占用空间高

	

	视频说明：光栅图以 “像素” 为存储单位，且每个像素需用 24 位数据表示（视频原话 “用 24 位来乘”）。例如存储一张 300 万像素的图像时，会因像素数量多、单像素位数高，导致需要极大的存储空间。

- 缺点 2：缩放后画质受损，出现模糊失真

	

	视频实操示例：

	1. 光栅图中的内容（如数字、图像中的 “土豆” 元素）缩小时，显示清晰；
	2. 一旦放大光栅图，内容会变得模糊、粗糙（视频反复强调 “放大后不清楚”“放大后看上去很粗糙”），本质是像素拉伸后无法还原细节，导致视觉失真。

## 2. 矢量图的核心原理

视频明确矢量图与光栅图的本质区别在于 “存储逻辑”，核心原理可拆解为两点：

- 2.1 存储单位：基础几何图形组合，而非像素

	

	矢量图不存储单个像素的 “位模式”（视频原话 “存的不是位模式”），而是将整个图像分解为 “基础几何图形的组合”。视频明确举例：分解后的元素包括

	线段、矩形、圆形

	等，例如一张简单的矢量图可能由多个 “特别小的圆”（视频原话）构成。

- 2.2 表示方式：数学公式描述，而非像素数据

	

	视频核心结论：所有基础几何图形（线段、矩形、圆形）均可通过数学公式精确表示，矢量图存储时仅需记录 “公式参数”，无需存储像素信息。

	

	视频具体示例：以 “圆” 为例，无需存储圆边缘所有像素，仅需记录两个核心参数 ——“圆心坐标” 和 “半径”，即可通过圆的数学公式（如标准方程：(x-a)²+(y-b)²=r²，视频未直接写方程，但明确参数逻辑）确定圆的完整形态。

## 3. 矢量图的关键特点：缩放不影响画质

视频反复强调矢量图的核心优势：调整图像大小（放大 / 缩小）时，不会改变图像质量，始终保持清晰。

- 背后原理：实时计算生成图像

	

	视频解释：由于矢量图存储的是 “数学公式及参数”，而非固定像素数据，当需要缩放时，计算机会基于原始参数 “实时重新计算” 图形形态（视频原话 “实时计算”“实时画”）。

	

	对比示例：

	- 光栅图放大：像素拉伸→模糊；
	- 矢量图放大：基于 “圆心坐标 + 半径” 重新计算圆的范围→生成的圆边缘平滑、清晰，无任何模糊或粗糙感。

## 4. 矢量图的典型用途（视频明确举例）

视频聚焦矢量图的核心应用场景：**计算机输入法字体 / 屏幕显示字体**

- 视频逻辑：
	1. 字体需频繁缩放（如调整文档字号、界面字体大小）；
	2. 若字体用光栅图存储，缩放后会模糊（符合光栅图缺点）；
	3. 矢量图存储的字体，因基于数学公式实时计算，无论放大（如超大号标题）或缩小（如正文小字），都能保持清晰（视频演示 “字体放大缩小无模糊” 的现象）。
- 适配原因：字体颜色需求简单（无需多种复杂颜色），且字体形态可通过 “线段、曲线” 等基础几何图形 + 数学公式精准描述，完全匹配矢量图的存储优势。

## 5. 光栅图与矢量图的核心对比（视频总结）

视频最后直接对比两者的优劣势，整理如下表：

| 对比维度   | 光栅图（视频口误 “关山图”）          | 矢量图                                              |
| ---------- | ------------------------------------ | --------------------------------------------------- |
| 存储内容   | 单个像素的 24 位数据（位模式）       | 几何图形参数 + 数学公式                             |
| 文件体积   | 大（300 万像素图像需极大空间）       | 小（仅存参数，无需像素数据）                        |
| 缩放后画质 | 受损、模糊、粗糙                     | 无影响，始终清晰                                    |
| 图像精细度 | 高（可存储照片等复杂图像的精细细节） | 低（视频原话 “没那么精细”，无法呈现照片级细腻质感） |
| 核心优势   | 精细度高，适合复杂图像（如照片）     | 缩放不失真，适合频繁调整大小的场景（如字体）        |
| 核心劣势   | 体积大、缩放失真                     | 精细度不足，不适合复杂图像                          |



# 视频存储核心知识点总结（基于本视频内容）

## 一、视频的本质构成：帧与图像序列

1. **帧的定义**：视频在每个时间点上的单张图片，是构成视频的最小单位，视频中明确强调 “每一个时间点上的一张图就是一帧”。
2. **胶片播放类比（视频核心原理示例）**：
	- 视频播放逻辑完全对应传统电影胶片的工作方式：胶片上印有连续的单张静态图片，胶片通过旋转（滚动）机制，将图片依次传递到 “灯光投射区域”。
	- 胶片滚动时，单张图片（帧）被灯光投射到白色荧屏上，由于图片内容连续且切换快速，视觉上形成 “动态图像”，这是视频能呈现运动效果的底层逻辑。
3. **视频的本质属性：空间 + 时间的结合**：
	- 空间信息：单张帧（图片）本身的内容，即图像的像素细节（如人物的位置、场景的色彩），对应 “静态视觉信息”。
	- 时间信息：帧的连续滚动（播放）顺序和速度，对应 “动态变化信息”。
	- 示例：快进效果的成因 —— 当帧的滚动速度（时间维度）加快时，人眼感知到图像运动速度同步变快，即日常使用的 “快进” 功能。

## 二、帧速率：决定视频流畅度的核心指标

1. **帧速率的定义**：单位时间内播放的帧数量，单位为 “帧 / 秒（fps）”，视频中重点聚焦 “75 帧 / 秒” 这一关键数值。
2. **帧速率与流畅度的关系（视频核心结论）**：
	- 高帧速率（如 75 帧 / 秒、60 帧 / 秒）：帧与帧的切换间隔极短，人眼无法分辨单张帧的边界，感知为 “无卡顿的连续动态图像”。
	- 低帧速率（如 2 帧 / 秒）：帧切换间隔长，人眼可清晰察觉单张帧的切换，呈现 “翻动 PPT” 的卡顿效果。
3. **视频中的关键结论**：帧速率需达到 75 帧 / 秒或更高，才能让视觉呈现 “无卡顿的动态效果”；低于 75 帧 / 秒时，易出现明显卡顿。

## 三、视频存储逻辑：与图像存储的共性及优化

1. **存储共性（核心逻辑）**：
	- 视频存储的本质是 “连续帧的组合存储”：由于单张帧（图片）在计算机中的存储方式（如二进制像素编码、模式存储）已明确，视频只需将 “按时间顺序排列的连续帧” 组合存储，其底层存储模式（二进制）与单张图像完全一致。
	- 示例：若已知 “一张高清图片以二进制模式存储于计算机”，则视频存储可理解为 “将 75 张相同规格的高清图片（对应 1 秒视频）按顺序拼接，以相同二进制模式存储”。
2. **存储痛点：为什么需要压缩？**
	- 未压缩视频体积巨大：以 75 帧 / 秒为例，每秒需存储 75 张图片，若每张图片为高清（高像素），1 秒视频的体积即等于 75 张高清图片的体积之和，长期存储或传输时成本极高。
3. **视频压缩与编码（视频提及技术）**：
	- 解决体积问题的核心方案：通过 “压缩技术” 减少冗余数据，并采用特定编码格式存储，视频中明确提及编码方式 ——**MPG 编码**，这是视频存储的核心编码格式之一。

## 四、视频清晰度的本质：帧的像素密度

1. **清晰度与像素的关系（视频核心解释）**：
	- 视频的 “标清、高清、蓝光” 等清晰度等级，本质由 “单张帧（图片）的像素密度” 决定：
		- 标清：单张帧的像素数量少（采样率低），视觉细节模糊（如人物面部轮廓不清晰）。
		- 高清 / 蓝光：单张帧的像素数量多（采样率高），视觉细节细腻（如人物发丝、场景纹理清晰可见）。
2. **清晰度与体积的权衡**：清晰度越高（帧像素越多），单张帧的存储体积越大，最终视频的整体体积也越大，需通过 MPG 压缩技术平衡 “清晰度” 与 “存储体积”。

## 五、视觉滞留原理：动态效果的生理基础

1. **原理定义**：人眼对光信号的感知存在 “延迟滞留特性”—— 当光信号消失后，人眼仍会短暂（约 0.1-0.4 秒）保留该光信号的视觉印象，不会立即感知黑暗。
2. **视频中的生活示例**：强光开关实验 —— 打开强光后迅速关闭，人眼不会立即看到黑暗，而是仍能短暂感知 “光亮”，这是视觉滞留的直接体现。
3. **与视频的关联**：视觉滞留是视频呈现动态效果的关键 —— 前一帧的视觉印象未消失时，后一帧已接续播放，两者在人眼中叠加，形成 “连续动态”，而非单张帧的割裂切换。

## 六、补充说明

- 本视频仅讲解视频存储的底层原理（帧、帧速率、存储逻辑、视觉滞留），未涉及任何计算机代码（如视频编码实现代码、帧存储代码片段），因此无相关代码可总结。



# 36. 逻辑运算 - 位层次 知识点总结

## 一、第四章数据运算整体框架（视频开篇概述）

视频明确第四章聚焦 “数据存储后的运算”，核心内容范围如下：

1. **三类核心运算**：
	- 逻辑运算（本视频重点讲 “位层次逻辑运算”，后续讲 “模式层次逻辑运算”）；
	- 移位运算（需区分 “逻辑移位” 与 “算术移位”，后续讲解）；
	- 算术运算（重点讲解两类，略讲一类）：
		- 二进制补码形式存储的整数的加法、减法运算（核心，必讲）；
		- 符号加绝对值形式存储的整数的加法、减法运算（略讲，原因：逻辑复杂、计算机中实际应用少）；
		- 浮点格式存储的实数的加法、减法运算（后续讲解）；
2. **不扩展内容**：不额外讲解整数 / 实数的乘法、除法运算，严格按教材范围展开；
3. **最终目标**：理解各类运算的逻辑，掌握教材要求的基础运算规则，后续延伸至实际应用。

## 二、逻辑运算基础概念（视频核心定义）

### 1. 逻辑运算的本质

逻辑运算是**应用于二进制位模式**的基本运算，分为两类：

- **位层次逻辑运算**：针对 “单个二进制位” 或 “两个模式中对应位置的单个二进制位” 的运算（本视频重点）；
- **模式层次逻辑运算**：针对 “n 位二进制位模式” 的运算，本质是 “对模式中 n 个对应二进制位分别执行相同的位层次逻辑运算”（n 为模式的位数，后续视频讲解）。

### 2. 二进制位的真假映射规则

计算机中用二进制位表示逻辑状态：

- 二进制位 `0` → 表示 “假”（False）；
- 二进制位 `1` → 表示 “真”（True）。

### 3. 布尔代数的作用

逻辑运算的数学基础是**布尔代数**：由数学家布尔提出，专门用于定义和操作 “真 / 假”（即 0/1）的逻辑关系，是计算机实现逻辑运算的理论依据。

## 三、位层次的四大基本逻辑运算（视频重点详解）

### 1. NOT（非运算）—— 一元运算符

#### （1）定义

- 仅需**1 个输入**（一元运算符）；
- 输出结果是 “输入的相反值”（即 “取反”）：输入为 0 则输出 1，输入为 1 则输出 0。

#### （2）真值表（输入→输出映射）

| 输入（X） | 输出（NOT X） |
| --------- | ------------- |
| 0         | 1             |
| 1         | 0             |

#### （3）示例（视频同步案例）

- 电子元件类比：输入 “低电压”（对应 0）→ 经过 NOT 元件 → 输出 “高电压”（对应 1）；输入 “高电压”（对应 1）→ 输出 “低电压”（对应 0）；
- 二进制位运算：`NOT 0 = 1`，`NOT 1 = 0`。

### 2. AND（与运算）—— 二元运算符

#### （1）定义

- 需**2 个输入**（二元运算符）；
- 仅当 “两个输入均为 1（真）” 时，输出才为 1（真）；其他 3 种情况（一真一假、两假）均输出 0（假）。

#### （2）真值表（输入 X、Y→输出映射）

| 输入 X | 输入 Y | 输出（X AND Y） |
| ------ | ------ | --------------- |
| 0      | 0      | 0               |
| 0      | 1      | 0               |
| 1      | 0      | 0               |
| 1      | 1      | 1               |

#### （3）示例（视频同步案例）

- 二进制位运算：`0 AND 0 = 0`，`0 AND 1 = 0`，`1 AND 0 = 0`，`1 AND 1 = 1`；
- 生活类比（视频丈母娘案例）：丈母娘要求 “有房且有车” 才同意结婚：
	- 没房（0）、没车（0）→ 不同意（0）；
	- 有房（1）、没车（0）→ 不同意（0）；
	- 没房（0）、有车（1）→ 不同意（0）；
	- 有房（1）、有车（1）→ 同意（1）。

### 3. OR（或运算）—— 二元运算符

#### （1）定义

- 需**2 个输入**（二元运算符）；
- 仅当 “两个输入均为 0（假）” 时，输出才为 0（假）；其他 3 种情况（一真一假、两真）均输出 1（真）（“只要有一个为真，结果就为真”）。

#### （2）真值表（输入 X、Y→输出映射）

| 输入 X | 输入 Y | 输出（X OR Y） |
| ------ | ------ | -------------- |
| 0      | 0      | 0              |
| 0      | 1      | 1              |
| 1      | 0      | 1              |
| 1      | 1      | 1              |

#### （3）示例（视频同步案例）

- 二进制位运算：`0 OR 0 = 0`，`0 OR 1 = 1`，`1 OR 0 = 1`，`1 OR 1 = 1`；
- 生活类比（视频丈母娘案例）：丈母娘放宽要求 “有房或有车” 就同意结婚：
	- 没房（0）、没车（0）→ 不同意（0）；
	- 有房（1）、没车（0）→ 同意（1）；
	- 没房（0）、有车（1）→ 同意（1）；
	- 有房（1）、有车（1）→ 同意（1）。

### 4. XOR（异或运算）—— 二元运算符

#### （1）定义

- 需**2 个输入**（二元运算符）；
- 当 “两个输入不同” 时（一真一假），输出为 1（真）；当 “两个输入相同” 时（两真或两假），输出为 0（假）。

#### （2）真值表（输入 X、Y→输出映射）

| 输入 X | 输入 Y | 输出（X XOR Y） |
| ------ | ------ | --------------- |
| 0      | 0      | 0               |
| 0      | 1      | 1               |
| 1      | 0      | 1               |
| 1      | 1      | 0               |

#### （3）示例（视频同步案例）

- 二进制位运算：`0 XOR 0 = 0`，`0 XOR 1 = 1`，`1 XOR 0 = 1`，`1 XOR 1 = 0`；
- 生活类比（视频丈母娘案例）：丈母娘提出 “奇怪要求”：仅当 “有房没车” 或 “没房有车” 时同意结婚，“两有” 或 “两无” 均不同意：
	- 没房（0）、没车（0）→ 不同意（0）；
	- 有房（1）、没车（0）→ 同意（1）；
	- 没房（0）、有车（1）→ 同意（1）；
	- 有房（1）、有车（1）→ 不同意（0）。

## 四、关键结论（视频强调内容）

1. 位层次逻辑运算的核心是 “对单个二进制位（或对应位）的真 / 假关系运算”，所有规则基于布尔代数；
2. 四大运算中，仅 NOT 是一元运算（操作 1 个二进制位），AND、OR、XOR 均为二元运算（操作 2 个二进制位）；
3. 后续 “模式层次逻辑运算” 是位层次运算的扩展（对 n 位模式的每一位执行相同位运算），需先掌握位层次规则。



# 逻辑运算 - 模式层次 知识点总结

## 一、模式层次逻辑运算的核心前提

模式层次逻辑运算是 “位层次逻辑运算” 的扩展，核心是对**n 位二进制串（模式）的每一位分别执行位逻辑运算**，运算前需满足以下前提：

1. **位数一致性要求**：参与双目运算（与、或、异或）的两个运算对象，必须是**相同位数（n 位）的二进制串**。
2. **位数不匹配处理**：若两个二进制串位数不同，需先将**位数较少的串高位补 0**，统一为 n 位后再运算（示例：3 位二进制串`101`需转为 4 位`0101`，才能与 4 位串运算）。
3. **运算结果形式**：运算输出结果为与输入同位数的 n 位二进制串，而非单纯的 “真 / 假”（区别于单一位的逻辑判断）。

## 二、四种模式层次逻辑运算（含视频示例）

所有运算均遵循 “**逐位处理**” 原则：对二进制串的每一位单独执行对应位逻辑运算，最终组合所有结果位形成输出串。

### 1. 非运算（NOT）—— 单目运算

#### 定义

仅需 1 个 n 位二进制串作为输入，对**每一位执行 “取反” 操作**，是唯一的单目模式逻辑运算。

#### 运算规则

- 输入位为`0` → 输出位为`1`
- 输入位为`1` → 输出位为`0`

#### 视频示例（n=8，8 位二进制串）

| 运算步骤             | 内容                                                         |
| -------------------- | ------------------------------------------------------------ |
| 输入（8 位二进制串） | `1 0 1 1 0 0 1 0`                                            |
| 逐位取反过程         | 第 1 位：1→0；第 2 位：0→1；第 3 位：1→0；第 4 位：1→0；第 5 位：0→1；第 6 位：0→1；第 7 位：1→0；第 8 位：0→1 |
| 输出（8 位二进制串） | `0 1 0 0 1 1 0 1`                                            |

### 2. 与运算（AND）—— 双目运算

#### 定义

需 2 个 n 位二进制串（A、B）作为输入，对**A 和 B 的对应位**分别执行 “与” 操作。

#### 运算规则（真值表）

仅当对应位**均为 1**时，结果位为 1；否则为 0：

- `1 & 1 = 1`
- `1 & 0 = 0`
- `0 & 1 = 0`
- `0 & 0 = 0`

#### 视频示例（n=8，8 位二进制串）

| 运算对象   | 8 位二进制串（按位对应）                                     |
| ---------- | ------------------------------------------------------------ |
| 输入 A     | `1 1 0 0 1 1 0 0`                                            |
| 输入 B     | `1 0 1 0 1 0 1 0`                                            |
| 逐位与运算 | 位 1：1&1=1；位 2：1&0=0；位 3：0&1=0；位 4：0&0=0；位 5：1&1=1；位 6：1&0=0；位 7：0&1=0；位 8：0&0=0 |
| 输出结果   | `1 0 0 0 1 0 0 0`                                            |

### 3. 或运算（OR）—— 双目运算

#### 定义

需 2 个 n 位二进制串（A、B）作为输入，对**A 和 B 的对应位**分别执行 “或” 操作。

#### 运算规则（真值表）

只要对应位**有 1**，结果位为 1；仅当均为 0 时为 0：

- `1 | 1 = 1`
- `1 | 0 = 1`
- `0 | 1 = 1`
- `0 | 0 = 0`

#### 视频示例（n=8，8 位二进制串）

| 运算对象   | 8 位二进制串（按位对应） |              |              |              |              |              |              |              |      |
| ---------- | ------------------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ---- |
| 输入 A     | `1 1 0 0 1 1 0 0`        |              |              |              |              |              |              |              |      |
| 输入 B     | `1 0 1 0 1 0 1 0`        |              |              |              |              |              |              |              |      |
| 逐位或运算 | 位 1：1                  | 1=1；位 2：1 | 0=1；位 3：0 | 1=1；位 4：0 | 0=0；位 5：1 | 1=1；位 6：1 | 0=1；位 7：0 | 1=1；位 8：0 | 0=0  |
| 输出结果   | `1 1 1 0 1 1 1 0`        |              |              |              |              |              |              |              |      |

### 4. 异或运算（XOR）—— 双目运算（含视频错误纠正）

#### 定义

需 2 个 n 位二进制串（A、B）作为输入，对**A 和 B 的对应位**分别执行 “异或” 操作。

#### 运算规则（真值表）

对应位**不同**时，结果位为 1；对应位**相同**时，结果位为 0：

- `1 ^ 1 = 0`
- `1 ^ 0 = 1`
- `0 ^ 1 = 1`
- `0 ^ 0 = 0`

#### 视频中的错误纠正

视频指出：某参考材料中异或运算的某一位结果错误（示例：若 A 的某一位为`0`、B 对应位也为`0`，正确结果应为`0`，但材料误写为`1`），需以真值表为准。

#### 视频示例（n=8，8 位二进制串，含错误纠正）

| 运算对象                 | 8 位二进制串（按位对应）                                     |
| ------------------------ | ------------------------------------------------------------ |
| 输入 A                   | `0 1 0 1 0 1 0 1`                                            |
| 输入 B                   | `0 1 1 1 0 0 0 1`                                            |
| 逐位异或运算（纠正错误） | 位 1：0^0=0（纠正：非 1）；位 2：1^1=0；位 3：0^1=1；位 4：1^1=0；位 5：0^0=0；位 6：1^0=1；位 7：0^0=0；位 8：1^1=0 |
| 输出结果（纠正后）       | `0 0 1 0 0 1 0 0`                                            |



# 逻辑运算的应用 —— 复位操作

## 1. 复位的核心概念

- 定义：对二进制数（原始数）中**指定的位**进行固定值设置的操作，需通过 “原始数 + 掩码（Mask）” 配合二元逻辑运算实现（仅需 1 个操作数的运算无法实现）
- 复位目标分类：根据逻辑运算类型，复位可分为 “复位为 0”“复位为 1”“复位为原位置反” 三类
- 关键前提：必须包含两个操作数 —— 待处理的 “原始数”、用于控制复位范围的 “掩码”

## 2. 非运算（NOT）：无法实现复位

### 2.1 核心原因

- 非运算规则：仅需 1 个操作数，功能是对二进制数的**所有位**进行取反（如 `1→0`、`0→1`）
- 局限性：无法针对 “指定的位” 进行选择性复位（要么全取反，要么不操作），不符合 “指定位复位” 的需求
- 结论：非运算无复位能力，不用于复位场景

## 3. 与运算（AND）：复位为 0

### 3.1 核心逻辑

- 与运算规则：`1 AND 1 = 1`、`1 AND 0 = 0`、`0 AND 1 = 0`、`0 AND 0 = 0`（全 1 为 1，有 0 为 0）
- 复位原理：通过掩码的 “0/1” 控制原始数各位的最终值 ——
	- 需**复位为 0**的位：掩码对应位设为`0`（无论原始数该位是 0 还是 1，运算后均为 0）
	- 需**保留原始值**的位：掩码对应位设为`1`（运算后与原始数该位值完全一致）
- 复位目标：将原始数指定位强制设为 0，其余位保留原值

### 3.2 视频示例（8 位二进制数操作）

#### 示例条件

- 原始数（8 位）：`10110101`（前 5 位：`10110`，后 3 位：`101`）
- 需求：前 5 位复位为 0，后 3 位保留原始值
- 掩码设计：前 5 位设`0`（控制复位），后 3 位设`1`（控制保留）→ 掩码为 `00000111`

#### 运算过程

| 步骤 | 数据类型 | 8 位二进制值                   | 说明                                 |
| ---- | -------- | ------------------------------ | ------------------------------------ |
| 1    | 原始数   | 10110101                       | 待处理的二进制数                     |
| 2    | 掩码     | 00000111                       | 前 5 位 0（复位），后 3 位 1（保留） |
| 3    | AND 运算 | 10110101 & 00000111 = 00000101 | 前 5 位均为 0，后 3 位与原始数一致   |

#### 运算结果

- 最终值：`00000101`（前 5 位复位为 0，后 3 位保留原始值`101`）

### 3.3 代码示例（与视频逻辑一致，C 语言）

c







```c
#include <stdio.h>
int main() {
    // 原始数：10110101（二进制）= 181（十进制），用unsigned char存储8位数据
    unsigned char original = 0xB5;  // 0xB5 是10110101的十六进制表示
    // 掩码：00000111（二进制）= 7（十进制），前5位0，后3位1
    unsigned char mask = 0x07;      
    // AND运算实现“复位为0”
    unsigned char result = original & mask;
    
    // 二进制格式输出（便于观察位变化）
    printf("原始数（二进制）：");
    for (int i = 7; i >= 0; i--) {  // 从最高位（第7位）到最低位（第0位）输出
        printf("%d", (original >> i) & 1);
    }
    printf("\n掩码（二进制）：   ");
    for (int i = 7; i >= 0; i--) {
        printf("%d", (mask >> i) & 1);
    }
    printf("\nAND结果（二进制）：");
    for (int i = 7; i >= 0; i--) {
        printf("%d", (result >> i) & 1);
    }
    // 十进制验证（00000101 = 5）
    printf("\n结果（十进制）：%d\n", result);
    return 0;
}
```

#### 运行结果

plaintext







```plaintext
原始数（二进制）：10110101
掩码（二进制）：   00000111
AND结果（二进制）：00000101
结果（十进制）：5
```

## 4. 或运算（OR）：复位为 1

### 4.1 核心逻辑

- 或运算规则：`1 OR 1 = 1`、`1 OR 0 = 1`、`0 OR 1 = 1`、`0 OR 0 = 0`（有 1 为 1，全 0 为 0）
- 复位原理：通过掩码的 “0/1” 控制原始数各位的最终值 ——
	- 需**复位为 1**的位：掩码对应位设为`1`（无论原始数该位是 0 还是 1，运算后均为 1）
	- 需**保留原始值**的位：掩码对应位设为`0`（运算后与原始数该位值完全一致）
- 复位目标：将原始数指定位强制设为 1，其余位保留原值

### 4.2 视频示例（8 位二进制数操作）

#### 示例条件

- 原始数（8 位）：`10110101`（前 5 位：`10110`，后 3 位：`101`）
- 需求：前 5 位复位为 1，后 3 位保留原始值
- 掩码设计：前 5 位设`1`（控制复位），后 3 位设`0`（控制保留）→ 掩码为 `11111000`

#### 运算过程

| 步骤 | 数据类型 | 8 位二进制值 | 说明                                 |                                    |
| ---- | -------- | ------------ | ------------------------------------ | ---------------------------------- |
| 1    | 原始数   | 10110101     | 待处理的二进制数                     |                                    |
| 2    | 掩码     | 11111000     | 前 5 位 1（复位），后 3 位 0（保留） |                                    |
| 3    | OR 运算  | 10110101     | 11111000 = 11111101                  | 前 5 位均为 1，后 3 位与原始数一致 |

#### 运算结果

- 最终值：`11111101`（前 5 位复位为 1，后 3 位保留原始值`101`）

### 4.3 代码示例（与视频逻辑一致，C 语言）

c







```c
#include <stdio.h>
int main() {
    // 原始数：10110101（二进制）= 181（十进制）
    unsigned char original = 0xB5;  
    // 掩码：11111000（二进制）= 248（十进制），前5位1，后3位0
    unsigned char mask = 0xF8;      
    // OR运算实现“复位为1”
    unsigned char result = original | mask;
    
    // 二进制格式输出
    printf("原始数（二进制）：");
    for (int i = 7; i >= 0; i--) {
        printf("%d", (original >> i) & 1);
    }
    printf("\n掩码（二进制）：   ");
    for (int i = 7; i >= 0; i--) {
        printf("%d", (mask >> i) & 1);
    }
    printf("\nOR结果（二进制）： ");
    for (int i = 7; i >= 0; i--) {
        printf("%d", (result >> i) & 1);
    }
    // 十进制验证（11111101 = 253）
    printf("\n结果（十进制）：%d\n", result);
    return 0;
}
```

#### 运行结果

plaintext







```plaintext
原始数（二进制）：10110101
掩码（二进制）：   11111000
OR结果（二进制）： 11111101
结果（十进制）：253
```

## 5. 异或运算（XOR）：复位为取反

### 5.1 核心逻辑

- 异或运算规则：`1 XOR 1 = 0`、`1 XOR 0 = 1`、`0 XOR 1 = 1`、`0 XOR 0 = 0`（相同为 0，不同为 1）
- 复位原理：通过掩码的 “0/1” 控制原始数各位的最终值 ——
	- 需**复位为取反**的位：掩码对应位设为`1`（原始数该位为 0 则运算后为 1，为 1 则为 0）
	- 需**保留原始值**的位：掩码对应位设为`0`（运算后与原始数该位值完全一致）
- 复位目标：将原始数指定位强制取反，其余位保留原值

### 5.2 视频示例（8 位二进制数操作）

#### 示例条件

- 原始数（8 位）：`10110101`（前 5 位：`10110`，后 3 位：`101`）
- 需求：前 5 位取反（复位为反值），后 3 位保留原始值
- 掩码设计：前 5 位设`1`（控制取反），后 3 位设`0`（控制保留）→ 掩码为 `11111000`

#### 运算过程

| 步骤 | 数据类型 | 8 位二进制值                   | 说明                                            |
| ---- | -------- | ------------------------------ | ----------------------------------------------- |
| 1    | 原始数   | 10110101                       | 待处理的二进制数，前 5 位为`10110`              |
| 2    | 掩码     | 11111000                       | 前 5 位 1（取反），后 3 位 0（保留）            |
| 3    | XOR 运算 | 10110101 ^ 11111000 = 01001101 | 前 5 位取反（10110→01001），后 3 位与原始数一致 |

#### 运算结果

- 最终值：`01001101`（前 5 位取反为`01001`，后 3 位保留原始值`101`）

### 5.3 代码示例（与视频逻辑一致，C 语言）

c







```c
#include <stdio.h>
int main() {
    // 原始数：10110101（二进制）= 181（十进制）
    unsigned char original = 0xB5;  
    // 掩码：11111000（二进制）= 248（十进制），前5位1，后3位0
    unsigned char mask = 0xF8;      
    // XOR运算实现“复位为取反”
    unsigned char result = original ^ mask;
    
    // 二进制格式输出
    printf("原始数（二进制）：");
    for (int i = 7; i >= 0; i--) {
        printf("%d", (original >> i) & 1);
    }
    printf("\n掩码（二进制）：   ");
    for (int i = 7; i >= 0; i--) {
        printf("%d", (mask >> i) & 1);
    }
    printf("\nXOR结果（二进制）：");
    for (int i = 7; i >= 0; i--) {
        printf("%d", (result >> i) & 1);
    }
    // 十进制验证（01001101 = 77）
    printf("\n结果（十进制）：%d\n", result);
    return 0;
}
```

#### 运行结果

plaintext







```plaintext
原始数（二进制）：10110101
掩码（二进制）：   11111000
XOR结果（二进制）：01001101
结果（十进制）：77
```

## 6. 掩码设计的核心原则（视频总结）

- 掩码是实现 “指定位复位” 的关键，需根据**复位目标**和**逻辑运算规则**反向设计
- 通用设计表（以 8 位二进制数为例）：

| 逻辑运算 | 复位目标       | 需操作位的掩码值 | 需保留位的掩码值 | 示例掩码（前 5 位操作，后 3 位保留） |
| -------- | -------------- | ---------------- | ---------------- | ------------------------------------ |
| AND      | 复位为 0       | 0                | 1                | 00000111（前 5 位 0，后 3 位 1）     |
| OR       | 复位为 1       | 1                | 0                | 11111000（前 5 位 1，后 3 位 0）     |
| XOR      | 复位为原位置反 | 1                | 0                | 11111000（前 5 位 1，后 3 位 0）     |

- 本质：通过掩码的 “0/1” 控制逻辑运算对原始数各位的 “修改 / 保留”，实现精准的位操作



# 移位运算知识点总结

## 一、移位运算基本概念

- 定义：将位模式中的位进行**位置改变**（仅支持向左移或向右移），通过位的位置调整实现数据操作（如乘 2、除 2、提取特定位等）。
- 核心分类：根据处理对象（无符号数 / 有符号数）分为两大类 ——**逻辑移位运算**和**算术移位运算**。

## 二、逻辑移位运算

### 1. 核心特性

- 适用场景：仅用于**无符号数**（因移位过程可能改变符号，逻辑移位不处理符号保留逻辑）。
- 通用规则：移位后空出的位用**0**填充；移出位直接**丢弃**（循环移位除外，无丢弃）。
- 细分类型：包含 “简单逻辑移位” 和 “循环移位” 两种。

### 2. 简单逻辑移位（左移 / 右移）

#### （1）逻辑左移

- 操作规则：位模式整体向左移动`n`位（视频以`n=1`为例），**最左侧`n`位直接丢弃**，**最右侧空出的`n`位补 0**。
- 视频示例（8 位无符号位模式）：
	- 原位模式（无符号数）：`10110010`（十进制值：178）
	- 逻辑左移 1 位过程：
		1. 丢弃最左侧的最高位 “1”；
		2. 最右侧空出的 1 位补 “0”；
	- 结果位模式：`01100100`（十进制值：100）
- 本质：左移 1 位等价于无符号数**乘 2**（若未丢弃有效高位，如`00110010`（50）左移 1 位得`01100100`（100），即 50×2）。

#### （2）逻辑右移

- 操作规则：位模式整体向右移动`n`位（视频以`n=1`为例），**最右侧`n`位直接丢弃**，**最左侧空出的`n`位补 0**。
- 视频示例（8 位无符号位模式）：
	- 原位模式（无符号数）：`10110010`（十进制值：178）
	- 逻辑右移 1 位过程：
		1. 丢弃最右侧的最低位 “0”；
		2. 最左侧空出的 1 位补 “0”；
	- 结果位模式：`01011001`（十进制值：89）
- 本质：右移 1 位等价于无符号数**除以 2**（整数除法，丢弃小数部分，如 178÷2=89）。

### 3. 循环移位（左移 / 右移）

- 核心区别：无位丢弃、无位新增，**移出的位直接补到空出的位置**，形成 “循环闭环”（视频强调 “没有位被丢弃或增加”）。

#### （1）循环左移

- 操作规则：位模式整体向左移动`n`位，**最左侧`n`位依次移出**，并按移出顺序补到**最右侧空出的`n`位**。
- 视频示例（8 位无符号位模式）：
	- 原位模式：`10110010`
	- 循环左移 1 位过程：
		1. 最左侧高位 “1” 移出；
		2. 将移出的 “1” 补到最右侧空出位；
	- 结果位模式：`01100101`

#### （2）循环右移

- 操作规则：位模式整体向右移动`n`位，**最右侧`n`位依次移出**，并按移出顺序补到**最左侧空出的`n`位**。
- 视频示例（8 位无符号位模式）：
	- 原位模式：`10110011`（注意：选择移出位为 1 的模式，体现与逻辑右移的区别）
	- 循环右移 1 位过程：
		1. 最右侧低位 “1” 移出；
		2. 将移出的 “1” 补到最左侧空出位；
	- 结果位模式：`11011001`（对比逻辑右移结果`01011001`，差异明显）

## 三、算术移位运算

### 1. 核心特性

- 适用场景：用于**有符号数**（位模式必须以**二进制补码**格式表示，视频强调 “假定位模式是二进制补码”）。
- 核心目的：实现有符号数的**乘 2（左移）** 或**除 2（右移）** 运算，且右移时强制保留符号。
- 关键规则：符号位（补码最左侧第一位，0 = 正数，1 = 负数）需特殊处理，避免符号错误或判断溢出。

### 2. 算术右移

- 操作规则：位模式整体向右移动`n`位，**最右侧`n`位丢弃**，**最左侧空出的`n`位补原符号位**（确保符号不变，视频核心规则）。
- 视频示例（8 位二进制补码，有符号数）：
	- 原位模式（补码）：`10011011`（十进制值：-103，视频明确给出）
		- 补码转十进制验证：符号位 1（负数）→ 反码 = 补码 - 1=`10011010` → 原码 = 反码取反 =`01100101`（值 101）→ 原数 =-101？修正：视频明确 “原数 - 103，移位后 - 52”，原模式应为`10011011`（补码计算：-103 = 256 - 103 = 153 → 153 二进制`10011001`？此处以视频描述为准，重点保留视频示例关系）
	- 算术右移 1 位过程：
		1. 最右侧低位 “1” 丢弃；
		2. 最左侧空出位补原符号位 “1”；
	- 结果位模式（补码）：`11001101`（十进制值：-52，视频明确给出）
		- 补码转十进制验证：符号位 1（负数）→ 反码 =`11001100` → 原码 =`00110011`（值 51）→ 结果 =-52（计算机整数除法：-103÷2=-51.5，取整为 - 52）
- 本质：右移 1 位等价于有符号数**除以 2**（整数除法，丢弃小数部分，符号不变）。

### 3. 算术左移

- 操作规则：位模式整体向左移动`n`位，**最左侧`n`位丢弃**，**最右侧空出的`n`位补 0**；需判断溢出 —— 若**原符号位≠新符号位**，则溢出（结果无效，视频重点）。
- 视频示例 1（溢出案例，8 位补码）：
	- 原位模式（补码）：`01111111`（十进制值：127，8 位补码最大正数）
	- 算术左移 1 位过程：
		1. 最左侧符号位 “0” 丢弃；
		2. 最右侧空出位补 “0”；
	- 结果位模式（补码）：`11111110`（十进制值：-2，视频明确给出）
	- 溢出判断：原符号位 0 ≠ 新符号位 1 → 发生溢出（理论 127×2=254，8 位补码无法表示，结果无效）
- 视频示例 2（无溢出案例，8 位补码）：
	- 原位模式（补码）：`11001101`（十进制值：-52，视频隐含）
	- 算术左移 1 位过程：
		1. 最左侧符号位 “1” 丢弃；
		2. 最右侧空出位补 “0”；
	- 结果位模式（补码）：`10011010`（十进制值：-106）
	- 溢出判断：原符号位 1 = 新符号位 1 → 无溢出（本质：-52×2=-104？此处以视频 “左移等价乘 2” 逻辑为准，重点保留溢出判断规则）

## 四、移位运算的实际应用（视频示例）

### 需求：提取 8 位无符号位模式中 “倒数第三位” 的值（即从右数第 3 位，值为 0 或 1）

### 实现步骤（视频演示流程）

#### 1. 步骤 1：逻辑右移 2 位（将目标位移到最右侧）

- 原位模式（无符号）：`10110010`（视频示例模式，倒数第三位为 “0”）
- 逻辑右移 2 位过程：最右侧 2 位 “10” 丢弃，最左侧补 0 → 结果模式：`00101100`（此时原倒数第三位 “0” 移动到最右侧第 1 位）

#### 2. 步骤 2：与掩码`00000001`做 AND 运算（保留目标位）

- 运算逻辑：AND 运算仅当两位均为 1 时结果 1，否则 0，用`00000001`可保留最右侧 1 位（目标位），其余位清 0。

- 运算过程（视频展示）：

	plaintext

	```plaintext
	00101100  （右移2位后的模式）
	```

	

AND 00000001 （掩码：仅保留最右侧 1 位）

———————————

00000000 （运算结果）

plaintext

```plaintext
- 结论：结果为0，即原位模式的倒数第三位值为0（与视频预期一致）。
```



# 算术移位与乘 2、除 2（二进制）知识点总结

## 1. 算术移位的核心规则（二进制）

视频明确核心结论：**在二进制算术移位中，左移 1 位等价于 “乘 2”，右移 1 位等价于 “除 2”**，但该规律的生效前提是**不发生溢出**。

- 适用场景：针对二进制整数（视频中涵盖无符号整数、补码表示的负数）；
- 计算机除法特性：右移实现的 “除 2” 为**整数除法**，直接丢弃小数部分，不进行四舍五入。

## 2. 左移 1 位 → 实现 “乘 2”（不溢出前提）

### 2.1 操作逻辑

- 二进制左移 1 位时：**低位补 0，高位保留（不丢弃）**（因不溢出，高位符号 / 数值位无丢失）；
- 本质：二进制数每左移 1 位，各数位权重翻倍（×2¹），整体数值 ×2。

### 2.2 视频中的正数示例（4 位二进制）

#### 示例：3 × 2 = 6

1. 原始二进制（正数）：`0011`（对应十进制 3，计算：0×2³ + 0×2² + 1×2¹ + 1×2⁰ = 3）；
2. 左移 1 位操作：`0011 << 1` → 低位补 0，结果为 `0110`；
3. 结果验证：`0110` 对应十进制 6（0×2³ + 1×2² + 1×2¹ + 0×2⁰ = 6），与 3×2=6 完全一致，符合 “左移乘 2” 规律。

### 2.3 代码示例（C 语言，模拟左移乘 2）

c







```c
#include <stdio.h>
int main() {
    // 视频中4位二进制正数 0011（十进制3）左移乘2
    int positive_num = 3;  // 二进制：0011（简化表示，实际计算机中为32位/64位）
    int left_shift_result = positive_num << 1;  // 左移1位，等价于×2
    
    printf("原始数值：%d（二进制：0011）\n", positive_num);
    printf("左移1位后：%d（二进制：0110）\n", left_shift_result);
    printf("验证规律：%d × 2 = %d\n", positive_num, left_shift_result);
    
    return 0;
}
// 输出结果：
// 原始数值：3（二进制：0011）
// 左移1位后：6（二进制：0110）
// 验证规律：3 × 2 = 6
```

## 3. 右移 1 位 → 实现 “除 2”（整数除法）

### 3.1 操作逻辑

- 二进制右移 1 位时：**高位补 0（正数），低位直接丢弃**；
- 本质：二进制数每右移 1 位，各数位权重减半（×2⁻¹），因计算机整数除法特性，直接丢弃小数部分。

### 3.2 视频中的 3 个核心示例（4 位二进制）

#### 示例 1：3 ÷ 2 = 1（非整除，丢小数）

1. 原始二进制：`0011`（十进制 3）；
2. 右移 1 位操作：`0011 >> 1` → 低位 1 丢弃，高位补 0，结果为 `0001`；
3. 结果验证：`0001` 对应十进制 1，3÷2 为整数除法，丢弃小数 0.5，结果为 1，符合 “右移除 2” 规律。

#### 示例 2：4 ÷ 2 = 2（整除，无小数）

1. 原始二进制：`0100`（十进制 4）；
2. 右移 1 位操作：`0100 >> 1` → 低位 0 丢弃，高位补 0，结果为 `0010`；
3. 结果验证：`0010` 对应十进制 2，4÷2=2，无小数，结果准确。

#### 示例 3：5 ÷ 2 = 2（非整除，丢小数）

1. 原始二进制：`0101`（十进制 5）；
2. 右移 1 位操作：`0101 >> 1` → 低位 1 丢弃，高位补 0，结果为 `0010`；
3. 结果验证：`0010` 对应十进制 2，5÷2 为整数除法，丢弃小数 0.5，结果为 2。

### 3.3 代码示例（C 语言，模拟右移除 2）

c







```c
#include <stdio.h>
int main() {
    // 示例1：3 ÷ 2 = 1
    int num1 = 3;  // 二进制：0011
    int right1 = num1 >> 1;
    printf("1. %d（0011）右移1位：%d（0001），%d ÷ 2 = %d\n", num1, right1, num1, right1);
    
    // 示例2：4 ÷ 2 = 2
    int num2 = 4;  // 二进制：0100
    int right2 = num2 >> 1;
    printf("2. %d（0100）右移1位：%d（0010），%d ÷ 2 = %d\n", num2, right2, num2, right2);
    
    // 示例3：5 ÷ 2 = 2
    int num3 = 5;  // 二进制：0101
    int right3 = num3 >> 1;
    printf("3. %d（0101）右移1位：%d（0010），%d ÷ 2 = %d\n", num3, right3, num3, right3);
    
    return 0;
}
// 输出结果：
// 1. 3（0011）右移1位：1（0001），3 ÷ 2 = 1
// 2. 4（0100）右移1位：2（0010），4 ÷ 2 = 2
// 3. 5（0101）右移1位：2（0010），5 ÷ 2 = 2
```

## 4. 十进制移位类比（视频核心理解技巧）

视频通过 “十进制移位规律” 类比二进制移位，帮助降低理解难度，核心对应关系如下表：

| 移位方向  | 十进制操作（补 0 / 丢位） | 十进制效果（乘 / 除） | 二进制操作（补 0 / 丢位）  | 二进制效果（乘 / 除） |
| --------- | ------------------------- | --------------------- | -------------------------- | --------------------- |
| 左移 1 位 | 低位补 0（如 14 → 140）   | 乘 10（14×10=140）    | 低位补 0（如 0011 → 0110） | 乘 2（3×2=6）         |
| 右移 1 位 | 低位丢弃（如 14 → 1）     | 除 10（14÷10=1）      | 低位丢弃（如 0011 → 0001） | 除 2（3÷2=1）         |

### 十进制类比示例（视频提及）

- 左移：十进制数 `14` 左移 1 位 → 补 0 为 `140`，14×10=140；
- 右移：十进制数 `14` 右移 1 位 → 丢低位为 `1`，14÷10=1（整数除法，丢小数）。

## 5. 溢出问题（左移乘 2 的关键限制）

视频强调：**“左移乘 2” 的规律仅在 “不溢出” 时生效**，若左移导致符号位改变或数值超出位数范围，结果会完全错误。

### 5.1 视频中的溢出案例（4 位补码负数）

#### 步骤 1：确定补码对应的十进制数

- 补码（4 位）：`1001`（视频明确为负数补码）；
- 补码转原码：负数补码 → 原码 = 补码 “取反 + 1”（视频表述为 “取范加一”，核心逻辑一致）；
	- 补码 `1001` 取反 → `0110`；
	- `0110 + 1 = 0111`？视频字幕修正：最终对应十进制 `-5`（视频结论，以视频表述为准）。

#### 步骤 2：补码左移 1 位操作

- 补码 `1001` 左移 1 位 → 高位 1 丢弃，低位补 0，结果为 `0110`；
- `0110` 是正数补码，对应十进制 `6`。

#### 步骤 3：验证溢出

- 理论结果：`-5 × 2 = -10`；
- 实际结果：左移后得到 `6`，与理论结果完全不符；
- 溢出原因：4 位补码中，负数符号位为 1，左移后符号位变为 0（正数），数值超出 4 位补码的表示范围，导致规律失效。

### 5.2 溢出核心结论

- 溢出判断（整数）：左移后**符号位发生改变**（如负数→正数、正数→负数），即判定为溢出；
- 后果：溢出时 “左移乘 2” 规律失效，计算结果错误；右移因数值范围缩小，一般不会溢出（视频未提及右移溢出）。

## 6. 视频核心知识点总结

1. **移位与乘除关系**：二进制左移 1 位 =×2，右移 1 位 =÷2（整数除法，丢小数）；
2. **操作细节**：左移补 0（低位），右移丢低位（正数补 0 高位）；
3. **前提条件**：左移必须 “不溢出”，溢出会导致结果错误（如负数补码左移变正数）；
4. **理解技巧**：用十进制移位类比（左移 ×10、右移 ÷10），快速掌握逻辑；
5. **计算机除法特性**：右移除 2 时，无论是否整除，均丢弃小数部分（如 3÷2=1、5÷2=2）。



# 计算机算术运算（二进制补码实现）

## 一、核心概念区分：算术运算 vs 算术移位

视频明确区分两者差异，核心区别如下：

- **算术移位**：对二进制数进行左移 / 右移操作（如左移乘 2、右移除 2），仅单一数值的位置变化；
- **算术运算**：对两个二进制数进行**加减乘除**（本视频仅讲加减，因乘除复杂度高），适用于整数和浮点数，核心依赖**二进制补码**实现。

## 二、算术运算的核心原理：二进制补码

### 2.1 补码的核心作用

计算机中无独立减法器，通过补码可将**减法转换为加法**（`a - b = a + (-b)`），仅需一个加法器即可实现加减运算。

### 2.2 补码与反码的关系

- 反码：对二进制数每一位取反（0 变 1、1 变 0），记为 “b̅”（b 的反码）；
- 补码：反码加 1（即 `b的补码 = b̅ + 1`）；
- 负数的表示：计算机中负数以其绝对值的补码形式存储（如 - 17 的补码 = 17 的补码取反加 1）。

### 2.3 运算流程

视频提及的算术运算流程图逻辑：

1. 输入两个二进制数 `a`（被操作数）、`b`（操作数），结果为 `r`；
2. 若为**加法**：直接计算 `r = a的补码 + b的补码`；
3. 若为**减法**：先求 `b的补码`，再计算 `r = a的补码 + b的补码`（即 `a - b = a + (-b)`，`-b` 用 `b的补码` 表示）。

## 三、加法运算（补码加法）

### 3.1 加法运算规则

1. 将两个数转换为**相同位数的二进制补码**（本视频统一用 8 位补码示例）；
2. 按二进制加法规则逐位相加（逢 2 进 1）；
3. 若结果超出位数（如 8 位相加得 9 位），**舍弃最高位的进位**（不影响结果正确性，除非溢出）；
4. 将最终补码结果转换为十进制，验证正确性。

### 3.2 示例 1：两个正数补码相加（17 + 22 = 39）

1. 十进制转 8 位补码：

	- 17（正数，补码 = 原码）：`00010001`
	- 22（正数，补码 = 原码）：`00010110`

2. 补码加法计算：

	plaintext

	

	

	

	```plaintext
	  00010001  （17的补码）
	+ 00010110  （22的补码）
	----------
	  00100111  （无进位，直接相加）
	```

	

3. 结果转换：`00100111` 是正数（最高位 0），转十进制为 `39`，与预期一致。

### 3.3 示例 2：正数与负数补码相加（24 + (-17) = 7）

1. 十进制转 8 位补码：

	- 24（正数）：`00011000`
	- -17（负数，补码 = 17 的补码取反加 1）：17 的补码是`00010001`，取反`11101110`，加 1 得`11101111`

2. 补码加法计算（含进位舍弃）：

	plaintext

	

	

	

	```plaintext
	  00011000  （24的补码）
	+ 11101111  （-17的补码）
	----------
	1 00000111  （相加得9位，舍弃最高位1）
	  00000111  （最终结果补码）
	```

	

3. 结果转换：`00000111` 转十进制为 `7`，与预期（24-17=7）一致。

## 四、减法运算（补码减法转加法）

### 4.1 减法运算规则

核心逻辑：`a - b = a + (-b)`，其中 `-b` 用 `b的补码` 表示，步骤如下：

1. 将 `a`、`b` 转换为 8 位补码；
2. 求 `b的补码`（若 `b` 为负数，其补码已存在；若 `b` 为正数，补码 = 原码取反加 1）；
3. 计算 `a的补码 + b的补码`，舍弃超出 8 位的进位；
4. 补码结果转十进制，验证正确性。

### 4.2 示例 1：正数减负数（24 - (-17) = 41）

1. 十进制转 8 位补码：

	- `a=24`：`00011000`
	- `b=-17`：`11101111`（已为补码），求 `b的补码`（即 `-b=17` 的补码）：`11101111` 取反 `00010000`，加 1 得 `00010001`

2. 补码加法计算（减法转加法）：

	plaintext

	

	

	

	```plaintext
	  00011000  （24的补码）
	+ 00010001  （b的补码，即17的补码）
	----------
	  00101001  （无进位）
	```

	

3. 结果转换：`00101001` 转十进制为 `41`，与预期（24 + 17 = 41）一致。

### 4.3 示例 2：负数减正数（-35 - 20 = -55）

1. 十进制转 8 位补码：

	- `a=-35`：35 的补码是`00100011`，取反`11011100`，加 1 得`11011101`
	- `b=20`：`00010100`（正数补码），求 `b的补码`（即 `-20` 的补码）：`00010100` 取反 `11101011`，加 1 得 `11101100`

2. 补码加法计算（含进位舍弃）：

	plaintext

	

	

	

	```plaintext
	  11011101  （-35的补码）
	+ 11101100  （b的补码，即-20的补码）
	----------
	1 11001001  （相加得9位，舍弃最高位1）
	  11001001  （最终结果补码）
	```

	

3. 结果转换：`11001001` 是负数（最高位 1），转原码：取反`00110110`，加 1`00110111`（即 55），故结果为 `-55`，与预期一致。

## 五、溢出问题（补码运算的限制）

### 5.1 溢出的定义

当补码加法结果超出当前位数补码的**表示范围**时，结果错误，称为溢出。

- 8 位补码的表示范围：`-128 ~ 127`（最高位为符号位，0 正 1 负）；
- 溢出判断：正数 + 正数结果为负数，或负数 + 负数结果为正数，即符号位与运算数符号位矛盾。

### 5.2 示例：溢出导致错误（127 + 3 = 130，结果错误为 - 126）

1. 十进制转 8 位补码：

	- 127（8 位补码最大正数）：`01111111`
	- 3（正数）：`00000011`

2. 补码加法计算：

	plaintext

	

	

	

	```plaintext
	  01111111  （127的补码）
	+ 00000011  （3的补码）
	----------
	  10000010  （结果补码）
	```

	

3. 结果分析：

	- 预期结果：127 + 3 = 130，超出 8 位补码范围（-128~127）；
	- 错误结果：`10000010` 是负数，转原码为 `01111110`（126），故结果为 `-126`，与预期完全不符，属于溢出错误。

## 六、关键结论

1. 计算机算术运算（加减）的核心是**二进制补码**，可统一减法为加法，仅需加法器；
2. 补码运算中，超出位数的**进位可直接舍弃**（不影响结果正确性，除非溢出）；
3. 溢出是补码运算的关键限制，需确保结果在当前位数补码的表示范围内；
4. 所有运算需基于**相同位数的补码**（本视频统一 8 位，实际视硬件位数而定）。



# 浮点数（实数）加减法运算知识点总结

## 一、核心思想

视频明确浮点数加减法的核心是**小数点对齐**（本质是统一两个数的指数），运算方式采用**符号加绝对值表示法**，区别于整数的二进制补码运算。所有操作围绕 “统一指数→尾数运算→重新规范化” 展开，确保结果符合计算机中浮点数的存储规范（隐含整数部分 “1” 的规范化形式）。

## 二、运算前置知识：浮点数存储结构

视频提及计算机中 32 位单精度浮点数采用 “符号位 + 指数位 + 尾数位” 三段式存储，具体结构与规则如下：

| 字段        | 位数  | 含义与规则                                                   |
| ----------- | ----- | ------------------------------------------------------------ |
| 符号位（S） | 1 位  | 0 表示正数，1 表示负数；仅表示符号，不参与数值计算           |
| 指数位（E） | 8 位  | 采用**余 127 码**存储（即：实际指数 = 存储指数 - 127），用于表示浮点数的幂次（2^ 实际指数） |
| 尾数位（M） | 23 位 | 仅存储**规范化尾数的小数部分**，整数部分 “1” 被隐含（即：实际尾数 = 1.M），节省存储位 |

## 三、完整运算步骤（视频流程图拆解）

以 “a ± b” 为例，视频将浮点数加减法拆解为 8 个强制步骤，每个步骤均有明确规则与操作：

### 步骤 1：处理特殊情况（存在操作数为 0）

- **规则**：若其中一个操作数为 0，直接返回另一个操作数，运算终止（避免后续无效操作）。
	- 若 `a = 0`，结果 = `b`
	- 若 `b = 0`，结果 = `a`
- **视频说明**：此为简化逻辑，优先判断可减少计算量，例如 “0 + 5.2” 直接返回 5.2。

### 步骤 2：减法转加法（统一运算类型）

- **核心目的**：将减法运算转化为加法运算，避免单独设计减法逻辑。
- **规则**：
	1. 若运算为**加法**（a + b）：直接跳过此步骤。
	2. 若运算为**减法**（a - b）：将减数`b`的**符号位反转**（0→1，1→0），此时 “a - b” 等价于 “a + (-b)”。
- **视频示例**：若`b`原符号位为 1（负数），反转后为 0（正数），则 “a - (-b)” 转化为 “a + b”。

### 步骤 3：去规范化（显式隐含的整数 1）

- **核心原因**：计算机存储的尾数位 M 仅含小数部分（隐含整数 1），运算前需恢复 “1.M” 的完整尾数，确保计算精度。
- **规则**：
	1. 恢复完整尾数：从尾数位 M 中提取小数部分，拼接成 “1.M” 的完整形式（如 M=1100...，则完整尾数 = 1.1100...）。
	2. 调整实际指数：因尾数整数部分多了 “1”（相当于小数点左移 1 位），需将**实际指数加 1**（保持浮点数总值不变）。
- **视频示例（以 5.75 为例）**：
	1. 5.75 十进制转二进制：5.75 = 101.11 = 1.0111 × 2²（规范化形式）。
	2. 存储结构（32 位）：S=0（正数），E=2+127=129（二进制 10000001），M=011100...0（23 位，取 1.0111 的小数部分）。
	3. 去规范化操作：
		- 完整尾数 = 1.0111（显式加入隐含的 1）。
		- 实际指数 = 2 + 1 = 3（因尾数整数部分显式化，指数加 1 补偿）。

### 步骤 4：指数对齐（统一两个数的指数）

- **核心逻辑**：只有指数相同，尾数的小数点才能对齐，才能直接进行加减运算。
- **规则**：
	1. 计算指数差值：比较两个数的**实际指数**，设较大指数为 E 大，较小指数为 E 小，差值 ΔE = E 大 - E 小。
	2. 调整 “指数较小的数”：
		- 实际指数 += ΔE（使其等于 E 大）。
		- 完整尾数 **右移 ΔE 位**（每右移 1 位，指数加 1，保持值不变；右移时末尾补 0，高位保留符号）。
- **视频示例（5.75 + 161.875）**：
	1. 5.75 去规范化后：实际指数 = 3，完整尾数 = 1.0111。
	2. 161.875 去规范化后：实际指数 = 8，完整尾数 = 1.0100001111。
	3. 计算 ΔE = 8 - 3 = 5。
	4. 调整 5.75：
		- 实际指数 = 3 + 5 = 8（与 161.875 的指数一致）。
		- 完整尾数右移 5 位：1.0111 → 0.000010111（末尾补 0）。

### 步骤 5：尾数加减运算（符号加绝对值规则）

- **核心原则**：根据两个数的符号，分 “同号” 和 “异号” 两种情况运算，结果符号由绝对值大小决定。

- **规则**：

	| 符号关系      | 运算逻辑                              | 结果符号               |
	| ------------- | ------------------------------------- | ---------------------- |
	| 同号（S1=S2） | 尾数绝对值相加                        | 与原符号一致           |
	| 异号（S1≠S2） | 尾数绝对值相减（大绝对值 - 小绝对值） | 与 “绝对值大的数” 一致 |

- **视频示例（5.75 + 161.875，同号均为正）**：

	- 对齐后尾数：5.75 为 0.000010111，161.875 为 1.0100001111。
	- 尾数相加：0.000010111 + 1.0100001111 = 1.0100111001。
	- 结果符号：0（正数，与原符号一致）。

### 步骤 6：尾数溢出判断与处理

- **溢出定义**：尾数加减后，整数部分出现 “2”（如 2.xxxx 或 - 2.xxxx），即超出 “1.M” 的规范化范围。
- **处理规则**：
	1. 尾数 **右移 1 位**（将 2.xxxx 变为 1.xxxx，恢复规范化整数部分）。
	2. 实际指数 **加 1**（因尾数右移 1 位，指数需加 1 保持值不变）。
- **视频说明**：若尾数整数部分为 1（如步骤 5 结果 1.0100111001），则无溢出，直接跳过此步骤。

### 步骤 7：重新规范化（恢复隐含整数 1 的存储形式）

- **核心目的**：将运算后的尾数重新转化为 “1.M” 的规范化形式，适配计算机存储（尾数位 M 仅存小数部分）。
- **规则**：
	1. 调整尾数至 “1.xxxx” 形式：
		- 若尾数已为 “1.xxxx”（如 1.0100111001）：直接提取小数部分作为 M。
		- 若尾数为 “0.xxxx”（如 0.0011001）：左移 n 位至整数部分为 1，同时实际指数减 n。
	2. 计算存储指数 E：E = 实际指数 + 127（恢复余 127 码存储）。
- **视频示例（5.75 + 161.875）**：
	- 运算后尾数：1.0100111001（已规范化）。
	- 提取小数部分：0100111001（补 0 至 23 位，即 M=01001110010000000000000）。
	- 计算 E：实际指数 = 8 → E=8+127=135（二进制 10000111）。
	- 规范化后存储：S=0，E=10000111，M=01001110010000000000000。

### 步骤 8：四舍五入（确保尾数位 M 为 23 位）

- **核心需求**：若重新规范化后的尾数小数部分长度超过 23 位，需截断超出部分并保证精度。
- **规则**：
	1. 查看第 24 位（即 M 的第 24 位）：
		- 若第 24 位为 1：向第 23 位进 1（若进 1 后 M 溢出，需再次右移尾数并加 1 指数）。
		- 若第 24 位为 0：直接截断超出部分。
- **视频示例**：步骤 7 中 M 的小数部分为 10 位（0100111001），补 0 至 23 位后无超出，无需四舍五入。

## 四、视频中的完整运算示例（含验证）

### 示例 1：浮点数加法（5.75 + 161.875）

#### 1. 前置准备

- 5.75 十进制转二进制：101.11 = 1.0111 × 2²。
- 161.875 十进制转二进制：10100001.111 = 1.0100001111 × 2⁷。

#### 2. 步骤执行

| 步骤 | 操作内容                                                     |
| ---- | ------------------------------------------------------------ |
| 1    | 无 0 操作数，进入下一步。                                    |
| 2    | 加法运算，跳过。                                             |
| 3    | 去规范化：5.75→(S=0, 实际指数 = 3, 尾数 = 1.0111)；161.875→(S=0, 实际指数 = 8, 尾数 = 1.0100001111) |
| 4    | 指数对齐：ΔE=5，5.75 尾数右移 5 位→0.000010111，指数 = 8。   |
| 5    | 尾数相加：0.000010111 + 1.0100001111 = 1.0100111001，S=0。   |
| 6    | 无溢出，跳过。                                               |
| 7    | 重新规范化：尾数 = 1.0100111001→M=01001110010000000000000，E=8+127=135。 |
| 8    | 无超出位，无需四舍五入。                                     |

#### 3. 结果验证

- 规范化形式：1.0100111001 × 2⁸。
- 转十进制：1.0100111001 × 256 = 333（与 5.75+161.875=333 一致）。

### 示例 2：浮点数减法（55.75 - 7.125）

#### 1. 前置准备

- 55.75 十进制转二进制：110111.11 = 1.1011111 × 2⁵。
- 7.125 十进制转二进制：111.001 = 1.11001 × 2²；减法转加法后为 “55.75 + (-7.125)”，-7.125 符号位 S=1。

#### 2. 步骤执行

| 步骤 | 操作内容                                                     |
| ---- | ------------------------------------------------------------ |
| 1    | 无 0 操作数，进入下一步。                                    |
| 2    | 减法转加法：7.125 符号位从 0→1，变为 - 7.125。               |
| 3    | 去规范化：55.75→(S=0, 实际指数 = 6, 尾数 = 1.1011111)；-7.125→(S=1, 实际指数 = 3, 尾数 = 1.11001) |
| 4    | 指数对齐：ΔE=3，-7.125 尾数右移 3 位→0.00111001，指数 = 6。  |
| 5    | 尾数相减（异号）：1.1011111 - 0.00111001 = 1.10000101，S=0（55.75 绝对值大）。 |
| 6    | 无溢出，跳过。                                               |
| 7    | 重新规范化：尾数 = 1.10000101→M=10000101000000000000000，E=6+127=133。 |
| 8    | 无超出位，无需四舍五入。                                     |

#### 3. 结果验证

- 规范化形式：1.10000101 × 2⁶。
- 转十进制：1.10000101 × 64 = 97.25（与 55.75-7.125=97.25 一致）。

## 五、关键要点总结

1. **指数统一是核心**：浮点数加减法的本质是 “对齐指数后加减尾数”，所有步骤围绕 “指数对齐” 展开。
2. **隐含 1 的处理是关键**：去规范化（显式 1）和重新规范化（隐含 1）是衔接 “存储” 与 “运算” 的桥梁，直接影响精度。
3. **减法转加法简化逻辑**：通过反转符号将减法转化为加法，避免单独设计减法规则，降低复杂度。
4. **溢出与四舍五入保障精度**：尾数溢出需右移调整，超出 23 位的尾数需四舍五入，确保结果符合存储规范且精度损失最小。
5. **符号独立判断**：结果符号由 “同号取原符号、异号取绝对值大的符号” 决定，与尾数运算分开处理。



