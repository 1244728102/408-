# C 语言程序设计从入门到精通【2025 完整版】知识点总结

## 一、基础入门

### 1. C 语言核心定位与应用场景

- **语言特性**：面向过程、结构化程序设计语言，兼顾高效性与灵活性。
- **核心应用**：操作系统开发（如 Linux 内核）、嵌入式开发、驱动程序、底层硬件控制，同时适配**考研复试、计算机二级、软考、专升本、大一课程**等场景。
- **优势**：代码执行效率高，可直接操作内存，是其他高级语言（如 C++、Python）的基础。

### 2. VS2022 安装与环境配置

#### 安装步骤

1. 官网下载 VS2022 社区版（免费，适合个人开发）；
2. 运行安装程序，勾选「使用 C++ 的桌面开发」工作负载（必须包含此组件，否则无法编译 C 语言）；
3. 选择安装路径（建议非系统盘），点击「安装」；
4. 安装完成后启动 VS2022，首次使用需登录或选择「跳过」；
5. 新建项目：点击「创建新项目」→ 选择「空项目」→ 命名项目（如「FirstCProject」）→ 选择保存路径 → 点击「创建」；
6. 添加源文件：右键项目下的「源文件」→ 「添加」→ 「新建项」→ 选择「C++ 文件 (.cpp)」，命名为「main.c」（后缀改为`.c`，确保按 C 语言编译）。

### 3. 第一个 C 语言项目（Hello World）

#### 完整代码

c

```c
#include <stdio.h>  // 包含标准输入输出库（printf依赖）

int main()  // 程序入口函数（必须存在，且仅一个）
{
    printf("Hello World\n");  // 打印字符串，\n表示换行
    return 0;  // 函数返回值（0表示程序正常结束）
}
```

#### 代码解析

- `#include <stdio.h>`：预处理指令，引入标准输入输出头文件，否则无法使用`printf`。
- `int main()`：主函数，程序从`main`开始执行，`int`表示返回值类型为整数。
- `printf("Hello World\n")`：库函数，用于在控制台输出字符串，`\n`是换行转义字符。
- `return 0`：主函数返回 0，告知操作系统程序正常结束（非 0 表示异常）。

### 4. main 函数的多种写法（标准与兼容形式）

#### （1）标准写法（C99 及以后推荐）

c

```c
#include <stdio.h>
int main()  // 无参数，返回值为int
{
    printf("标准main函数\n");
    return 0;
}
```

#### （2）带命令行参数的写法（需处理外部传入参数时使用）

c

```c
#include <stdio.h>
int main(int argc, char* argv[])  // argc：参数个数；argv：参数数组
{
    printf("参数个数：%d\n", argc);
    for (int i = 0; i < argc; i++) {
        printf("参数%d：%s\n", i, argv[i]);
    }
    return 0;
}
```

#### （3）兼容旧编译器的写法（不推荐，非标准）

c

```c
#include <stdio.h>
void main()  // void表示无返回值，部分旧编译器支持
{
    printf("兼容旧编译器的main函数\n");
    // 无需return（void返回值）
}
```

## 二、输入输出与基础语法

### 1. 库函数与 printf（格式化输出）

#### （1）printf 核心功能

- 向控制台输出指定格式的内容，语法：`printf("格式控制字符串", 变量1, 变量2, ...)`。
- 常用格式符：
	- `%d`：十进制整数；
	- `%c`：单个字符；
	- `%s`：字符串；
	- `%f`：浮点数（默认保留 6 位小数）；
	- `%.2f`：浮点数保留 2 位小数；
	- `%p`：内存地址（十六进制）。

#### （2）完整示例

c

```c
#include <stdio.h>
int main()
{
    int num = 100;
    char ch = 'A';
    char str[] = "C Language";
    float pi = 3.14159;

    printf("整数：%d\n", num);          // 输出：整数：100
    printf("字符：%c\n", ch);          // 输出：字符：A
    printf("字符串：%s\n", str);       // 输出：字符串：C Language
    printf("浮点数（默认）：%f\n", pi); // 输出：浮点数（默认）：3.141590
    printf("浮点数（保留2位）：%.2f\n", pi); // 输出：浮点数（保留2位）：3.14
    printf("变量num的地址：%p\n", &num); // 输出：变量num的地址：006FFD7C（示例地址）

    return 0;
}
```

### 2. scanf（格式化输入）与 VS 安全提示解决

#### （1）scanf 核心功能

- 从控制台读取用户输入，语法：`scanf("格式控制字符串", &变量1, &变量2, ...)`，`&`表示取变量地址。

#### （2）基础示例（读取整数、字符、字符串）

c

```c
#include <stdio.h>
int main()
{
    int age;
    char gender;
    char name[20]; // 字符数组存储字符串

    // 读取整数
    printf("请输入年龄：");
    scanf("%d", &age);  // 注意：age前必须加&

    // 读取字符（需注意缓冲区残留的换行符）
    getchar(); // 吸收上一个scanf后的换行符
    printf("请输入性别（男/女）：");
    scanf("%c", &gender);

    // 读取字符串（遇空格/换行终止）
    printf("请输入姓名：");
    scanf("%s", name);  // 字符数组名本身是地址，无需加&

    // 输出结果
    printf("\n姓名：%s，性别：%c，年龄：%d\n", name, gender, age);
    return 0;
}
```

#### （3）VS 提示 “scanf 不安全” 的解决方法

- **方法 1：添加预处理指令（推荐，兼容性强）**

	

	在源文件

	第一行

	添加

	```
	#define _CRT_SECURE_NO_WARNINGS 1
	```

	，禁用 VS 的安全检查：

	c

	```c
	#define _CRT_SECURE_NO_WARNINGS 1  // 必须放在第一行
	#include <stdio.h>
	
	int main()
	{
	    int num;
	    scanf("%d", &num);  // 无安全提示
	    printf("%d\n", num);
	    return 0;
	}
	```
	
	
	
- **方法 2：使用 VS 特有函数`scanf_s`（不推荐，可移植性差）**

	

	```
	scanf_s
	```

	需额外指定字符串长度，仅在 VS 中可用：

	c

	```c
	#include <stdio.h>
	int main()
	{
	    char str[10];
	    scanf_s("%s", str, (unsigned)_countof(str));  // 需指定数组长度
	    printf("%s\n", str);
	    return 0;
	}
	```
	
	

### 3. getchar 与 putchar（字符输入输出）

- `getchar()`：从控制台读取**单个字符**，返回值为字符的 ASCII 码（int 类型，需用`int`接收以判断 EOF）。
- `putchar(ch)`：向控制台输出**单个字符**，参数为字符变量或 ASCII 码。

#### 示例（循环读取字符直到换行）

c

```c
#include <stdio.h>
int main()
{
    int ch;  // 用int接收getchar()，避免EOF判断错误
    printf("请输入字符（按回车结束）：");
    
    // 循环读取字符，直到遇到换行符'\n'
    while ((ch = getchar()) != '\n')
    {
        putchar(ch);  // 输出读取的字符
        putchar(' '); // 每个字符后加空格
    }
    
    return 0;
}
// 输入：abc → 输出：a b c
```

## 三、数据类型与变量

### 1. 基本数据类型（C 标准规定）

| 类型分类   | 具体类型       | 常见字节数（32 位 / 64 位） | 取值范围（示例）           |
| ---------- | -------------- | --------------------------- | -------------------------- |
| 整型       | `int`          | 4 字节                      | -2¹⁵~2¹⁵-1（-32768~32767） |
|            | `short`        | 2 字节                      | -2¹⁵~2¹⁵-1                 |
|            | `long`         | 4 字节 / 8 字节             | -2³¹~2³¹-1 / -2⁶³~2⁶³-1    |
|            | `long long`    | 8 字节                      | -2⁶³~2⁶³-1                 |
| 无符号整型 | `unsigned int` | 4 字节                      | 0~2¹⁶-1（0~65535）         |
| 字符型     | `char`         | 1 字节                      | -128~127（默认`signed`）   |
| 浮点型     | `float`        | 4 字节                      | 约 ±3.4×10⁻³⁸~±3.4×10³⁸    |
|            | `double`       | 8 字节                      | 约 ±1.7×10⁻³⁰⁸~±1.7×10³⁰⁸  |

#### 示例（数据类型占用字节数计算）

c

```c
#include <stdio.h>
int main()
{
    printf("int：%zu字节\n", sizeof(int));        // 4
    printf("short：%zu字节\n", sizeof(short));    // 2
    printf("long：%zu字节\n", sizeof(long));      // 4（32位）/8（64位）
    printf("long long：%zu字节\n", sizeof(long long)); // 8
    printf("char：%zu字节\n", sizeof(char));      // 1
    printf("float：%zu字节\n", sizeof(float));    // 4
    printf("double：%zu字节\n", sizeof(double));  // 8
    return 0;
}
// 注：%zu是sizeof返回值（size_t类型）的格式符
```

### 2. 变量定义与初始化

#### （1）变量定义语法

`数据类型 变量名1 = 初始值1, 变量名2 = 初始值2;`（未初始化的局部变量值随机，全局变量默认 0）。

#### （2）示例（局部变量与全局变量）

c

```c
#include <stdio.h>

// 全局变量：定义在函数外，作用域为整个文件，默认初始化为0
int global_var;
double global_double = 3.14;

int main()
{
    // 局部变量：定义在函数内，作用域为函数内，必须手动初始化
    int local_var = 10;
    char local_char = 'A';

    // 输出变量值
    printf("全局变量global_var：%d\n", global_var);    // 0（默认初始化）
    printf("全局变量global_double：%.2f\n", global_double); // 3.14
    printf("局部变量local_var：%d\n", local_var);      // 10
    printf("局部变量local_char：%c\n", local_char);    // A

    return 0;
}
```

#### （3）变量命名规则

- 由字母、数字、下划线组成，不能以数字开头；
- 区分大小写（`num`与`Num`是不同变量）；
- 不能使用 C 关键字（如`int`、`if`、`for`）。

### 3. signed 与 unsigned（有符号与无符号）

- `signed`：默认修饰整型 / 字符型，表示变量可存正负值（如`signed int a = -5`）。
- `unsigned`：修饰整型 / 字符型，表示变量仅存非负值（如`unsigned int b = 5`）。

#### 示例（无符号变量的溢出特性）

c

```c
#include <stdio.h>
int main()
{
    unsigned int u = 4294967295;  // 32位unsigned int最大值
    u++;  // 溢出：最大值+1后变为0
    printf("u = %u\n", u);  // 0（%u是unsigned int的格式符）

    signed int s = 2147483647;  // 32位signed int最大值
    s++;  // 溢出：未定义行为（通常变为-2147483648）
    printf("s = %d\n", s);  // -2147483648

    return 0;
}
```

### 4. 作用域（块作用域与文件作用域）

#### （1）块作用域（{} 内的变量）

- 变量定义在`if`、`for`、`while`的`{}`或函数体内，作用域仅限`{}`内。

#### （2）文件作用域（全局变量）

- 变量定义在所有函数外，作用域从定义处到文件结束，可被同一文件内的所有函数访问。

#### 示例（作用域对比）

c

```c
#include <stdio.h>

// 文件作用域变量（全局变量）
int file_scope = 100;

void test()
{
    // 访问文件作用域变量
    printf("test()中访问file_scope：%d\n", file_scope);  // 100
}

int main()
{
    test();

    // 块作用域变量（if的{}内）
    if (1)
    {
        int block_scope = 200;
        printf("if块内访问block_scope：%d\n", block_scope);  // 200
    }

    // printf("if块外访问block_scope：%d\n", block_scope);  // 错误：超出作用域

    return 0;
}
```

## 四、操作符与表达式

### 1. 算术操作符（+、-、*、/、%）

- `+`、`-`、`*`：与数学含义一致；
- `/`：整数除法（舍弃小数，如`10/3=3`），浮点数除法需转换类型（如`10.0/3=3.333...`）；
- `%`：取余（仅用于整数，结果符号与被除数一致，如`10%3=1`、`-10%3=-1`）。

#### 示例

c

```c
#include <stdio.h>
int main()
{
    int a = 10, b = 3;

    printf("a + b = %d\n", a + b);  // 13
    printf("a - b = %d\n", a - b);  // 7
    printf("a * b = %d\n", a * b);  // 30
    printf("a / b = %d\n", a / b);  // 3（整数除法）
    printf("a / (double)b = %.2f\n", a / (double)b);  // 3.33（强制类型转换）
    printf("a %% b = %d\n", a % b);  // 1（取余）
    printf("-a %% b = %d\n", -a % b);  // -1（结果符号与被除数一致）

    return 0;
}
```

### 2. 自增 / 自减操作符（++、--）

- **前缀操作**（`++a`、`--a`）：先修改变量值，再使用变量；
- **后缀操作**（`a++`、`a--`）：先使用变量，再修改变量值。

#### 示例

c

```c
#include <stdio.h>
int main()
{
    int a = 5, b = 5;

    // 前缀自增：先+1，再赋值
    int c = ++a;  // a先变为6，c=6
    printf("a = %d, c = %d\n", a, c);  // 6, 6

    // 后缀自增：先赋值，再+1
    int d = b++;  // 先d=5，b再变为6
    printf("b = %d, d = %d\n", b, d);  // 6, 5

    // 自减同理
    int e = 5, f = 5;
    int g = --e;  // e=4, g=4
    int h = f--;  // h=5, f=4
    printf("e = %d, g = %d\n", e, g);  // 4, 4
    printf("f = %d, h = %d\n", f, h);  // 4, 5

    return 0;
}
```

### 3. 赋值操作符（=、+=、-=、*=、/=、%=）

- `=`：基础赋值（如`a = 10`）；
- 复合赋值（`a += 5`等价于`a = a + 5`，其他同理）。

#### 示例

c

```c
#include <stdio.h>
int main()
{
    int a = 10;

    a += 5;  // 等价于a = a + 5 → 15
    printf("a += 5: %d\n", a);  // 15

    a -= 3;  // 等价于a = a - 3 → 12
    printf("a -= 3: %d\n", a);  // 12

    a *= 2;  // 等价于a = a * 2 → 24
    printf("a *= 2: %d\n", a);  // 24

    a /= 4;  // 等价于a = a / 4 → 6
    printf("a /= 4: %d\n", a);  // 6

    a %= 2;  // 等价于a = a % 2 → 0
    printf("a %%= 2: %d\n", a);  // 0

    return 0;
}
```

### 4. 关系操作符（>、>=、<、<=、==、!=）

- 用于判断两个值的关系，返回值为**1（真）** 或**0（假）**；
- 注意：`==`是 “等于判断”，`=`是 “赋值”，不可混淆。

#### 示例

c

```c
#include <stdio.h>
int main()
{
    int a = 5, b = 3;

    printf("a > b: %d\n", a > b);    // 1（真）
    printf("a >= b: %d\n", a >= b);  // 1（真）
    printf("a < b: %d\n", a < b);    // 0（假）
    printf("a <= b: %d\n", a <= b);  // 0（假）
    printf("a == b: %d\n", a == b);  // 0（假）
    printf("a != b: %d\n", a != b);  // 1（真）

    // 常见错误：用=代替==
    if (a = 10)  // 赋值操作，a变为10，条件为真
    {
        printf("错误：a = 10被当作判断条件\n");  // 会执行
    }

    return 0;
}
```

### 5. 逻辑操作符（&&、||、!）

- `&&`（逻辑与）：两边都为真时结果为真，**短路特性**（左边为假则右边不执行）；
- `||`（逻辑或）：一边为真时结果为真，**短路特性**（左边为真则右边不执行）；
- `!`（逻辑非）：真变假，假变真。

#### 示例（含短路特性）

c

```c
#include <stdio.h>
int main()
{
    int a = 1, b = 0;

    // 逻辑与：左边假，右边不执行
    (a == 0) && (b++);  // a==0为假，b++不执行，b仍为0
    printf("b = %d\n", b);  // 0

    // 逻辑或：左边真，右边不执行
    (a == 1) || (b++);  // a==1为真，b++不执行，b仍为0
    printf("b = %d\n", b);  // 0

    // 逻辑非
    printf("!a = %d\n", !a);  // 0（a=1为真，!a为假）
    printf("!b = %d\n", !b);  // 1（b=0为假，!b为真）

    return 0;
}
```

### 6. 条件操作符（三目运算符）

- 语法：`条件 ? 表达式1 : 表达式2`；
- 逻辑：条件为真时执行表达式 1，否则执行表达式 2。

#### 示例（求最大值）

c

```c
#include <stdio.h>
int main()
{
    int a = 5, b = 8;

    // 用三目运算符求最大值
    int max = (a > b) ? a : b;
    printf("最大值：%d\n", max);  // 8

    // 嵌套使用：求三个数的最大值
    int c = 6;
    int max_three = (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);
    printf("三个数的最大值：%d\n", max_three);  // 8

    return 0;
}
```

## 五、控制语句

### 1. 语句分类

| 语句类型     | 作用                             | 示例                      |
| ------------ | -------------------------------- | ------------------------- |
| 表达式语句   | 表达式后加；，执行并丢弃结果     | `a = 10;`、`i++;`         |
| 函数调用语句 | 调用函数并加；                   | `printf("hello");`        |
| 控制语句     | 控制程序流程（分支、循环、跳转） | `if`、`for`、`break`      |
| 复合语句     | {} 包裹的语句块，作为一个整体    | `if(1){...}`              |
| 空语句       | 仅；，用于循环体为空的场景       | `for(int i=0; i<5; i++);` |

### 2. if 语句（分支控制）

#### （1）单分支 if

c

```c
#include <stdio.h>
int main()
{
    int score = 85;
```

### 2. if 语句（分支控制）

#### （2）双分支 if-else（二选一逻辑）

- 语法：`if(条件){语句块1;} else{语句块2;}`
- 逻辑：条件为真执行语句块 1，为假执行语句块 2。

#### 示例（判断成绩是否及格）

c

```c
#include <stdio.h>
int main()
{
    int score = 75;
    if (score >= 60)
    {
        printf("成绩及格，继续加油！\n");
    }
    else
    {
        printf("成绩不及格，需要补考！\n");
    }
    // 输出：成绩及格，继续加油！
    return 0;
}
```

#### （3）嵌套 if（多条件分层判断）

- 语法：在 if/else 语句块内嵌套另一个 if/else，用于多维度条件判断。

#### 示例（判断成绩等级：优秀 / 良好 / 及格 / 不及格）

c

```c
#include <stdio.h>
int main()
{
    int score = 88;
    if (score >= 90)
    {
        printf("成绩等级：优秀\n");
    }
    else if (score >= 80)  // 隐含条件：score < 90
    {
        printf("成绩等级：良好\n");
    }
    else if (score >= 60)  // 隐含条件：score < 80
    {
        printf("成绩等级：及格\n");
    }
    else  // 隐含条件：score < 60
    {
        printf("成绩等级：不及格\n");
    }
    // 输出：成绩等级：良好
    return 0;
}
```

#### （4）悬空 else（易错点）

- **核心规则**：else 始终与**最近的未配对 if**结合，与代码缩进无关。
- 常见错误：缩进误导，导致 else 匹配错误。

#### 示例（错误写法与正确写法对比）

c

```c
#include <stdio.h>
int main()
{
    int a = 1, b = 2;

    // 错误写法：缩进看似else匹配外层if，实际匹配内层if
    if (a == 0)
        if (b == 2)
            printf("a=0且b=2\n");
    else  // 实际匹配内层if（a==0为假时，此else不执行）
        printf("a≠0\n");
    // 无输出（因a=1≠0，外层if不执行，内层if和else都不执行）

    // 正确写法：用{}明确else的匹配关系
    if (a == 0)
    {
        if (b == 2)
            printf("a=0且b=2\n");
    }
    else  // 明确匹配外层if
    {
        printf("a≠0\n");
    }
    // 输出：a≠0

    return 0;
}
```

### 3. switch 语句（多分支常量匹配）

#### （1）核心语法

c

```c
switch(表达式)  // 表达式必须是整型/字符型/枚举型（结果为常量）
{
    case 常量1:  // 常量1必须是字面量（如1、'A'），不可重复
        语句块1;
        break;  // 跳出switch，若无break则继续执行下一个case
    case 常量2:
        语句块2;
        break;
    ...
    default:  // 所有case不匹配时执行（可选，通常放最后）
        语句块n;
        break;
}
```

#### （2）示例 1（根据数字输出星期几）

c

```c
#include <stdio.h>
int main()
{
    int day = 3;
    switch (day)
    {
        case 1:
            printf("星期一\n");
            break;
        case 2:
            printf("星期二\n");
            break;
        case 3:
            printf("星期三\n");
            break;
        case 4:
            printf("星期四\n");
            break;
        case 5:
            printf("星期五\n");
            break;
        case 6:
            printf("星期六\n");
            break;
        case 7:
            printf("星期日\n");
            break;
        default:
            printf("输入错误（1-7）\n");
            break;
    }
    // 输出：星期三
    return 0;
}
```

#### （3）示例 2（多个 case 共用代码）

- 当多个 case 逻辑一致时，可省略中间 break，共用同一个语句块。

c

```c
#include <stdio.h>
int main()
{
    int day = 6;
    switch (day)
    {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            printf("工作日，努力搬砖！\n");
            break;
        case 6:
        case 7:
            printf("周末，好好休息！\n");
            break;
        default:
            printf("输入错误（1-7）\n");
            break;
    }
    // 输出：周末，好好休息！
    return 0;
}
```

### 4. while 语句（先判断后执行的循环）

#### （1）核心语法

c

```c
while(循环条件)  // 条件为真（非0）时执行循环体
{
    循环体语句;
    （可选）循环变量调整;  // 避免死循环
}
```

#### （2）示例 1（打印 1 到 10 的整数）

c

```c
#include <stdio.h>
int main()
{
    int i = 1;  // 循环变量初始化
    while (i <= 10)  // 循环条件：i≤10
    {
        printf("%d ", i);  // 循环体：打印i
        i++;  // 循环变量调整：i自增1
    }
    // 输出：1 2 3 4 5 6 7 8 9 10
    return 0;
}
```

#### （3）while 中的 break（跳出整个循环）

- `break`作用：立即终止当前循环，跳到循环外继续执行后续代码。

c

```c
#include <stdio.h>
int main()
{
    int i = 1;
    while (i <= 10)
    {
        if (i == 5)
        {
            break;  // 当i=5时，跳出while循环
        }
        printf("%d ", i);
        i++;
    }
    // 输出：1 2 3 4（i=5时循环终止）
    return 0;
}
```

#### （4）while 中的 continue（跳过本次循环）

- `continue`作用：跳过当前循环体中剩余的语句，直接回到循环条件判断。

c

```c
#include <stdio.h>
int main()
{
    int i = 1;
    while (i <= 10)
    {
        i++;  // 注意：i++需放在continue前，否则死循环
        if (i % 2 == 0)
        {
            continue;  // 跳过偶数的打印
        }
        printf("%d ", i);
    }
    // 输出：3 5 7 9 11（跳过2、4、6、8、10）
    return 0;
}
```

### 5. for 语句（初始化 / 判断 / 调整一体化循环）

#### （1）核心语法

c

```c
for(初始化表达式; 循环条件; 调整表达式)
// 执行顺序：1.初始化 → 2.判断条件（真则执行循环体） → 3.执行循环体 → 4.调整表达式 → 回到2
{
    循环体语句;
}
```

- 优势：将循环的 “初始化、条件、调整” 集中在一行，结构清晰，不易遗漏调整语句。

#### （2）示例 1（打印 1 到 10 的整数，对比 while）

c

```c
#include <stdio.h>
int main()
{
    // for循环：初始化、条件、调整集中管理
    for (int i = 1; i <= 10; i++)  // C99及以后支持在for内定义i
    {
        printf("%d ", i);
    }
    // 输出：1 2 3 4 5 6 7 8 9 10
    return 0;
}
```

#### （3）for 中的 break（与 while 一致）

c

```c
#include <stdio.h>
int main()
{
    for (int i = 1; i <= 10; i++)
    {
        if (i == 5)
        {
            break;  // i=5时跳出循环
        }
        printf("%d ", i);
    }
    // 输出：1 2 3 4
    return 0;
}
```

#### （4）for 中的 continue（调整表达式仍执行）

- 注意：`continue`跳过循环体，但**调整表达式会正常执行**（与 while 不同，无需担心死循环）。

c

```c
#include <stdio.h>
int main()
{
    for (int i = 1; i <= 10; i++)
    {
        if (i % 2 == 0)
        {
            continue;  // 跳过偶数打印，i仍会自增
        }
        printf("%d ", i);
    }
    // 输出：1 3 5 7 9
    return 0;
}
```

#### （5）for 循环的灵活写法（示例）

- 初始化、调整表达式可省略（需确保循环正常终止）：

c

```c
#include <stdio.h>
int main()
{
    int i = 1;
    // 省略初始化（i已在外部定义），省略调整（在循环体中调整）
    for (; i <= 10; )
    {
        printf("%d ", i);
        i++;  // 循环体中调整i
    }
    // 输出：1 2 3 4 5 6 7 8 9 10
    return 0;
}
```

### 6. do while 语句（先执行后判断的循环）

#### （1）核心语法

c

```c
do
{
    循环体语句;
    （可选）循环变量调整;
} while(循环条件);  // 注意：末尾必须加;
```

- 特点：**至少执行一次循环体**（无论条件是否为真），适合 “先操作再判断” 的场景（如输入验证）。

#### （2）示例 1（输入密码直到正确）

c

```c
#include <stdio.h>
int main()
{
    int password;
    do
    {
        printf("请输入密码（123456）：");
        scanf("%d", &password);
        if (password != 123456)
        {
            printf("密码错误，请重新输入！\n");
        }
    } while (password != 123456);  // 密码错误则继续循环

    printf("密码正确，欢迎进入！\n");
    return 0;
}
// 执行流程：先输入密码→判断错误→提示→循环；直到输入123456→退出循环
```

#### （3）do while 中的 break 与 continue

- `break`：跳出循环；`continue`：跳过循环体剩余语句，直接进入条件判断。

c

```c
#include <stdio.h>
int main()
{
    int i = 1;
    do
    {
        if (i == 5)
        {
            i++;
            continue;  // 跳过i=5的打印，直接判断条件
        }
        if (i == 8)
        {
            break;  // i=8时跳出循环
        }
        printf("%d ", i);
        i++;
    } while (i <= 10);
    // 输出：1 2 3 4 6 7（跳过5，8时终止）
    return 0;
}
```

### 7. 循环嵌套（循环内嵌套循环）

- 语法：在一个循环的循环体中定义另一个循环，外层循环控制 “次数”，内层循环控制 “每次的细节”。
- 典型场景：打印图形（如直角三角形、99 乘法表）。

#### 示例（打印 99 乘法表）

c

```c
#include <stdio.h>
int main()
{
    // 外层循环：控制行数（1-9）
    for (int i = 1; i <= 9; i++)
    {
        // 内层循环：控制每行的列数（1-i）
        for (int j = 1; j <= i; j++)
        {
            printf("%d×%d=%-2d ", j, i, j*i);  // %-2d：左对齐，占2位
        }
        printf("\n");  // 每行结束换行
    }
    return 0;
}
// 输出结果：
// 1×1=1  
// 1×2=2  2×2=4  
// 1×3=3  2×3=6  3×3=9  
// ...（直到9行）
```

### 8. goto 语句与标号（跳转语句）

#### （1）核心语法

c

```c
标号名:  // 标号：由字母、数字、下划线组成，后加:
    语句;
goto 标号名;  // 跳转到指定标号处执行
```

- 规则：`goto`只能在**同一个函数内**跳转，不能跨函数；常用于 “跳出多层循环”（比 break 更高效）。

#### （2）示例（用 goto 跳出多层循环）

c

```c
#include <stdio.h>
int main()
{
    // 多层循环：外层3次，内层5次
    for (int i = 1; i <= 3; i++)
    {
        for (int j = 1; j <= 5; j++)
        {
            printf("i=%d, j=%d\n", i, j);
            if (j == 3)
            {
                goto end_loop;  // j=3时，跳转到end_loop标号
            }
        }
    }

end_loop:  // 标号
    printf("循环结束！\n");
    return 0;
}
// 输出：
// i=1, j=1
// i=1, j=2
// i=1, j=3
// 循环结束！（直接跳出两层循环）
```

## 六、数组

### 1. 一维数组的创建与初始化

#### （1）数组创建语法

```
数据类型 数组名[数组长度];
```

- 数组长度：必须是**常量表达式**（C99 前不支持变量，C99 后支持变长数组 VLA）；
- 数组名：表示数组首元素的地址（常量，不可修改）。

#### （2）数组初始化（三种常见方式）

c

```c
#include <stdio.h>
int main()
{
    // 方式1：完全初始化（初始化元素个数=数组长度）
    int arr1[5] = {1, 2, 3, 4, 5};  // arr1 = [1,2,3,4,5]

    // 方式2：部分初始化（未初始化元素默认为0）
    int arr2[5] = {1, 2};  // arr2 = [1,2,0,0,0]

    // 方式3：省略数组长度（编译器根据初始化元素个数自动计算长度）
    int arr3[] = {1, 2, 3, 4};  // 长度=4，arr3 = [1,2,3,4]

    // 错误示例：初始化元素个数>数组长度
    // int arr4[3] = {1,2,3,4};  // 编译报错

    return 0;
}
```

### 2. 一维数组的使用（通过下标访问）

- 数组下标：从**0**开始（首元素下标为 0，末元素下标为 “长度 - 1”）；
- 语法：`数组名[下标]`（可读写，如`arr[0] = 10`、`printf("%d", arr[0])`）。

#### 示例（遍历数组并修改元素）

c

```c
#include <stdio.h>
int main()
{
    int arr[] = {10, 20, 30, 40, 50};
    int len = sizeof(arr) / sizeof(arr[0]);  // 计算数组长度（通用方法）

    // 1. 遍历数组：打印所有元素
    printf("数组初始值：");
    for (int i = 0; i < len; i++)
    {
        printf("%d ", arr[i]);
    }
    // 输出：数组初始值：10 20 30 40 50

    // 2. 修改数组元素：所有元素加5
    for (int i = 0; i < len; i++)
    {
        arr[i] += 5;
    }

    // 3. 再次遍历：打印修改后的值
    printf("\n数组修改后：");
    for (int i = 0; i < len; i++)
    {
        printf("%d ", arr[i]);
    }
    // 输出：数组修改后：15 25 35 45 55

    return 0;
}
```

### 3. 一维数组在内存中的存储

- 特性：数组元素在内存中**连续存储**，每个元素占用的字节数 = 数据类型字节数；
- 地址规律：下一个元素的地址 = 当前元素地址 + 数据类型字节数（如 int 数组，地址差 4）。

#### 示例（打印数组元素地址）

c

```c
#include <stdio.h>
int main()
{
    int arr[] = {1, 2, 3};
    int len = sizeof(arr) / sizeof(arr[0]);

    for (int i = 0; i < len; i++)
    {
        // %p：以十六进制打印地址
        printf("arr[%d] = %d, 地址：%p\n", i, arr[i], &arr[i]);
    }
    // 输出示例（地址为随机值，但连续且差4）：
    // arr[0] = 1, 地址：006FFD6C
    // arr[1] = 2, 地址：006FFD70  （006FFD6C + 4 = 006FFD70）
    // arr[2] = 3, 地址：006FFD74  （006FFD70 + 4 = 006FFD74）

    return 0;
}
```

### 4. 二维数组的创建与初始化

#### （1）二维数组创建语法

```
数据类型 数组名[行数][列数];
```

- 可理解为 “数组的数组”（每行是一个一维数组）；
- 行数可省略（需初始化），列数**不可省略**（编译器需确定每行元素个数）。

#### （2）二维数组初始化（四种常见方式）

c

```c
#include <stdio.h>
int main()
{
    // 方式1：完全初始化（按行初始化，用{}分隔每行）
    int arr1[2][3] = {{1,2,3}, {4,5,6}};  // arr1 = [[1,2,3], [4,5,6]]

    // 方式2：部分初始化（未初始化元素默认为0）
    int arr2[2][3] = {{1}, {4,5}};  // arr2 = [[1,0,0], [4,5,0]]

    // 方式3：省略行分隔符（按顺序初始化，编译器自动分行）
    int arr3[2][3] = {1,2,3,4,5,6};  // 等价于方式1

    // 方式4：省略行数（编译器根据列数和元素个数计算行数）
    int arr4[][3] = {1,2,3,4,5};  // 列数=3，元素数=5→行数=2（剩余元素补0）
                                  // arr4 = [[1,2,3], [4,5,0]]

    return 0;
}
```

### 5. 二维数组的使用（双下标访问）

- 语法：`数组名[行下标][列下标]`（行、列下标均从 0 开始）；
- 遍历方式：外层循环控制行数，内层循环控制列数。

#### 示例（遍历二维数组并打印）

c

```c
#include <stdio.h>
int main()
{
    int arr[2][3] = {{1,2,3}, {4,5,6}};
    int rows = sizeof(arr) / sizeof(arr[0]);    // 计算行数（arr[0]是第一行的地址）
    int cols = sizeof(arr[0]) / sizeof(arr[0][0]);  // 计算列数

    // 遍历二维数组
    for (int i = 0; i < rows; i++)  // 外层：行
    {
        for (int j = 0; j < cols; j++)  // 内层：列
        {
            printf("%d ", arr[i][j]);
        }
        printf("\n");  // 每行结束换行
    }
    // 输出：
    // 1 2 3 
    // 4 5 6 

    return 0;
}
```

### 6. 二维数组在内存中的存储

- 特性：与一维数组一致，**连续存储**（按行优先顺序，第一行所有元素存完后存第二行）；
- 地址规律：`arr[i][j]`的地址 = `&arr[0][0] + i*cols + j`（cols 为列数）。

#### 示例（打印二维数组元素地址）

c

```c
#include <stdio.h>
int main()
{
    int arr[2][3] = {{1,2,3}, {4,5,6}};
    int rows = 2, cols = 3;

    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            printf("arr[%d][%d] 地址：%p\n", i, j, &arr[i][j]);
        }
    }
    // 输出示例（地址连续，每行元素差4，行与行之间也差4）：
    // arr[0][0] 地址：006FFD58
    // arr[0][1] 地址：006FFD5C  （+4）
    // arr[0][2] 地址：006FFD60  （+4）
    // arr[1][0] 地址：006FFD64  （+4，第一行结束到第二行）
    // arr[1][1] 地址：006FFD68  （+4）
    // arr[1][2] 地址：006FFD6C  （+4）

    return 0;
}
```

### 7. C99 中的变长数组（VLA）

- 特性：数组长度可由**变量**指定（创建时长度确定，创建后不可修改）；
- 注意：VS2022 不支持变长数组（需用 GCC 等编译器）。

#### 示例（创建变长数组）

c

```c
#include <stdio.h>
int main()
{
    int n;
    printf("请输入数组长度：");
    scanf("%d", &n);

    int arr[n];  // 变长数组：长度由变量n指定
    for (int i = 0; i < n; i++)
    {
        arr[i] = i + 1;  // 初始化数组
    }

    // 遍历数组
    printf("变长数组元素：");
    for (int i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    // 输入n=5 → 输出：变长数组元素：1 2 3 4 5

    return 0;
}
```

## 七、字符与字符串

### 1. 注释（代码说明，不参与编译）

#### （1）两种注释方式

- **单行注释**：`// 注释内容`（从`//`开始到行尾，适合短注释，支持中文）；
- **多行注释**：`/* 注释内容 */`（可跨多行，适合长注释，**不可嵌套**，嵌套会导致编译错误）。

#### 示例（注释的正确使用）

c

```c
#include <stdio.h>
/*
这是多行注释：
功能：计算两个整数的和并输出
适用场景：基础语法演示
注意：变量需初始化后使用
*/
int main()
{
    int a = 10; // 单行注释：定义变量a，初始值10（整型）
    int b = 20; // 定义变量b，初始值20
    int sum = a + b; // 计算a与b的和，结果存入sum
    printf("sum = %d\n", sum); // 输出结果（%d对应整型sum）
    return 0;
}
```

### 2. 字符和 ASCII 编码

#### （1）核心概念

- `char`类型本质：占 1 字节（8 位），存储的是字符对应的**ASCII 码值**（整数），而非字符本身；
- 常见 ASCII 码值（需记忆）：
	- 控制字符：`'\n'`（换行）=10，`' '`（空格）=32；
	- 数字字符：`'0'`=48，`'1'`=49，…，`'9'`=57（数字字符 ASCII 码 = 数字 + 48）；
	- 字母字符：`'A'`=65，`'B'`=66，…，`'Z'`=90；`'a'`=97，…，`'z'`=122（大小写字母 ASCII 码差 32）。

#### 示例（ASCII 码与字符的对应关系）

c

```c
#include <stdio.h>
int main()
{
    // 1. 字符转ASCII码（%d输出char类型）
    char ch1 = 'A';
    char ch2 = 'a';
    char ch3 = '0';
    printf("'A'的ASCII码：%d\n", ch1);  // 输出：65
    printf("'a'的ASCII码：%d\n", ch2);  // 输出：97
    printf("'0'的ASCII码：%d\n", ch3);  // 输出：48

    // 2. ASCII码转字符（%c输出整数）
    int ascii1 = 10;  // '\n'的ASCII码
    int ascii2 = 32;  // 空格的ASCII码
    printf("ASCII=10对应字符：[%c]\n", ascii1); // 输出：[换行]（光标移下一行）
    printf("ASCII=32对应字符：[%c]\n", ascii2); // 输出：[ ]（空格）

    // 3. 字母大小写转换（利用ASCII码差值32）
    char lower = 'm';
    char upper = lower - 32;  // 'm'-32='M'
    printf("小写'%c'转大写：%c\n", lower, upper); // 输出：m→M

    return 0;
}
```

### 3. 转义字符（改变字符原有含义）

#### （1）常见转义字符及功能

| 转义字符 | 功能描述                               | 示例代码               | 输出效果 |
| -------- | -------------------------------------- | ---------------------- | -------- |
| `\n`     | 换行符（光标移至下一行开头）           | `printf("a\nb");`      | ab       |
| `\t`     | 水平制表符（等效 Tab 键，占 4/8 空格） | `printf("name\tage");` | name age |
| `\\`     | 表示单个反斜杠（\）                    | `printf("C:\\test");`  | C:\test  |
| `\'`     | 表示单个单引号（'）                    | `printf("\'hello\'");` | 'hello'  |
| `\"`     | 表示单个双引号（"）                    | `printf("\"C\"");`     | "C"      |
| `\r`     | 回车符（光标移至当前行开头，覆盖）     | `printf("123\r45");`   | 453      |
| `\a`     | 警报声（蜂鸣提示，无视觉输出）         | `printf("\a");`        | 蜂鸣一次 |

#### 示例（转义字符实际效果演示）

c

```c
#include <stdio.h>
int main()
{
    // 1. \n 和 \t 组合使用（格式化输出表格）
    printf("姓名\t性别\t年龄\n");
    printf("张三\t男\t20\n");
    printf("李四\t女\t19\n");

    // 2. \\、\'、\" 转义（输出特殊符号）
    printf("\n文件路径：C:\\Users\\Desktop\\code.c\n");
    printf("名言：\'学而不思则罔\'\n");
    printf("书名：\"C语言程序设计\"\n");

    // 3. \r 回车符（覆盖前面内容）
    printf("\n下载进度：30%%\r");  // 输出后光标回开头
    printf("下载进度：100%%\n");    // 覆盖前面的"30%"

    return 0;
}
// 最终输出：
// 姓名    性别    年龄
// 张三    男      20
// 李四    女      19
// 
// 文件路径：C:\Users\Desktop\code.c
// 名言：'学而不思则罔'
// 书名："C语言程序设计"
// 
// 下载进度：100%
```

### 4. 字符串和字符数组

#### （1）核心区别

- **字符数组**：仅存储字符序列，无固定结束标志（如`char arr[] = {'h','e','l','l','o'}`）；
- **字符串**：以 **`'\0'`（ASCII 码 = 0，空字符）** 为结束标志的字符数组，`'\0'`不计入字符串长度（如`char str[] = "hello"`，编译器自动添加`'\0'`）。

#### （2）字符串的 3 种初始化方式

c

```c
#include <stdio.h>
#include <string.h>  // 使用strlen()需包含此头文件
int main()
{
    // 方式1：直接赋值字符串常量（推荐，自动加'\0'）
    char str1[] = "C Language";  // 数组长度=10（字符）+1（'\0'）=11
    // 方式2：指定数组长度，手动加'\0'
    char str2[11] = {'C',' ','L','a','n','g','u','a','g','e','\0'};  // 与str1等价
    // 方式3：部分初始化，剩余元素自动补'\0'
    char str3[20] = "C Language";  // 前10位存字符，后10位补'\0'

    // 错误示例：无'\0'的字符数组（不是字符串，printf会乱码）
    char arr[] = {'h','e','l','l','o'};  // 无'\0'，strlen()会读取到随机'\0'为止

    // 验证：strlen()计算字符串长度（仅统计'\0'前的字符）
    printf("str1长度：%zu\n", strlen(str1));  // 输出：10（不含'\0'）
    printf("str2长度：%zu\n", strlen(str2));  // 输出：10
    printf("str3长度：%zu\n", strlen(str3));  // 输出：10
    printf("arr长度（乱码）：%zu\n", strlen(arr));  // 输出：随机值（如12、15等）

    // 打印字符串（printf("%s")遇'\0'停止，arr无'\0'会乱码）
    printf("\nstr1：%s\n", str1);  // 输出：C Language
    printf("str2：%s\n", str2);  // 输出：C Language
    printf("arr：%s\n", arr);    // 输出：hello+乱码（如hello烫烫烫）

    return 0;
}
```

### 5. gets 函数与 puts 函数（字符串输入输出）

#### （1）puts 函数（输出字符串）

- 功能：输出字符串内容，并**自动添加换行符**（无需手动写`\n`）；
- 语法：`void puts(const char *str);`（参数为字符串首地址，如字符数组名）；
- 终止条件：遇`'\0'`停止输出。

#### （2）gets 函数（读取字符串）

- 功能：从控制台读取字符串，存入字符数组，**自动丢弃输入的换行符并添加`'\0'`**；
- 语法：`char *gets(char *str);`（参数为字符数组名，需确保数组容量足够）；
- 风险：**无长度限制**，若输入长度超过数组容量，会导致缓冲区溢出（VS 等编译器会提示 “不安全”）。

#### 示例（gets 与 puts 的使用）

c

```c
#include <stdio.h>
int main()
{
    char str[50];  // 定义足够大的字符数组，避免溢出

    // 用gets读取字符串（支持输入含空格的内容，如"Hello World"）
    printf("请输入一个字符串（可含空格）：");
    gets(str);  // 输入示例：I love C programming

    // 用puts输出字符串（自动换行）
    printf("\n你输入的字符串是：");
    puts(str);  // 输出：I love C programming（并换行）

    // 对比printf输出（需手动加'\n'）
    printf("用printf输出：%s\n", str);  // 输出：用printf输出：I love C programming

    return 0;
}
// 注意：VS2022中gets被标记为不安全，可替换为VS特有函数gets_s（但可移植性差）：
// gets_s(str, sizeof(str));  // gets_s需指定数组长度，仅VS支持
```

## 八、函数基础

### 1. 函数是什么？

#### （1）函数的定义与作用

- 函数是封装特定功能的代码块，可重复调用，减少冗余代码，提高可读性和维护性；
- 分类：
	- **库函数**：C 标准库提供的现成函数（如`printf`、`scanf`、`strlen`），使用需包含对应头文件；
	- **自定义函数**：用户根据需求编写的函数（核心：按需设计，见名知意）。

#### （2）库函数使用示例（需包含头文件）

c

```c
#include <stdio.h>    // printf、scanf所需头文件
#include <string.h>   // strlen（计算字符串长度）所需头文件
#include <math.h>     // sqrt（求平方根）所需头文件

int main()
{
    // 1. 使用printf（库函数）输出
    printf("库函数使用演示\n");

    // 2. 使用strlen（库函数）计算字符串长度
    char str[] = "Hello C";
    printf("字符串\"%s\"的长度：%zu\n", str, strlen(str));  // 输出：7

    // 3. 使用sqrt（库函数）求平方根
    double num = 25.0;
    double result = sqrt(num);
    printf("%.1f的平方根：%.1f\n", num, result);  // 输出：25.0的平方根：5.0

    return 0;
}
```

### 2. 自定义函数（核心语法与示例）

#### （1）自定义函数的语法结构

c

```c
返回值类型 函数名(参数列表)
{
    // 函数体：实现功能的代码
    [return 返回值;]  // 非void类型需返回对应类型值，void类型可省略
}
```

- **返回值类型**：函数执行后返回的数据类型（如`int`、`double`、`void`（无返回值））；
- **函数名**：符合标识符规则（字母、数字、下划线，首字符非数字），见名知意（如`add`表加法，`getMax`表求最大值）；
- **参数列表**：函数接收的输入（无参数时写`void`或空，推荐写`void`）；
- **return 语句**：返回数据给调用者，或仅用于终止函数（`void`类型可用`return;`）。

#### （2）示例 1：无参数、无返回值（打印菜单）

c

```c
#include <stdio.h>

// 函数：无参数（void），无返回值（void），打印操作菜单
void printMenu()
{
    printf("==================== 菜单 ====================\n");
    printf("1. 加法计算    2. 减法计算    3. 乘法计算    4. 退出\n");
    printf("==============================================\n");
}

int main()
{
    printMenu();  // 调用自定义函数
    return 0;
}
// 输出：
// ==================== 菜单 ====================
// 1. 加法计算    2. 减法计算    3. 乘法计算    4. 退出
// ==============================================
```

#### （3）示例 2：有参数、有返回值（求两个整数的最大值）

c

```c
#include <stdio.h>

// 函数：参数a、b（int），返回值为最大值（int）
int getMax(int a, int b)
{
    // 简化写法：return (a > b) ? a : b;（三目运算符）
    if (a > b)
    {
        return a;  // a大则返回a
    }
    else
    {
        return b;  // b大则返回b
    }
}

int main()
{
    int num1 = 18, num2 = 25;
    // 1. 调用函数，返回值存入变量
    int max1 = getMax(num1, num2);
    printf("%d和%d的最大值：%d\n", num1, num2, max1);  // 输出：25

    // 2. 直接用函数返回值作为printf参数（链式访问）
    printf("30和22的最大值：%d\n", getMax(30, 22));  // 输出：30

    return 0;
}
```

#### （4）示例 3：返回值为 double（计算圆的面积）

c

```c
#include <stdio.h>
#define PI 3.14159  // 定义常量PI（圆周率）

// 函数：参数为半径（double），返回值为面积（double）
double calculateCircleArea(double radius)
{
    double area = PI * radius * radius;
    return area;
}

int main()
{
    double r1 = 5.0, r2 = 3.2;
    printf("半径%.1f的圆面积：%.2f\n", r1, calculateCircleArea(r1));  // 输出：78.54
    printf("半径%.1f的圆面积：%.2f\n", r2, calculateCircleArea(r2));  // 输出：32.17

    return 0;
}
```

### 3. 函数的形参和实参

#### （1）核心概念

- **实参（实际参数）**：调用函数时传入的具体值（如`getMax(num1, num2)`中的`num1`、`num2`）；
- **形参（形式参数）**：函数定义时的参数（如`int getMax(int a, int b)`中的`a`、`b`）；
- **关键特性**：形参是实参的**临时拷贝**，函数内部修改形参值，**不会影响实参**（传值调用）。

#### 示例 1：形参修改不影响实参

c

```c
#include <stdio.h>

// 函数：修改形参x的值
void changeValue(int x)
{
    x = 100;  // 修改形参
    printf("函数内形参x：%d\n", x);  // 输出：100
}

int main()
{
    int num = 10;
    printf("调用前实参num：%d\n", num);  // 输出：10

    changeValue(num);  // 传入实参num，形参x是num的拷贝

    printf("调用后实参num：%d\n", num);  // 输出：10（实参未变）

    return 0;
}
```

#### 示例 2：错误的交换函数（传值调用无法交换实参）

c

```c
#include <stdio.h>

// 错误：传值调用，仅交换形参，实参不变
void swap(int x, int y)
{
    int temp = x;
    x = y;
    y = temp;
    printf("函数内x=%d, y=%d\n", x, y);  // 输出：x=20, y=10（形参交换成功）
}

int main()
{
    int a = 10, b = 20;
    printf("交换前a=%d, b=%d\n", a, b);  // 输出：10, 20

    swap(a, b);  // 调用交换函数

    printf("交换后a=%d, b=%d\n", a, b);  // 输出：10, 20（实参未交换）

    return 0;
}
// 注：若要实现交换，需用「传址调用」（后续指针章节讲解）
```

### 4. 函数的链式访问

#### （1）定义

- 链式访问：将一个函数的返回值作为另一个函数的参数，形成 “链式” 调用（常见于`printf`、`strlen`等函数）。

#### 示例 1：printf 的链式访问（printf 返回值为输出的字符数）

c

```c
#include <stdio.h>
int main()
{
    // 内层printf输出"abc"，返回值=3（输出3个字符），作为外层printf的参数
    printf("内层printf输出的字符数：%d\n", printf("abc\n"));

    // 执行顺序：
    // 1. 先执行内层printf("abc\n")：输出"abc"并换行，返回3；
    // 2. 再执行外层printf("内层...：%d\n", 3)：输出字符数3。

    // 最终输出：
    // abc
    // 内层printf输出的字符数：3

    return 0;
}
```

#### 示例 2：自定义函数的链式访问（求三个数的最大值）

c

```c
#include <stdio.h>

// 函数：求两个数的最大值
int getMax(int a, int b)
{
    return (a > b) ? a : b;
}

int main()
{
    int num1 = 15, num2 = 28, num3 = 22;

    // 链式访问：getMax(num1, num2)的返回值作为getMax的第二个参数
    int max = getMax(getMax(num1, num2), num3);

    printf("三个数的最大值：%d\n", max);  // 输出：28

    return 0;
}
```

### 5. 函数的嵌套调用

#### （1）定义

- 嵌套调用：在一个函数的函数体中调用另一个函数（C 语言**不支持函数嵌套定义**，但支持嵌套调用）。

#### 示例：嵌套调用打印等腰三角形

c

```c
#include <stdio.h>

// 函数1：打印n个空格
void printSpace(int n)
{
    for (int i = 0; i < n; i++)
    {
        printf(" ");
    }
}

// 函数2：打印n个星号并换行
void printStar(int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("*");
    }
    printf("\n");
}

// 函数3：打印rows行等腰三角形（嵌套调用printSpace和printStar）
void printTriangle(int rows)
{
    for (int i = 1; i <= rows; i++)
    {
        printSpace(rows - i);  // 嵌套调用：打印空格
        printStar(2 * i - 1);  // 嵌套调用：打印星号（每行星号数=2i-1）
    }
}

int main()
{
    printTriangle(5);  // 调用printTriangle，间接调用其他函数

    // 输出结果（5行等腰三角形）：
    //     *
    //    ***
    //   *****
    //  *******
    // *********

    return 0;
}
```

### 6. 无参数和无返回值的函数

#### （1）语法特点

- **无参数**：函数定义时参数列表写`void`（明确无参数，推荐）或空（兼容旧标准）；
- **无返回值**：返回值类型写`void`，函数体中可省略`return`，若写`return`则后面不加值（`return;`）。

#### 示例：无参数无返回值函数（打印欢迎信息）

c

```c
#include <stdio.h>

// 无参数（void），无返回值（void）
void printWelcome()
{
    printf("=============================\n");
    printf("  欢迎学习C语言函数章节！\n");
    printf("  今日目标：掌握函数基础语法\n");
    printf("=============================\n");
    return;  // 可省略，无返回值函数的return仅用于终止函数
}

// 无参数（空），无返回值（void）
void printEnd()
{
    printf("\n本次学习结束，下次再见！\n");
}

int main()
{
    printWelcome();  // 调用无参数无返回值函数
    printEnd();      // 调用无参数无返回值函数

    return 0;
}
```

### 7. 函数中的 return 语句

#### （1）return 的两大作用

1. **返回数据**：将函数结果返回给调用者（仅适用于非`void`类型函数）；
2. **终止函数**：无论函数体是否执行完，遇到`return`立即退出函数。

#### （2）使用规则

- 非`void`类型函数：`return`后必须跟与返回值类型匹配的值（或可自动转换的表达式）；
- `void`类型函数：`return`后不可跟值，或直接省略`return`；
- 一个函数中可有多条`return`语句，但仅一条会被执行（执行到第一条`return`即退出）。

#### 示例 1：多 return 语句（判断数字正负）

c

```c
#include <stdio.h>

// 返回值：1=正数，-1=负数，0=零
int judgeNumber(int num)
{
    if (num > 0)
    {
        return 1;  // 正数，返回1并退出
    }
    else if (num < 0)
    {
        return -1;  // 负数，返回-1并退出
    }
    else
    {
        return 0;  // 零，返回0并退出
    }
}

int main()
{
    int n1 = 30, n2 = -15, n3 = 0;
    printf("%d → %d（1=正，-1=负，0=零）\n", n1, judgeNumber(n1));  // 30→1
    printf("%d → %d（1=正，-1=负，0=零）\n", n2, judgeNumber(n2));  // -15→-1
    printf("%d → %d（1=正，-1=负，0=零）\n", n3, judgeNumber(n3));  // 0→0

    return 0;
}
```

#### 示例 2：return 终止函数（提前退出循环）

c

```c
#include <stdio.h>

// 函数：在数组中查找目标值，找到返回索引，未找到返回-1
int findTarget(int arr[], int len, int target)
{
    for (int i = 0; i < len; i++)
    {
        if (arr[i] == target)
        {
            return i;  // 找到目标，返回索引并退出函数（循环终止）
        }
    }
    return -1;  // 循环结束未找到，返回-1
}

int main()
{
    int arr[] = {10, 20, 30, 40, 50};
    int len = sizeof(arr) / sizeof(arr[0]);
    int target1 = 30, target2 = 35;

    int index1 = findTarget(arr, len, target1);
    if (index1 != -1)
    {
        printf("目标%d的索引：%d\n", target1, index1);  // 输出：30→2
    }
    else
    {
        printf("目标%d不存在\n", target1);
    }

    int index2 = findTarget(arr, len, target2);
    if (index2 != -1)
    {
        printf("目标%d的索引：%d\n", target2, index2);
    }
    else
    {
        printf("目标%d不存在\n", target2);  // 输出：35不存在
    }

    return 0;
}
```

## 九、函数声明与多文件组织

### 1. 函数声明（函数原型）

#### （1）核心作用

- 告诉编译器函数的**返回值类型、函数名、参数列表**（无需函数体），确保函数调用时编译器能验证参数和返回值的合法性；
- 解决 “函数定义在调用之后” 的编译错误（C 语言要求函数 “先声明 / 定义，后调用”）。

#### （2）声明语法

```
返回值类型 函数名(参数类型1, 参数类型2, ...);
```

- 参数名可省略（仅需参数类型），但为了可读性建议保留参数名。

#### 示例 1：函数声明解决 “定义在后” 问题

c

```c
#include <stdio.h>

// 函数声明（告诉编译器：存在一个getMin函数，返回int，接收两个int参数）
int getMin(int a, int b);  // 也可写为int getMin(int, int);

int main()
{
    int x = 15, y = 8;
    // 调用getMin：此时编译器已通过声明知道函数结构，不会报错
    int min_val = getMin(x, y);
    printf("最小值：%d\n", min_val);  // 输出：8
    return 0;
}

// 函数定义（在调用之后，需提前声明）
int getMin(int a, int b)
{
    return (a < b) ? a : b;
}
```

#### 示例 2：声明与定义的参数名可不同（仅需类型匹配）

c

```c
#include <stdio.h>

// 声明时参数名是x、y
int add(int x, int y);

int main()
{
    printf("10+20=%d\n", add(10, 20));  // 输出：30
    return 0;
}

// 定义时参数名是a、b（与声明不同，但类型匹配，合法）
int add(int a, int b)
{
    return a + b;
}
```

### 2. 多文件组织（头文件.h + 源文件.c）

#### （1）核心目的

- 大型项目中拆分代码：将函数声明、宏定义、类型定义放在**头文件（.h）**，函数实现放在**源文件（.c）**，主函数放在单独的.c 文件，提高代码模块化和可维护性。

#### （2）文件分工

| 文件类型 | 文件名示例     | 存放内容                                       | 注意事项                                          |
| -------- | -------------- | ---------------------------------------------- | ------------------------------------------------- |
| 头文件   | `math_utils.h` | 函数声明、宏定义、typedef 类型定义、头文件包含 | 必须加**头文件保护**（防止重复包含）              |
| 源文件   | `math_utils.c` | 头文件中声明的函数的实现                       | 需包含对应的头文件（如`#include "math_utils.h"`） |
| 主文件   | `main.c`       | main 函数，调用其他文件的函数                  | 包含所需头文件（如`#include "math_utils.h"`）     |

#### （3）示例：多文件实现 “数学工具函数”

##### ① 头文件 `math_utils.h`（函数声明 + 宏定义）

c

```c
// 头文件保护：防止重复包含（核心！）
#ifndef MATH_UTILS_H  // 若未定义MATH_UTILS_H
#define MATH_UTILS_H  // 定义MATH_UTILS_H

// 宏定义：圆周率
#define PI 3.14159

// 函数声明1：求两个整数的最大值
int getMax(int a, int b);

// 函数声明2：求圆的面积
double calculateCircleArea(double radius);

// 函数声明3：求n的阶乘（n≥0）
int factorial(int n);

#endif  // 结束头文件保护
```

##### ② 源文件 `math_utils.c`（函数实现）

c

```c
// 包含自定义头文件（用""，优先从当前目录查找）
#include "math_utils.h"

// 实现getMax函数（与声明一致）
int getMax(int a, int b)
{
    return (a > b) ? a : b;
}

// 实现calculateCircleArea函数（使用头文件中的PI）
double calculateCircleArea(double radius)
{
    return PI * radius * radius;
}

// 实现factorial函数
int factorial(int n)
{
    if (n == 0 || n == 1)
        return 1;
    return n * factorial(n - 1);  // 递归调用（后续章节详解）
}
```

##### ③ 主文件 `main.c`（调用函数）

c

```c
#include <stdio.h>
#include "math_utils.h"  // 包含自定义头文件，使用其中的函数和宏

int main()
{
    // 调用getMax
    printf("15和22的最大值：%d\n", getMax(15, 22));  // 输出：22

    // 调用calculateCircleArea（使用PI）
    printf("半径5的圆面积：%.2f\n", calculateCircleArea(5.0));  // 输出：78.54

    // 调用factorial
    printf("5的阶乘：%d\n", factorial(5));  // 输出：120

    return 0;
}
```

#### （4）头文件保护的两种方式

- **方式 1：#ifndef + #define + #endif**（兼容所有编译器，推荐）：

	

	如上述

	```
	math_utils.h
	```

	所示，核心是通过宏定义判断是否已包含头文件，避免重复编译。

- **方式 2：#pragma once**（简洁，部分编译器支持，如 VS、GCC）：

	

	直接在头文件第一行写

	```
	#pragma once
	```

	，功能与方式 1 一致，示例：

	c

	```c
	#pragma once  // 头文件保护，仅编译一次
	#define PI 3.14
	int add(int a, int b);
	```

	

## 十、递归函数

### 1. 递归的定义与核心条件

#### （1）定义

- 递归：函数**直接或间接调用自身**的编程技巧，将复杂问题拆解为与原问题结构相同的子问题，直到子问题可直接解决（递归出口）。

#### （2）递归的两个必要条件

1. **递归出口**：存在一个或多个 “终止条件”，当满足时停止递归（否则会导致无限递归，栈溢出）；
2. **递归递推**：每次递归调用时，问题规模必须**缩小**，且子问题与原问题结构一致。

### 2. 示例 1：求 n 的阶乘（递归实现）

#### （1）阶乘数学定义

- 当 n=0 或 n=1 时，n! = 1；
- 当 n>1 时，n! = n × (n-1)!（递推关系）。

#### （2）递归代码实现

c

```c
#include <stdio.h>

// 递归函数：求n的阶乘
int factorial(int n)
{
    // 递归出口：n=0或n=1，返回1
    if (n == 0 || n == 1)
    {
        return 1;
    }
    // 递归递推：n! = n × (n-1)!（调用自身，问题规模缩小）
    return n * factorial(n - 1);
}

int main()
{
    int num;
    printf("请输入一个非负整数：");
    scanf("%d", &num);

    if (num < 0)
    {
        printf("阶乘仅支持非负整数！\n");
        return 1;  // 异常退出，返回非0值
    }

    printf("%d的阶乘：%d\n", num, factorial(num));
    // 输入5 → 输出：5的阶乘：120（递归过程：5*4! → 5*4*3! → ... → 5*4*3*2*1*1）
    return 0;
}
```

### 3. 示例 2：递归打印 1 到 n 的整数

#### （1）思路

- 递归出口：当 n=1 时，打印 1 并返回；
- 递归递推：先打印 1 到 n-1 的整数，再打印 n（或先打印 n，再递归打印 1 到 n-1，顺序相反）。

#### （2）代码实现（正序打印 1 到 n）

c

```c
#include <stdio.h>

// 递归函数：正序打印1到n
void printFrom1ToN(int n)
{
    // 递归出口：n=1时，打印1
    if (n == 1)
    {
        printf("%d ", 1);
        return;
    }
    // 递归递推：先打印1到n-1，再打印n
    printFrom1ToN(n - 1);
    printf("%d ", n);
}

int main()
{
    int n = 5;
    printf("正序打印1到%d：", n);
    printFrom1ToN(n);  // 输出：1 2 3 4 5
    return 0;
}
```

#### （3）代码实现（逆序打印 n 到 1）

c

```c
#include <stdio.h>

// 递归函数：逆序打印n到1
void printFromNTo1(int n)
{
    // 递归出口：n=1时，打印1
    if (n == 1)
    {
        printf("%d ", 1);
        return;
    }
    // 递归递推：先打印n，再递归打印n-1到1
    printf("%d ", n);
    printFromNTo1(n - 1);
}

int main()
{
    int n = 5;
    printf("逆序打印%d到1：", n);
    printFromNTo1(n);  // 输出：5 4 3 2 1
    return 0;
}
```

### 4. 示例 3：斐波那契数列（递归实现）

#### （1）斐波那契数列定义

- 第 1 项：F (1)=1；
- 第 2 项：F (2)=1；
- 第 n 项（n≥3）：F (n) = F (n-1) + F (n-2)。

#### （2）递归代码实现

c

```c
#include <stdio.h>

// 递归函数：求第n项斐波那契数
int fibonacci(int n)
{
    // 递归出口：第1项和第2项均为1
    if (n == 1 || n == 2)
    {
        return 1;
    }
    // 递归递推：F(n) = F(n-1) + F(n-2)
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main()
{
    int n = 10;
    printf("第%d项斐波那契数：%d\n", n, fibonacci(n));  // 输出：55
    printf("前%d项斐波那契数列：", n);
    for (int i = 1; i <= n; i++)
    {
        printf("%d ", fibonacci(i));  // 输出：1 1 2 3 5 8 13 21 34 55
    }
    return 0;
}
```

#### （3）递归的效率问题（重点）

- 上述斐波那契递归实现存在**大量重复计算**（如计算 F (5) 需 F (4) 和 F (3)，计算 F (4) 又需 F (3) 和 F (2)，F (3) 被重复计算）；

- 优化方案：使用**迭代（循环）** 或**记忆化递归**（存储已计算结果），示例迭代实现：

	c

	```c
	#include <stdio.h>
	
	// 迭代函数：求第n项斐波那契数（无重复计算，效率高）
	int fibonacciIter(int n)
	{
	    if (n == 1 || n == 2)
	        return 1;
	    int a = 1, b = 1, c;  // a=F(1), b=F(2)
	    for (int i = 3; i <= n; i++)
	    {
	        c = a + b;  // F(i) = F(i-2) + F(i-1)
	        a = b;      // 更新a为F(i-1)
	        b = c;      // 更新b为F(i)
	    }
	    return b;
	}
	
	int main()
	{
	    printf("第10项斐波那契数（迭代）：%d\n", fibonacciIter(10));  // 输出：55
	    return 0;
	}
	```
	
	

### 5. 递归的栈溢出问题（避坑点）

#### （1）原因

- 函数调用时会在**栈区**分配内存（存储函数参数、局部变量、返回地址），称为 “函数栈帧”；
- 无限递归（无出口或出口无法触发）会导致栈区内存被耗尽，触发 “栈溢出” 错误（程序崩溃）。

#### （2）示例：无限递归导致栈溢出

c

```c
#include <stdio.h>

// 错误：无递归出口，会无限调用自身
void infiniteRecursion()
{
    printf("递归中...\n");
    infiniteRecursion();  // 无终止条件，无限递归
}

int main()
{
    infiniteRecursion();  // 运行后会崩溃，提示“栈溢出”
    return 0;
}
```

#### （3）避免栈溢出的方法

1. 确保递归有**明确的出口**，且每次递归都能向出口靠近；
2. 控制递归深度（避免深度过大，如 n 超过 1000 的阶乘递归可能栈溢出，需用迭代）；
3. 优先使用迭代实现（循环），递归仅用于问题结构天然适合递归的场景（如树形结构遍历）。

## 十一、指针基础

### 1. 内存地址的概念

#### （1）内存的本质

- 计算机内存是由大量 “内存单元” 组成的线性存储空间，每个内存单元占**1 字节（8 位）**；
- 每个内存单元有唯一的 “编号”，称为**内存地址**（类似房间号），CPU 通过地址访问内存中的数据。

#### （2）地址的表示

- 地址用**十六进制数**表示（简化显示，1 位十六进制对应 4 位二进制）；
- 32 位操作系统的地址范围：0x00000000 ~ 0xFFFFFFFF（共 2³² 个地址，对应 4GB 内存）；
- 64 位操作系统的地址范围：0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF（共 2⁶⁴个地址）。

### 2. 指针的定义（存储地址的变量）

#### （1）核心概念

- 指针：本质是**变量**，但存储的不是普通数据（如整数、字符），而是**另一个变量的内存地址**；
- 指针的价值：通过指针可间接访问和修改其指向的变量（突破函数传值调用的限制，实现 “传址调用”）。

#### （2）指针变量的定义语法

```
数据类型 *指针变量名;
```

- `*`：表示 “指针变量”，与变量名绑定（不是与数据类型绑定）；
- 数据类型：指**指针指向的变量的数据类型**（不是指针本身的类型），决定了通过指针访问内存时的 “步长”（如 int * 指针每次移动 4 字节）。

#### 示例：指针变量的定义与基本使用

c

```c
#include <stdio.h>

int main()
{
    // 1. 定义普通变量a，分配内存（假设地址为0x006FFD7C）
    int a = 10;
    printf("变量a的值：%d\n", a);          // 输出：10
    printf("变量a的地址（&a）：%p\n", &a); // 输出：006FFD7C（%p用于打印地址）

    // 2. 定义int*类型指针p，存储a的地址（p指向a）
    int *p = &a;  // &是“取地址符”，获取a的地址并赋值给p
    // 注意：int* p 可写为 int *p 或 int*p，推荐int *p（清晰表示*与p绑定）
    printf("\n指针p的值（存储的地址）：%p\n", p);  // 输出：006FFD7C（与&a相同）
    printf("指针p自身的地址（&p）：%p\n", &p);    // 输出：006FFD70（p是变量，有自己的地址）

    // 3. *是“解引用符”：通过指针p访问其指向的变量a
    printf("\n通过*p访问a的值：%d\n", *p);  // 输出：10（等价于a）

    // 4. 通过*p修改a的值
    *p = 20;  // 等价于a = 20
    printf("修改后，a的值：%d\n", a);        // 输出：20
    printf("修改后，通过*p访问a的值：%d\n", *p);  // 输出：20

    return 0;
}
```

### 3. 指针的类型与大小

#### （1）指针的类型

- 指针的类型由 “指向的变量类型” 决定，如 int*、char*、double*，不同类型指针的核心区别：
	1. 解引用时访问的内存字节数不同（int*解引用访问 4 字节，char*访问 1 字节，double * 访问 8 字节）；
	2. 指针算术运算的 “步长” 不同（int* p++ 移动 4 字节，char* p++ 移动 1 字节）。

#### 示例：不同类型指针的解引用与步长

c

```c
#include <stdio.h>

int main()
{
    // 定义不同类型的变量
    int a = 0x12345678;    // 4字节（十六进制表示，便于观察内存）
    char b = 0x99;         // 1字节
    double c = 3.14;       // 8字节

    // 定义对应类型的指针
    int *p_int = &a;
    char *p_char = &b;
    double *p_double = &c;

    // 1. 解引用访问的字节数（通过printf观察）
    printf("*p_int（int*解引用）：%x\n", *p_int);  // 输出：12345678（4字节）
    printf("*p_char（char*解引用）：%x\n", *p_char);  // 输出：99（1字节）
    printf("*p_double（double*解引用）：%.2f\n", *p_double);  // 输出：3.14（8字节）

    // 2. 指针算术运算的步长（p++移动的字节数）
    printf("\np_int初始地址：%p\n", p_int);
    p_int++;  // int*步长=4字节
    printf("p_int++后地址：%p\n", p_int);  // 地址+4（如006FFD7C → 006FFD80）

    printf("\np_char初始地址：%p\n", p_char);
    p_char++;  // char*步长=1字节
    printf("p_char++后地址：%p\n", p_char);  // 地址+1（如006FFD7B → 006FFD7C）

    printf("\np_double初始地址：%p\n", p_double);
    p_double++;  // double*步长=8字节
    printf("p_double++后地址：%p\n", p_double);  // 地址+8（如006FFD6C → 006FFD74）

    return 0;
}
```

#### （2）指针的大小（关键特性）

- 无论指针类型是 int*、char*还是 double*，在**同一操作系统位数**下，指针大小都相同（因为存储的是地址，地址的位数由操作系统位数决定）；
- 32 位操作系统：指针大小 = 4 字节；
- 64 位操作系统：指针大小 = 8 字节。

#### 示例：计算不同类型指针的大小

c

```c
#include <stdio.h>

int main()
{
    // 计算不同类型指针的大小（sizeof返回size_t类型，用%zu打印）
    printf("int*指针大小：%zu字节\n", sizeof(int*));      // 32位→4，64位→8
    printf("char*指针大小：%zu字节\n", sizeof(char*));    // 32位→4，64位→8
    printf("double*指针大小：%zu字节\n", sizeof(double*));// 32位→4，64位→8
    printf("void*指针大小：%zu字节\n", sizeof(void*));    // 32位→4，64位→8（void*是通用指针）

    return 0;
}
```

### 4. 野指针与空指针（避坑点）

#### （1）野指针（危险！）

- 定义：未初始化、未赋值或指向已释放内存的指针（指向随机地址）；
- 危害：解引用野指针会访问随机内存，可能导致程序崩溃、数据损坏或运行异常（行为未定义）。

#### 示例：野指针的产生与危害

c

```c
#include <stdio.h>

int main()
{
    // 1. 未初始化的野指针（p指向随机地址）
    int *p;  // 未初始化，p的值是随机的
    // *p = 10;  // 错误：解引用野指针，程序可能崩溃

    // 2. 指向已释放内存的野指针（后续动态内存章节详解）
    int a = 10;
    int *q = &a;
    // 当a的作用域结束（如出函数），a的内存被释放，q变为野指针

    return 0;
}
```

#### （2）空指针（安全的 “无指向” 指针）

- 定义：指向`NULL`的指针（`NULL`是 C 标准库定义的宏，值为 0，对应地址 0x0，该地址不可访问）；
- 作用：明确表示指针 “暂时无指向”，避免野指针，解引用前可通过`if(p != NULL)`判断，提高安全性。

#### 示例：空指针的使用

c

```c
#include <stdio.h>

int main()
{
    // 1. 定义空指针（必须包含<stdio.h>或<stddef.h>，NULL在其中定义）
    int *p = NULL;
    printf("空指针p的地址：%p\n", p);  // 输出：00000000（32位）或0000000000000000（64位）

    // 2. 解引用空指针前先判断（避免崩溃）
    if (p != NULL)
    {
        *p = 10;  // 不会执行，因为p==NULL
    }
    else
    {
        printf("指针p是NULL，不可解引用！\n");  // 输出：此句
    }

    // 3. 后续可给p赋值有效地址
    int a = 20;
    p = &a;  // p不再是NULL，指向a
    if (p != NULL)
    {
        *p = 30;  // 安全，等价于a=30
        printf("a的值：%d\n", a);  // 输出：30
    }

    return 0;
}
```

### 5. 指针与函数（传址调用）

#### （1）传址调用的核心作用

- 突破 “传值调用” 的限制：传值调用时函数修改的是形参（实参的拷贝），无法影响实参；
- 传址调用：将实参的地址传给形参（指针），函数通过指针解引用可直接修改实参的值。

#### 示例 1：用传址调用实现两数交换（解决之前传值调用的错误）

c

```c
#include <stdio.h>

// 传址调用：形参是int*指针，接收实参的地址
void swap(int *x, int *y)
{
    int temp = *x;  // *x访问x指向的实参a
    *x = *y;        // 修改a的值为*y（b的值）
    *y = temp;      // 修改b的值为temp（原a的值）
}

int main()
{
    int a = 10, b = 20;
    printf("交换前：a=%d, b=%d\n", a, b);  // 输出：10, 20

    // 传入a和b的地址（&a, &b），形参x=&a，y=&b
    swap(&a, &b);

    printf("交换后：a=%d, b=%d\n", a, b);  // 输出：20, 10（实参被修改）
    return 0;
}
```

#### 示例 2：用传址调用返回多个值（函数仅能返回 1 个值，指针可突破）

c

```c
#include <stdio.h>

// 功能：计算两个数的和与差，通过指针返回结果
void calculateSumAndDiff(int a, int b, int *sum, int *diff)
{
    *sum = a + b;  // 结果存入sum指向的变量
    *diff = a - b; // 结果存入diff指向的变量
}

int main()
{
    int x = 25, y = 15;
    int sum, diff;  // 存储和与差的变量

    // 传入sum和diff的地址，函数通过指针修改它们的值
    calculateSumAndDiff(x, y, &sum, &diff);

    printf("和：%d\n", sum);  // 输出：40
    printf("差：%d\n", diff);  // 输出：10
    return 0;
}
```

## 十二、指针与数组深度关联

### 1. 数组名的本质（首元素地址）

#### （1）核心结论

- 数组名是**数组首元素的地址**（常量，不可修改，类似`const int*`），而非整个数组的地址（仅两种例外：`sizeof(数组名)`、`&数组名`）；
- 关键等式：`arr[i] == *(arr + i)`（通过指针算术访问数组元素，与下标访问等价）。

#### （2）数组名与指针的异同

| 特性         | 数组名（如`int arr[5]`）           | 指针变量（如`int* p = arr`）     |
| ------------ | ---------------------------------- | -------------------------------- |
| 本质         | 首元素地址（常量，不可修改）       | 存储地址的变量（可修改指向）     |
| 能否赋值     | 不能（如`arr = &a`编译报错）       | 能（如`p = &b`合法）             |
| `sizeof`结果 | 数组总字节数（如`sizeof(arr)=20`） | 指针大小（32 位→4，64 位→8）     |
| 访问元素方式 | `arr[i]` 或 `*(arr+i)`             | `p[i]` 或 `*(p+i)` 或 `*(arr+i)` |

#### 示例 1：数组名与指针的等价访问

c

```c
#include <stdio.h>

int main()
{
    int arr[] = {10, 20, 30, 40, 50};
    int *p = arr;  // p指向数组首元素（arr是首元素地址）

    // 1. 下标访问：数组名与指针等价
    printf("arr[0] = %d, p[0] = %d\n", arr[0], p[0]);  // 输出：10, 10
    printf("arr[2] = %d, p[2] = %d\n", arr[2], p[2]);  // 输出：30, 30

    // 2. 指针算术访问：*(数组名+i) 与 *(指针+i) 等价
    printf("*(arr+1) = %d, *(p+1) = %d\n", *(arr+1), *(p+1));  // 输出：20, 20
    printf("*(arr+3) = %d, *(p+3) = %d\n", *(arr+3), *(p+3));  // 输出：40, 40

    // 3. 指针自增：p可修改，arr不可修改
    p++;  // p指向arr[1]（地址+4字节）
    printf("\np自增后，*p = %d\n", *p);  // 输出：20
    // arr++;  // 错误：arr是常量，不可修改

    return 0;
}
```

#### 示例 2：`sizeof(数组名)`与`sizeof(指针)`的区别

c

```c
#include <stdio.h>

int main()
{
    int arr[5] = {1,2,3,4,5};
    int *p = arr;

    // 1. sizeof(arr)：数组总字节数=元素个数×元素类型字节数
    printf("sizeof(arr) = %zu\n", sizeof(arr));  // 输出：20（5×4）

    // 2. sizeof(p)：指针大小（与类型无关，仅与系统位数有关）
    printf("sizeof(p) = %zu\n", sizeof(p));      // 32位→4，64位→8

    // 3. sizeof(arr[0])：单个元素的字节数
    printf("sizeof(arr[0]) = %zu\n", sizeof(arr[0]));  // 输出：4（int类型）

    // 4. 计算数组长度的通用公式：sizeof(arr)/sizeof(arr[0])
    int len = sizeof(arr) / sizeof(arr[0]);
    printf("数组长度：%d\n", len);  // 输出：5

    return 0;
}
```

### 2. 指针数组（数组元素是指针）

#### （1）定义语法

```
数据类型 *数组名[数组长度];
```

- 优先级：`[]`高于`*`，所以 “数组名先与`[]`结合”，表示 “数组”，再与`*`结合，表示 “数组元素是指针”；
- 常见用途：存储多个字符串的地址（字符串常量本质是字符数组首地址）。

#### 示例 1：指针数组存储字符串列表

c

```c
#include <stdio.h>

int main()
{
    // 指针数组：每个元素是char*指针，指向一个字符串常量
    char *str_arr[] = {
        "apple",   // str_arr[0] = "apple"的首地址
        "banana",  // str_arr[1] = "banana"的首地址
        "cherry"   // str_arr[2] = "cherry"的首地址
    };
    int len = sizeof(str_arr) / sizeof(str_arr[0]);  // 数组长度=3

    // 遍历指针数组，打印每个字符串
    for (int i = 0; i < len; i++)
    {
        // str_arr[i]是字符串首地址，%s输出字符串
        printf("str_arr[%d] = %s\n", i, str_arr[i]);
    }

    // 输出结果：
    // str_arr[0] = apple
    // str_arr[1] = banana
    // str_arr[2] = cherry

    return 0;
}
```

#### 示例 2：指针数组与二维字符数组的对比

- 指针数组存储字符串更节省内存（仅存储地址，字符串长度可不同）；
- 二维字符数组需固定每行长度（可能浪费内存）。

c

```c
#include <stdio.h>

int main()
{
    // 1. 指针数组（节省内存）
    char *ptr_arr[] = {"cat", "dog", "elephant"};
    printf("指针数组大小：%zu\n", sizeof(ptr_arr));  // 3×8=24（64位系统，每个指针8字节）

    // 2. 二维字符数组（固定每行长度，浪费内存）
    char char_arr[3][10] = {"cat", "dog", "elephant"};  // 每行固定10字节
    printf("二维字符数组大小：%zu\n", sizeof(char_arr));  // 3×10=30（"elephant"仅8字节，浪费2字节）

    return 0;
}
```

### 3. 数组指针（指向数组的指针）

#### （1）定义语法

```
数据类型 (*指针名)[数组长度];
```

- 优先级：`()`高于`[]`，所以 “指针名先与`*`结合”，表示 “指针”，再与`[]`结合，表示 “指针指向的是数组”；
- 关键：数组指针的类型由 “指向的数组元素类型” 和 “数组长度” 共同决定，如`int (*p)[5]`表示 “指向 int [5] 数组的指针”。

#### （2）数组指针与指针数组的核心区别

| 类型     | 定义语法       | 本质                    | 用途                       |
| -------- | -------------- | ----------------------- | -------------------------- |
| 指针数组 | `int *p[5];`   | 数组，元素是 int * 指针 | 存储多个地址（如字符串）   |
| 数组指针 | `int (*p)[5];` | 指针，指向 int [5] 数组 | 遍历二维数组、传递二维数组 |

#### 示例 1：数组指针指向一维数组

c

```c
#include <stdio.h>

int main()
{
    int arr[5] = {1,2,3,4,5};
    int (*p)[5] = &arr;  // &arr是整个数组的地址，类型是int(*)[5]，需用数组指针接收

    // 1. 访问数组元素：通过数组指针解引用后得到数组名（首元素地址）
    printf("(*p)[0] = %d\n", (*p)[0]);  // 输出：1（*p等价于arr）
    printf("(*p)[2] = %d\n", (*p)[2]);  // 输出：3
    printf("*(*p + 3) = %d\n", *(*p + 3));  // 输出：4（*p+3是arr[3]地址，解引用得值）

    // 2. 数组指针的算术运算：步长=指向的数组总字节数（5×4=20）
    printf("\n初始p地址：%p\n", p);
    p++;  // 地址+20字节（指向arr后面的内存）
    printf("p++后地址：%p\n", p);  // 地址差值为20（64位系统示例：006FFD60 → 006FFD74）

    return 0;
}
```

#### 示例 2：数组指针遍历二维数组

- 二维数组本质是 “数组的数组”，每行是一个一维数组，数组指针可指向二维数组的行；
- 优势：避免二维数组传参时退化为指针（丢失列信息）。

c

```c
#include <stdio.h>

// 函数参数：数组指针（指向int[3]数组，明确列数=3）
void print2DArray(int (*p)[3], int rows)
{
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            // p[i]等价于*(p+i)，指向第i行，p[i][j]是第i行第j列元素
            printf("%d ", p[i][j]);
        }
        printf("\n");
    }
}

int main()
{
    int arr[2][3] = {{10,20,30}, {40,50,60}};
    // 数组名arr是首行（int[3]数组）的地址，类型是int(*)[3]，可直接传给数组指针参数
    print2DArray(arr, 2);

    // 输出结果：
    // 10 20 30 
    // 40 50 60 

    return 0;
}
```

## 十三、字符串与指针

### 1. 字符串常量与指针

#### （1）核心特性

- 字符串常量（如`"hello"`）本质是**只读的字符数组**，存储在内存的 “常量区”，不可修改；
- 用`char*`指针指向字符串常量时，指针存储的是字符串首字符的地址（如`char* str = "hello"`等价于`char* str = &"hello"[0]`）。

#### （2）`char* str`与`char str[]`的区别

| 类型         | 定义示例                | 存储区域       | 是否可修改 | 本质                 |
| ------------ | ----------------------- | -------------- | ---------- | -------------------- |
| `char* str`  | `char* str = "hello";`  | 常量区（只读） | 不可修改   | 指针指向字符串常量   |
| `char str[]` | `char str[] = "hello";` | 栈区（可写）   | 可修改     | 字符数组，拷贝字符串 |

#### 示例 1：字符串常量不可修改（`char* str`）

c

```c
#include <stdio.h>

int main()
{
    char* str = "hello";  // str指向常量区的"hello"
    printf("str = %s\n", str);  // 输出：hello

    // str[0] = 'H';  // 错误：修改常量区数据，程序崩溃（行为未定义）
    // *str = 'H';    // 同样错误：解引用指针修改常量区

    // 允许修改指针的指向（指针变量在栈区，可修改）
    str = "world";
    printf("str = %s\n", str);  // 输出：world

    return 0;
}
```

#### 示例 2：字符数组可修改（`char str[]`）

c

```c
#include <stdio.h>

int main()
{
    char str[] = "hello";  // 栈区分配6字节（5个字符+'\0'），拷贝"hello"
    printf("修改前：str = %s\n", str);  // 输出：hello

    // 修改字符数组元素（合法，栈区数据可写）
    str[0] = 'H';  // 第一个字符改为'H'
    *(str+1) = 'E';  // 第二个字符改为'E'
    printf("修改后：str = %s\n", str);  // 输出：HEllo

    return 0;
}
```

### 2. 指针操作字符串（常见场景）

#### （1）字符串长度计算（模拟`strlen`）

- 思路：用指针遍历字符串，直到遇到`'\0'`，统计字符个数（不包含`'\0'`）。

c

```c
#include <stdio.h>

// 模拟strlen：计算字符串长度（指针实现）
size_t my_strlen(const char* str)  // const修饰：确保指针指向的内容不被修改
{
    const char* p = str;  // 临时指针，避免修改原指针指向
    while (*p != '\0')    // 遍历到'\0'停止
    {
        p++;              // 指针后移
    }
    return p - str;       // 地址差=字符个数（指针减法，单位是元素类型字节数）
}

int main()
{
    char* str1 = "C programming";
    char str2[] = "hello world";

    printf("str1长度：%zu\n", my_strlen(str1));  // 输出：13
    printf("str2长度：%zu\n", my_strlen(str2));  // 输出：11

    return 0;
}
```

#### （2）字符串拷贝（模拟`strcpy`）

- 思路：用指针将源字符串（`src`）的字符逐个拷贝到目标字符串（`dest`），直到遇到`'\0'`（需确保`dest`容量足够）。

c

```c
#include <stdio.h>

// 模拟strcpy：将src拷贝到dest（包含'\0'）
char* my_strcpy(char* dest, const char* src)
{
    char* p = dest;  // 保存dest初始地址，用于返回
    while (*src != '\0')
    {
        *dest = *src;  // 拷贝当前字符
        dest++;        // 目标指针后移
        src++;         // 源指针后移
    }
    *dest = '\0';  // 拷贝'\0'，确保目标字符串终止
    return p;
}

int main()
{
    char dest[20];  // 目标数组，容量足够
    char* src = "hello C";

    my_strcpy(dest, src);
    printf("dest = %s\n", dest);  // 输出：hello C

    return 0;
}
```

## 十四、二级指针（指向指针的指针）

### 1. 定义与内存模型

#### （1）定义语法

```
数据类型 **二级指针名;
```

- 本质：二级指针存储的是**一级指针的地址**，通过两次解引用可访问最终数据（`**p`）；
- 内存模型：`数据 → 一级指针（存数据地址） → 二级指针（存一级指针地址）`。

#### 示例 1：二级指针的基本使用

c

```c
#include <stdio.h>

int main()
{
    // 1. 定义普通变量（数据）
    int a = 100;
    // 2. 定义一级指针（存a的地址）
    int *p = &a;
    // 3. 定义二级指针（存p的地址）
    int **pp = &p;

    // 访问数据的三种方式
    printf("直接访问a：%d\n", a);          // 输出：100
    printf("一级指针解引用：%d\n", *p);    // 输出：100（*p = a）
    printf("二级指针两次解引用：%d\n", **pp);  // 输出：100（**pp = *p = a）

    // 访问地址的方式
    printf("\n&a = %p, p = %p\n", &a, p);          // 地址相同（a的地址）
    printf("&p = %p, pp = %p\n", &p, pp);          // 地址相同（p的地址）
    printf("*pp = %p\n", *pp);                      // 输出：p的值（a的地址）

    return 0;
}
```

### 2. 二级指针的用途

#### （1）处理指针数组

- 指针数组的数组名是 “一级指针的地址”，需用二级指针接收（如`char** argv`是命令行参数的标准写法）。

#### 示例 1：二级指针遍历指针数组

c

```c
#include <stdio.h>

// 函数参数：二级指针（接收指针数组的地址）
void printPtrArray(char** arr, int len)
{
    for (int i = 0; i < len; i++)
    {
        // arr[i]等价于*(arr+i)，是一级指针（指向字符串），%s输出字符串
        printf("arr[%d] = %s\n", i, arr[i]);
    }
}

int main()
{
    char* str_arr[] = {"apple", "banana", "cherry"};
    int len = sizeof(str_arr) / sizeof(str_arr[0]);

    // 指针数组名str_arr是一级指针（str_arr[0]）的地址，类型是char**，可传给二级指针参数
    printPtrArray(str_arr, len);

    // 输出结果：
    // arr[0] = apple
    // arr[1] = banana
    // arr[2] = cherry

    return 0;
}
```

#### （2）在函数中修改一级指针的指向

- 若需在函数中修改一级指针的指向（而非指针指向的数据），需传递一级指针的地址（即二级指针）。

#### 示例 2：用二级指针修改一级指针的指向

c

```c
#include <stdio.h>

// 函数：通过二级指针修改一级指针p的指向，使其指向b
void changePtrPoint(int** pp, int* b)
{
    *pp = b;  // *pp是一级指针p，修改p的指向为b
}

int main()
{
    int a = 10, b = 20;
    int *p = &a;  // 初始p指向a

    printf("修改前：*p = %d\n", *p);  // 输出：10（p指向a）

    // 传递p的地址（&p，二级指针），以及b的地址
    changePtrPoint(&p, &b);

    printf("修改后：*p = %d\n", *p);  // 输出：20（p指向b）

    return 0;
}
```

## 十五、动态内存分配

### 1. 动态内存的核心意义

- 静态内存（如数组、局部变量）：编译时分配，大小固定，栈区存储，函数结束后自动释放；
- 动态内存：运行时分配，大小可按需调整，堆区存储，需手动申请（`malloc/calloc/realloc`）和释放（`free`）；
- 解决问题：静态数组大小固定的局限性（如不确定用户输入的数据量时，用动态内存按需分配）。

### 2. 动态内存函数（`stdlib.h`头文件）

#### （1）`malloc`函数（分配指定字节数的内存）

- 函数原型：`void* malloc(size_t size);`
- 功能：在堆区分配`size`字节的连续内存，返回指向该内存的`void*`指针（需强制类型转换）；
- 注意：分配的内存**未初始化**（内容是随机值），分配失败返回`NULL`。

#### 示例 1：`malloc`分配 int 类型内存

c

```c
#include <stdio.h>
#include <stdlib.h>  // 包含动态内存函数声明

int main()
{
    int n = 5;
    // 分配n个int的内存：n×sizeof(int)字节，强制转换为int*
    int* arr = (int*)malloc(n * sizeof(int));

    // 检查分配是否成功（必须！避免野指针）
    if (arr == NULL)
    {
        printf("内存分配失败！\n");
        return 1;  // 异常退出
    }

    // 初始化动态内存（手动赋值）
    for (int i = 0; i < n; i++)
    {
        arr[i] = i + 1;  // arr[0]=1, arr[1]=2, ..., arr[4]=5
    }

    // 遍历动态数组
    printf("动态数组元素：");
    for (int i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);  // 输出：1 2 3 4 5
    }

    // 手动释放动态内存（必须！避免内存泄漏）
    free(arr);
    arr = NULL;  // 释放后置空，避免野指针

    return 0;
}
```

#### （2）`calloc`函数（分配并初始化内存）

- 函数原型：`void* calloc(size_t nmemb, size_t size);`
- 功能：在堆区分配`nmemb`个 “每个大小为`size`字节” 的连续内存，**自动初始化为 0**，返回`void*`指针；
- 与`malloc`对比：`calloc(n, sizeof(int))`等价于`malloc(n×sizeof(int)) + memset(内存, 0, n×sizeof(int))`。

#### 示例 2：`calloc`分配并初始化内存

c

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int n = 3;
    // 分配3个int的内存，自动初始化为0
    int* p = (int*)calloc(n, sizeof(int));

    if (p == NULL)
    {
        printf("内存分配失败！\n");
        return 1;
    }

    // 打印初始化后的内存（均为0）
    printf("calloc初始化后：");
    for (int i = 0; i < n; i++)
    {
        printf("%d ", p[i]);  // 输出：0 0 0
    }

    free(p);
    p = NULL;

    return 0;
}
```

#### （3）`realloc`函数（调整已分配的内存大小）

- 函数原型：`void* realloc(void* ptr, size_t size);`
- 功能：调整`ptr`指向的动态内存大小为`size`字节，返回新内存的地址；
- 内存调整规则：
	1. 若原内存后有足够空间：直接扩展，返回原地址；
	2. 若原内存后空间不足：分配新内存，拷贝原数据到新内存，释放原内存，返回新地址；
	3. 若`ptr == NULL`：等价于`malloc(size)`；
	4. 若`size == 0`：等价于`free(ptr)`，返回`NULL`；
- 注意：调整失败返回`NULL`，需用新指针接收（避免原指针丢失）。

#### 示例 3：`realloc`调整动态内存大小

c

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    // 1. 先用malloc分配5个int的内存
    int* arr = (int*)malloc(5 * sizeof(int));
    if (arr == NULL) { printf("分配失败！\n"); return 1; }

    // 初始化前5个元素
    for (int i = 0; i < 5; i++)
    {
        arr[i] = i + 1;  // 1,2,3,4,5
    }

    // 2. 用realloc将内存调整为8个int的大小
    int* new_arr = (int*)realloc(arr, 8 * sizeof(int));
    if (new_arr == NULL)
    {
        printf("内存调整失败！\n");
        free(arr);  // 调整失败，需释放原内存
        return 1;
    }
    arr = new_arr;  // 调整成功，更新指针指向新内存

    // 初始化新增的3个元素（索引5-7）
    for (int i = 5; i < 8; i++)
    {
        arr[i] = i + 1;  // 6,7,8
    }

    // 遍历调整后的数组
    printf("调整后数组：");
    for (int i = 0; i < 8; i++)
    {
        printf("%d ", arr[i]);  // 输出：1 2 3 4 5 6 7 8
    }

    free(arr);
    arr = NULL;

    return 0;
}
```

#### （4）`free`函数（释放动态内存）

- 函数原型：`void free(void* ptr);`
- 功能：释放`ptr`指向的堆区动态内存（归还给系统）；
- 注意事项：
	1. `ptr`必须是动态内存函数（`malloc/calloc/realloc`）的返回值，不可释放静态内存（如栈区变量）；
	2. 不可重复释放（同一内存释放多次，程序崩溃）；
	3. 释放后`ptr`变为野指针，需手动置为`NULL`；
	4. 若`ptr == NULL`，`free`无操作（安全）。

#### 示例 4：`free`的常见错误

c

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int a = 10;
    int* p1 = (int*)malloc(sizeof(int));
    int* p2 = p1;  // p2与p1指向同一块动态内存

    // 错误1：释放静态内存（栈区变量a的地址）
    // free(&a);  // 程序崩溃

    // 正确释放：释放动态内存
    free(p1);
    p1 = NULL;  // 置空，避免野指针

    // 错误2：重复释放（p2与p1指向同一块内存，已被free(p1)释放）
    // free(p2);  // 程序崩溃（p2已变成野指针）

    // 安全操作：释放NULL指针（无任何影响）
    free(NULL);

    return 0;
}
```

### 3. 动态内存常见问题（避坑指南）

#### （1）内存泄漏

- 定义：动态内存已分配但未释放，程序运行期间内存持续占用，直到程序结束才归还给系统；

- 场景：函数中分配动态内存后未释放就返回，或分支语句中遗漏`free`；

- 示例：

	c

	```c
	void func()
	{
	    int* p = (int*)malloc(10);
	    // 错误：未free(p)就返回，内存泄漏
	    return;
	}
	```
	
	

#### （2）野指针访问

- 场景 1：释放内存后未置空，继续解引用指针；
- 场景 2：`malloc/calloc/realloc`分配失败返回`NULL`，未检查就解引用；
- 避免：释放后置`NULL`，分配后必检查`NULL`。

#### （3）越界访问

- 定义：访问动态内存的范围超过分配的大小（如分配 5 个 int，却访问`arr[10]`）；
- 危害：破坏堆区内存结构，导致程序崩溃或数据损坏（行为未定义）；
- 避免：严格控制访问索引在分配范围内。

## 十六、结构体（struct）：自定义复杂数据类型

### 1. 结构体的核心作用

- 解决 “单一数据类型无法描述复杂实体” 的问题（如学生需包含姓名、年龄、成绩等多类数据）；
- 结构体是**不同类型数据的集合**（成员可是 int、char、指针、甚至其他结构体），但各成员占用独立内存。

### 2. 结构体的定义与初始化

#### （1）定义语法（3 种方式）

| 定义方式               | 语法示例                                                     | 特点                         |
| ---------------------- | ------------------------------------------------------------ | ---------------------------- |
| 先定义类型再定义变量   | `struct Student { char name[20]; int age; float score; }; struct Student stu1;` | 类型可重复使用（推荐）       |
| 定义类型时直接定义变量 | `struct Student { char name[20]; int age; }; struct Student stu1, stu2;` | 一次性定义类型和变量         |
| 匿名结构体（无类型名） | `struct { char name[20]; int age; } stu1;`                   | 类型不可复用，仅用于临时变量 |

#### （2）初始化（类似数组，按成员顺序或指定成员名）

c

```c
#include <stdio.h>
#include <string.h>

// 1. 定义结构体类型
struct Student {
    char name[20];  // 姓名（字符数组）
    int age;        // 年龄（整型）
    float score;    // 成绩（浮点型）
};

int main()
{
    // 2. 初始化方式1：按成员顺序初始化（未赋值成员默认为0/空）
    struct Student stu1 = {"张三", 20, 95.5};
    // 2. 初始化方式2：指定成员名初始化（顺序可打乱）
    struct Student stu2 = {.age=19, .name="李四", .score=88.0};
    // 2. 初始化方式3：先定义后赋值（字符数组需用strcpy，不可直接赋值）
    struct Student stu3;
    strcpy(stu3.name, "王五");  // 字符数组用strcpy赋值
    stu3.age = 21;
    stu3.score = 92.3;

    // 打印结构体成员
    printf("stu1：%s, %d岁, %.1f分\n", stu1.name, stu1.age, stu1.score);
    printf("stu2：%s, %d岁, %.1f分\n", stu2.name, stu2.age, stu2.score);
    printf("stu3：%s, %d岁, %.1f分\n", stu3.name, stu3.age, stu3.score);

    return 0;
}
// 输出：
// stu1：张三, 20岁, 95.5分
// stu2：李四, 19岁, 88.0分
// stu3：王五, 21岁, 92.3分
```

### 3. 结构体成员的访问（. 和 -> 运算符）

#### （1）访问规则

- 若为**结构体变量**：用 `.` 运算符（`变量名.成员名`）；
- 若为**结构体指针**：用 `->` 运算符（`指针名->成员名`），或先解引用再用 `.`（`(*指针名).成员名`，等价但繁琐）。

#### 示例：结构体变量与指针的成员访问

c

```c
#include <stdio.h>
#include <string.h>

struct Student {
    char name[20];
    int age;
};

int main()
{
    struct Student stu = {"赵六", 22};
    struct Student *p = &stu;  // 结构体指针p指向stu

    // 1. 结构体变量访问：.
    printf("变量访问：%s, %d岁\n", stu.name, stu.age);  // 输出：赵六, 22岁

    // 2. 结构体指针访问：->（推荐）
    printf("指针访问（->）：%s, %d岁\n", p->name, p->age);  // 输出：赵六, 22岁

    // 2. 结构体指针访问：(*p).成员（等价于->）
    printf("指针访问（(*p).）：%s, %d岁\n", (*p).name, (*p).age);  // 输出：赵六, 22岁

    // 通过指针修改成员值
    p->age = 23;  // 等价于stu.age=23
    strcpy(p->name, "赵六（修改后）");
    printf("修改后：%s, %d岁\n", stu.name, stu.age);  // 输出：赵六（修改后）, 23岁

    return 0;
}
```

### 4. 结构体数组（存储多个结构体对象）

#### （1）定义与初始化

- 语法：`struct 结构体类型 数组名[数组长度] = {初始化列表};`
- 用途：存储批量同类实体（如班级所有学生、公司所有员工）。

#### 示例：结构体数组管理班级学生

c

```c
#include <stdio.h>

// 定义学生结构体
struct Student {
    char name[20];
    int age;
    float score;
};

int main()
{
    // 1. 定义并初始化结构体数组（3个学生）
    struct Student class_arr[3] = {
        {"张三", 20, 95.5},
        {"李四", 19, 88.0},
        {"王五", 21, 92.3}
    };

    // 2. 遍历结构体数组（两种方式：下标、指针）
    printf("=== 下标遍历 ===\n");
    for (int i = 0; i < 3; i++) {
        printf("第%d个学生：%s, %d岁, %.1f分\n", 
               i+1, class_arr[i].name, class_arr[i].age, class_arr[i].score);
    }

    printf("\n=== 指针遍历 ===\n");
    struct Student *p = class_arr;  // 指针指向数组首元素
    for (int i = 0; i < 3; i++) {
        printf("第%d个学生：%s, %d岁, %.1f分\n", 
               i+1, p->name, p->age, p->score);
        p++;  // 指针后移（步长=结构体总字节数）
    }

    return 0;
}
```

### 5. 结构体与函数（传值 vs 传址）

#### （1）传值调用（拷贝结构体）

- 特点：函数接收结构体的**拷贝**，修改形参不影响实参；
- 缺点：结构体体积大时，拷贝开销高（效率低）。

#### （2）传址调用（传递结构体指针）

- 特点：函数接收结构体的**地址**，通过指针修改实参；
- 优点：无需拷贝，效率高（推荐用于大结构体）。

#### 示例：结构体作为函数参数

c

```c
#include <stdio.h>
#include <string.h>

struct Student {
    char name[20];
    float score;
};

// 1. 传值调用：修改形参（不影响实参）
void modifyByValue(struct Student s) {
    s.score = 60.0;  // 修改的是拷贝，实参不变
    strcpy(s.name, "修改失败");
}

// 2. 传址调用：修改实参（通过指针）
void modifyByAddr(struct Student *s) {
    s->score = 90.0;  // 修改实参的成绩
    strcpy(s->name, "修改成功");
}

int main()
{
    struct Student stu = {"张三", 85.5};

    // 测试传值调用
    modifyByValue(stu);
    printf("传值调用后：%s, %.1f分\n", stu.name, stu.score);  // 输出：张三, 85.5分（未变）

    // 测试传址调用
    modifyByAddr(&stu);
    printf("传址调用后：%s, %.1f分\n", stu.name, stu.score);  // 输出：修改成功, 90.0分（已变）

    return 0;
}
```

### 6. 结构体嵌套（结构体作为成员）

#### （1）场景：复杂实体包含子实体（如 “学生” 包含 “生日”，“生日” 是结构体）

#### 示例：嵌套结构体的定义与访问

c

```c
#include <stdio.h>

// 1. 先定义子结构体（生日）
struct Date {
    int year;  // 年
    int month; // 月
    int day;   // 日
};

// 2. 定义父结构体（学生，包含Date类型成员）
struct Student {
    char name[20];
    struct Date birthday;  // 嵌套子结构体
    float score;
};

int main()
{
    // 初始化嵌套结构体
    struct Student stu = {
        "张三",
        {2004, 9, 15},  // 子结构体birthday的初始化
        95.5
    };

    // 访问嵌套结构体成员（父.子.子成员）
    printf("姓名：%s\n", stu.name);
    printf("生日：%d年%d月%d日\n", 
           stu.birthday.year, stu.birthday.month, stu.birthday.day);
    printf("成绩：%.1f分\n", stu.score);

    // 修改嵌套结构体成员
    stu.birthday.year = 2003;
    printf("修改后生日：%d年%d月%d日\n", 
           stu.birthday.year, stu.birthday.month, stu.birthday.day);

    return 0;
}
```

## 十七、共用体（union）：共享内存的自定义类型

### 1. 共用体与结构体的核心区别

| 特性     | 结构体（struct）                                             | 共用体（union）                                     |
| -------- | ------------------------------------------------------------ | --------------------------------------------------- |
| 内存分配 | 各成员占用**独立内存**，总大小 = 各成员大小之和（含内存对齐） | 所有成员共享**同一块内存**，总大小 = 最大成员的大小 |
| 数据存储 | 各成员可同时存储有效数据                                     | 仅最后赋值的成员有效，其他成员值被覆盖              |
| 用途     | 描述复杂实体（多属性共存）                                   | 节省内存、类型转换、判断硬件大小端                  |

### 2. 共用体的定义与使用

#### （1）定义语法

```
union 共用体名 { 成员类型1 成员名1; 成员类型2 成员名2; ... };
```

#### （2）示例：共用体的内存共享特性

c

```c
#include <stdio.h>

// 定义共用体（成员共享内存）
union Data {
    int i;     // 4字节
    float f;   // 4字节
    char c;    // 1字节
};

int main()
{
    union Data data;

    // 1. 查看共用体大小（=最大成员大小，此处为4字节）
    printf("共用体大小：%zu字节\n", sizeof(union Data));  // 输出：4

    // 2. 赋值int成员，查看其他成员值（仅i有效）
    data.i = 0x12345678;  // 十六进制整数（4字节）
    printf("赋值data.i=0x12345678后：\n");
    printf("data.i = %#x\n", data.i);    // 输出：0x12345678（有效）
    printf("data.f = %f\n", data.f);    // 输出：随机浮点数（无效，内存被i覆盖）
    printf("data.c = %#x\n", data.c);    // 输出：0x78（仅低1字节有效，因c是char）

    // 3. 赋值float成员，查看其他成员值（仅f有效）
    data.f = 3.14f;
    printf("\n赋值data.f=3.14后：\n");
    printf("data.f = %.2f\n", data.f);   // 输出：3.14（有效）
    printf("data.i = %#x\n", data.i);    // 输出：随机整数（无效，内存被f覆盖）

    return 0;
}
```

### 3. 共用体的典型用途：判断 CPU 大小端

#### （1）大小端概念

- **大端（Big-Endian）**：数据高位字节存低地址，低位字节存高地址（如 0x12345678，地址 0 存 0x12，地址 3 存 0x78）；
- **小端（Little-Endian）**：数据低位字节存低地址，高位字节存高地址（如 0x12345678，地址 0 存 0x78，地址 3 存 0x12）。

#### （2）共用体判断大小端（利用内存共享）

c

```c
#include <stdio.h>

union EndianCheck {
    int i;    // 4字节整数
    char c;   // 1字节字符（仅访问低地址字节）
};

int main()
{
    union EndianCheck ec;
    ec.i = 0x12345678;  // 赋值4字节整数

    // 若c=0x78：低地址存低位字节→小端；若c=0x12：低地址存高位字节→大端
    if (ec.c == 0x78) {
        printf("当前CPU是小端模式\n");
    } else if (ec.c == 0x12) {
        printf("当前CPU是大端模式\n");
    }

    // 主流PC（x86架构）均为小端，嵌入式设备可能为大端
    return 0;
}
```

## 十八、枚举（enum）：定义有名字的常量

### 1. 核心作用

- 用**有意义的名字**代替无意义的数字常量（如用`MON`代替 1，`TUE`代替 2），提高代码可读性和可维护性；
- 枚举常量是**编译期常量**，值在编译时确定，不可修改。

### 2. 枚举的定义与使用

#### （1）定义语法

```
enum 枚举名 { 常量1, 常量2, ..., 常量n };
```

- 默认值：第一个常量默认为 0，后续常量依次 + 1；
- 手动赋值：可指定某个常量的值，后续常量从该值继续 + 1。

#### 示例：枚举的定义与使用

c

```c
#include <stdio.h>

// 1. 定义枚举（星期），默认值：MON=0, TUE=1, ..., SUN=6
enum Weekday {
    MON,    // 0
    TUE,    // 1
    WED,    // 2
    THU=5,  // 手动赋值为5
    FRI,    // 6（THU+1）
    SAT,    // 7
    SUN     // 8
};

int main()
{
    // 2. 定义枚举变量（值只能是枚举常量）
    enum Weekday today = WED;
    enum Weekday tomorrow = THU;

    // 3. 打印枚举常量的值和变量
    printf("MON = %d\n", MON);    // 输出：0
    printf("THU = %d\n", THU);    // 输出：5
    printf("SUN = %d\n", SUN);    // 输出：8
    printf("今天是星期%d（WED）\n", today);  // 输出：今天是星期2（WED）
    printf("明天是星期%d（THU）\n", tomorrow);  // 输出：明天是星期5（THU）

    // 4. 枚举变量的赋值（仅能赋值枚举常量）
    today = FRI;
    printf("修改后今天是星期%d（FRI）\n", today);  // 输出：修改后今天是星期6（FRI）

    return 0;
}
```

### 3. 枚举的使用场景：状态标识

#### 示例：用枚举表示订单状态

c

```c
#include <stdio.h>

// 枚举：订单状态（有意义的名字代替数字）
enum OrderStatus {
    PENDING = 1,   // 待支付
    PAID,          // 已支付（2）
    SHIPPED,       // 已发货（3）
    DELIVERED,     // 已送达（4）
    CANCELLED      // 已取消（5）
};

// 函数：根据状态打印订单信息
void printOrderStatus(enum OrderStatus status) {
    switch (status) {
        case PENDING:
            printf("订单状态：待支付\n");
            break;
        case PAID:
            printf("订单状态：已支付\n");
            break;
        case SHIPPED:
            printf("订单状态：已发货\n");
            break;
        case DELIVERED:
            printf("订单状态：已送达\n");
            break;
        case CANCELLED:
            printf("订单状态：已取消\n");
            break;
        default:
            printf("无效状态\n");
    }
}

int main()
{
    enum OrderStatus order1 = PAID;
    enum OrderStatus order2 = DELIVERED;

    printOrderStatus(order1);  // 输出：订单状态：已支付
    printOrderStatus(order2);  // 输出：订单状态：已送达

    return 0;
}
```

## 十九、文件操作：数据持久化

### 1. 文件的基本概念

#### （1）文件分类（按存储方式）

- **文本文件**：以 ASCII 码存储（如.txt、.c），可直接用记事本打开，占用空间大，读写效率低；
- **二进制文件**：以二进制形式存储（如.exe、.png、.dat），不可直接阅读，占用空间小，读写效率高。

#### （2）文件指针（FILE*）：文件操作的核心

- C 语言用`FILE`结构体描述文件信息（如文件名、位置指针、读写模式），`FILE*`是指向该结构体的指针；
- 所有文件操作函数（`fopen`、`fread`、`fwrite`等）均需通过文件指针操作文件。

### 2. 文件操作的基本流程

#### 流程：打开文件（fopen）→ 读写文件（fread/fwrite 等）→ 关闭文件（fclose）

#### （1）打开文件：fopen 函数

- 函数原型：`FILE* fopen(const char* filename, const char* mode);`
- 参数说明：
	- `filename`：文件名（含路径，如`"test.txt"`或`"D:\\data.dat"`，注意转义符`\\`）；
	- `mode`：打开模式（核心，决定读写权限），常见模式如下：

| 打开模式 | 含义                               | 适用文件类型  | 若文件不存在      |
| -------- | ---------------------------------- | ------------- | ----------------- |
| `r`      | 只读（文本文件）                   | 文本 / 二进制 | 报错（返回 NULL） |
| `w`      | 只写（文本文件），覆盖原有内容     | 文本 / 二进制 | 创建新文件        |
| `a`      | 追加（文本文件），在文件末尾写入   | 文本 / 二进制 | 创建新文件        |
| `rb`     | 只读（二进制文件）                 | 二进制        | 报错              |
| `wb`     | 只写（二进制文件），覆盖原有内容   | 二进制        | 创建新文件        |
| `ab`     | 追加（二进制文件），在文件末尾写入 | 二进制        | 创建新文件        |
| `r+`     | 读写（文本文件），不覆盖原有内容   | 文本 / 二进制 | 报错              |
| `w+`     | 读写（文本文件），覆盖原有内容     | 文本 / 二进制 | 创建新文件        |

- 返回值：成功返回`FILE*`指针，失败返回`NULL`（必须检查，避免空指针操作）。

#### （2）关闭文件：fclose 函数

- 函数原型：`int fclose(FILE* stream);`
- 功能：关闭文件，释放文件相关资源（必须调用，避免资源泄漏和数据丢失）；
- 返回值：成功返回 0，失败返回 EOF（-1）。

### 3. 文本文件的读写

#### （1）字符读写：fputc（写）、fgetc（读）

- `fputc(int c, FILE* stream)`：将字符`c`写入文件`stream`，成功返回`c`，失败返回 EOF；
- `fgetc(FILE* stream)`：从文件`stream`读取一个字符，成功返回字符 ASCII 码，失败 / 到文件尾返回 EOF。

#### 示例：用 fputc/fgetc 读写文本文件

c

```c
#include <stdio.h>

int main()
{
    FILE *fp;
    char ch;

    // 1. 打开文件（w模式：写文本文件，不存在则创建）
    fp = fopen("test.txt", "w");
    if (fp == NULL) {  // 检查是否成功打开
        printf("文件创建失败！\n");
        return 1;
    }

    // 2. 写文件（写入字符串"Hello File!"）
    char str[] = "Hello File!";
    for (int i = 0; str[i] != '\0'; i++) {
        fputc(str[i], fp);  // 逐个字符写入
    }
    fclose(fp);  // 写完关闭文件

    // 3. 读文件（r模式：读文本文件）
    fp = fopen("test.txt", "r");
    if (fp == NULL) {
        printf("文件打开失败！\n");
        return 1;
    }

    // 逐个字符读取，直到文件尾（EOF）
    printf("读取文件内容：");
    while ((ch = fgetc(fp)) != EOF) {
        printf("%c", ch);  // 输出：Hello File!
    }
    fclose(fp);  // 读完关闭文件

    return 0;
}
```

#### （2）字符串读写：fputs（写）、fgets（读）

- `fputs(const char* str, FILE* stream)`：将字符串`str`写入文件（不含`'\0'`），成功返回非负，失败返回 EOF；
- `fgets(char* str, int n, FILE* stream)`：从文件读取最多`n-1`个字符（或到换行符 / EOF），自动添加`'\0'`，成功返回`str`，失败 / 到文件尾返回 NULL。

#### 示例：用 fputs/fgets 读写文本文件

c

```c
#include <stdio.h>

int main()
{
    FILE *fp;
    char buf[100];  // 存储读取的字符串

    // 1. 写文件（写入多行字符串）
    fp = fopen("test.txt", "w");
    if (fp == NULL) { return 1; }
    fputs("第一行：C语言文件操作\n", fp);
    fputs("第二行：fputs和fgets示例\n", fp);
    fclose(fp);

    // 2. 读文件（逐行读取）
    fp = fopen("test.txt", "r");
    if (fp == NULL) { return 1; }

    printf("读取文件内容：\n");
    // fgets读取一行（最多99个字符，含换行符）
    while (fgets(buf, sizeof(buf), fp) != NULL) {
        printf("%s", buf);  // 输出两行内容
    }
    fclose(fp);

    return 0;
}
```

#### （3）格式化读写：fprintf（写）、fscanf（读）

- 与`printf/scanf`用法一致，仅多一个文件指针参数，支持按格式读写（如`%d`、`%s`、`%f`）。

#### 示例：用 fprintf/fscanf 读写学生信息（文本文件）

c

```c
#include <stdio.h>

struct Student {
    char name[20];
    int age;
    float score;
};

int main()
{
    FILE *fp;
    struct Student stu1 = {"张三", 20, 95.5};
    struct Student stu2;

    // 1. 写文件（格式化写入结构体）
    fp = fopen("student.txt", "w");
    if (fp == NULL) { return 1; }
    fprintf(fp, "%s %d %.1f", stu1.name, stu1.age, stu1.score);  // 格式：姓名 年龄 成绩
    fclose(fp);

    // 2. 读文件（格式化读取到结构体）
    fp = fopen("student.txt", "r");
    if (fp == NULL) { return 1; }
    fscanf(fp, "%s %d %f", stu2.name, &stu2.age, &stu2.score);  // 注意&符号（除字符串）
    fclose(fp);

    // 打印读取的信息
    printf("读取的学生信息：\n");
    printf("姓名：%s\n年龄：%d\n成绩：%.1f\n", stu2.name, stu2.age, stu2.score);

    return 0;
}
```

### 4. 二进制文件的读写（fread/fwrite）

#### （1）函数原型

- 写文件：`size_t fwrite(const void* ptr, size_t size, size_t nmemb, FILE* stream);`
- 读文件：`size_t fread(void* ptr, size_t size, size_t nmemb, FILE* stream);`
- 参数说明：
	- `ptr`：数据缓冲区（写时是数据源，读时是数据存储区）；
	- `size`：单个数据的字节数（如`sizeof(int)`、`sizeof(struct Student)`）；
	- `nmemb`：数据的个数；
	- `stream`：文件指针；
- 返回值：成功读写的**数据个数**（不是字节数），失败 / 到文件尾返回 0。

#### 示例：用 fread/fwrite 读写结构体（二进制文件）

c

```c
#include <stdio.h>

struct Student {
    char name[20];
    int age;
    float score;
};

int main()
{
    FILE *fp;
    struct Student class[2] = {
        {"张三", 20, 95.5},
        {"李四", 19, 88.0}
    };
    struct Student read_class[2];  // 存储读取的结构体数组

    // 1. 写二进制文件（wb模式）
    fp = fopen("student.dat", "wb");
    if (fp == NULL) { return 1; }
    // 写入2个struct Student，每个大小为sizeof(struct Student)
    size_t write_num = fwrite(class, sizeof(struct Student), 2, fp);
    printf("成功写入%d个学生数据\n", write_num);  // 输出：2
    fclose(fp);

    // 2. 读二进制文件（rb模式）
    fp = fopen("student.dat", "rb");
    if (fp == NULL) { return 1; }
    // 读取2个struct Student到read_class
    size_t read_num = fread(read_class, sizeof(struct Student), 2, fp);
    printf("成功读取%d个学生数据\n", read_num);  // 输出：2
    fclose(fp);

    // 打印读取的信息
    printf("\n读取的学生信息：\n");
    for (int i = 0; i < 2; i++) {
        printf("第%d个：%s, %d岁, %.1f分\n", 
               i+1, read_class[i].name, read_class[i].age, read_class[i].score);
    }

    return 0;
}
```

### 5. 文件定位函数（随机读写）

#### （1）fseek：移动文件位置指针

- 原型：`int fseek(FILE* stream, long offset, int whence);`
- 功能：将文件位置指针从`whence`开始移动`offset`字节；
- 参数：
	- `whence`：基准位置（`SEEK_SET`= 文件开头，`SEEK_CUR`= 当前位置，`SEEK_END`= 文件末尾）；
	- `offset`：偏移量（正数向后移，负数向前移）；
- 返回值：成功返回 0，失败返回非 0。

#### （2）ftell：获取当前文件位置指针

- 原型：`long ftell(FILE* stream);`
- 功能：返回当前位置指针相对于文件开头的字节数；
- 返回值：成功返回字节数，失败返回 - 1L。

#### （3）rewind：将指针移到文件开头

- 原型：`void rewind(FILE* stream);`
- 功能：等价于`fseek(stream, 0L, SEEK_SET)`。

#### 示例：用 fseek/ftell 实现文件大小计算

c

```c
#include <stdio.h>

// 函数：计算文件大小（字节数）
long getFileSize(const char* filename) {
    FILE *fp = fopen(filename, "rb");  // 二进制模式读（避免文本文件换行符转换影响）
    if (fp == NULL) {
        printf("文件打开失败！\n");
        return -1;
    }

    fseek(fp, 0L, SEEK_END);  // 指针移到文件末尾
    long size = ftell(fp);    // 获取末尾相对于开头的字节数（即文件大小）
    fclose(fp);

    return size;
}

int main()
{
    long size = getFileSize("student.dat");  // 之前创建的二进制文件
    if (size != -1) {
        printf("文件student.dat的大小：%ld字节\n", size);  // 输出：(20+4+4)*2=56字节
    }

    return 0;
}
```

### 6. 文件操作的错误处理

#### （1）检查 fopen 返回值（必须！）

- 若文件路径错误、权限不足，fopen 会返回 NULL，需判断并提示错误。

#### （2）ferror：检查文件操作是否出错

- 原型：`int ferror(FILE* stream);`
- 功能：若文件操作出错，返回非 0，否则返回 0。

#### （3）clearerr：清除文件错误标志

- 原型：`void clearerr(FILE* stream);`
- 功能：清除文件的错误标志和 EOF 标志，使文件可继续操作。

#### 示例：文件操作的错误处理

c

```c
#include <stdio.h>

int main()
{
    FILE *fp = fopen("nonexistent.txt", "r");  // 打开不存在的文件
    if (fp == NULL) {
        printf("fopen失败：文件不存在或权限不足\n");
        return 1;
    }

    // 尝试读取文件（会失败）
    char ch = fgetc(fp);
    if (ferror(fp)) {  // 检查是否出错
        printf("fgetc操作失败！\n");
        clearerr(fp);  // 清除错误标志（可选）
    }

    fclose(fp);
    return 0;
}
```

## 二十、预处理指令（编译前的 “代码加工”）

C 语言编译流程分为**预处理→编译→汇编→链接**，预处理指令是编译前由 “预处理器” 执行的命令，以`#`开头，无分号结尾，核心作用是简化代码、实现条件编译、批量替换等。

### 1. 常用预处理指令分类

| 指令                     | 核心作用                                     | 示例                                                    |
| ------------------------ | -------------------------------------------- | ------------------------------------------------------- |
| `#include`               | 包含头文件（将头文件内容插入当前位置）       | `#include <stdio.h>`、`#include "my.h"`                 |
| `#define`                | 宏定义（文本替换，无类型检查）               | `#define PI 3.14`、`#define MAX(a,b) ((a)>(b)?(a):(b))` |
| `#undef`                 | 取消宏定义（使后续宏失效）                   | `#undef PI`                                             |
| `#ifdef/#ifndef`         | 条件编译（根据宏是否定义决定是否编译代码块） | `#ifdef DEBUG printf("调试信息\n"); #endif`             |
| `#if/#elif/#else/#endif` | 条件编译（根据表达式值决定是否编译）         | `#if MAX_SIZE > 100 ... #else ... #endif`               |
| `#line`                  | 修改当前行号和文件名（用于调试）             | `#line 100 "test.c"`                                    |
| `#error`                 | 编译时输出错误信息（强制终止编译）           | `#error "必须定义MAX_SIZE！"`                           |
| `#pragma`                | 编译器指令（平台相关，如对齐、警告控制）     | `#pragma pack(1)`（设置内存对齐为 1 字节）              |

### 2. 核心指令详解

#### （1）`#include`：头文件包含

- **两种包含方式的区别**：

	| 方式         | 查找路径                                        | 适用场景                                 |
	| ------------ | ----------------------------------------------- | ---------------------------------------- |
	| `<头文件名>` | 先查找编译器自带的头文件目录（如 /usr/include） | 包含标准库头文件（如 stdio.h、stdlib.h） |
	| `"头文件名"` | 先查找当前源文件目录，再查找编译器目录          | 包含自定义头文件（如 my_utils.h）        |

- **注意事项**：

	1. 避免循环包含（如 a.h 包含 b.h，b.h 又包含 a.h），需用头文件保护（`#ifndef`或`#pragma once`）；
	2. 头文件中仅存放声明（函数声明、宏定义、typedef），不存放函数实现（避免重复定义错误）。

#### （2）`#define`：宏定义（文本替换）

宏定义是**无类型的文本替换**，编译前预处理器会将代码中所有宏名替换为宏体，分为 “无参宏” 和 “带参宏”。

##### ① 无参宏（常量定义）

- 语法：`#define 宏名 宏体`（宏体若含空格或特殊字符，需用括号或引号包裹）；

- 示例：

	c

	```c
	#define PI 3.1415926  // 定义圆周率
	#define MAX_SIZE 100  // 定义数组最大长度
	#define HELLO "Hello, C!"  // 定义字符串常量
	```

	
	
- **避坑点**：宏体后不要加`;`，否则会被一起替换（如`#define PI 3.14;`会导致`float r=2*PI;`变成`float r=2*3.14;;`，多一个分号）。

##### ② 带参宏（类似 “函数”，但本质是替换）

- 语法：`#define 宏名(参数列表) 宏体`；

- 核心优势：无函数调用开销（直接替换），但无类型检查，需注意优先级问题；

- **示例 1：实现两数最大值**

	c

	```c
	// 必须加括号！避免优先级问题（如MAX(2+3,4)，不加括号会变成2+3>4?2+3:4，虽正确；但MAX(2,3+4)不加括号会变成2>3+4?2:3+4，错误）
	#define MAX(a, b) ((a) > (b) ? (a) : (b))
	
	int main() {
	    printf("最大值：%d\n", MAX(5, 8));  // 替换为((5)>(8)?(5):(8))，输出8
	    printf("最大值：%d\n", MAX(3+2, 4));  // 替换为((3+2)>(4)?(3+2):(4))，输出5
	    return 0;
	}
	```
	
	
	
- **示例 2：带多个参数的宏**

	c

	```c
	// 实现两数相加后乘2
	#define ADD_DOUBLE(a, b) ((a) + (b)) * 2  // 注意：整体若需优先级，需再加外层括号
	
	int main() {
	    printf("结果：%d\n", ADD_DOUBLE(2, 3));  // 替换为((2)+(3))*2=10，正确
	    return 0;
	}
	```
	
	
	
- **带参宏与函数的区别**：

	| 特性     | 带参宏（#define）                                       | 函数（function）                             |
	| -------- | ------------------------------------------------------- | -------------------------------------------- |
	| 本质     | 文本替换（编译前）                                      | 代码块调用（运行时）                         |
	| 类型检查 | 无（参数和返回值均无类型）                              | 有（参数和返回值需声明类型）                 |
	| 开销     | 无调用开销（直接替换，可能导致代码膨胀）                | 有调用开销（压栈、跳转、返回）               |
	| 返回值   | 无返回值，结果直接嵌入代码                              | 有明确返回值（需 return 语句）               |
	| 副作用   | 可能产生副作用（如 MAX (a++, b++) 会导致 a/b 自增两次） | 副作用可控（仅在函数内部修改参数或全局变量） |

#### （3）条件编译（`#ifdef/#if`）

条件编译的核心作用是**根据条件选择性编译代码**，常用于：

- 区分调试版和发布版（调试版输出调试信息，发布版屏蔽）；
- 跨平台代码（不同平台编译不同代码，如 Windows 和 Linux 的 API 差异）；
- 屏蔽暂时不需要的代码（替代注释，更灵活）。

##### ① `#ifdef/#ifndef/#endif`（检查宏是否定义）

c

```c
#include <stdio.h>

#define DEBUG  // 定义DEBUG宏（调试版）
// #undef DEBUG  // 取消DEBUG宏（发布版）

int main() {
    int a = 10;
    // 若DEBUG已定义，则编译以下代码
    #ifdef DEBUG
        printf("调试信息：a的地址=%p，a的值=%d\n", &a, a);  // 调试版输出
    #else
        printf("a的值=%d\n", a);  // 发布版输出
    #endif

    return 0;
}
```

##### ② `#if/#elif/#else/#endif`（根据表达式值编译）

c

```c
#include <stdio.h>

#define MAX_SIZE 150  // 可根据需求修改

int main() {
    // 根据MAX_SIZE的值选择不同的数组长度
    #if MAX_SIZE > 200
        int arr[MAX_SIZE] = {0};
        printf("大数组：长度=%d\n", MAX_SIZE);
    #elif MAX_SIZE > 100
        int arr[MAX_SIZE] = {0};
        printf("中数组：长度=%d\n", MAX_SIZE);
    #else
        int arr[100] = {0};
        printf("小数组：长度=100\n");
    #endif

    return 0;
}
```

#### （4）`#pragma`：编译器控制指令（平台相关）

`#pragma`是编译器扩展指令，不同编译器支持的参数不同，常见用法：

- **`#pragma pack(n)`：设置内存对齐字节数**（n=1,2,4,8 等，用于结构体内存对齐）；
- **`#pragma warning(disable: 4996)`：屏蔽指定警告**（如 VS 中屏蔽 “scanf 不安全” 的 4996 警告）；
- **`#pragma once`：头文件保护**（等价于`#ifndef/#define/#endif`，部分编译器支持）。

示例：用`#pragma pack`控制结构体对齐

c

```c
#include <stdio.h>

// 设置内存对齐为1字节（取消默认对齐，按实际字节存储）
#pragma pack(1)
struct Test1 {
    char c;  // 1字节
    int i;   // 4字节
};
#pragma pack()  // 恢复默认对齐（通常为4或8字节）

// 默认对齐（假设默认4字节）
struct Test2 {
    char c;  // 1字节，默认对齐需补3字节（偏移量为4的整数倍）
    int i;   // 4字节
};

int main() {
    printf("Test1大小（1字节对齐）：%zu\n", sizeof(struct Test1));  // 输出：5（1+4）
    printf("Test2大小（默认对齐）：%zu\n", sizeof(struct Test2));  // 输出：8（1+3+4）
    return 0;
}
```

## 二十一、`typedef`：类型别名（简化复杂类型）

`typedef`用于给已有的数据类型（包括基本类型、结构体、指针等）定义**别名**，核心作用是简化复杂类型名、提高代码可读性和可维护性。

### 1. 语法与基本用法

- 语法：`typedef 原类型名 别名;`（注意：别名在原类型名之后，与变量定义顺序一致）；

- 示例：基本类型别名

	c

	```c
	#include <stdio.h>
	
	// 给int定义别名Int（大小写不敏感，但习惯大写区分别名）
	typedef int Int;
	// 给float定义别名Float
	typedef float Float;
	
	int main() {
	    Int a = 10;    // 等价于int a=10;
	    Float b = 3.14f;  // 等价于float b=3.14f;
	    printf("a=%d, b=%.2f\n", a, b);  // 输出：10, 3.14
	    return 0;
	}
	```
	

### 2. 核心应用场景

#### （1）简化结构体类型名

结构体类型名默认较长（`struct Student`），用`typedef`可简化为短别名：

c

```c
#include <stdio.h>

// 方式1：定义结构体时直接加typedef
typedef struct Student {
    char name[20];
    int age;
} Stu;  // Stu是struct Student的别名

// 方式2：先定义结构体，再typedef
struct Teacher {
    char name[20];
    int id;
};
typedef struct Teacher Tea;  // Tea是struct Teacher的别名

int main() {
    Stu stu = {"张三", 20};  // 等价于struct Student stu;
    Tea tea = {"李老师", 1001};  // 等价于struct Teacher tea;
    printf("学生：%s, %d岁\n", stu.name, stu.age);
    printf("老师：%s, 工号%d\n", tea.name, tea.id);
    return 0;
}
```

#### （2）简化指针类型名（尤其是多级指针）

复杂指针（如`int*`、`char**`）用`typedef`简化后更易读：

c

```c
#include <stdio.h>

// 给int*定义别名IntPtr
typedef int* IntPtr;
// 给char**定义别名StrPtr（指向字符串的指针的指针）
typedef char** StrPtr;

int main() {
    int a = 10;
    IntPtr p = &a;  // 等价于int* p = &a;
    printf("*p = %d\n", *p);  // 输出：10

    char* str = "hello";
    StrPtr pp = &str;  // 等价于char** pp = &str;
    printf("**pp = %s\n", **pp);  // 输出：hello
    return 0;
}
```

#### （3）定义函数指针别名（关键应用）

函数指针语法复杂（`int (*func_ptr)(int, int)`），`typedef`可极大简化：

c

```c
#include <stdio.h>

// 定义函数指针别名：FuncPtr是“接收两个int、返回int的函数指针”的别名
typedef int (*FuncPtr)(int, int);

// 加法函数
int add(int a, int b) {
    return a + b;
}

// 减法函数
int sub(int a, int b) {
    return a - b;
}

// 接收函数指针作为参数（用别名简化参数类型）
int calculate(FuncPtr func, int a, int b) {
    return func(a, b);  // 调用函数指针指向的函数
}

int main() {
    FuncPtr fp1 = add;    // 等价于int (*fp1)(int,int) = add;
    FuncPtr fp2 = sub;    // 等价于int (*fp2)(int,int) = sub;

    printf("3+5=%d\n", calculate(fp1, 3, 5));  // 输出：8
    printf("10-4=%d\n", calculate(fp2, 10, 4));  // 输出：6
    return 0;
}
```

### 3. `typedef`与`#define`的区别

| 特性         | `typedef`                                                    | `#define`                                                    |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 本质         | 类型别名（编译器处理，有类型检查）                           | 文本替换（预处理器处理，无类型检查）                         |
| 作用域       | 局部作用域（如函数内定义仅在函数内有效）                     | 全局作用域（从定义处到文件结束，可`#undef`取消）             |
| 处理时机     | 编译阶段                                                     | 预处理阶段（编译前）                                         |
| 对指针的处理 | 仅给指针类型定义别名（如`typedef int* IntPtr; IntPtr p1,p2;`均为 int*） | 文本替换（如`#define IntPtr int*; IntPtr p1,p2;`会变成`int* p1,p2;`，p2 是 int） |

示例：指针处理的区别

c

```c
#include <stdio.h>

// 1. typedef定义指针别名
typedef int* IntPtr;
// 2. #define定义指针文本
#define IntPtrDef int*

int main() {
    // typedef：p1和p2均为int*
    IntPtr p1, p2;
    // #define：p3是int*，p4是int（替换后为int* p3,p4;）
    IntPtrDef p3, p4;

    printf("p1类型：%zu字节\n", sizeof(p1));  // 8字节（64位系统，int*）
    printf("p2类型：%zu字节\n", sizeof(p2));  // 8字节（int*）
    printf("p3类型：%zu字节\n", sizeof(p3));  // 8字节（int*）
    printf("p4类型：%zu字节\n", sizeof(p4));  // 4字节（int）
    return 0;
}
```

## 二十二、内存对齐（结构体大小的关键）

内存对齐是 CPU 为了**提高访问效率**而采用的存储规则：CPU 访问内存时，通常按 “对齐字节数”（如 4 字节、8 字节）批量读取，若数据存储地址不是对齐字节数的整数倍，CPU 需多次读取，效率降低。C 语言编译器会自动对结构体成员进行内存对齐，但需理解规则以避免内存浪费。

### 1. 内存对齐的核心规则（默认对齐）

默认对齐字节数（`alignment`）通常是**结构体中最大成员的大小**（或编译器默认值，如 VS 默认 8 字节，GCC 默认 4 字节，可通过`#pragma pack`修改），规则如下：

1. **成员对齐**：每个成员的存储地址必须是 “成员自身大小” 的整数倍；
2. **整体对齐**：结构体的总大小必须是 “最大成员大小” 的整数倍（不足则补字节）。

### 2. 示例：结构体内存对齐计算

#### 示例 1：基本结构体对齐

c

```c
#include <stdio.h>

// 最大成员是int（4字节），默认对齐字节数=4
struct Test {
    char c1;  // 成员1：char（1字节），地址0（0是1的整数倍），占用0~0
    int i;    // 成员2：int（4字节），需地址是4的整数倍→地址4，占用4~7（补3字节：1~3）
    char c2;  // 成员3：char（1字节），地址8（8是1的整数倍），占用8~8
};  // 整体大小需是4的整数倍→当前8+1=9，补3字节→总大小12

int main() {
    printf("struct Test大小：%zu字节\n", sizeof(struct Test));  // 输出：12
    return 0;
}
```

#### 示例 2：成员顺序影响结构体大小

结构体大小不仅取决于成员类型，还取决于成员顺序，合理排序可减少内存浪费：

c

```c
#include <stdio.h>

// 方案1：char→int→char（最大成员4字节，总大小12）
struct BadOrder {
    char c1;  // 0~0，补3字节
    int i;    // 4~7
    char c2;  // 8~8，补3字节
};  // 总大小12

// 方案2：char→char→int（最大成员4字节，总大小8）
struct GoodOrder {
    char c1;  // 0~0
    char c2;  // 1~1，补2字节（2~3）
    int i;    // 4~7
};  // 总大小8（节省4字节）

int main() {
    printf("BadOrder大小：%zu\n", sizeof(struct BadOrder));  // 12
    printf("GoodOrder大小：%zu\n", sizeof(struct GoodOrder));  // 8
    return 0;
}
```

#### 示例 3：嵌套结构体的对齐

嵌套结构体的对齐规则：嵌套结构体的 “有效大小” 是其自身最大成员的整数倍，再参与外层结构体的对齐：

c

```c
#include <stdio.h>

struct Inner {
    char c;  // 1字节
    int i;   // 4字节，补3字节→Inner总大小8（1+3+4=8，是4的整数倍）
};

// 外层结构体最大成员是Inner（8字节），默认对齐字节数=8
struct Outer {
    char c;      // 0~0，补7字节（1~7）
    struct Inner in;  // 8~15（8是8的整数倍）
    int i;       // 16~19，总大小20，需补4字节→24（24是8的整数倍）
};

int main() {
    printf("Inner大小：%zu\n", sizeof(struct Inner));  // 8
    printf("Outer大小：%zu\n", sizeof(struct Outer));  // 24
    return 0;
}
```

### 3. 手动控制内存对齐（`#pragma pack`）

若需节省内存（如嵌入式开发），可通过`#pragma pack(n)`手动设置对齐字节数`n`（`n`必须是 2 的幂，如 1,2,4,8），此时对齐规则变为：

1. 成员对齐：地址是 “min (成员自身大小，n)” 的整数倍；
2. 整体对齐：总大小是 “min (最大成员大小，n)” 的整数倍。

示例：设置 1 字节对齐（取消对齐，按实际字节存储）

c

```c
#include <stdio.h>

// 设置对齐字节数为1（无对齐，直接连续存储）
#pragma pack(1)
struct Test {
    char c1;  // 0~0
    int i;    // 1~4
    char c2;  // 5~5
};  // 总大小=1+4+1=6（无需补字节）
#pragma pack()  // 恢复默认对齐

int main() {
    printf("struct Test大小（1字节对齐）：%zu\n", sizeof(struct Test));  // 输出：6
    return 0;
}
```

## 二十三、C 标准库常用函数（提高开发效率）

C 标准库（`stdlib.h`、`string.h`、`time.h`等）提供了大量实用函数，无需重复实现，以下是高频使用的函数分类。

### 1. 字符串处理函数（`string.h`）

| 函数原型                                                 | 功能                                     | 注意事项                                       |
| -------------------------------------------------------- | ---------------------------------------- | ---------------------------------------------- |
| `size_t strlen(const char* str)`                         | 计算字符串长度（不含 '\0'）              | 字符串必须以 '\0' 结尾，否则返回随机值         |
| `char* strcpy(char* dest, const char* src)`              | 将 src 拷贝到 dest（含 '\0'）            | dest 容量必须≥src 长度，否则缓冲区溢出         |
| `char* strncpy(char* dest, const char* src, size_t n)`   | 拷贝 src 的前 n 个字符到 dest            | 若 src 长度＜n，dest 剩余部分补 '\0'           |
| `char* strcat(char* dest, const char* src)`              | 将 src 追加到 dest 末尾（含 '\0'）       | dest 容量必须≥dest 原长度 + src 长度，避免溢出 |
| `char* strncat(char* dest, const char* src, size_t n)`   | 追加 src 的前 n 个字符到 dest            | 自动添加 '\0'，更安全                          |
| `int strcmp(const char* s1, const char* s2)`             | 比较 s1 和 s2（ASCII 码）                | 返回值：0（相等）、>0（s1>s2）、<0（s1<s2）    |
| `int strncmp(const char* s1, const char* s2, size_t n)`  | 比较前 n 个字符                          | 仅比较前 n 个字符，适合固定长度字符串          |
| `char* strchr(const char* str, int c)`                   | 查找 str 中首次出现 c 的位置             | 返回指向该字符的指针，未找到返回 NULL          |
| `char* strstr(const char* haystack, const char* needle)` | 查找 needle 在 haystack 中首次出现的位置 | 返回指向起始位置的指针，未找到返回 NULL        |

示例：常用字符串函数用法

c

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str1[20] = "hello";
    char str2[] = "world";

    // 1. strlen：计算长度
    printf("str1长度：%zu\n", strlen(str1));  // 5

    // 2. strcat：追加
    strcat(str1, " ");
    strcat(str1, str2);
    printf("str1追加后：%s\n", str1);  // "hello world"

    // 3. strcmp：比较
    char str3[] = "hello world";
    int cmp = strcmp(str1, str3);
    if (cmp == 0) {
        printf("str1 == str3\n");
    } else if (cmp > 0) {
        printf("str1 > str3\n");
    } else {
        printf("str1 < str3\n");
    }

    // 4. strchr：查找字符
    char* p = strchr(str1, 'w');
    if (p != NULL) {
        printf("找到'w'，后续字符串：%s\n", p);  // "world"
    }

    // 5. strstr：查找子串
    char* q = strstr(str1, "lo");
    if (q != NULL) {
        printf("找到'lo'，后续字符串：%s\n", q);  // "lo world"
    }

    return 0;
}
```

### 2. 内存操作函数（`string.h`）

与字符串函数的区别：内存函数**不依赖 '\0'**，可操作任意类型数据（如 int、结构体）。

| 函数原型                                               | 功能                                     | 注意事项                                       |
| ------------------------------------------------------ | ---------------------------------------- | ---------------------------------------------- |
| `void* memset(void* ptr, int c, size_t n)`             | 将 ptr 的前 n 字节设为 c（以字节为单位） | c 是 int，但仅用低 8 位（0~255），适合初始化 0 |
| `void* memcpy(void* dest, const void* src, size_t n)`  | 拷贝 src 的前 n 字节到 dest              | dest 和 src 内存不可重叠，否则结果未定义       |
| `void* memmove(void* dest, const void* src, size_t n)` | 拷贝 src 的前 n 字节到 dest              | 支持 dest 和 src 内存重叠（更安全）            |
| `int memcmp(const void* s1, const void* s2, size_t n)` | 比较 s1 和 s2 的前 n 字节                | 返回值：0（相等）、>0（s1>s2）、<0（s1<s2）    |

示例：内存函数操作 int 数组

c

```c
#include <stdio.h>
#include <string.h>

int main() {
    int arr1[5] = {1,2,3,4,5};
    int arr2[5] = {0};

    // 1. memset：将arr2前20字节（5*4）设为0（已初始化，此处仅示例）
    memset(arr2, 0, sizeof(arr2));
    printf("memset后arr2：");
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr2[i]);  // 0 0 0 0 0
    }
    printf("\n");

    // 2. memcpy：拷贝arr1的前16字节（4个int）到arr2
    memcpy(arr2, arr1, 4 * sizeof(int));
    printf("memcpy后arr2：");
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr2[i]);  // 1 2 3 4 0
    }
    printf("\n");

    // 3. memcmp：比较arr1和arr2的前16字节
    int cmp = memcmp(arr1, arr2, 4 * sizeof(int));
    printf("memcmp结果：%d（0表示相等）\n", cmp);  // 0

    return 0;
}
```

### 3. 常用工具函数（`stdlib.h`）

| 函数原型                                  | 功能                                      | 注意事项                                        |
| ----------------------------------------- | ----------------------------------------- | ----------------------------------------------- |
| `int atoi(const char* str)`               | 将字符串 str 转为 int（如 "123"→123）     | 字符串需以数字开头，非数字部分忽略，溢出未定义  |
| `long atol(const char* str)`              | 将字符串转为 long                         | 同 atoi，支持更大范围                           |
| `double atof(const char* str)`            | 将字符串转为 double（如 "3.14"→3.14）     | 支持小数和科学计数法（如 "1e3"→1000.0）         |
| `void* malloc(size_t size)`               | 动态分配 size 字节内存（未初始化）        | 失败返回 NULL，需手动 free                      |
| `void* calloc(size_t nmemb, size_t size)` | 分配 nmemb 个 size 字节内存（初始化为 0） | 失败返回 NULL，需手动 free                      |
| `void* realloc(void* ptr, size_t size)`   | 调整 ptr 指向的内存大小为 size 字节       | 可能分配新内存并拷贝数据，失败返回 NULL         |
| `void free(void* ptr)`                    | 释放动态内存                              | 不可释放非动态内存，不可重复释放                |
| `void exit(int status)`                   | 终止程序运行                              | status=0 表示正常退出，非 0 表示异常退出        |
| `int rand(void)`                          | 生成 0~RAND_MAX（约 32767）的随机整数     | 伪随机，需用 srand 初始化种子                   |
| `void srand(unsigned int seed)`           | 初始化 rand 的随机种子                    | 通常用 time (NULL) 作为种子（确保每次种子不同） |

示例：随机数生成与字符串转整数

c

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>  // 包含time函数

int main() {
    // 1. atoi：字符串转整数
    char str1[] = "1234";
    int num1 = atoi(str1);
    printf("atoi(\"1234\") = %d\n", num1);  // 1234

    char str2[] = "3.14abc";
    int num2 = atoi(str2);
    printf("atoi(\"3.14abc\") = %d\n", num2);  // 3（忽略非数字部分）

    // 2. 生成随机数（1~100）
    srand((unsigned int)time(NULL));  // 用当前时间作为种子（每秒变化）
    for (int i = 0; i < 5; i++) {
        int rand_num = rand() % 100 + 1;  // rand()%100→0~99，+1→1~100
        printf("随机数%d：%d\n", i+1, rand_num);
    }

    return 0;
}
```

### 4. 时间函数（`time.h`）

| 函数原型                                                     | 功能                                                         | 注意事项                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------ |
| `time_t time(time_t* t)`                                     | 获取当前系统时间（秒数，从 1970-01-01 00:00:00 UTC 开始）    | t 非 NULL 时，将时间存入 t，同时返回时间值       |
| `struct tm* localtime(const time_t* timep)`                  | 将 time_t 时间转为本地时间（年 / 月 / 日 / 时 / 分 / 秒）    | 返回的 struct tm 指针指向静态内存，不可 free     |
| `char* ctime(const time_t* timep)`                           | 将 time_t 时间转为本地时间字符串（如 "Wed Jun 01 12:34:56 2024\n"） | 字符串含换行符，不可修改                         |
| `size_t strftime(char* s, size_t maxsize, const char* format, const struct tm* tmptr)` | 按 format 格式将 struct tm 时间转为字符串                    | 灵活控制时间格式（如 "% Y-% m-% d % H:% M:% S"） |

示例：获取并格式化当前时间

c

```c
#include <stdio.h>
#include <time.h>

int main() {
    // 1. 获取当前时间（time_t类型，秒数）
    time_t now = time(NULL);
    printf("当前时间（秒数）：%lld\n", (long long)now);  // 如1717234567

    // 2. ctime：直接转为字符串
    char* time_str1 = ctime(&now);
    printf("ctime格式：%s", time_str1);  // 如"Wed Jun 01 12:34:56 2024\n"

    // 3. localtime+strftime：自定义格式
    struct tm* local_tm = localtime(&now);
    char time_str2[50];
    // 格式：年-月-日 时:分:秒（%Y=4位年，%m=2位月，%d=2位日，%H=24小时，%M=分，%S=秒）
    strftime(time_str2, sizeof(time_str2), "%Y-%m-%d %H:%M:%S", local_tm);
    printf("自定义格式：%s\n", time_str2);  // 如"2024-06-01 12:34:56"

    return 0;
}
```

## 二十四、C 语言常见错误与避坑指南

### 1. 语法错误（编译报错，易排查）

- **错误 1：遗漏分号**

	示例：`int a=10`（末尾无分号）→ 编译报错 “expected ';' before ...”；

	解决：养成每句代码结尾加分号的习惯。

- **错误 2：括号不匹配**

	示例：`for(int i=0; i<5; i++) { printf("%d",i)`（缺右括号）→ 编译报错 “expected '}' before ...”；

	解决：写括号时成对写，复杂代码用缩进区分层级。

- **错误 3：变量未声明**

	示例：`printf("%d", a)`（a 未定义）→ 编译报错 “undeclared identifier 'a'”；

	解决：变量使用前必须声明，注意作用域（如函数内变量不可在函数外使用）。

### 2. 运行时错误（编译通过，运行崩溃或结果错误，难排查）

- **错误 1：野指针访问**

	场景：指针未初始化（`int* p; *p=10;`）、指针指向已释放内存（`free(p); *p=10;`）；

	后果：程序崩溃（段错误）、数据损坏；

	解决：指针初始化时置为 NULL，使用前检查非 NULL，free 后立即置为 NULL。

- **错误 2：数组越界访问**

	场景：`int arr[5]; arr[5] = 10;`（arr 下标最大为 4）；

	后果：破坏相邻内存数据，程序崩溃或结果异常（行为未定义）；

	解决：用变量控制下标范围（如`for(int i=0; i<5; i++)`），避免硬编码下标。

- **错误 3：内存泄漏**

	场景：动态分配内存后未 free（`int* p = malloc(4); p = NULL;`）；

	后果：程序运行时间越长，内存占用越高，最终可能耗尽内存；

	解决：动态内存 “谁分配谁释放”，函数中分配的内存需在返回前释放，或明确由调用者释放。

- **错误 4：字符串无 '\0' 结尾**

	场景：`char str[5] = {'h','e','l','l','o'}; strlen(str);`（str 无 '\0'）；

	后果：strlen 会继续读取内存直到遇到 '\0'，返回随机值；

	解决：字符串初始化时确保末尾有 '\0'（如`char str[] = "hello";`或`char str[6] = {'h','e','l','l','o','\0'};`）。

- **错误 5：函数参数类型不匹配**

	场景：`int add(int a, int b) { return a+b; }`，调用时`add(3.14, 5.2);`（实参是 double）；

	后果：编译警告，实参被强制类型转换（3.14→3，5.2→5），结果错误；

	解决：调用函数时确保实参类型与形参一致，开启编译器警告（如 GCC 的`-Wall`选项）。

### 3. 逻辑错误（编译运行正常，结果不符合预期）

- **错误 1：循环条件错误**

	场景：`for(int i=1; i<=5; i--)`（i 初始为 1，i-- 后为 0，循环条件永远成立，死循环）；

	解决：检查循环变量的初始化、条件和更新语句，确保循环能正常终止。

- **错误 2：优先级混淆**

	场景：`if(a && b == c)`（实际是`a && (b==c)`，若想表达`(a&&b)==c`需加括号）；

	解决：不确定优先级时加括号（优先级：== 高于 &&，* 高于 + 等）。

- **错误 3：浮点数比较用 ==**

	场景：`if(3.14 == 10.0 / 3.1831)`（浮点数存储有精度误差，10.0/3.1831≈3.14，但 == 比较可能为假）；

	解决：比较浮点数时判断差值是否小于极小值（如`if(fabs(a - b) < 1e-6)`，`fabs`是绝对值函数）。

## 二十五、C 语言编程规范与实践技巧

### 1. 代码风格规范

- **变量 / 函数命名**：

	- 变量：小写字母 + 下划线（如`student_name`、`max_score`），避免拼音和无意义命名（如`a`、`temp`）；
	- 函数：小写字母 + 下划线（如`calculate_sum`、`print_student`），动词开头（如`get_`、`set_`、`is_`）；
	- 宏 /typedef 别名：大写字母 + 下划线（如`PI`、`MAX_SIZE`、`STUDENT`）。

- **代码缩进与换行**：

	- 缩进：用 4 个空格（或 1 个 Tab），保持统一（避免混合使用空格和 Tab）；
	- 换行：每个语句占一行，循环 / 条件语句的代码块单独换行（如`if(cond) { ... }`，`{`可换行或不换行，保持统一）。

- **注释规范**：

	- 单行注释：`// 注释内容`（用于解释单行代码或短逻辑）；

	- 多行注释：`/* 注释内容 */`（用于解释函数、结构体等复杂内容）；

	- 函数注释：说明功能、参数含义、返回值、注意事项（示例如下）：

		c

		```c
		/**
		 * @brief 计算两个整数的最大值
		 * @param a 第一个整数
		 * @param b 第二个整数
		 * @return 较大的整数（若相等，返回任意一个）
		 */
		int max(int a, int b) {
		    return a > b ? a : b;
		}
		```

		

### 2. 模块化编程

- **拆分代码到多个文件**：
	- 头文件（.h）：存放函数声明、宏定义、typedef（如`student.h`声明`struct Student`和相关函数）；
	- 源文件（.c）：存放函数实现（如`student.c`实现`student.h`中声明的函数）；
	- 主文件（main.c）：调用其他模块的函数，实现程序入口。
- **避免全局变量滥用**：
	- 全局变量会导致模块间耦合度高，难以维护；
	- 替代方案：用局部变量 + 函数参数传递，或用 static 限制变量作用域（仅当前文件可见）。

### 3. 调试技巧

- **printf 调试**：在关键位置打印变量值（如循环内打印循环变量，函数入口打印参数），定位错误位置；
- **使用 assert 宏**：在调试阶段检查关键条件（如`assert(p != NULL);`），条件不满足时终止程序并打印错误位置（需包含`<assert.h>`，发布版可通过`#define NDEBUG`禁用）；
- **编译器警告**：开启编译器的高警告级别（如 GCC 的`-Wall -Wextra`，VS 的`/W4`），警告往往是错误的前兆；
- **调试工具**：使用 GDB（命令行）或 VS Debugger（图形化），设置断点、单步执行、查看变量值，高效定位错误。

### 4. 性能优化建议

- **减少函数调用开销**：频繁调用的简单函数（如计算最大值）可改为带参宏（`#define MAX(a,b) ((a)>(b)?(a):(b))`），或用`inline`关键字（C99 支持，编译器可能将函数内联展开，减少调用开销）；
- **避免重复计算**：多次使用的计算结果（如`strlen(str)`）存储到变量中，避免重复调用；
- **合理使用动态内存**：静态数组足够时不用动态内存（减少分配 / 释放开销），动态内存按需分配，避免过度分配；
- **选择合适的数据类型**：如存储年龄用`unsigned char`（0~255）而非`int`（节省内存），避免用`double`存储整数（浪费内存且有精度问题）。

至此，C 语言核心知识点已完整覆盖，从基础语法（变量、循环、分支）到进阶内容（指针、结构体、动态内存、文件操作），再到编程规范与调试技巧，可满足日常开发和面试需求。实际应用中需多写代码、多调试，逐步积累经验，才能熟练掌握 C 语言。

## 二十六、C99/C11/C17 标准新特性（现代 C 语言）

C 语言标准不断迭代，从 1989 年的 C89（ANSI C）到 2011 年的 C11、2017 年的 C17，新增了许多实用特性，提升开发效率和代码安全性。以下是高频使用的新特性，现代编译器（GCC 4.6+、Clang 3.0+、VS 2013+）均已支持。

### 1. C99 核心新特性（2000 年发布，应用最广）

#### （1）变长数组（VLA，Variable-Length Array）

- **核心作用**：数组长度可由运行时变量决定（无需编译前固定），适合不确定数组大小的场景；
- **语法**：`int arr[n];`（`n`是运行时确定的非负整数）；
- **注意**：变长数组在栈区分配内存，不可用`sizeof`在函数外计算大小，且不支持初始化（如`int arr[n] = {0}`非法）。

示例：变长数组的使用

c

```c
#include <stdio.h>

// 用变长数组存储用户输入的n个整数
void printArray(int n, int arr[n]) {  // 形参也支持变长数组
    printf("数组元素：");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;
    printf("请输入数组长度：");
    scanf("%d", &n);

    int arr[n];  // 变长数组，长度由n决定（运行时输入）
    for (int i = 0; i < n; i++) {
        printf("请输入第%d个元素：", i+1);
        scanf("%d", &arr[i]);
    }

    printArray(n, arr);
    return 0;
}
```

#### （2）`_Bool` 布尔类型（替代自定义布尔值）

- **核心作用**：原生支持布尔类型，避免用`int`模拟（如`#define TRUE 1`）；
- **使用**：需包含头文件`<stdbool.h>`，可直接用`bool`（`_Bool`的别名）、`true`（1）、`false`（0）。

示例：布尔类型的使用

c

```c
#include <stdio.h>
#include <stdbool.h>  // 必须包含，否则bool/true/false未定义

// 判断一个数是否为偶数（返回布尔值）
bool isEven(int num) {
    return num % 2 == 0;  // 满足返回true，否则返回false
}

int main() {
    int a = 10, b = 7;
    printf("%d是偶数吗？%s\n", a, isEven(a) ? "是" : "否");  // 是
    printf("%d是偶数吗？%s\n", b, isEven(b) ? "是" : "否");  // 否

    bool flag = true;
    if (flag) {
        printf("flag为true\n");
    }
    return 0;
}
```

#### （3）`for` 循环内变量声明（局部化变量作用域）

- **特性**：允许在`for`循环初始化部分声明变量（如`for(int i=0; i<5; i++)`），变量作用域仅限于`for`循环内部；
- **优势**：避免变量污染外部作用域，代码更简洁。

示例：for 循环内声明变量

c

```c
#include <stdio.h>

int main() {
    // C99前：需在for外声明i（int i; for(i=0; ...)）
    // C99后：直接在for内声明i，作用域仅循环内
    for (int i = 0; i < 5; i++) {
        printf("i = %d\n", i);  // 正常访问i
    }

    // printf("i = %d\n", i);  // 错误：i未定义（作用域已结束）
    return 0;
}
```

#### （4）`%zd` 格式符（打印`size_t`类型）

- **背景**：`size_t`是`sizeof`的返回类型（无符号整数，32 位系统为`unsigned int`，64 位为`unsigned long`）；
- **特性**：用`%zd`打印`size_t`类型，避免因平台差异导致的格式不匹配警告。

示例：打印 size_t 类型

c

```c
#include <stdio.h>

int main() {
    int arr[10];
    size_t len = sizeof(arr);  // len是size_t类型

    // C99前：用%u（32位）或%lu（64位），可能有警告
    // C99后：用%zd，跨平台兼容
    printf("数组大小：%zd字节\n", len);  // 输出：40（10×4）
    return 0;
}
```

### 2. C11 核心新特性（2011 年发布，增强安全性）

#### （1）`_Generic` 泛型选择（模拟 “函数重载”）

- **核心作用**：根据参数类型选择不同的表达式，实现 “类型敏感” 的操作，类似 C++ 的函数重载；
- **语法**：`_Generic (表达式, 类型1: 结果1, 类型2: 结果2, ..., 默认: 结果n)`。

示例：泛型函数（打印不同类型变量）

c

```c
#include <stdio.h>

// 定义泛型宏：根据参数类型选择打印格式
#define print(x) _Generic((x), \
    int: printf("int: %d\n", x), \
    float: printf("float: %.2f\n", x), \
    char*: printf("string: %s\n", x), \
    default: printf("未知类型\n") \
)

int main() {
    print(10);          // 匹配int：输出int: 10
    print(3.14f);       // 匹配float：输出float: 3.14
    print("hello");     // 匹配char*：输出string: hello
    print(3.14);        // 匹配default：输出未知类型（double类型未定义）
    return 0;
}
```

#### （2）静态断言（`static_assert`，编译期断言）

- **核心作用**：在编译阶段检查条件是否成立，若不成立则编译失败（区别于`assert`的运行时断言）；
- **优势**：提前发现错误（如平台兼容性问题），无需运行程序。

示例：静态断言检查平台位数

c

```c
#include <stdio.h>

// 编译期检查当前是否为64位系统（size_t为8字节）
static_assert(sizeof(size_t) == 8, "当前不是64位系统！");

int main() {
    printf("64位系统检查通过\n");
    return 0;
}
// 若在32位系统编译：报错“static assertion failed: 当前不是64位系统！”
```

#### （3）安全函数（`strncpy_s`、`snprintf_s`等，可选）

- **背景**：C 标准库原有函数（`strcpy`、`sprintf`）无缓冲区大小检查，易导致缓冲区溢出；
- **特性**：C11 新增 “安全函数”，需传入缓冲区大小，超出时返回错误码并终止程序（部分编译器需开启特定选项，如 VS 的`_CRT_SECURE_NO_WARNINGS`禁用警告）；
- **注意**：安全函数是 “可选特性”，不同编译器实现可能不同，跨平台兼容性较差，实际开发中可优先用`strncpy`、`snprintf`（非安全但更通用）。

示例：安全函数`snprintf_s`

c

```c
#include <stdio.h>
#include <string.h>

int main() {
    char buf[10];  // 缓冲区大小10字节

    // snprintf_s：需传入缓冲区大小，确保不溢出
    // 参数：缓冲区、缓冲区大小、格式串、参数
    int ret = snprintf_s(buf, sizeof(buf), "hello %s", "world");
    if (ret >= 0) {
        printf("buf: %s\n", buf);  // 输出：buf: hello wor（"hello world"共11字节，buf仅10，截断为"hello wor"）
    } else {
        printf("缓冲区溢出！\n");
    }
    return 0;
}
```

### 3. C17 核心新特性（2017 年发布，优化与修复）

C17 是 “维护性标准”，无重大新特性，主要修复 C11 的漏洞、优化兼容性，例如：

- 移除 C11 中未广泛实现的特性（如`_Atomic`的部分用法）；
- 明确`__STDC_VERSION__`宏的值为`201710L`（用于判断编译器是否支持 C17）；
- 优化`sizeof`对柔性数组的处理（后续 “柔性数组” 章节讲解）。

## 二十七、C 语言柔性数组（结构体的灵活成员）

柔性数组（Flexible Array Member）是 C99 引入的结构体特性，允许结构体最后一个成员是 “未知大小的数组”，用于存储变长数据，避免内存碎片和多次内存分配。

### 1. 柔性数组的定义与语法

- **语法**：结构体最后一个成员必须是数组，且数组大小省略（`[]`中无数字）；
- **规则**：柔性数组前必须有至少一个其他成员，结构体总大小不包含柔性数组的内存（仅计算前序成员大小）。

示例：定义含柔性数组的结构体

c

```c
#include <stdio.h>
#include <stdlib.h>

// 含柔性数组的结构体：存储“长度+数据”（如字符串、字节流）
struct FlexArray {
    int len;        // 柔性数组的元素个数（前序成员，必须有）
    int data[];     // 柔性数组（最后一个成员，大小省略）
};

int main() {
    // 结构体大小：仅包含len（4字节），不包含data
    printf("struct FlexArray大小：%zd字节\n", sizeof(struct FlexArray));  // 输出：4
    return 0;
}
```

### 2. 柔性数组的使用（动态内存分配）

柔性数组本身不占用内存，需通过`malloc`分配 “结构体大小 + 柔性数组大小” 的连续内存，实现变长存储。

示例：用柔性数组存储变长数据

c

```c
#include <stdio.h>
#include <stdlib.h>

struct FlexArray {
    int len;    // 数据长度
    int data[]; // 柔性数组（存储int类型数据）
};

// 创建含柔性数组的结构体：n是data的元素个数
struct FlexArray* createFlexArray(int n) {
    // 分配内存：结构体大小 + n个int的大小（连续内存）
    struct FlexArray* fa = (struct FlexArray*)malloc(
        sizeof(struct FlexArray) + n * sizeof(int)
    );
    if (fa == NULL) {
        return NULL;
    }
    fa->len = n;  // 记录数据长度
    return fa;
}

// 打印柔性数组的数据
void printFlexArray(struct FlexArray* fa) {
    if (fa == NULL) {
        return;
    }
    printf("数据长度：%d，数据：", fa->len);
    for (int i = 0; i < fa->len; i++) {
        printf("%d ", fa->data[i]);
    }
    printf("\n");
}

int main() {
    // 1. 创建含5个int的柔性数组
    struct FlexArray* fa1 = createFlexArray(5);
    if (fa1 == NULL) {
        printf("内存分配失败\n");
        return 1;
    }
    // 给柔性数组赋值
    for (int i = 0; i < fa1->len; i++) {
        fa1->data[i] = i * 10;  // 0,10,20,30,40
    }
    printFlexArray(fa1);  // 输出：数据长度：5，数据：0 10 20 30 40

    // 2. 调整柔性数组大小（realloc）
    struct FlexArray* fa2 = (struct FlexArray*)realloc(
        fa1, sizeof(struct FlexArray) + 8 * sizeof(int)  // 扩展为8个int
    );
    if (fa2 == NULL) {
        printf("内存调整失败\n");
        free(fa1);
        return 1;
    }
    fa2->len = 8;  // 更新长度
    // 给新增的3个元素赋值
    for (int i = 5; i < fa2->len; i++) {
        fa2->data[i] = i * 10;  // 50,60,70
    }
    printFlexArray(fa2);  // 输出：数据长度：8，数据：0 10 20 30 40 50 60 70

    // 3. 释放内存（仅需free一次，因为是连续内存）
    free(fa2);
    fa2 = NULL;
    return 0;
}
```

### 3. 柔性数组的优势（对比 “指针 + 动态内存”）

传统实现变长数据时，常用 “结构体 + 指针”（如`struct { int len; int* data; }`），但需两次内存分配（结构体 + 数据），而柔性数组仅需一次连续分配，优势如下：

| 特性         | 柔性数组（Flexible Array）           | 指针 + 动态内存（int* data）           |
| ------------ | ------------------------------------ | -------------------------------------- |
| 内存分配次数 | 1 次（结构体 + 数据连续内存）        | 2 次（结构体、数据分别分配）           |
| 内存连续性   | 连续（缓存访问效率高，避免内存碎片） | 不连续（结构体和数据在堆区不同位置）   |
| 释放内存次数 | 1 次（free 结构体即可）              | 2 次（需先 free 数据，再 free 结构体） |
| 数据访问效率 | 高（连续内存，减少 CPU 缓存失效）    | 低（不连续，可能触发多次缓存访问）     |

## 二十八、多文件项目实战（模块化开发）

实际 C 语言项目不会将所有代码写在一个`.c`文件中，而是按 “功能模块” 拆分到多个文件（`.h`头文件 +`.c`源文件），实现模块化开发，便于维护和协作。以下以 “学生管理系统” 为例，讲解多文件项目的结构与编译。

### 1. 项目结构设计

学生管理系统需实现 “添加学生、查询学生、打印学生列表” 功能，拆分为 3 个模块：

plaintext

```plaintext
student_system/          # 项目根目录
├── include/             # 头文件目录（存放所有.h）
│   └── student.h        # 学生模块头文件（结构体声明、函数声明）
├── src/                 # 源文件目录（存放所有.c）
│   ├── student.c        # 学生模块源文件（函数实现）
│   └── main.c           # 主程序（入口函数，调用学生模块）
└── Makefile             # 编译脚本（可选，简化编译命令）
```

### 2. 各文件代码实现

#### （1）`include/student.h`（头文件：声明结构体和函数）

头文件需加 “头文件保护”（`#ifndef/#define/#endif`或`#pragma once`），避免重复包含：

c

```c
#ifndef STUDENT_H  // 头文件保护：防止重复包含
#define STUDENT_H

#include <stdio.h>
#include <string.h>

// 1. 声明学生结构体
struct Student {
    char name[20];
    int age;
    float score;
};

// 2. 声明学生管理函数
// 添加学生到数组
void addStudent(struct Student arr[], int* count, const char* name, int age, float score);
// 根据姓名查询学生
struct Student* findStudent(struct Student arr[], int count, const char* name);
// 打印所有学生
void printAllStudents(struct Student arr[], int count);

#endif  // STUDENT_H
```

#### （2）`src/student.c`（源文件：实现头文件声明的函数）

源文件需包含对应的头文件（`#include "../include/student.h"`），实现函数逻辑：

c

```c
#include "../include/student.h"  // 包含头文件，关联声明与实现

// 实现：添加学生到数组
void addStudent(struct Student arr[], int* count, const char* name, int age, float score) {
    if (*count >= 50) {  // 假设数组最大容量50
        printf("学生数量已达上限，无法添加！\n");
        return;
    }
    // 给当前位置的学生赋值
    strcpy(arr[*count].name, name);
    arr[*count].age = age;
    arr[*count].score = score;
    (*count)++;  // 学生数量+1（注意括号：*count++是先取count值，再自增）
}

// 实现：根据姓名查询学生（返回指针，未找到返回NULL）
struct Student* findStudent(struct Student arr[], int count, const char* name) {
    for (int i = 0; i < count; i++) {
        if (strcmp(arr[i].name, name) == 0) {  // 字符串比较用strcmp
            return &arr[i];  // 找到，返回学生地址
        }
    }
    return NULL;  // 未找到
}

// 实现：打印所有学生
void printAllStudents(struct Student arr[], int count) {
    if (count == 0) {
        printf("暂无学生数据！\n");
        return;
    }
    printf("=== 学生列表 ===\n");
    printf("姓名\t年龄\t成绩\n");
    for (int i = 0; i < count; i++) {
        printf("%s\t%d\t%.1f\n", arr[i].name, arr[i].age, arr[i].score);
    }
}
```

#### （3）`src/main.c`（主程序：调用模块函数，实现业务逻辑）

主程序包含头文件，调用`student.c`实现的函数，处理用户交互：

c

```c
#include "../include/student.h"
#include <stdio.h>

int main() {
    struct Student students[50];  // 存储学生的数组（最大50人）
    int studentCount = 0;         // 当前学生数量
    int choice;                   // 用户选择的功能编号

    // 菜单循环
    while (1) {
        printf("\n=== 学生管理系统 ===\n");
        printf("1. 添加学生\n");
        printf("2. 查询学生\n");
        printf("3. 打印所有学生\n");
        printf("4. 退出\n");
        printf("请输入选择（1-4）：");
        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                // 添加学生：读取用户输入
                char name[20];
                int age;
                float score;
                printf("请输入姓名：");
                scanf("%s", name);  // 简化处理，不支持空格
                printf("请输入年龄：");
                scanf("%d", &age);
                printf("请输入成绩：");
                scanf("%f", &score);
                // 调用添加函数
                addStudent(students, &studentCount, name, age, score);
                break;
            }
            case 2: {
                // 查询学生
                char name[20];
                printf("请输入要查询的姓名：");
                scanf("%s", name);
                struct Student* stu = findStudent(students, studentCount, name);
                if (stu != NULL) {
                    printf("查询结果：姓名=%s，年龄=%d，成绩=%.1f\n", 
                           stu->name, stu->age, stu->score);
                } else {
                    printf("未找到姓名为%s的学生！\n", name);
                }
                break;
            }
            case 3:
                // 打印所有学生
                printAllStudents(students, studentCount);
                break;
            case 4:
                // 退出程序
                printf("程序退出！\n");
                return 0;
            default:
                printf("无效选择，请重新输入！\n");
        }
    }
}
```

### 3. 项目编译与运行

#### （1）手动编译（通过`gcc`命令）

在项目根目录执行以下命令，编译所有源文件并生成可执行文件：

bash

```bash
# 语法：gcc 源文件路径1 源文件路径2 -o 可执行文件名 -I 头文件目录
gcc src/main.c src/student.c -o student_system -I include
```

- `-o student_system`：指定生成的可执行文件名为`student_system`；
- `-I include`：指定头文件搜索目录为`include`（否则编译器找不到`student.h`）。

运行可执行文件：

bash

```bash
# Windows：直接运行
student_system.exe
# Linux/macOS：
./student_system
```

#### （2）Makefile 编译（简化命令，适合多文件项目）

当项目文件较多时，手动输入编译命令繁琐，可编写`Makefile`（无后缀名），用`make`命令自动编译：

makefile

```makefile
# Makefile内容
CC = gcc                  # 编译器
CFLAGS = -I include -Wall # 编译选项：-I指定头文件目录，-Wall开启所有警告
TARGET = student_system   # 目标可执行文件名
SRCS = src/main.c src/student.c  # 所有源文件

# 生成目标：依赖SRCS，执行编译命令
$(TARGET): $(SRCS)
    $(CC) $(SRCS) -o $(TARGET) $(CFLAGS)

# 清理目标文件（make clean时执行）
clean:
    rm -f $(TARGET)  # Linux/macOS：删除可执行文件
    # del $(TARGET).exe  # Windows：删除可执行文件
```

编译与运行：

bash

```bash
# 编译（在项目根目录执行）
make
# 运行（同手动编译）
./student_system  # Linux/macOS
student_system.exe  # Windows
# 清理可执行文件
make clean
```

## 二十九、C 语言常见面试题解析（高频考点）

### 1. 指针与数组的区别？

**答案**：

| 维度         | 数组（如`int arr[5]`）                      | 指针（如`int* p`）                                   |
| ------------ | ------------------------------------------- | ---------------------------------------------------- |
| 本质         | 首元素地址（常量，不可修改，如`arr++`非法） | 存储地址的变量（可修改指向，如`p++`合法）            |
| 内存分配     | 编译时分配（栈区 / 全局区），大小固定       | 运行时可指向任意同类型内存（栈区 / 堆区）            |
| `sizeof`结果 | 数组总字节数（如`sizeof(arr)=20`）          | 指针大小（32 位→4，64 位→8）                         |
| 初始化方式   | 支持`int arr[] = {1,2,3}`（元素初始化）     | 需指向已存在的内存（如`p=arr`或`p=(int*)malloc(4)`） |
| 访问元素     | `arr[i]`或`*(arr+i)`（`arr+i`是常量地址）   | `p[i]`或`*(p+i)`（`p+i`是变量地址）                  |

**核心考点**：数组名是 “常量指针”，不可修改指向；指针是 “变量”，可修改指向。

### 2. 动态内存泄漏的原因是什么？如何避免？

**答案**：

- **泄漏原因**：动态内存（`malloc/calloc/realloc`分配）未被`free`，且指向该内存的指针被覆盖或销毁，导致内存无法回收（如`int* p = malloc(4); p = NULL;`，`p`不再指向分配的内存，无法`free`）。
- **避免方法**：
	1. 遵循 “谁分配谁释放” 原则，分配内存后记录指针，确保使用完后`free`；
	2. `free`后立即将指针置为`NULL`（避免野指针）；
	3. 用工具检测泄漏（如 Linux 的`valgrind`、VS 的 “内存泄漏检测”）；
	4. 复杂项目中使用 “智能指针”（如 C++ 的`unique_ptr`，C 需手动实现引用计数）。

### 3. 如何判断 CPU 是大端还是小端？（至少两种方法）

**答案**：

大端：数据高位字节存低地址（如`0x12345678`，地址 0 存`0x12`）；小端：低位字节存低地址（地址 0 存`0x78`）。

**方法 1：共用体（推荐，简洁）**

c

```c
#include <stdio.h>

union EndianCheck {
    int i;    // 4字节
    char c;   // 1字节（访问低地址）
};

int main() {
    union EndianCheck ec;
    ec.i = 0x12345678;
    if (ec.c == 0x78) {
        printf("小端模式\n");
    } else if (ec.c == 0x12) {
        printf("大端模式\n");
    }
    return 0;
}
```

**方法 2：指针强制类型转换**

c

```c
#include <stdio.h>

int main() {
    int i = 0x12345678;
    char* p = (char*)&i;  // 强制转换为char*，每次访问1字节
    if (*p == 0x78) {
        printf("小端模式\n");
    } else if (*p == 0x12) {
        printf("大端模式\n");
    }
    return 0;
}
```

### 4. 结构体为什么需要内存对齐？如何手动控制对齐？

**答案**：

- **对齐原因**：CPU 访问内存时按 “对齐字节数”（如 4 字节）批量读取，若数据未对齐（如 int 存地址 1），CPU 需读取 2 次（地址 0-3 和 4-7），效率低；对齐后仅需 1 次读取，提升性能。
- **手动控制方法**：
	1. `#pragma pack(n)`：设置对齐字节数为`n`（`n`是 2 的幂，如 1、2、4）；
	2. `#pragma pack()`：恢复默认对齐（编译器默认对齐字节数为最大成员大小）。

**示例**：

c

```c
#pragma pack(1)  // 1字节对齐（取消对齐）
struct Test { char c; int i; };  // 大小=1+4=5
#pragma pack()  // 恢复默认对齐
```

### 5. `sizeof("abc")`和`strlen("abc")`的结果分别是多少？为什么？

**答案**：

- `sizeof("abc")`结果是`4`：`"abc"`是字符串常量，末尾隐含`'\0'`（结束符），总字节数 = 3 个字符 + 1 个`'\0'`=4；
- `strlen("abc")`结果是`3`：`strlen`计算字符串长度时，仅统计`'\0'`前的字符个数，不包含`'\0'`。

## 三十、C 语言学习资源推荐（进阶与实战）

### 1. 书籍

- **入门**：《C 语言程序设计（谭浩强）》（经典入门，适合零基础）、《C Primer Plus（第 6 版）》（内容全面，侧重实战）；
- **进阶**：《C 和指针》（深入指针与内存）、《C 陷阱与缺陷》（避坑指南，高频面试考点）、《C 程序设计语言（第 2 版）》（C 语言创始人编写，权威）；
- **实战**：《C 语言实战教程》（项目驱动，如嵌入式、系统编程）、《Linux C 编程一站式学习》（Linux 环境下 C 开发）。

### 2. 在线资源

- **教程**：
	- [菜鸟教程 - C 语言](https://www.runoob.com/cprogramming/c-tutorial.html)（零基础入门，示例丰富）；
	- [Coursera-Programming with C（University of London）](https://www.coursera.org/learn/programming-with-c)（名校课程，系统讲解）；
- **工具**：
	- [OnlineGDB](https://www.onlinegdb.com/)（在线 C 编译器，无需安装，支持调试）；
	- [Valgrind](https://valgrind.org/)（Linux 内存检测工具，排查泄漏和野指针）；
- **文档**：
	- [C 语言标准文档（C11）](https://www.iso.org/standard/57853.html)（权威标准，了解语言细节）；
	- [GCC 手册](https://gcc.gnu.org/onlinedocs/)（编译器用法，优化选项）。

### 3. 实战项目

- **基础**：计算器、通讯录、学生管理系统（巩固结构体、文件操作）；
- **进阶**：
	- 简易 Shell（Linux 系统编程，涉及进程创建、管道）；
	- 贪吃蛇游戏（SDL 库，图形化开发）；
	- 日志系统（文件操作、多线程安全，适合嵌入式）；
- **开源贡献**：参与轻量级 C 开源项目（如[libcurl](https://curl.se/libcurl/)、[zlib](https://zlib.net/)），阅读源码提升能力。

## 总结

C 语言是一门 “贴近硬件、高效灵活” 的编程语言，核心在于**指针、内存管理、结构体**三大支柱。学习时需注意：

1. **理解内存模型**：明确变量 / 数组 / 指针在栈区、堆区、全局区的存储差异，避免野指针和内存泄漏；
2. **多写多调试**：通过项目实战（如多文件系统）巩固知识点，用调试工具（GDB、VS Debugger）排查错误；
3. **关注标准迭代**：掌握 C99/C11 的实用特性（变长数组、泛型），适应现代编译器；
4. **重视编程规范**：模块化开发、清晰命名、详细注释，提升代码可维护性。

掌握 C 语言后，可向嵌入式开发（单片机、物联网）、系统编程（Linux 内核、驱动）、高性能计算（服务器开发）等方向进阶，其底层思维也会为学习其他语言（如 C++、Rust）打下坚实基础。

