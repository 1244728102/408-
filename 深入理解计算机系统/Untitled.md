##  课程补充

学完强烈推荐去做南大的PA https://nju-projectn.github.io/ics-pa-gitbook/ics2019/ 理解"程序如何在计算机上运行"的根本途径是从"零"开始实现一个完整的计算机系统. [![img](https://i0.hdslb.com/bfs/reply/9f3ad0659e84c96a711b88dd33f4bc2e945045e0.png)南京大学计算机科学与技术系](https://search.bilibili.com/all?from_source=webcommentline_search&keyword=南京大学计算机科学与技术系&seid=9635678079816136317&from_avid=31289365&from_comid=3030754098)[![img](https://i0.hdslb.com/bfs/reply/9f3ad0659e84c96a711b88dd33f4bc2e945045e0.png)计算机系统基础课程](https://search.bilibili.com/all?from_source=webcommentline_search&keyword=计算机系统基础课程&seid=9635678079816136317&from_avid=31289365&from_comid=3030754098)的小型项目 (Programming Assignment, PA)将提出x86/mips32/ris[cv32](https://www.bilibili.com/read/cv32/)架构相应的教学版子集, 指导学生实现一个经过简化但功能完备的x86/mips32/ris[cv32](https://www.bilibili.com/read/cv32/)模拟器NEMU(NJU EMUlator), 最终在NEMU上运行游戏"仙剑奇侠传", 来让学生探究"程序在计算机上运行"的基本原理. NEMU受到了QEMU的启发, 并去除了大量与课程内容差异较大的部分.

# CMU 15-213 CSAPP 课程第一讲知识点总结

## 一、课程基础与定位（知识相关核心信息）

1. **课程覆盖范围**
	- 面向专业：计算机科学（15-213）、电气与计算机工程（18-213）、研究生（51-213），覆盖 CMU 全校约 5% 学生，是系统方向核心前置课。
	- 后续衔接：为计算机网络、操作系统、嵌入式系统等课程奠定基础（解决后续课程 “机器编程基础” 的补教问题）。
2. **教材与工具**
	- 唯一教材：《计算机系统：程序员的视角》（第三版），与课程 “高度绑定”（“书即课程，课程即书”），无电子版 / 盗版，版税全部捐赠给 CMU，需掌握书中未细讲的细节（课上仅覆盖核心，细节需自学）。
	- 核心工具：调试工具`gdb`（Linux）/`lldb`（macOS）（学期全程依赖，用于查看机器码、调试汇编）；“鲨鱼机”（英特尔捐赠的统一硬件，用于性能实验和自动评分，确保硬件一致性）。

## 二、课程核心目标

1. **打破 “代码 - 机器分离” 认知**

	解决传统编程课 “只关注代码逻辑，脱离机器现实” 的问题，让学习者理解代码执行时 “计算机盒子内部的运作机制”。

2. **双重价值定位**

	- 即时应用：为软件开发（如大型项目、性能优化）、系统设计（如硬件设计）提供实用工具与底层逻辑（如解决内存漏洞、定位性能瓶颈）。
	- 前置铺垫：为后续系统课程提供统一的底层知识框架（如理解操作系统的进程管理需先掌握机器级控制流）。

## 三、核心技术知识点（“计算机的伟大现实”）

### 3.1 数据表示与算术特性（有限位表示的妥协）

计算机用**有限位**表示数据（如 32 位、64 位），导致算术特性与常规数学直觉存在差异，是系统级 Bug 的核心根源之一。

#### 3.1.1 整数表示与溢出（32/64 位有符号整数）

- **核心问题**：有符号整数范围有限（如 32 位：`-2³¹ ~ 2³¹-1`），超出范围会发生 “溢出回绕”，符号位被篡改，结果违背数学规律。

- **视频演示案例 1：50000² 的溢出**

	数学结果：`50000 × 50000 = 2,500,000,000`（超出 32 位有符号整数上限`2,147,483,647`）

	实际结果：溢出后符号位置 1，结果为负数

	`gdb`调试演示（视频操作还原）：

	gdb

	```gdb
	(gdb) print 50000 * 50000
	$1 = -1794967296  # 32位有符号整数溢出结果
	```

	

- **视频演示案例 2：多整数相乘溢出**

	计算`300 × 400 × 500 × 600`（数学结果：`36,000,000,000`）

	32 位溢出结果：数值错误但符号位未置 1（因溢出后高位未触发符号位反转）

	`gdb`调试演示：

	gdb

	```gdb
	(gdb) print 300 * 400 * 500 * 600
	$2 = 884901888  # 32位溢出后错误结果
	```

	

- **关键特性**：整数算术满足**交换律和结合律**（如`300×400×500×600`与`600×500×400×300`结果相同），但不满足 “平方非负”“乘积递增” 等常规数学性质。

- **实际影响**：安全漏洞（如输入负数绕过正数值校验）、关键系统错误（如火箭推力计算中 “正推力变负”）。

#### 3.1.2 浮点数表示与非结合性

- **核心问题**：浮点数用 “符号位 + 阶码 + 尾数” 表示，范围极端但精度有限，小数位会因 “阶码差异” 被忽略，导致**结合律失效**。

- **视频演示案例：(1e20 + 3.14) - 1e20 ≠ 3.14**

	数学逻辑：`(a + b) - a = b`

	浮点数实际结果：`1e20`（极大值）的阶码远大于`3.14`，`3.14`的尾数无法被`1e20`的尾数存储，导致`1e20 + 3.14 = 1e20`，最终结果为`0.0`。

	代码验证（与视频演示一致）：

	c

	```c
	#include <stdio.h>
	int main() {
	    double large = 1e20;
	    double small = 3.14;
	    // 结合律失效场景
	    double res1 = (large + small) - large;
	    // 正常场景
	    double res2 = small + (large - large);
	    
	    printf("(1e20 + 3.14) - 1e20 = %.6f\n", res1);  // 输出：0.000000
	    printf("3.14 + (1e20 - 1e20) = %.6f\n", res2);  // 输出：3.140000
	    return 0;
	}
	```

	

- **实际影响**：科学计算（如物理模拟）、工程设计（如桥梁 / 核电站参数计算）的精度误差，需严格控制浮点数的范围与运算顺序。

#### 3.1.3 经典溢出案例：16 位整数的 “回绕”

- **视频漫画示例**：`32767 + 1 = -32768`

	

	16 位有符号整数范围：

	```
	-32768 ~ 32767
	```

	（

	```
	2¹⁵-1
	```

	）

	

	二进制原理：

	```
	32767
	```

	（

	```
	0111 1111 1111 1111
	```

	）加 1 后，二进制变为

	```
	1000 0000 0000 0000
	```

	（补码表示

	```
	-32768
	```

	）。

	

	```
	gdb
	```

	调试演示：

	gdb

	

	```gdb
	(gdb) print (short)32767 + 1  # 强制16位有符号整数
	$3 = -32768
	```

	

### 3.2 机器级编程（x86-64 架构核心）

- **核心定位**：不要求 “手写汇编”，而是掌握 “高级代码→汇编→机器码” 的映射关系，理解编译器生成的机器指令逻辑。
- **关键概念**：
	1. 汇编语言：机器码的文本表示，课程全程使用**x86-64 指令集**（替代传统 32 位教学，适配现代 64 位系统）。
	2. 目标代码：指令的二进制编码（机器可直接执行，无可读性）。
- **核心工具**：`gdb`（Linux）/`lldb`（macOS），用于：
	- 查看高级代码对应的汇编指令（`disassemble`命令）；
	- 单步执行机器指令（`stepi`），观察寄存器 / 内存变化；
	- 定位机器级 Bug（如溢出、内存越界）。

### 3.3 内存系统与内存安全（C/C++ 核心风险）

#### 3.3.1 内存分层与性能关联

- **分层结构**：现代计算机采用 “寄存器→L1/L2/L3 缓存→内存→磁盘” 分层存储，目标是平衡 “高性能”（寄存器 / 缓存）与 “大容量”（内存 / 磁盘）。
- **性能关键**：程序的内存访问模式决定**缓存命中率**—— 连续访问（如行优先遍历数组）会触发缓存 “预取”，命中率高；跳跃访问（如列优先遍历数组）会导致缓存频繁失效，性能骤降（后续 “缓存实验室” 重点）。

#### 3.3.2 C/C++ 数组无边界检查的致命问题

- **核心风险**：C/C++ 不校验数组索引是否越界，越界访问会篡改内存中 “无关数据”，导致 “距离效应”（内存篡改与程序崩溃不同步，调试极难）。

- **视频演示案例：结构体数组越界**

	

	结构体内存布局（根据视频描述还原）：

	```
	int a[2]
	```

	（8 字节，每个

	```
	int
	```

	4 字节） +

	 

	```
	double d
	```

	（8 字节），内存连续排列（

	```
	a[0]→a[1]→d
	```

	）。

	

	代码演示（与视频现象一致）：

	c

	```c
	#includ <stdio.h>
	struct Data {
	    int a[2];    // 0-3字节：a[0]，4-7字节：a[1]
	    double d;    // 8-15字节：d（double占8字节）
	};
	
	int main() {
	    struct Data data;
	    data.a[0] = 10;
	    data.a[1] = 20;
	    data.d = 3.14;
	
	    // 1. 正常访问：a[0]/a[1]修改不影响d
	    printf("正常：a[0]=%d, a[1]=%d, d=%.2f\n", 
	           data.a[0], data.a[1], data.d);  // 输出：10,20,3.14
	
	    // 2. 越界访问1：a[2]篡改d的低4字节
	    data.a[2] = 0x12345678;  // a[2]对应内存8-11字节（d的低4字节）
	    printf("a[2]越界：d=%.2f\n", data.d);  // 输出：异常值（低4字节被改）
	
	    // 3. 越界访问2：a[3]篡改d的高4字节
	    data.a[3] = 0x87654321;  // a[3]对应内存12-15字节（d的高4字节）
	    printf("a[3]越界：d=%.2f\n", data.d);  // 输出：完全异常值
	
	    // 4. 越界访问3：a[6]篡改栈帧元数据（如返回地址），程序崩溃
	    data.a[6] = 0xdeadbeef;  // 触发内存错误，终止运行
	    return 0;
	}
	```

	

- **后果**：

	1. 调试困难：内存篡改发生后，程序可能正常运行数小时 / 天，直到访问被篡改的数据才崩溃，无法追溯根源。
	2. 安全漏洞：攻击者可通过越界访问篡改程序控制流（如修改函数返回地址），执行恶意代码（后续 “攻击实验室” 重点）。

### 3.4 程序性能优化（缓存利用核心案例）

- **核心现象**：循环嵌套顺序仅改变 “遍历顺序”，但因内存访问模式不同，性能差异可达**20 倍**。

- **视频演示案例：矩阵复制（行优先 vs 列优先）**

	矩阵定义：`int src[2408][2048], dest[2408][2048]`（2408 行、2048 列，内存按 “行优先” 存储）。

	1. **行优先复制（高效，缓存命中率高）**

		内存访问模式：连续访问（如`src[0][0]→src[0][1]→src[0][2]`），符合缓存 “预取机制”（缓存会提前加载连续内存块）。

		代码：

		c

		```c
		void copy_row(int src[2408][2048], int dest[2408][2048]) {
		    for (int i = 0; i < 2408; i++) {  // 行循环在外
		        for (int j = 0; j < 2048; j++) {  // 列循环在内
		            dest[i][j] = src[i][j];
		        }
		    }
		}
		```

		

	2. **列优先复制（低效，缓存命中率低）**

		内存访问模式：跳跃访问（如`src[0][0]→src[1][0]→src[2][0]`），每次访问间隔`2048×4=8192`字节，缓存频繁失效（需从内存重新加载，速度比缓存慢 100 + 倍）。

		代码：

		c

		```c
		void copy_col(int src[2408][2048], int dest[2408][2048]) {
		    for (int j = 0; j < 2048; j++) {  // 列循环在外
		        for (int i = 0; i < 2408; i++) {  // 行循环在内
		            dest[i][j] = src[i][j];
		        }
		    }
		}
		```

		

- **结论**：程序性能不仅取决于 “算法复杂度”，还取决于 “底层内存访问模式”—— 需适配内存分层结构才能最大化性能。

## 四、后续课程核心主题（知识框架）

1. **异常控制流（ECF）**

	贯穿硬件到软件的控制流切换机制，包括：硬件中断、进程上下文切换（`fork`/`exec`）、Linux 信号、非局部跳转（`longjmp`），是 “shell 实验室”（实现 Linux shell）的核心知识。

2. **虚拟内存**

	硬件与软件结合的内存抽象，将内存表示为 “连续大字节数组”，隐藏分层存储细节，同时提供内存保护、共享功能，是 “malloc 实验室”（实现`malloc`/`free`）的核心知识。

3. **I/O 与网络编程**

	数据进出计算机的机制，重点是 Linux I/O 模型（如文件描述符）和互联网 Socket 编程，实现跨机器通信（如客户端 - 服务器交互）。

4. **并发编程**

	线程级并行、同步机制（如锁、信号量），解决多线程资源竞争问题，确保并发程序正确性。

## 五、核心实验室对应的知识目标

| 实验室名称    | 核心知识目标                                            | 典型任务示例                                        |
| ------------- | ------------------------------------------------------- | --------------------------------------------------- |
| 数据实验室    | 掌握整数 / 浮点数的位级表示，熟练使用位操作             | 不用条件语句实现`int abs(int x)`                    |
| 炸弹实验室    | 逆向工程二进制程序，通过`gdb`分析汇编指令               | 无源代码情况下，找出 “炸弹” 各阶段的正确输入        |
| 攻击实验室    | 理解内存安全漏洞，学习 “返回导向编程（ROP）” 绕过栈保护 | 构造输入篡改程序控制流，执行指定代码                |
| 缓存实验室    | 理解缓存工作原理，优化内存访问模式以减少缓存缺失        | 实现缓存模拟器，优化矩阵运算代码                    |
| shell 实验室  | 掌握进程创建、信号处理，理解异常控制流                  | 实现简化版 Linux shell（支持`ls`/`cd`）             |
| malloc 实验室 | 理解堆内存布局与虚拟内存，实现动态内存分配              | 编写`malloc`/`free`，管理堆内存                     |
| 网络实验室    | 掌握 Socket 编程，理解客户端 - 服务器模型               | 实现基于 TCP 的 “echo” 服务（客户端发啥服务器回啥） |

编辑分享