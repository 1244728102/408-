# 串的定义与基本操作

## 1. 串的定义与核心概念

### 1.1 串的本质定义

串（字符串）是由**有限个字符**组成的有序序列，记为 `S = "c₁c₂c₃…cₙ"`（`n≥0`），其中：

- `S` 为**串名**（字符串变量名）；
- `cᵢ`（`1≤i≤n`）为串的元素，仅能是字符（如英文字母、数字、空格、标点等）；
- `n` 为**串的长度**（字符个数），当 `n=0` 时称为**空串**。

> 视频示例：`"hello world"` 是长度为 11 的串，`"11pro"` 是长度为 5 的串。

### 1.2 关键术语

| 术语     | 定义                                                      | 视频实例                                                     |
| -------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| 串名     | 字符串变量的名称，用于标识不同串                          | 串 `s = "abc123"` 中，`s` 为串名                             |
| 串长     | 串中字符的总个数，空串长度为 0                            | 串 `t = "iPhone 11pro"` 长度为 11（含空格，空格是独立字符）  |
| 空串     | 长度为 0 的串，记为 `""`（双引号内无任何字符）            | `m = ""`，`m` 是空串，长度 = 0                               |
| 空格串   | 由一个或多个空格字符组成的串，长度≥1                      | `n = " "`（3 个空格），`n` 是空格串，长度 = 3                |
| 子串     | 从主串中选取的**连续字符序列**（空串是所有串的子串）      | 主串 `t = "iPhone 11pro"` 中，`"11pro"` 是子串，`"iPhone"` 也是子串 |
| 主串     | 包含子串的原始串                                          | 上述例子中，`t` 是 `"11pro"` 的主串                          |
| 字符位置 | 字符在主串中的序号（**从 1 开始计数**，与线性表位序一致） | 主串 `t = "iPhone 11pro"` 中，字符 `'1'`（第一个 1）的位置是 8 |
| 子串位置 | 子串在主串中的序号，等于子串**第一个字符在主串中的位置**  | 子串 `"11pro"` 在主串 `t` 中的位置是 8（因子串第一个字符 `'1'` 位置为 8） |

> 引号（单 / 双）是**边界符**，仅用于标识串的起止，不计入串的长度。

## 2. 串与线性表的区别

串是**特殊的线性表**，二者逻辑结构均为 “有序序列”，但存在两点关键差异：

| 对比维度     | 线性表                             | 串（字符串）                              |
| ------------ | ---------------------------------- | ----------------------------------------- |
| 元素类型     | 无限制（可是整数、结构体、对象等） | 仅能是字符（如 ASCII 字符、Unicode 字符） |
| 基本操作对象 | 单个元素（如插入 / 删除一个元素）  | 子串（如查找 / 删除一个连续字符序列）     |

> 视频示例：搜索引擎查找时，输入的 “关键词” 是子串，目标网页内容是主串 —— 操作对象是子串而非单个字符。

## 3. 串的基本操作

### 3.1 串的存储结构

c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 串的动态存储结构体（视频未显式给出，但符合课程常规设计）
typedef struct {
    char *ch;   // 指向存储串的动态数组
    int length; // 串的长度
} SString;
```

### 3.2 10 种基本操作

#### 操作 1：串的赋值（StrAssign）

- **功能**：将字符序列 `chars` 赋值给串 `T`（若 `T` 已有内容，需先释放旧内存）。
- **代码**：

c

```c
// 成功返回1，失败返回0（如内存分配失败）
int StrAssign(SString *T, char *chars) {
    // 1. 释放T的旧内存（避免内存泄漏）
    if (T->ch != NULL) {
        free(T->ch);
        T->ch = NULL;
    }
    // 2. 计算chars的长度（不含'\0'）
    int len = strlen(chars);
    if (len == 0) { // 赋值为空串
        T->ch = NULL;
        T->length = 0;
        return 1;
    }
    // 3. 分配新内存（+1是为了兼容C语言字符串的'\0'，方便调试）
    T->ch = (char *)malloc((len + 1) * sizeof(char));
    if (T->ch == NULL) { // 内存分配失败
        T->length = 0;
        return 0;
    }
    // 4. 复制字符序列到T
    for (int i = 0; i < len; i++) {
        T->ch[i] = chars[i];
    }
    T->ch[len] = '\0'; // 末尾加'\0'，符合C语言字符串规范
    T->length = len;
    return 1;
}
```

#### 操作 2：串的复制（StrCopy）

- **功能**：将串 `S` 的内容复制到串 `T`（覆盖 `T` 原有内容）。
- **代码**：

c

```c
// 成功返回1，失败返回0（如S为空）
int StrCopy(SString *T, SString S) {
    // 1. 释放T的旧内存
    if (T->ch != NULL) {
        free(T->ch);
        T->ch = NULL;
    }
    // 2. 若S是空串，T也设为空串
    if (S.length == 0) {
        T->ch = NULL;
        T->length = 0;
        return 1;
    }
    // 3. 分配内存并复制内容
    T->ch = (char *)malloc((S.length + 1) * sizeof(char));
    if (T->ch == NULL) {
        T->length = 0;
        return 0;
    }
    for (int i = 0; i < S.length; i++) {
        T->ch[i] = S.ch[i];
    }
    T->ch[S.length] = '\0';
    T->length = S.length;
    return 1;
}
```

#### 操作 3：串的判空（StrEmpty）

- **功能**：判断串 `S` 是否为空串（长度 = 0）。
- **代码**：

c

```c
// 是空串返回1，非空返回0
int StrEmpty(SString S) {
    return (S.length == 0) ? 1 : 0;
}
```

#### 操作 4：求串长（StrLength）

- **功能**：返回串 `S` 的长度（字符个数）。
- **代码**：

c

```c
int StrLength(SString S) {
    return S.length;
}
```

#### 操作 5：串的清空（ClearString）

- **功能**：将串 `S` 设为空串（**不释放内存**，仅逻辑清空）。
- **视频强调**：清空 ≠ 销毁，清空后内存仍可复用。
- **代码**：

c

```c
void ClearString(SString *S) {
    S->length = 0; // 仅将长度设为0，不释放ch指向的内存
    if (S->ch != NULL) {
        S->ch[0] = '\0'; // 可选：将第一个字符设为'\0'，标记空串
    }
}
```

#### 操作 6：串的销毁（DestroyString）

- **功能**：释放串 `S` 占用的内存（**彻底销毁**，之后不可再使用 `S`）。
- **代码**：

c

```c
void DestroyString(SString *S) {
    if (S->ch != NULL) {
        free(S->ch);     // 释放动态数组内存
        S->ch = NULL;    // 避免野指针
    }
    S->length = 0;       // 长度设为0
}
```

#### 操作 7：串的连接（Concat）

- **功能**：将串 `S` 和串 `W` 连接，结果存入串 `T`（`T = S + W`）。
- **代码**：

c

```c
// 成功返回1，失败返回0（如内存分配失败）
int Concat(SString *T, SString S, SString W) {
    // 1. 释放T的旧内存
    if (T->ch != NULL) {
        free(T->ch);
        T->ch = NULL;
    }
    // 2. 计算连接后的总长度
    int totalLen = S.length + W.length;
    if (totalLen == 0) { // S和W均为空
        T->ch = NULL;
        T->length = 0;
        return 1;
    }
    // 3. 分配内存并复制S和W的内容
    T->ch = (char *)malloc((totalLen + 1) * sizeof(char));
    if (T->ch == NULL) {
        T->length = 0;
        return 0;
    }
    // 复制S的内容
    for (int i = 0; i < S.length; i++) {
        T->ch[i] = S.ch[i];
    }
    // 复制W的内容（接在S之后）
    for (int i = 0; i < W.length; i++) {
        T->ch[S.length + i] = W.ch[i];
    }
    T->ch[totalLen] = '\0';
    T->length = totalLen;
    return 1;
}
```

#### 操作 8：求子串（SubString）

- **功能**：从串 `S` 的第 `pos` 个字符开始，截取 `len` 个字符，存入串 `Sub`。
- **视频注意**：`pos` 从 1 开始，需判断合法性（`pos≤S.length` 且 `len≤S.length-pos+1`）。
- **代码**：

c

```c
// 成功返回1，失败返回0（参数非法）
int SubString(SString *Sub, SString S, int pos, int len) {
    // 1. 检查参数合法性（pos从1开始，len≥0）
    if (pos < 1 || pos > S.length || len < 0 || len > S.length - pos + 1) {
        Sub->ch = NULL;
        Sub->length = 0;
        return 0;
    }
    // 2. 释放Sub的旧内存
    if (Sub->ch != NULL) {
        free(Sub->ch);
        Sub->ch = NULL;
    }
    // 3. 若len=0，Sub设为空串
    if (len == 0) {
        Sub->ch = NULL;
        Sub->length = 0;
        return 1;
    }
    // 4. 分配内存并复制子串
    Sub->ch = (char *)malloc((len + 1) * sizeof(char));
    if (Sub->ch == NULL) {
        Sub->length = 0;
        return 0;
    }
    // S的第pos个字符对应数组下标pos-1
    for (int i = 0; i < len; i++) {
        Sub->ch[i] = S.ch[pos - 1 + i];
    }
    Sub->ch[len] = '\0';
    Sub->length = len;
    return 1;
}
```

#### 操作 9：串的定位（Index）

- **功能**：查找子串 `W` 在主串 `S` 中**第一次出现的位置**（`W` 是空串返回 0）。
- **视频说明**：朴素模式匹配（未讲 KMP，仅基础遍历对比），找到返回子串首字符位置，未找到返回 0。
- **代码**：

c

```c
int Index(SString S, SString W) {
    // 1. 特殊情况：W是空串或S长度 < W长度，返回0
    if (W.length == 0 || S.length < W.length) {
        return 0;
    }
    // 2. 朴素匹配：遍历S的所有可能起始位置
    int i = 0; // S的数组下标（对应S的第i+1个字符）
    int j = 0; // W的数组下标
    while (i < S.length && j < W.length) {
        if (S.ch[i] == W.ch[j]) { // 字符匹配，继续对比下一个
            i++;
            j++;
        } else { // 不匹配，S回溯到上一轮起始位置+1，W重置为0
            i = i - j + 1;
            j = 0;
        }
    }
    // 3. 若j遍历完W，说明匹配成功，返回S的起始位置（i-j+1，因i是数组下标）
    if (j == W.length) {
        return i - j + 1;
    } else { // 未匹配成功
        return 0;
    }
}
```

#### 操作 10：串的比较（StrCompare）

- **功能**：按字符 ASCII 码对比串 `S` 和 `T`，返回差值：
	- 若 `S > T`，返回正整数；
	- 若 `S == T`，返回 0；
	- 若 `S < T`，返回负整数。
- **视频规则**：
	1. 从第一个字符开始逐位对比，直到出现不同字符或某一串结束；
	2. 若前缀相同，**长度更长的串更大**。
- **代码**：

c

```c
int StrCompare(SString S, SString T) {
    // 1. 逐字符对比（直到出现不同或某一串结束）
    for (int i = 0; i < S.length && i < T.length; i++) {
        if (S.ch[i] != T.ch[i]) {
            return S.ch[i] - T.ch[i]; // 返回ASCII码差值
        }
    }
    // 2. 前缀相同，比较长度（长的串更大）
    return S.length - T.length;
}
```

## 4. 字符集与编码

### 4.1 字符集的定义

字符集是 “字符的集合”，如：

- **ASCII 字符集**：包含英文字母、数字、标点、控制字符（共 128 个）；
- **Unicode 字符集**：包含全球语言字符（中文、日语、法语等），解决 ASCII 无法表示非英文字符的问题。

### 4.2 编码规则（字符→二进制）

编码是 “字符集与二进制数的映射规则”，视频重点讲解 2 种：

| 编码规则 | 适用字符集 | 存储占用 | 视频实例                                                     |
| -------- | ---------- | -------- | ------------------------------------------------------------ |
| ASCII    | ASCII      | 1 字节   | 空格字符编码为 `00100000`（十进制 32）； `'a'` 编码为 `01100001`（十进制 97） |
| UTF-8    | Unicode    | 可变长   | 英文字符 1 字节，中文字符 3 字节（如 “串” 编码为 `E4 B8 B2`） |

> 视频强调：考研中默认 “每个字符占 1 字节”（即 ASCII 编码），仅需关注英文字符、数字、空格。

### 4.3 乱码的原因

乱码源于 “编码与解码规则不一致”：

- 存储时用 **UTF-8 编码**（如 “串”→`E4 B8 B2`）；
- 读取时用 **ASCII 解码**（`E4`→乱码字符，`B8`→乱码字符，`B2`→乱码字符）；
- 本质是 “用错误的映射规则解析二进制数据”。

## 5. 常见误区（重点提醒）

1. **空串 vs 空格串**：
	- 空串：`""`，长度 = 0，无任何字符；
	- 空格串：`" "`（n 个空格），长度 = n≥1，含空格字符。
2. **引号不是串的内容**：
	- 双引号 / 单引号是 “串的边界符”，仅用于标识串的起止，不计入串长（如 `"abc"` 长度 = 3，不是 5）。
3. **位置从 1 开始**：
	- 串中字符 / 子串的位置从 1 计数（与线性表位序一致），区别于 C 语言数组的 0 开始下标（如串 `S = "abc"` 中，`'a'` 位置 = 1，对应数组下标 0）。



# 串的存储结构与基本操作知识点总结

## 一、串的存储结构概述

串是**特殊的线性表**，其存储结构与线性表一致，仅需将线性表中存储的 “通用数据元素（ElemType）” 替换为 “字符（char）” 即可。

## 二、串的顺序存储

顺序存储通过**连续的内存空间**存储字符，分为 “定长顺序存储（静态数组）” 和 “堆分配存储（动态数组）” 两类。

### 2.1 定长顺序存储（静态数组实现）

#### 核心定义

采用 “静态数组 + 长度变量” 的结构体，数组容量固定（定长），系统在**栈区**分配内存，函数执行结束后自动回收。

c

```c
// 宏定义数组最大容量（视频中提及255，符合char型长度记录的上限）
#define MAXSIZE 255
// 定长顺序串的结构体定义（视频中王道方案：舍弃data[0]，从data[1]存字符）
typedef struct {
    char data[MAXSIZE + 1];  // data[0]未使用，data[1]~data[MAXSIZE]存储字符
    int length;              // 记录串的实际长度（单独变量，避免遍历求长）
} SString;
```

#### 三种长度记录方式

| 记录方式                  | 实现逻辑                                                 | 优点                                           | 缺点                                       |
| ------------------------- | -------------------------------------------------------- | ---------------------------------------------- | ------------------------------------------ |
| 1. 单独 length 变量       | 结构体中单独定义 int length，直接记录实际长度            | 无需遍历，获取长度 O (1)；无长度限制           | 需额外存储 length 变量                     |
| 2. data [0] 存长度        | 用 data [0]（char 型）存储长度，data [1]~data [n] 存字符 | 字符位序与数组下标一致（位序 1 对应 data [1]） | char 占 1 字节，长度最大 255，超出无法存储 |
| 3. 末尾加 '\0'（ASCII 0） | 不记录长度，在串末尾插入 '\0' 作为结束标志               | 无需额外变量存储长度                           | 获取长度需遍历整个串，时间复杂度 O (n)     |

#### 视频推荐方案（王道方案）

采用 “**舍弃 data [0]+ 单独 int length**”：

- 字符从 data [1] 开始存储，位序与下标完全一致（位序 i 对应 data [i]），无需转换；
- int 型 length 可存储更大长度（突破 255 限制），获取长度 O (1)，兼顾前两种方式的优点。

### 2.2 堆分配存储（动态数组实现）

#### 核心定义

采用 “字符指针 + 长度变量” 的结构体，通过`malloc`在**堆区**动态申请内存，需手动调用`free`释放，长度可灵活调整。

c

```c
// 堆分配串的结构体定义
typedef struct {
    char *data;  // 指向堆区连续内存的基地址
    int length;  // 记录串的实际长度
} HString;
```

#### 内存分配与释放（视频关键操作）

c

```c
// 1. 初始化堆分配串（申请内存）
void InitHString(HString *T, int initLen) {
    // 调用malloc申请initLen字节的连续内存
    T->data = (char *)malloc(initLen * sizeof(char));
    if (T->data == NULL) {
        exit(1);  // 内存分配失败，退出程序
    }
    T->length = 0;  // 初始长度为0
}

// 2. 释放堆分配串的内存
void DestroyHString(HString *T) {
    free(T->data);  // 手动释放堆区内存
    T->data = NULL; // 指针置空，避免野指针
    T->length = 0;  // 长度置0
}
```

### 2.3 顺序存储的优缺点

- **优点**：支持**随机存取**（通过下标直接访问任意字符，时间复杂度 O (1)）；
- **缺点**：插入 / 删除操作需移动大量字符（内存空间拓展 / 收缩不便，时间复杂度 O (n)）。

## 三、串的链式存储

通过 “节点 + 指针” 的链表结构存储字符，解决顺序存储的 “拓展不便” 问题，但需优化 “存储密度”。

### 3.1 核心定义（多字符节点优化）

#### 问题：单字符节点存储密度低

若单个节点仅存 1 个字符（1 字节）+1 个指针（32 位机 4 字节），存储密度 = 1/(1+4)=20%，资源浪费严重。

#### 优化方案：单个节点存储多个字符

c

```c
// 宏定义每个节点存储的最大字符数（视频中提及“可更多，方便画图”，此处设4）
#define CHUNKSIZE 4
// 串的链式存储节点定义（块链结构）
typedef struct Chunk {
    char data[CHUNKSIZE];        // 每个节点存储CHUNKSIZE个字符
    struct Chunk *next;          // 指向下一个节点的指针
} Chunk;

// 块链串的结构体定义（记录头节点、尾节点、总长度）
typedef struct {
    Chunk *head, *tail;  // 头指针、尾指针（方便操作）
    int length;          // 串的实际总长度
} LString;
```

### 3.2 末尾节点填充

若串的总长度不是 CHUNKSIZE 的整数倍，最后一个节点的未用空间需用**特殊字符填充**（如`#`或`'\0'`），避免读取垃圾数据。

### 3.3 链式存储的优缺点

- **优点**：插入 / 删除操作方便（仅需修改指针，无需移动大量字符）；
- **缺点**：不支持随机存取（访问第 i 个字符需从表头遍历，时间复杂度 O (n)）；存储密度仍低于顺序存储（需额外存储指针）。

## 四、串的基本操作（基于定长顺序存储 SString）

视频中重点讲解 5 个基本操作，均基于 “王道定长顺序串（data [0] 舍弃，int length）” 实现。

### 4.1 求串长（StrLength）

#### 功能

返回串的实际长度（直接读取 length 变量）。

c

```c
// 求串S的长度
int StrLength(SString S) {
    return S.length;  // O(1)时间，直接返回length
}
```

### 4.2 清空串（ClearString）

#### 功能

逻辑清空串（无需删除字符，仅将 length 置 0）。

c

```c
// 清空串S（内存中字符仍存在，逻辑上视为空串）
void ClearString(SString *S) {
    S->length = 0;  // O(1)时间，仅修改长度
}
```

### 4.3 求子串（SubString）

#### 功能

从串`S`的第`i`个字符开始，截取长度为`len`的子串，存入`sub`中；若越界（如`i+len-1 > S.length`），返回`false`。

c

```c
// 求子串：sub = S的第i个字符开始的len个字符
bool SubString(SString *sub, SString S, int i, int len) {
    // 1. 判断越界：i非法（<1或> S.length）、len非法（<0）、截取范围超出S
    if (i < 1 || i > S.length || len < 0 || i + len - 1 > S.length) {
        return false;  // 子串不存在，返回失败
    }
    // 2. 复制S的字符到sub
    for (int k = 1; k <= len; k++) {
        sub->data[k] = S.data[i + k - 1];  // S的i+k-1对应sub的k
    }
    // 3. 设置sub的长度
    sub->length = len;
    return true;  // 成功返回true
}
```

### 4.4 比较两个串（StrCompare）

#### 功能

逐字符对比串`S`和`T`：

- 若某位置字符不同，返回`S该字符 - T该字符`（正数表示 S>T，负数表示 S<T）；
- 若所有对比字符相同，返回`S.length - T.length`（正数 S 更长，0 表示两串相等）。

c

```c
// 比较串S和T：返回值>0则S>T，=0则S=T，<0则S<T
int StrCompare(SString S, SString T) {
    // 1. 逐字符对比（遍历到较短串的末尾）
    for (int i = 1; i <= S.length && i <= T.length; i++) {
        if (S.data[i] != T.data[i]) {
            return S.data[i] - T.data[i];  // 字符不同，返回差值
        }
    }
    // 2. 所有对比字符相同，返回长度差值
    return S.length - T.length;
}
```

### 4.5 定位子串（Index）

#### 功能

在主串`S`中查找子串`T`第一次出现的位置（位序）：

- 若找到，返回子串第一个字符的位序；
- 若未找到，返回 0。

c

```c
// 定位子串：返回T在S中第一次出现的起始位序，未找到返回0
int Index(SString S, SString T) {
    int S_len = StrLength(S);  // 主串长度
    int T_len = StrLength(T);  // 子串长度
    SString sub;               // 临时存储截取的子串
    // 遍历主串：最多截取到S_len - T_len + 1的位置（避免越界）
    for (int i = 1; i <= S_len - T_len + 1; i++) {
        // 截取S中从i开始、长度为T_len的子串
        SubString(&sub, S, i, T_len);
        // 对比截取的子串与T：若相等，返回当前起始位序i
        if (StrCompare(sub, T) == 0) {
            return i;
        }
    }
    return 0;  // 遍历结束未找到，返回0
}
```



# 串的存储结构与基本操作知识点总结

## 五、关键概念与视频实例补充

### 5.1 顺序存储的内存分配区域

- **定长顺序存储（静态数组）**：内存分配在**栈区**，无需手动管理。
	例：函数内定义`SString s`，函数执行结束后，`s.data`数组与`s.length`占用的栈区内存会被系统自动回收，避免内存泄漏。
- **堆分配存储（动态数组）**：内存分配在**堆区**，必须手动管理。
	例：通过`InitHString(&h, 10)`申请 10 字节堆内存后，若不再使用，需调用`DestroyHString(&h)`释放，否则会导致堆区内存泄漏（视频明确 “`malloc`申请的堆区内存需`free`回收”）。

### 5.2 链式存储的存储密度计算

#### 存储密度公式

存储密度 = （节点中实际存储的字符占用空间） / （节点总占用空间）

#### 两种节点对比（视频案例）

| 节点类型                  | 字符占用空间        | 指针占用空间（32 位机） | 节点总空间 | 存储密度 | 视频结论               |
| ------------------------- | ------------------- | ----------------------- | ---------- | -------- | ---------------------- |
| 单字符节点                | 1 字节（1 个 char） | 4 字节（1 个指针）      | 5 字节     | 1/5=20%  | 存储密度低，资源浪费   |
| 多字符节点（CHUNKSIZE=4） | 4 字节（4 个 char） | 4 字节（1 个指针）      | 8 字节     | 4/8=50%  | 存储密度提升，推荐使用 |

### 5.3 基本操作的实例验证

#### 5.3.1 求子串实例

假设主串`S.data = "abcdefg"`（`S.length=7`），需截取 “从第 4 个字符开始，长度为 3 的子串”：

- 调用`SubString(&sub, S, 4, 3)`：
	循环中`k=1`时，`sub.data[1] = S.data[4] = 'd'`；
	`k=2`时，`sub.data[2] = S.data[5] = 'e'`；
	`k=3`时，`sub.data[3] = S.data[6] = 'f'`；
	最终`sub.length=3`，`sub.data`为`["", 'd','e','f']`（`data[0]`未使用），符合视频 “子串为 def” 的预期。

#### 5.3.2 串比较实例

- **场景 1：字符不同**：`S.data="abcdefg"`（len=7），`T1.data="abx"`（len=3）
	对比`S.data[3]='c'`与`T1.data[3]='x'`，返回`'c'-'x' = -23`（负数），表示`S < T1`（符合视频逻辑）。
- **场景 2：长度不同**：`S.data="abcdefg"`（len=7），`T2.data="abcd"`（len=4）
	前 4 个字符完全相同，返回`7-4=3`（正数），表示`S > T2`（符合视频 “长度长的串更大” 的规则）。

#### 5.3.3 子串定位实例

主串`S.data="abcdefg"`（len=7），子串`T.data="def"`（len=3）：

- 遍历`i`的范围：`1 ≤ i ≤ 7-3+1 = 5`（视频明确 “遍历到主串长度 - 子串长度 + 1”）；
- 当`i=4`时，截取子串`sub.data="def"`，与`T`比较返回 0，故`Index(S,T)=4`（视频 “返回子串第一个字符的位序”）。

## 六、核心结论与注意事项

### 6.1 存储结构选择建议

- 若需频繁**读取字符**（如随机访问）：优先选择**顺序存储**（随机存取 O (1)，效率高）；
- 若需频繁**插入 / 删除字符**（如字符串拼接、截取）：优先选择**链式存储**（无需移动大量字符，仅改指针）；
- 若字符串长度**固定且较小**：用**定长顺序存储**（无需手动管理内存）；
- 若字符串长度**不确定且可能较大**：用**堆分配存储**（动态调整容量，突破 255 限制）。

### 6.2 代码实现注意事项

1. **定长顺序串的下标问题**：
	王道方案中`data[0]`未使用，字符从`data[1]`开始存储，循环需从`1`遍历（避免误操作`data[0]`）；
2. **堆分配串的内存检查**：
	`malloc`可能失败（返回`NULL`），代码中需添加`if (T->data == NULL) exit(1)`的判断（视频未写但隐含 “内存分配失败需处理”）；
3. **链式串的末尾填充**：
	最后一个节点未填满的位置需用特殊字符（如`'#'`）填充，避免读取时遇到垃圾数据（视频明确 “填充特殊字符”）。



# 朴素模式匹配算法知识点总结

## 一、核心术语定义

视频中明确了字符串模式匹配的 3 个核心术语，是后续算法讲解的基础，具体定义如下：

| 术语            | 定义                                                         | 关键区别                                                     |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **主串（S）**   | 被搜索的完整字符串，是模式匹配的 “目标范围”，用长度`n`表示其字符个数。 | 必然存在，是匹配操作的载体。                                 |
| **模式串（T）** | 想要在主串中查找的子字符串，用长度`m`表示其字符个数。        | 不一定能在主串中找到（匹配可能失败），是匹配操作的 “目标对象”。 |
| **子串**        | 主串中**连续存在**的一段字符序列。                           | 一定是主串的一部分（必然存在），与模式串的区别在于：模式串是 “待找的”，子串是 “已存在的”。 |

### 关键推论

在长度为`n`的主串中，所有长度为`m`的子串总数为 **`n - m + 1`**（视频中明确提问并给出结论），这是朴素算法遍历子串的核心依据（仅当`n >= m`时可能匹配成功，`n < m`时直接匹配失败）。

## 二、朴素模式匹配算法的核心思想

视频中明确该算法本质是**暴力解法**，核心逻辑可拆解为 3 步：

1. **遍历候选子串**：在主串中依次取出所有长度为`m`的子串（共`n - m + 1`个），每个子串对应主串的一个 “起始位置”（从 1 开始计数，视频中采用 1-based 索引）。
2. **逐字符对比**：将每个候选子串与模式串从第一个字符开始逐位对比。
3. **返回结果**：
	- 若某候选子串与模式串完全一致，立即返回该子串在主串中的**起始位置**。
	- 若遍历所有候选子串后均不匹配，返回`0`表示匹配失败。

视频中举例：在主串中找 “笑出猪叫”（模式串），若存在则返回起始位置；找 “笑出喵叫”（模式串），因主串中无该子串，返回 0。

## 三、朴素模式匹配算法的两种实现方式

视频中讲解了两种实现思路，均基于 1-based 索引（符合考研数据结构的常见习惯），且明确第一种实现与 “上一节的 index 函数” 逻辑一致。

### 方式 1：基于字符串基本操作（取子串 + 字符串比较）

#### 实现逻辑

利用 “取子串（substring）” 和 “字符串比较（strcmp 类似功能）” 两个基本操作，直接遍历所有候选子串并对比：

1. 初始化循环变量`i = 1`（`i`表示当前候选子串在主串的起始位置）。
2. 循环条件：`i <= n - m + 1`（遍历所有长度为`m`的子串）。
3. 取主串中从`i`开始、长度为`m`的子串`S_sub = substring(S, i, m)`。
4. 对比`S_sub`与模式串`T`：
	- 若`S_sub == T`：返回`i`（匹配成功，返回起始位置）。
	- 若`S_sub != T`：`i += 1`（继续遍历下一个候选子串）。
5. 循环结束后仍未匹配：返回`0`（匹配失败）。

#### 完整代码（C 语言风格，1-based 索引）

c

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 辅助函数：从主串S中取“起始位置为i、长度为m”的子串（1-based）
char* substring(char* S, int i, int m) {
    // S是1-based存储（S[0] unused），子串长度为m
    char* sub = (char*)malloc((m + 1) * sizeof(char)); // 预留'\0'位置
    for (int k = 0; k < m; k++) {
        sub[k] = S[i + k]; // 从S[i]开始取m个字符
    }
    sub[m] = '\0'; // 字符串结束符
    return sub;
}

// 朴素模式匹配算法：基于字符串基本操作（对应视频中的index函数逻辑）
int naive_match_basic(char* S, char* T) {
    int n = strlen(S) - 1; // 主串长度（S[0] unused，实际字符从S[1]开始）
    int m = strlen(T) - 1; // 模式串长度（T[0] unused，实际字符从T[1]开始）
    
    // 若主串长度 < 模式串长度，直接匹配失败
    if (n < m) return 0;
    
    int i = 1; // 候选子串的起始位置（1-based）
    while (i <= n - m + 1) {
        char* S_sub = substring(S, i, m); // 取当前候选子串
        char* T_str = T + 1; // 模式串的实际字符起始位置（跳过T[0]）
        
        // 对比候选子串与模式串
        int is_match = 1;
        for (int k = 0; k < m; k++) {
            if (S_sub[k] != T_str[k]) {
                is_match = 0;
                break;
            }
        }
        
        free(S_sub); // 释放子串内存
        if (is_match) {
            return i; // 匹配成功，返回起始位置
        }
        i++; // 遍历下一个候选子串
    }
    return 0; // 所有子串均不匹配，返回0
}

// 测试示例（视频中隐含的测试场景）
int main() {
    // 1-based存储：S[0]、T[0] unused，实际字符从索引1开始
    char S[] = " 笑出猪叫的快乐时光"; // 主串：n=8（实际字符8个）
    char T1[] = " 笑出猪叫";         // 模式串1：m=4（匹配成功）
    char T2[] = " 笑出喵叫";         // 模式串2：m=4（匹配失败）
    
    int pos1 = naive_match_basic(S, T1);
    int pos2 = naive_match_basic(S, T2);
    
    printf("模式串1匹配结果：%d（1表示起始位置1）\n", pos1); // 输出1
    printf("模式串2匹配结果：%d（0表示失败）\n", pos2);     // 输出0
    return 0;
}
```

### 方式 2：基于数组下标（双指针遍历）

视频中强调该方式 “不依赖字符串基本操作，直接通过下标控制指针”，是考研中更常考察的实现方式，核心是通过两个指针`i`（主串指针）和`j`（模式串指针）的移动实现对比。

#### 实现逻辑

1. 初始化双指针：`i = 1`（主串从第一个字符开始），`j = 1`（模式串从第一个字符开始）。
2. 循环条件：`i <= n && j <= m`（两个指针均未超出字符串长度）。
3. 字符对比与指针移动：
	- 若`S[i] == T[j]`：说明当前字符匹配，双指针同时后移（`i++`，`j++`），继续对比下一个字符。
	- 若`S[i] != T[j]`：说明当前候选子串匹配失败，需切换到下一个候选子串：
		- 主串指针`i`回退到 “当前候选子串起始位置 + 1”（公式：`i = i - j + 2`）。
		- 模式串指针`j`重置为 1（重新从模式串第一个字符开始对比）。
4. 循环结束后判断结果：
	- 若`j > m`：说明模式串所有字符均匹配成功，返回`i - m`（当前主串指针位置减去模式串长度，即匹配子串的起始位置）。
	- 若`i > n`：说明主串已遍历完但未匹配，返回`0`。

#### 完整代码（C 语言风格，1-based 索引）

c

```c
#include <stdio.h>
#include <string.h>

// 朴素模式匹配算法：基于双指针（视频中王道书的实现逻辑）
int naive_match_double_ptr(char* S, char* T) {
    int n = strlen(S) - 1; // 主串长度（S[0] unused）
    int m = strlen(T) - 1; // 模式串长度（T[0] unused）
    
    if (n < m) return 0; // 主串比模式串短，直接失败
    
    int i = 1; // 主串指针（1-based）
    int j = 1; // 模式串指针（1-based）
    
    while (i <= n && j <= m) {
        if (S[i] == T[j]) {
            // 当前字符匹配，双指针后移
            i++;
            j++;
        } else {
            // 匹配失败，指针回退：主串到下一个候选子串起始位置，模式串重置
            i = i - j + 2;
            j = 1;
        }
    }
    
    // 判断匹配结果
    if (j > m) {
        return i - m; // 匹配成功，返回子串起始位置
    } else {
        return 0; // 匹配失败
    }
}

// 测试示例（视频中讲解的匹配场景）
int main() {
    // 1-based存储：S[0]、T[0] unused
    char S[] = " abcabcabc123"; // 主串：n=12（实际字符12个）
    char T[] = " abc123";       // 模式串：m=6（匹配子串起始位置为7）
    
    int pos = naive_match_double_ptr(S, T);
    if (pos != 0) {
        printf("匹配成功！子串起始位置：%d\n", pos); // 输出7
    } else {
        printf("匹配失败！\n");
    }
    return 0;
}
```

## 四、算法时间复杂度分析

视频中明确分析了朴素模式匹配算法的**最坏时间复杂度**，并通过具体例子说明推导过程：

### 1. 复杂度推导前提

- 主串长度为`n`，模式串长度为`m`。
- 时间复杂度的核心衡量指标：**字符对比次数**（算法中最耗时的操作）。

### 2. 最坏情况（视频重点强调）

#### 场景示例

- 主串`S = "AAAAA...AAB"`（共`n`个字符，前`n-1`个为 'A'，最后 1 个为 'B'）。
- 模式串`T = "AAAAAB"`（共`m`个字符，前`m-1`个为 'A'，最后 1 个为 'B'）。

#### 对比次数计算

- 每个候选子串（共`n - m + 1`个）都需要对比`m`次才能发现 “最后一个字符不匹配”（前`m-1`个 'A' 均匹配，第`m`个字符 'B' 不匹配）。
- 总对比次数 ≈ `(n - m + 1) * m`。
- 因实际应用中`n >> m`（如在长文档中搜短词），`m²`可忽略，最终最坏时间复杂度为 **`O(n \* m)`**。

### 3. 最好情况（视频简要提及）

- 场景：每个候选子串的第一个字符就与模式串第一个字符不匹配（如主串全为 'A'，模式串第一个字符为 'B'）。
- 总对比次数 ≈ `n`（仅需遍历主串一次），时间复杂度为 **`O(n + m)`**（`m`为模式串长度，可忽略）。

## 五、算法定位

- 朴素模式匹配算法是 “字符串模式匹配的基础算法”，考研 408 中需掌握其实现逻辑与时间复杂度。
- 该算法的局限性：最坏时间复杂度`O(n*m)`，效率较低，因此后续会学习优化算法（KMP 算法），解决朴素算法中 “指针回退” 导致的冗余操作。



# KMP 算法知识点总结

## 1. KMP 算法简介

- **名称来源**：由三位发明者名字中各取一个字母（K、M、P）命名，并非算法逻辑复杂的象征。
- **核心定位**：基于**朴素模式匹配算法**的优化算法，解决朴素算法中主串指针频繁回溯的效率问题。
- **核心优势**：模式匹配过程中，**主串指针不回溯**，仅通过调整模式串指针实现高效匹配。

## 2. 朴素模式匹配算法回顾（KMP 的优化基础）

### 2.1 算法思想

- 遍历主串中所有长度与模式串相等的子串，依次与模式串逐字符对比，直到找到第一个完全匹配的子串。
- 示例逻辑：若主串为`s`（长度`n`），模式串为`t`（长度`m`），则依次检查`s[1..m]`、`s[2..m+1]`、…、`s[n-m+1..n]`（1-based 索引）。

### 2.2 匹配失败处理

- 当某一子串在第`j`个字符（模式串第`j`位）匹配失败时：
	1. 主串指针`i`回溯到 “当前子串起始位置 + 1”（即`i = 原起始位置 + 1`）；
	2. 模式串指针`j`回溯到 1（重新从模式串第一个字符开始匹配）。

### 2.3 核心问题

- 主串指针频繁回溯，导致无效对比增多，**最坏时间复杂度为 O (n×m)**（例如主串全为`"A"`，模式串为`"AA...AB"`）。

## 3. KMP 算法核心优化思想

### 3.1 关键观察（优化依据）

- 当模式串第`j`个字符匹配失败时，**已匹配的前`j-1`个字符在主串和模式串中完全一致**（否则无法匹配到第`j`位）。
- 例：若模式串`t="ABAABC"`（长度 6），匹配到第 6 位（`C`）失败，则主串中对应前 5 位必然是`"AB AAB"`，与模式串前 5 位完全相同。

### 3.2 优化策略

- 利用模式串前`j-1`个字符的 **“前缀与后缀最长公共元素长度”**，确定模式串指针`j`的新位置（无需回溯主串指针`i`）。
- 示例（视频案例）：
	- 模式串`"ABAABC"`第 6 位匹配失败时，前 5 位`"AB AAB"`的前缀（`"A"`）与后缀（`"A"`）最长公共长度为 2，因此模式串指针`j`从 6 调整为 3（而非回溯到 1）；
	- 跳过无意义对比：无需检查主串中以 “2 号、3 号字符” 开头的子串，直接从 “4 号字符” 开头的子串开始，且无需对比前 2 个字符（已通过公共前缀后缀确认匹配）。

## 4. next 数组（KMP 的核心工具）

### 4.1 定义

`next[j]`表示：当模式串第`j`个字符（1-based 索引）与主串字符匹配失败时，模式串指针`j`应调整到的目标位置。

### 4.2 核心特性

- **仅与模式串有关**：与主串内容、主串匹配位置无关，仅由模式串自身的前缀 / 后缀结构决定。

- **手动计算逻辑**（视频以模式串`t="ABAABC"`为例，1-based）：

	| 模式串位置`j` | 模式串字符 | 已匹配前`j-1`位的 “前缀 / 后缀最长公共长度”                  | `next[j]`值 | 含义（匹配失败时`j`调整为）     |
	| ------------- | ---------- | ------------------------------------------------------------ | ----------- | ------------------------------- |
	| 1             | A          | 无（前 0 位）                                                | 0           | `j=0`后，主串`i++`、模式串`j++` |
	| 2             | B          | 前 1 位（`A`）无前后缀，长度 0                               | 1           | 1                               |
	| 3             | A          | 前 2 位（`AB`）前缀`A`与后缀`B`无公共，长度 0                | 1           | 1                               |
	| 4             | A          | 前 3 位（`ABA`）前缀`A`与后缀`A`公共长度 1                   | 2           | 2                               |
	| 5             | B          | 前 4 位（`ABAA`）前缀`AB`与后缀`AA`无公共，长度 0→修正为 1（前缀`A`与后缀`A`） | 2           | 2                               |
	| 6             | C          | 前 5 位（`AB AAB`）前缀`AB`与后缀`AB`公共长度 2              | 3           | 3                               |

## 5. KMP 算法执行流程

KMP 算法分为**预处理**和**模式匹配**两步，核心是 “先求 next 数组，再用 next 数组匹配”。

### 5.1 步骤 1：预处理（求模式串的 next 数组）

- 视频重点：考研中需掌握**手动计算 next 数组**（选择题高频考点），代码实现暂不要求，核心逻辑为：
	1. 初始化`next[1] = 0`，`i=2`（模式串第 2 位开始），`k=0`（记录当前前缀 / 后缀公共长度）；
	2. 若`t[i-1] == t[k]`（前`i-1`位的后缀与前`k`位前缀匹配），则`k++`，`next[i] = k`，`i++`；
	3. 若不匹配且`k>0`，则`k = next[k]`（回溯`k`到上一公共长度）；
	4. 若`k=0`，则`next[i] = 0`，`i++`；
	5. 重复 2-4 直到`i > m`（`m`为模式串长度）。

### 5.2 步骤 2：模式匹配（主串指针不回溯）

#### 5.2.1 匹配逻辑（1-based 索引）

1. 初始化：主串指针`i=1`（主串第 1 位），模式串指针`j=1`（模式串第 1 位）；
2. 循环条件：`i ≤ n`（`n`为主串长度）且`j ≤ m`（`m`为模式串长度）；
3. 字符匹配：
	- 若`j == 0`（模式串指针已到最前）或`s[i] == t[j]`：`i++`、`j++`（继续匹配下一位）；
	- 若不匹配：`j = next[j]`（调整模式串指针，主串指针`i`不变）；
4. 匹配结果判定：
	- 若`j > m`：匹配成功，返回主串匹配起始位置`i - m`（`i`已后移，需减去模式串长度）；
	- 若循环结束后`j ≤ m`：匹配失败，返回 - 1。

## 6. KMP 模式匹配代码实现

### 6.1 代码说明

- 采用**1-based 索引**（与视频中 “主串位置 1、模式串位置 1” 的表述一致）；
- 输入：主串`s`、模式串`t`、`next`数组、主串长度`n`、模式串长度`m`；
- 输出：匹配成功返回主串起始位置（1-based），失败返回 - 1。

### 6.2 完整代码

c

```c
// KMP模式匹配函数
// s：主串（1-based索引，s[1..n]）
// t：模式串（1-based索引，t[1..m]）
// next：模式串的next数组（1-based索引，next[1..m]）
// n：主串长度
// m：模式串长度
int KMP(char s[], char t[], int next[], int n, int m) {
    int i = 1; // 主串指针，从第1个字符开始
    int j = 1; // 模式串指针，从第1个字符开始
    
    while (i <= n && j <= m) {
        // 两种情况需同时后移：1. j到最前（j=0）；2. 当前字符匹配
        if (j == 0 || s[i] == t[j]) {
            i++;
            j++;
        } else {
            // 匹配失败，调整模式串指针（主串指针不回溯）
            j = next[j];
        }
    }
    
    // 模式串指针超过长度，说明完全匹配
    if (j > m) {
        return i - m; // 计算主串匹配起始位置
    } else {
        return -1; // 匹配失败
    }
}
```

## 7. 时间复杂度分析

| 算法             | 预处理阶段（求 next 数组） | 模式匹配阶段                       | 整体时间复杂度 |
| ---------------- | -------------------------- | ---------------------------------- | -------------- |
| 朴素模式匹配算法 | 无                         | O(n×m)                             | O(n×m)         |
| KMP 算法         | O (m)（遍历模式串 1 次）   | O (n)（主串指针不回溯，遍历 1 次） | O(n + m)       |

- 关键结论：KMP 算法通过 “主串不回溯” 和 “预处理模式串”，将时间复杂度从朴素算法的`O(n×m)`优化到`O(n+m)`，尤其适合主串极长、模式串较短的场景（如文本检索、字符串匹配）。

## 8. 考研考点提示

- 核心考察：**手动计算 next 数组**（选择题高频考点）；
- 理解要求：掌握 KMP 算法思想（主串不回溯、next 数组作用）、能手动模拟匹配过程；
- 代码要求：了解模式匹配代码逻辑即可，代码实现考察概率低。





# KMP 算法之 next 数组

## 一、KMP 算法核心前提

1. **算法原理回顾**：KMP 算法分为两大核心步骤
	- 步骤 1：根据**模式串**计算对应的`next`数组；
	- 步骤 2：基于`next`数组进行模式匹配（主串与模式串对比）。
2. **关键效率特性**：匹配过程中**主串指针不回溯**，仅通过调整模式串指针（依赖`next`数组）减少无效对比，提升效率。
3. **考研要求**：明确需掌握**手算`next`数组**的方法（视频反复强调 “考研重点”）。

## 二、next 数组基础概念

### 1. 数组定义与下标规则

- **下标对应关系**：`next`数组的下标与模式串字符下标**一一对应**（视频中模式串下标从 1 开始，例：长度为 n 的模式串，`next`数组下标范围为 1~n）。
- **`next[j]`的含义**：当模式串的第 j 个字符（下标 j 处）与主串匹配失败时，模式串指针 j 应跳转的**目标位置**（即下一次对比的模式串字符下标）。

### 2. next 数组的固定值（通用结论）

视频明确：**所有模式串的前两个`next`值均固定**，无需额外计算，直接套用：

- `next[1] = 0`：
	若模式串第 1 个字符匹配失败，需将模式串指针 j 设为 0，之后主串指针与模式串指针**同时加 1**（开始匹配主串的下一个子串）。
- `next[2] = 1`：
	若模式串第 2 个字符匹配失败，需将模式串指针 j 设为 1（尝试用模式串第 1 个字符与当前主串字符重新对比）。

## 三、手算 next 数组的核心方法（分界线法）

### 1. 方法步骤（通用流程）

1. **画分界线**：当模式串第 j 个字符匹配失败时，在第 j 个字符**左侧**画一条分界线（分界线左侧为 “已匹配成功的模式串前缀”，右侧为未知区域）。
2. **模式串右移**：将模式串逐步向右滑动，观察分界线左侧的 “已匹配前缀” 能否与模式串的 “前缀”（从第 1 个字符开始）**完全重合**。
3. **确定`next[j]`值**：
	- 若找到**最长重合前缀**，则`next[j] = 最长重合前缀的长度 + 1`（跳转至重合前缀的下一个位置）；
	- 若未找到任何重合前缀，则`next[j] = 1`（跳转至模式串第 1 个字符）。

### 2. 实例 1：模式串 “google”（字符序列：g o o g l e，下标 1~6）

逐个计算`next[1]~next[6]`，过程完全遵循视频讲解：

| 目标`next[j]` | 计算过程                                                     | 结果 |
| ------------- | ------------------------------------------------------------ | ---- |
| `next[1]`     | 通用固定值：第 1 个字符匹配失败时，j 跳转至 0                | 0    |
| `next[2]`     | 通用固定值：第 2 个字符匹配失败时，j 跳转至 1                | 1    |
| `next[3]`     | 第 3 个字符 “o” 匹配失败，分界线左侧为 “g o”：右移后无重合前缀，跳转至 1 | 1    |
| `next[4]`     | 第 4 个字符 “g” 匹配失败，分界线左侧为 “g o o”：右移后无重合前缀，跳转至 1 | 1    |
| `next[5]`     | 第 5 个字符 “l” 匹配失败，分界线左侧为 “g o o g”：最长重合前缀为 “g”（长度 1），跳转至 1+1=2 | 2    |
| `next[6]`     | 第 6 个字符 “e” 匹配失败，分界线左侧为 “g o o g l”：右移后无重合前缀，跳转至 1 | 1    |

最终 “google” 的`next`数组（下标 1~6）：`[0, 1, 1, 1, 2, 1]`

### 3. 实例 2：模式串 “ababcx”（假设，，长度 6，下标 1~6）

视频中未明说模式串字符，但根据`next[4]=2`、`next[5]=3`、`next[6]=4`的计算步骤，反推模式串为 “ababcx”，计算过程如下：

| 目标`next[j]` | 计算过程                                                     | 结果 |
| ------------- | ------------------------------------------------------------ | ---- |
| `next[1]`     | 通用固定值                                                   | 0    |
| `next[2]`     | 通用固定值                                                   | 1    |
| `next[3]`     | 第 3 个字符 “a” 匹配失败，分界线左侧为 “a b”：无重合前缀，跳转至 1 | 1    |
| `next[4]`     | 第 4 个字符 “b” 匹配失败，分界线左侧为 “a b a”：最长重合前缀 “a”（长度 1），跳转至 2 | 2    |
| `next[5]`     | 第 5 个字符 “c” 匹配失败，分界线左侧为 “a b a b”：最长重合前缀 “a b”（长度 2），跳转至 3 | 3    |
| `next[6]`     | 第 6 个字符 “x” 匹配失败，分界线左侧为 “a b a b c”：最长重合前缀 “a b c”（长度 3），跳转至 4 | 4    |

最终该模式串的`next`数组（下标 1~6）：`[0, 1, 1, 2, 3, 4]`

## 四、next 数组的应用：模式匹配实例

视频中以 “主串 = googoogle”、“模式串 = google”（`next`数组`[0,1,1,1,2,1]`）为例，演示匹配过程：

### 匹配步骤

1. **第一次匹配**：从主串第 1 个字符开始，对比模式串 1~6 个字符：
	- 第 1~5 个字符（g o o g l）匹配成功，第 6 个字符（主串 “o” vs 模式串 “e”）匹配失败；
	- 此时 j=6，根据`next[6]=1`，将模式串指针 j 调整为 1。
2. **第二次匹配**：主串指针不回溯，用当前主串字符（原第 6 个字符 “o”）与模式串第 1 个字符 “g” 对比：
	- 匹配失败，此时 j=1，根据`next[1]=0`，将 j 设为 0；
	- 按规则，主串指针与模式串指针**同时加 1**（主串指针到 7，模式串指针到 1）。
3. **第三次匹配**：从主串第 7 个字符开始，对比模式串 1~6 个字符：
	- 所有字符（g o o g l e）均匹配成功，匹配结束。



# KMP 算法进一步优化

## 一、优化背景与核心问题

### 1. KMP 算法基础回顾

视频中明确 KMP 算法的核心逻辑：

1. 先根据**模式串**计算`next`数组（记录每个位置匹配失败时，模式串指针`j`应回溯的位置）；
2. 利用`next`数组进行主串与模式串的匹配，主串指针`i`不回溯，仅调整模式串指针`j`。

### 2. 现有`next`数组的缺陷（优化必要性）

当模式串某位置`j`匹配失败时，若`next[j]`指向的位置`k`（即`k = next[j]`）的字符与`j`位置的字符**相同**，则跳转到`k`后仍会匹配失败（因为主串`i`位置字符已确定与`j`位置字符不相等，自然也与`k`位置字符不相等），导致不必要的比较步骤。

**视频实例 1**：模式串`abaa bc`（索引 1-6：`S[1]='a', S[2]='b', S[3]='a', S[4]='a', S[5]='b', S[6]='c'`）

- 当`j=3`（`S[3]='a'`）匹配失败时，`next[3]=1`（指向`S[1]='a'`）；
- 因`S[3] == S[1]`，主串`i`位置字符≠`S[3]`，故也≠`S[1]`，跳转到`j=1`的比较必然失败，需进一步跳转到`next[1]=0`，中间多一次无效比较。

**视频实例 2**：模式串`aaaa b`（索引 1-5：`S[1]='a', S[2]='a', S[3]='a', S[4]='a', S[5]='b'`）

- 当`j=4`（`S[4]='a'`）匹配失败时，`next[4]=3`（指向`S[3]='a'`）；
- 因`S[4] == S[3]`，跳转到`j=3`的比较必然失败，需继续跳转`next[3]=2`、`next[2]=1`，多三次无效比较。

## 二、优化方案：`nextval`数组

### 1. `nextval`数组定义

`nextval`数组是对`next`数组的优化：当模式串`j`位置与`next[j]`位置字符相同时，直接将`nextval[j]`设为`nextval[next[j]]`（跳过所有必然失败的中间步骤）；若不同，则`nextval[j] = next[j]`。

核心逻辑：**消除 “字符相同的回溯”，直接跳转到最终有效位置**。

### 2. 手算`nextval`数组的步骤

#### 步骤总览

1. **第一步**：先通过 KMP 基础方法计算模式串的`next`数组（视频默认已掌握`next`数组手算）；
2. **第二步**：初始化`nextval[1] = 0`（约定：模式串第一个字符的`nextval`固定为 0）；
3. **第三步**：对`j ≥ 2`，依次判断：
	- 若`S[j] != S[next[j]]`：则`nextval[j] = next[j]`；
	- 若`S[j] == S[next[j]]`：则`nextval[j] = nextval[next[j]]`（递归追溯到字符不同的位置）。

#### 实例 1：模式串`abaa bc`（`S = "ab a a b c"`，索引 1-6）

##### 第一步：计算`next`数组

| 模式串索引`j`    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---------------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串字符`S[j]` | `a`  | `b`  | `a`  | `a`  | `b`  | `c`  |
| `next[j]`        | 0    | 1    | 1    | 2    | 2    | 3    |

##### 第二步：计算`nextval`数组

- `j=1`：`nextval[1] = 0`（固定）；
- `j=2`：`S[2]='b'`，`next[2]=1`，`S[1]='a'`，`'b'≠'a'` → `nextval[2] = next[2] = 1`；
- `j=3`：`S[3]='a'`，`next[3]=1`，`S[1]='a'`，`'a'=='a'` → `nextval[3] = nextval[1] = 0`；
- `j=4`：`S[4]='a'`，`next[4]=2`，`S[2]='b'`，`'a'≠'b'` → `nextval[4] = next[4] = 2`；
- `j=5`：`S[5]='b'`，`next[5]=2`，`S[2]='b'`，`'b'=='b'` → `nextval[5] = nextval[2] = 1`；
- `j=6`：`S[6]='c'`，`next[6]=3`，`S[3]='a'`，`'c'≠'a'` → `nextval[6] = next[6] = 3`。

最终`nextval`数组结果：

| `j`          | 1    | 2    | 3    | 4    | 5    | 6    |
| ------------ | ---- | ---- | ---- | ---- | ---- | ---- |
| `nextval[j]` | 0    | 1    | 0    | 2    | 1    | 3    |

#### 实例 2：模式串`aaaa b`（`S = "a a a a b"`，索引 1-5）

##### 第一步：计算`next`数组

| 模式串索引`j`    | 1    | 2    | 3    | 4    | 5    |
| ---------------- | ---- | ---- | ---- | ---- | ---- |
| 模式串字符`S[j]` | `a`  | `a`  | `a`  | `a`  | `b`  |
| `next[j]`        | 0    | 1    | 2    | 3    | 4    |

##### 第二步：计算`nextval`数组

- `j=1`：`nextval[1] = 0`（固定）；
- `j=2`：`S[2]='a'`，`next[2]=1`，`S[1]='a'`，`'a'=='a'` → `nextval[2] = nextval[1] = 0`；
- `j=3`：`S[3]='a'`，`next[3]=2`，`S[2]='a'`，`'a'=='a'` → `nextval[3] = nextval[2] = 0`；
- `j=4`：`S[4]='a'`，`next[4]=3`，`S[3]='a'`，`'a'=='a'` → `nextval[4] = nextval[3] = 0`；
- `j=5`：`S[5]='b'`，`next[5]=4`，`S[4]='a'`，`'b'≠'a'` → `nextval[5] = next[5] = 4`。

最终`nextval`数组结果：

| `j`          | 1    | 2    | 3    | 4    | 5    |
| ------------ | ---- | ---- | ---- | ---- | ---- |
| `nextval[j]` | 0    | 0    | 0    | 0    | 4    |

## 三、优化前后 KMP 匹配性能对比

以**模式串`aaaa b`（`next`数组`[0,1,2,3,4]`，`nextval`数组`[0,0,0,0,4]`）** 为例，主串假设为`"aaaa c..."`（匹配到`j=4`时失败）。

### 1. 优化前（使用`next`数组）

1. `j=4`（`S[4]='a'`）与主串`i`位置字符（`'c'`）不匹配；
2. `j = next[4] = 3`，比较`S[3]='a'`与`'c'`，失败；
3. `j = next[3] = 2`，比较`S[2]='a'`与`'c'`，失败；
4. `j = next[2] = 1`，比较`S[1]='a'`与`'c'`，失败；
5. `j = next[1] = 0`，`i`和`j`同时加 1（进入下一轮匹配）。
	**总无效比较次数**：3 次。

### 2. 优化后（使用`nextval`数组）

1. `j=4`（`S[4]='a'`）与主串`i`位置字符（`'c'`）不匹配；
2. `j = nextval[4] = 0`，`i`和`j`同时加 1（直接进入下一轮匹配）。
	**总无效比较次数**：0 次。

结论：`nextval`数组通过跳过无效比较，显著提升 KMP 算法效率。

## 四、完整代码实现（1-based 索引）

视频中未直接给出代码，但根据 KMP 核心逻辑及`nextval`优化规则，补充完整代码（符合视频 1-based 索引习惯）。

### 1. 计算`next`数组

c

```c
#include <stdio.h>
#include <string.h>

// 计算模式串的next数组（1-based索引）
// 参数：pattern-模式串（首字符从index=1开始，index=0闲置），len-模式串长度，next-输出next数组
void getNext(char pattern[], int len, int next[]) {
    int j = 0; // j表示前缀指针（初始指向next[1]=0）
    next[1] = 0; // 约定第一个字符的next值为0
    
    // i表示后缀指针（从第二个字符开始，i=2到len）
    for (int i = 2; i <= len; i++) {
        // 若当前后缀与前缀不匹配，回溯j到next[j]
        while (j > 0 && pattern[i] != pattern[j+1]) {
            j = next[j];
        }
        // 若匹配，j向前移动
        if (pattern[i] == pattern[j+1]) {
            j++;
        }
        // 记录当前i的next值
        next[i] = j;
    }
}
```

### 2. 计算`nextval`数组

c

```c
// 基于next数组计算nextval数组（1-based索引）
// 参数：pattern-模式串（1-based），len-模式串长度，next-已计算的next数组，nextval-输出nextval数组
void getNextVal(char pattern[], int len, int next[], int nextval[]) {
    nextval[1] = 0; // 第一个字符的nextval固定为0
    
    // 从第二个字符开始计算（i=2到len）
    for (int i = 2; i <= len; i++) {
        // 若当前字符与next[i]指向的字符不同，nextval[i] = next[i]
        if (pattern[i] != pattern[next[i]]) {
            nextval[i] = next[i];
        } else {
            // 若相同，nextval[i] = nextval[next[i]]（递归追溯）
            nextval[i] = nextval[next[i]];
        }
    }
}
```

### 3. KMP 匹配（支持`next`或`nextval`数组）

c

```c
// KMP匹配函数（1-based索引）
// 参数：text-主串（1-based），textLen-主串长度，pattern-模式串（1-based），patLen-模式串长度，guide-导航数组（next或nextval）
// 返回值：模式串在主串中首次匹配的起始索引（1-based），未匹配返回-1
int kmpMatch(char text[], int textLen, char pattern[], int patLen, int guide[]) {
    int i = 1; // 主串指针（不回溯）
    int j = 0; // 模式串指针（根据guide调整）
    
    while (i <= textLen && j <= patLen) {
        // 情况1：j=0（初始/回溯到起点），或当前字符匹配，双指针同时后移
        if (j == 0 || text[i] == pattern[j+1]) {
            i++;
            j++;
        } else {
            // 情况2：字符不匹配，模式串指针根据guide回溯
            j = guide[j];
        }
    }
    
    // 若j超过模式串长度，说明匹配成功，返回起始索引（i - patLen）
    if (j > patLen) {
        return i - patLen;
    } else {
        return -1; // 未匹配
    }
}
```

### 4. 测试代码

c

```c
int main() {
    // 测试实例：模式串"aaaa b"（1-based，index0闲置），主串"xx aaaa c xx"（1-based）
    char text[] = "  xxa aaacxx"; // 简化表示，实际使用时需确保1-based（index0闲置，如text[0]=' '，text[3]='a'）
    char pattern[] = " aaaab"; // pattern[0]=' '，pattern[1]='a'~pattern[5]='b'
    int textLen = strlen(text) - 1; // 主串实际长度（排除index0的闲置字符）
    int patLen = strlen(pattern) - 1; // 模式串实际长度（5）
    
    // 1. 计算next数组
    int next[patLen + 1]; // next[1]~next[5]
    getNext(pattern, patLen, next);
    printf("next数组（1-based）：");
    for (int i = 1; i <= patLen; i++) {
        printf("%d ", next[i]); // 输出：0 1 2 3 4
    }
    printf("\n");
    
    // 2. 计算nextval数组
    int nextval[patLen + 1]; // nextval[1]~nextval[5]
    getNextVal(pattern, patLen, next, nextval);
    printf("nextval数组（1-based）：");
    for (int i = 1; i <= patLen; i++) {
        printf("%d ", nextval[i]); // 输出：0 0 0 0 4
    }
    printf("\n");
    
    // 3. KMP匹配（使用nextval数组）
    int result = kmpMatch(text, textLen, pattern, patLen, nextval);
    if (result != -1) {
        printf("模式串首次匹配起始索引（主串1-based）：%d\n", result);
    } else {
        printf("未匹配到模式串\n");
    }
    
    return 0;
}
```

## 五、核心结论

1. KMP 算法的优化本质是**优化导航数组**：将`next`数组升级为`nextval`数组，消除无效比较；
2. 优化后 KMP 的匹配逻辑不变，仅将`next`数组替换为`nextval`数组；
3. 考试重点：掌握`nextval`数组的手算方法（先求`next`，再按字符比较规则推导`nextval`）。



# KMP 算法之 PM 数组与 next 数组

## 1. 核心概念定义

### 1.1 PM 数组（部分匹配表）

- **定义**：PM 数组全称 “部分匹配表”，针对字符串`S`的每个位置`i`（索引从 0 开始），`PM[i]`表示**以`S[i]`为结尾的子串`S[0..i]`的最长相等前后缀的长度**。
- **关键规则（视频强调）**：
	- 前后缀定义：前缀是 “从字符串开头开始、不包含最后一个字符的子串”；后缀是 “从字符串中间开始、包含最后一个字符的子串”，且前后缀**不能是子串本身**（如子串 “a” 无前后缀，子串 “ab” 的前缀是 “a”、后缀是 “b”）。
	- 第一个位置（`i=0`）：子串仅含 1 个字符，无符合定义的前后缀，故`PM[0] = 0`。
	- 后续位置（`i≥1`）：需逐个判断子串`S[0..i]`的所有可能前后缀，找到 “最长的相等前后缀”，其长度即为`PM[i]`；若不存在相等前后缀，则`PM[i] = 0`。

## 2. PM 数组的计算方法

### 2.1 视频隐含的示例字符串

结合视频描述（“第一个位置无前后缀”“第二个位置 A 跟 B 无前后缀”“出现长度 1/2/3 的前后缀”“C 位置无前后缀”“A 位置有长度 1 的前后缀”），推导视频中使用的示例字符串为 `S = "ababaca"`（小写字母不影响逻辑，仅为统一格式）。

### 2.2 逐位置计算 PM 数组（i 从 0 到 6）

通过表格拆解每个位置的计算逻辑，明确前后缀对比过程：

| 子串`S[0..i]` | 位置`i` | 前缀集合（不含最后 1 个字符）                 | 后缀集合（不含第 1 个字符）                   | 最长相等前后缀  | `PM[i]` |
| ------------- | ------- | --------------------------------------------- | --------------------------------------------- | --------------- | ------- |
| "a"           | 0       | 无（子串长度 1，无前缀）                      | 无（子串长度 1，无后缀）                      | 无              | 0       |
| "ab"          | 1       | {"a"}                                         | {"b"}                                         | 无              | 0       |
| "aba"         | 2       | {"a", "ab"}                                   | {"a", "ba"}                                   | "a"（长度 1）   | 1       |
| "abab"        | 3       | {"a", "ab", "aba"}                            | {"b", "ab", "bab"}                            | "ab"（长度 2）  | 2       |
| "ababa"       | 4       | {"a", "ab", "aba", "abab"}                    | {"a", "ba", "aba", "baba"}                    | "aba"（长度 3） | 3       |
| "ababac"      | 5       | {"a", "ab", "aba", "abab", "ababa"}           | {"c", "ac", "bac", "abac", "babac"}           | 无              | 0       |
| "ababaca"     | 6       | {"a", "ab", "aba", "abab", "ababa", "ababac"} | {"a", "ca", "aca", "baca", "abaca", "babaca"} | "a"（长度 1）   | 1       |

### 2.3 最终 PM 数组结果

对字符串 `S = "ababaca"`，计算得到 PM 数组为：
`PM = [0, 0, 1, 2, 3, 0, 1]`

## 3. next 数组的计算方法

视频中明确 next 数组由 PM 数组推导而来，共 3 个核心步骤，无额外逻辑：

1. **步骤 1：PM 数组右移一位**：将 PM 数组的每个元素从原索引`i`移至新索引`i+1`，原索引 0 的位置空出（右移后数组长度比原 PM 数组多 1，对应字符串每个位置的匹配跳转值）。
2. **步骤 2：最左侧补 - 1**：在右移后空出的索引 0 位置填充`-1`（视频字幕中 “添一个一” 应为口误，结合 KMP 算法逻辑及后续 “全部加一” 步骤修正，否则结果不符合 next 数组定位功能）。
3. **步骤 3：所有元素加 1**：将步骤 2 得到的数组中每个元素加 1，最终结果即为 next 数组。

### 3.1 基于 PM 数组推导 next 数组（示例）

已知 `PM = [0, 0, 1, 2, 3, 0, 1]`，按视频步骤推导：

1. 步骤 1：PM 数组右移一位 → `[空, 0, 0, 1, 2, 3, 0, 1]`（长度从 7 变为 8）。
2. 步骤 2：最左侧补 - 1 → `[-1, 0, 0, 1, 2, 3, 0, 1]`。
3. 步骤 3：所有元素加 1 → `[0, 1, 1, 2, 3, 4, 1, 2]`。

### 3.2 最终 next 数组结果

对字符串 `S = "ababaca"`，推导得到 next 数组为：
`next = [0, 1, 1, 2, 3, 4, 1, 2]`

## 4. 完整代码实现

### 4.1 代码功能说明

严格遵循视频中 “逐位置算 PM 数组”“PM 转 next 数组” 的逻辑，无优化（符合视频 “简单粗暴版” 定位），实现两个核心功能：

1. 计算字符串的 PM 数组；
2. 由 PM 数组推导 next 数组。

### 4.2 Python 完整代码

python

```python
def compute_pm_array(s):
    """
    计算字符串s的PM数组（部分匹配表）
    逻辑：按视频描述，逐位置判断以当前字符结尾的子串的最长相等前后缀长度
    :param s: 输入字符串（如视频中的"ababaca"）
    :return: list，PM数组
    """
    n = len(s)
    pm = [0] * n  # PM数组长度与字符串长度一致，i=0初始化为0
    
    # 从i=1开始遍历（i=0已确定为0）
    for i in range(1, n):
        max_matching_len = 0  # 初始化最长相等前后缀长度为0
        # 前缀长度范围：1 ~ i（前后缀不能是子串本身，故最大前缀长度为i）
        for prefix_len in range(1, i + 1):
            # 截取前缀（s[0..prefix_len-1]）和后缀（s[i-prefix_len+1..i]）
            prefix = s[0:prefix_len]
            suffix = s[(i - prefix_len + 1):(i + 1)]
            # 若前后缀相等，更新最长长度
            if prefix == suffix:
                max_matching_len = prefix_len
        # 记录当前位置的PM值
        pm[i] = max_matching_len
    return pm


def compute_next_array(pm):
    """
    由PM数组推导next数组（严格遵循视频步骤：右移→补-1→加1）
    :param pm: 输入的PM数组（如[0,0,1,2,3,0,1]）
    :return: list，next数组
    """
    # 步骤1：PM数组右移一位，空出索引0（右移后长度=原PM长度+1）
    shifted_pm = [None] * (len(pm) + 1)
    for i in range(len(pm)):
        shifted_pm[i + 1] = pm[i]
    
    # 步骤2：在最左侧（索引0）填充-1
    shifted_pm[0] = -1
    
    # 步骤3：所有元素加1，得到next数组
    next_array = [x + 1 for x in shifted_pm]
    return next_array


# 示例：使用视频隐含的字符串"ababaca"测试代码
if __name__ == "__main__":
    # 输入视频中的示例字符串
    s = "ababaca"
    # 1. 计算PM数组
    pm_result = compute_pm_array(s)
    print(f"字符串 '{s}' 的PM数组：{pm_result}")
    # 输出：字符串 'ababaca' 的PM数组：[0, 0, 1, 2, 3, 0, 1]
    
    # 2. 由PM数组计算next数组
    next_result = compute_next_array(pm_result)
    print(f"字符串 '{s}' 的next数组：{next_result}")
    # 输出：字符串 'ababaca' 的next数组：[0, 1, 1, 2, 3, 4, 1, 2]
```

### 4.3 代码逻辑验证

- `compute_pm_array`函数：遍历每个位置的子串，逐个对比前后缀，与视频中 “看前后缀” 的核心逻辑完全一致；
- `compute_next_array`函数：严格执行 “右移→补 - 1→加 1” 三步，与视频描述的 next 数组构造方法完全匹配；
- 示例测试：输入字符串 “ababaca”，输出结果与前文手动计算的 PM、next 数组完全一致，验证代码正确性。



# KMP 算法知识点总结 PM数组

## 1. 暴力字符串匹配算法

视频中首先对比了暴力匹配与 KMP 算法，明确暴力匹配的缺陷是 KMP 算法的设计背景。

### 1.1 算法原理

- 核心逻辑：在主串（文本串）中逐个字符与子串（模式串）比对。
- 匹配失败处理：一旦某位置字符不匹配，**主串指针回退到 “上一次匹配起始位置的下一个字符”**，子串指针回退到起始位置，重新开始比对。

### 1.2 关键缺陷（视频案例）

- 极端场景：若主串和子串均为 “若干个 A + 结尾 B”（如主串`"AAAAAAB"`、子串`"AAAB"`），每次匹配都会比对到子串最后一个字符（B）才失败，主串指针需反复回退，做大量无用功。
- 时间复杂度：*O*(*N*×*M*)（*N*为主串长度，*M*为子串长度），效率极低。

## 2. KMP 算法核心思想

KMP 算法由 Knuth、Morris、Pratt 三位学者提出，核心是**避免主串指针回退**，仅通过子串指针的调整实现线性时间匹配。

### 2.1 核心突破

- 利用 “已匹配部分的信息”：匹配失败时，已知道主串中 “最后一次匹配成功的字符序列”，可通过该序列的 “相同前后缀” 跳过重复比对。
- 关键特性：**主串指针（记为`i`）永远只向前移动，不回退**，仅调整子串指针（记为`j`）。

### 2.2 时间复杂度

- 线性时间复杂度：*O*(*N*+*M*)（*N*为主串遍历时间，*M*为子串预处理（构建 next 数组）时间），仅需遍历一次主串即可完成匹配。

## 3. next 数组（KMP 算法核心）

视频强调：`next数组是KMP算法的关键`，其本质是 “子串中每个位置的最长相同前后缀长度”，作用是 “指导匹配失败时子串指针的跳转位置”。

### 3.1 next 数组的本质与作用

#### 3.1.1 本质定义

- 对於子串`pattern`的第`j`个位置（字符`pattern[j]`），`next[j]`表示 “`pattern[0..j]`（子串前`j+1`个字符）中**最长的、非空且长度小于当前子串长度**的相同前后缀的长度”。
	- 前缀：从子串起始位置开始的子序列（如`"AABA"`的前缀为`"A"`、`"AA"`、`"AAB"`）。
	- 后缀：从子串末尾位置结束的子序列（如`"AABA"`的后缀为`"A"`、`"BA"`、`"ABA"`）。
	- 约束：前后缀不能是子串本身（否则跳转无意义）。

#### 3.1.2 核心作用

- 匹配失败时的指针调整规则：当主串`text[i]`与子串`pattern[j]`不匹配时，无需回退`i`，仅需将`j`调整为`next[j-1]`（即 “最后一次匹配成功的字符（`j-1`位置）对应的 next 值”），直接从`j = next[j-1]`位置继续与`text[i]`比对。
- 原理：`next[j-1]`的值等于 “已匹配部分（`pattern[0..j-1]`）的最长相同前后缀长度”，跳转后可跳过 “已确认匹配的前缀部分”，避免重复比对。

### 3.2 next 数组的手动计算（视频示例）

视频以子串`pattern = "AABAABC"`（长度 7）为例，逐步计算每个位置的`next`值：

| 子串位置（j） | 子串字符 | 对应子串片段（pattern [0..j]） | 最长相同前后缀                                               | next [j] 值 |
| ------------- | -------- | ------------------------------ | ------------------------------------------------------------ | ----------- |
| 0             | A        | "A"（仅 1 个字符）             | 无（无前后缀）                                               | 0           |
| 1             | A        | "AA"（前 2 个字符）            | 无（前缀 "A" 与后缀 "A"？视频明确说 “无相同前后缀”，此处按视频结论） | 0           |
| 2             | B        | "AAB"（前 3 个字符）           | 前缀 "A"、后缀 "B" → 仅 "A" 相同                             | 1           |
| 3             | A        | "AABA"（前 4 个字符）          | 前缀 "AA"？视频说 “AB 是共同前后缀” → 长度 2                 | 2           |
| 4             | A        | "AABAA"（前 5 个字符）         | 无相同前后缀（视频说 “找不到”）                              | 0           |
| 5             | B        | "AABAAB"（前 6 个字符）        | （视频未提及，按逻辑推导：前缀 "AAB" 与后缀 "AAB" 相同，长度 3） | 3           |
| 6             | C        | "AABAABC"（前 7 个字符）       | （视频未提及，按逻辑推导：无相同前后缀）                     | 0           |

视频中明确的`next`数组核心值：`[0, 0, 1, 2, 0, ...]`（后续值可按规则推导，核心以视频提及部分为准）。

### 3.3 next 数组的递推计算方法

视频指出：暴力计算`next`数组效率低（*O*(*M*2)），需用**递推法**（利用已计算的`next`值规避重复运算，类似动态规划思想），时间复杂度*O*(*M*)。

#### 3.3.1 递推核心逻辑

假设已计算出`next[k] = j`（即子串`pattern[0..k]`的最长相同前后缀长度为`j`），需计算`next[k+1]`：

1. **情况 1：pattern [k+1] == pattern [j]**
	- 若子串第`k+1`个字符与第`j`个字符相同，则`pattern[0..k+1]`的最长相同前后缀长度为`j+1`，即`next[k+1] = j + 1`。
	- 原理：`pattern[0..j]`与`pattern[k-j+1..k]`已相同（因`next[k] = j`），若`pattern[j] == pattern[k+1]`，则前后缀可延长 1 位。
2. **情况 2：pattern [k+1] != pattern [j]**
	- 若不相同，则需寻找 “更短的相同前后缀”：将`j`更新为`next[j-1]`（即利用`pattern[0..j-1]`的最长相同前后缀长度，缩小比对范围）。
	- 重复此过程，直到`j == 0`（无更短前后缀）：若此时`pattern[k+1] != pattern[0]`，则`next[k+1] = 0`；若相同，则`next[k+1] = 1`。

#### 3.3.2 初始条件

- 子串第 1 个字符（`k=0`）：`next[0] = 0`（无前后缀）。
- 子串第 2 个字符（`k=1`）：`next[1] = 0`（视频明确 “无相同前后缀”）。

## 4. KMP 算法匹配步骤

假设已提前构建好子串的`next`数组，匹配过程如下：

### 4.1 初始化

- 主串指针：`i = 0`（从主串第 1 个字符开始）。
- 子串指针：`j = 0`（从子串第 1 个字符开始）。
- 主串长度：`n = strlen(text)`，子串长度：`m = strlen(pattern)`。

### 4.2 核心循环（`i < n && j < m`）

1. **匹配成功**：若`text[i] == pattern[j]`，则`i++`（主串指针前移）、`j++`（子串指针前移），继续比对下一个字符。
2. **匹配失败**：
	- 若`j != 0`（存在已匹配部分）：`j = next[j-1]`（按`next`数组跳转子串指针，主串指针`i`不回退）。
	- 若`j == 0`（无已匹配部分）：`i++`（主串指针前移，子串指针仍在起始位置）。

### 4.3 匹配结果判断

- 成功：当`j == m`（子串指针遍历完子串），返回主串中匹配的起始位置：`i - j`。
- 失败：当`i == n`（主串遍历完）且`j < m`，返回`-1`（无匹配子串）。

## 5. C 语言完整实现

### 5.1 头文件依赖

c

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h> // 用于动态内存分配（若需）
```

### 5.2 构建 next 数组函数

c

```c
/**
 * @brief 构建子串的next数组（按视频递推逻辑）
 * @param pattern 子串（模式串）
 * @param next 输出参数，存储构建后的next数组
 * @param m 子串长度
 */
void buildNext(char* pattern, int* next, int m) {
    // 初始条件：第1个字符的next值为0
    next[0] = 0;
    // j：已确定的最长相同前后缀长度（对应next[k] = j）
    int j = 0;
    // k：当前计算next值的子串位置（从第2个字符开始，k=1）
    int k = 1;

    while (k < m) {
        if (pattern[k] == pattern[j]) {
            // 情况1：当前字符与j位置字符相同，延长前后缀
            j++;
            next[k] = j;
            k++;
        } else {
            // 情况2：当前字符与j位置字符不同，跳转j
            if (j != 0) {
                j = next[j - 1]; // 按next数组找更短前后缀
            } else {
                // j=0仍不匹配，next[k] = 0
                next[k] = 0;
                k++;
            }
        }
    }
}
```

### 5.3 KMP 匹配函数

c

```c
/**
 * @brief KMP算法匹配主串与子串
 * @param text 主串（文本串）
 * @param pattern 子串（模式串）
 * @return 匹配成功：返回主串中匹配的起始索引；失败：返回-1
 */
int kmpSearch(char* text, char* pattern) {
    int n = strlen(text);    // 主串长度
    int m = strlen(pattern); // 子串长度

    // 边界判断：子串为空或子串长于主串，直接返回失败
    if (m == 0 || m > n) {
        return -1;
    }

    // 动态分配next数组（长度=子串长度）
    int* next = (int*)malloc(sizeof(int) * m);
    if (next == NULL) {
        printf("内存分配失败！\n");
        return -1;
    }

    // 1. 构建next数组
    buildNext(pattern, next, m);

    // 2. 开始KMP匹配
    int i = 0; // 主串指针
    int j = 0; // 子串指针
    while (i < n && j < m) {
        if (text[i] == pattern[j]) {
            // 匹配成功，双指针前移
            i++;
            j++;
        } else {
            // 匹配失败，调整子串指针
            if (j != 0) {
                j = next[j - 1];
            } else {
                // j=0，主串指针前移
                i++;
            }
        }
    }

    // 3. 释放next数组内存
    free(next);

    // 4. 判断匹配结果
    if (j == m) {
        // 子串遍历完，匹配成功，返回起始位置
        return i - j;
    } else {
        // 主串遍历完仍未匹配，返回失败
        return -1;
    }
}
```

### 5.4 测试代码

视频中主串示例为`"AABAABC"`，此处扩展主串为`"AABAABCA"`（便于验证匹配），子串为`"AABAABC"`（视频中计算 next 数组的子串）：

c

```c
int main() {
    // 测试案例（符合视频中主串、子串示例）
    char text[] = "AABAABCA";   // 主串
    char pattern[] = "AABAABC"; // 子串（视频中计算next数组的示例）

    // 调用KMP匹配
    int result = kmpSearch(text, pattern);

    // 输出结果
    if (result != -1) {
        printf("匹配成功！子串在主串中的起始索引为：%d\n", result);
        printf("匹配的子串：%.*s\n", strlen(pattern), text + result);
    } else {
        printf("匹配失败！主串中未找到子串。\n");
    }

    return 0;
}
```

### 5.5 测试结果

运行代码后，输出如下（匹配成功，符合预期）：

plaintext

```plaintext
匹配成功！子串在主串中的起始索引为：0
匹配的子串：AABAABC
```

## 6. 关键总结

1. KMP 算法的核心是**主串指针不回退**，通过`next数组`利用已匹配信息优化子串指针跳转。
2. `next数组的本质`是子串每个位置的 “最长相同前后缀长度”，而非单纯的 “跳转步数”。
3. 递推计算`next数组`是 KMP 算法的难点，核心是 “利用已有的 next 值规避重复比对”，体现动态规划思想。
4. KMP 算法时间复杂度为*O*(*N*+*M*)，远优于暴力匹配的*O*(*N*×*M*)，适用于大规模字符串匹配场景。









