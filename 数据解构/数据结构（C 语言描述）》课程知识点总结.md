# 《数据结构（C 语言描述）》课程知识点总结

## 一、课程基本信息

### 1.1 课程定位

- 核心目标：打造**大部分同学能听懂、学得会**的数据结构课程，聚焦核心知识点，去除冗余内容。
- 教材使用原则：以教材为框架参考，但针对教材 “重结果、轻过程”“逻辑顺序不友好” 的问题，调整细节实现与教学逻辑，适配非顶尖高校学生的学习需求。

### 1.2 适用人群

1. 在校学生：学校课程听不懂，需通过课程提升数据结构成绩（应对必修考试）。
2. 考研考生：针对计算机 408 考研，攻克数据结构核心考点。
3. 零基础 / 基础薄弱者：希望系统入门数据结构，建立清晰知识框架。

### 1.3 课程目标

1. 理解并掌握课程中的**数据结构与算法**核心原理。
2. 实现 “学以致用”：将知识应用于日常学习与未来工作，解决实际问题，而非仅为应付考试。

## 二、数据结构核心概念

### 2.1 数据与结构的定义

#### （1）数据

- 来源：生活中的方方面面（短视频、聊天记录、游戏数据等），即 “数据不是一切，但一切都正在成为数据”。
- 产业界价值：基于数据驱动业务（如短视频推荐、游戏消费行为分析等），通过数据挖掘有价值信息（参考 DIKWD 模型，课程暂不展开）。
- 编程语言中的数据：基础数据类型（int、char、double、float、string、布尔类型等），但仅靠基础类型无法满足复杂场景需求。

#### （2）结构（数据的组织形式）

- 定义：为满足**特定需求 / 场景**，对数据进行的组织方式（如表格、名片形式等，同一批数据可因需求不同采用不同组织形式）。
- 核心逻辑：当基础数据类型无法合理组织数据时，需设计新的组织形式 —— 这是数据结构的核心起源。
- 注意：课程学习的是 “计算机界前辈已设计好的成熟数据结构”，而非从零设计，重点是掌握其原理、操作（插入 / 删除 / 查询）及适用场景。

### 2.2 数据结构的官方定义与核心特性

- 官方定义：数据结构是**存储和组织数据的方式**，旨在便于数据的访问和修改。
- 核心特性：无 “万能数据结构”，每种数据结构均有其**优势与局限**，需根据场景选择适配的结构（如数组适合随机访问，链表适合插入 / 删除频繁的场景）。

### 2.3 数据结构与算法的关系

- 核心结论：**算法 + 数据结构 = 程序**（出自 1984 年图灵奖获得者、瑞典计算机科学家尼古拉斯・埃米尔・沃思）。
- 算法定义：
	- 学术定义：解决某一特定类型问题的 “有穷规则集合”，规定运算序列或求解步骤。
	- 通俗理解：解决问题的 “高效方法 / 步骤”（如游戏中英雄自动寻路的最短路径、地图导航、吃豆游戏路径规划等）。
- 课程中算法的范围：以 “基于特定数据结构的查找、排序算法” 为主，是蓝桥杯等编程竞赛的核心考点。

## 三、课程涵盖的核心内容

### 3.1 数据结构部分

- 线性结构：线性表、栈、队列、数组。
- 非线性结构：树（含二叉树）、图。

### 3.2 算法部分

- 查找算法：基于不同数据结构的查询方法（如数组的顺序查找、二叉树的二分查找等）。
- 排序算法：基于不同数据结构的排序方法（如冒泡排序、快速排序、归并排序等）。

## 四、C 语言前置知识（数据结构学习必备）

### 4.1 函数（基础支撑）

#### （1）函数的核心意义

1. 代码复用：将重复使用的功能封装为代码块，避免重复编写（如 “计算 1~100 的和” 需多次使用时，封装为函数可直接调用）。
2. 降低难度：简化代码逻辑，便于维护与调试。
3. 封装思想：**对内隐藏实现细节，对外暴露接口**（如调用`printf`无需知道其内部代码，仅需知道 “传入字符串即可输出”；类似电视 “按红色按钮开机”，无需知道成像原理）。

#### （2）函数的执行特性

- 函数不被调用则不执行（类似电视不按开机键则不工作）。

#### （3）函数的基本结构

- 结构组成：`返回值类型 函数名(参数列表) { 函数体; [return 返回值;] }`。
	- 返回值类型：可指定具体类型（如 int、double），无返回值则为`void`。
	- 参数列表：可无参数（空括号或`void`），也可含多个同 / 不同类型参数。
	- 返回值：若指定返回值类型，函数体中需用`return`返回对应类型的值，返回值最终传递到 “调用函数的位置”。

#### （4）参数与返回值的判断原则

- 核心依据：**根据需求编写**，无固定规则：
	- 需外部传入数据时加参数（如 “计算 1~N 的和”，N 需调用时传入，故加参数）。
	- 需向外部输出结果时加返回值（如 “计算 1~100 的和并返回结果”，需加返回值；若仅需输出结果无需返回，则不加）。
- 四种组合场景：
	1. 无参数 + 无返回值（如 “计算 1~100 的和并直接输出”）。
	2. 无参数 + 有返回值（如 “计算 1~100 的和并返回结果”）。
	3. 有参数 + 无返回值（如 “计算 1~N 的和并直接输出，N 由调用传入”）。
	4. 有参数 + 有返回值（如 “计算 1~N 的和并返回结果，N 由调用传入”）。

### 4.2 字符串（C 语言特殊处理）

#### （1）C 语言中字符串的本质

- 无 “字符串数据类型”：仅存在字符串常量（用双引号包裹，如`"Hello World"`），需通过**字符数组（char []）** 存储。
- 结束标志：字符串在内存中存储时，末尾会自动添加 **'\0'**（空字符），用于标识字符串结束（如`"Hello"`实际存储为`'H','e','l','l','o','\0'`）。

#### （2）字符串的赋值规则

- 不可直接赋值：声明字符数组后，无法用`str = "Hello"`直接赋值（语法错误）。
- 正确方式：需引入头文件`<string.h>`，使用`strcpy`函数（字符串复制函数），格式为`strcpy(目标字符数组, 源字符串)`（如`strcpy(str, "Hello")`）。

### 4.3 内存（指针学习的基础）

#### （1）冯诺依曼体系下的存储器分类

- 存储器是数据流转的核心桥梁，分为两类：
	1. 主存储器（内存 / 内存条）：用于运行当前程序（如打开的文档、视频、游戏），断电数据丢失；内存越大，可同时运行的程序越多，运行速度越快。
	2. 辅助存储器（硬盘）：用于长期存储数据（如文档、视频、软件安装包），断电数据不丢失；硬盘越大，可存储的文件越多。
- 手机 “128G 内存” 的误区：实际对应计算机的 “硬盘”（存储容量），而非 “内存”（运行内存）。

#### （2）内存地址空间

1. 地址抽象：操作系统将内存、显卡、BIOS 等设备的存储地址，抽象为**巨大的一维数组空间**，每个存储单元（字节）分配唯一编号 —— 即 “内存地址”。
2. 地址编码：

- 32 位操作系统：用 32 位二进制数（或 8 位十六进制数）表示地址，可标识`2^32`个字节（约 4GB），但因显卡、BIOS 等预留高位地址，实际识别内存小于 4GB。
- 64 位操作系统：用 64 位二进制数（或 16 位十六进制数）表示地址，可标识`2^64`个字节，支持更大内存。

1. 数据类型与内存占用：不同数据类型占用字节数不同（如 int 占 4 字节、char 占 1 字节），存储时需占用对应数量的连续内存地址（如 int 变量占用 4 个连续字节地址）。

### 4.4 数组（基础数据组织形式）

#### （1）数组的核心特性

1. 数据类型一致性：仅能存储**相同类型**的数据（如 int 数组仅存 int，char 数组仅存 char）。
2. 长度固定性：数组长度声明后不可修改（如`int a[5]`，长度固定为 5，无法动态扩容 / 缩容）。
3. 下标规则：若数组有 N 个元素，下标范围为**0~N-1**（如`int a[5]`的下标为 0、1、2、3、4），下标越界会导致内存访问错误。

#### （2）数组的内存存储

- 连续存储：数组元素在内存中占用**连续的地址空间**，每个元素占用的字节数由数据类型决定（如 int 数组的每个元素占 4 字节，`int a[5]`共占用 20 字节，地址连续）。

#### （3）数组的遍历

- 定义：通过循环（如 for 循环）依次访问数组的每个元素（“挨个取出元素”）。
- 示例：`int a[5] = {1,2,3,4,5}; for(int i=0; i<5; i++) { printf("%d", a[i]); }`（通过下标`i`遍历所有元素）。

### 4.5 指针与结构体（数据结构核心依赖，课程重点）

#### （1）指针的前置要求

- 必须理解 “内存地址空间”：指针的本质是 “存储内存地址的变量”，需先掌握内存地址的概念（如 int 指针存储 int 变量的内存地址，char 指针存储 char 变量的内存地址）。

#### （2）结构体的核心作用

- 解决 “基础类型无法组合复杂数据” 的问题：将不同类型的数据（如 int、char、string）组合为一个整体（如 “学生” 结构体可包含 “学号（int）、姓名（char []）、成绩（double）”）。
- 数据结构的基础：链表、树等复杂数据结构，均需通过 “结构体 + 指针” 实现（如链表节点用结构体存储数据，用指针指向后续节点）。

#### （3）关键语法

- `typedef`：用于重定义数据类型，简化复杂类型的声明（如`typedef struct Student { int id; char name[20]; } Stu;`，后续可直接用`Stu`声明学生类型变量，无需重复写`struct Student`）。
- 指针与结构体结合：访问结构体指针指向的成员时，需用`->`运算符（如`Stu *p; p->id = 1001;`）；直接访问结构体变量成员用`.`运算符（如`Stu s; s.id = 1001;`）。

## 四、C 语言前置知识（数据结构学习必备）

### 4.5 指针与结构体（数据结构核心依赖，课程重点）

#### （3）指针的核心知识点（数据结构必掌握）

##### ① 指针的本质与定义

- 本质：**存储内存地址的变量**，其值是另一个变量 / 数据的内存地址（如 int 指针存储 int 类型变量的地址，char 指针存储 char 类型变量的地址）。
- 定义格式：`数据类型 *指针变量名`，其中 “*” 表示 “该变量是指针类型”。
	示例：
	- `int *p;`：定义一个指向 int 类型数据的指针 p（p 存储 int 变量的地址）。
	- `char *q;`：定义一个指向 char 类型数据的指针 q（q 存储 char 变量的地址）。
- 注意：指针本身也占用内存（如 32 位系统中指针占 4 字节，64 位系统中占 8 字节），存储的是 “地址值”，而非目标数据的值。

##### ② 指针的两大核心操作

1. **取地址操作（&）**：获取变量的内存地址，赋值给指针变量（让指针 “指向” 该变量）。
	示例：

	c

	```c
	int a = 10;  // 定义int变量a，内存地址假设为0x1234
	int *p = &a; // 用&a获取a的地址，赋值给指针p，此时p的值=0x1234（p指向a）
	```
	
2. **解引用操作（\*）**：通过指针存储的地址，访问 / 修改目标变量的值（“通过指针操作目标数据”）。
	示例：

	c

	```c
	*p = 20;  // 解引用p，修改其指向的变量a的值为20（等价于a=20）
	printf("%d", *p); // 输出20（等价于printf("%d", a);）
	```

##### ③ 指针与数组的关系（数据结构高频场景）

- 数组名的本质：**数组首元素的地址**（即`数组名 == &数组[0]`），是一个 “常量指针”（地址不可修改，不能给数组名赋值）。
	示例：

	c

	```c
	int a[5] = {1,2,3,4,5}; 
	printf("%p", a);    // 输出a[0]的地址（如0x1234）
	printf("%p", &a[0]);// 输出与上面相同，验证数组名是首元素地址
	```

- 指针遍历数组：通过指针的 “自增” 操作（移动地址），可遍历数组元素（比下标遍历更灵活，是数据结构中数组操作的常用方式）。
	示例：

	c

	```c
	int a[5] = {1,2,3,4,5};
	int *p = a; // p指向a[0]
	for(int i=0; i<5; i++){
	    printf("%d ", *p); // 输出当前指向的元素（1,2,3,4,5）
	    p++; // 指针自增，地址移动“一个int的字节数”（4字节），指向 next元素
	}
	```
	
- 关键结论：`a[i]` 等价于 `*(a+i)`（通过数组名 + 偏移量访问元素，本质是指针运算）。

##### ④ 指针的关键注意事项（避坑点）

1. 野指针：未初始化的指针（值为随机地址），解引用会导致内存访问错误（如`int *p; *p=10;`，p 未指向有效地址，操作非法）。
	避免方式：指针定义时初始化（如`int *p=NULL;`，NULL 表示空指针，指向无效地址）。
2. 指针类型匹配：指针类型必须与指向的数据类型一致（如 int 指针不能指向 char 变量，否则解引用时会导致 “数据截断” 或 “访问越界”）。
	例外：`void *`（万能指针）可指向任意类型数据，但使用前需强制转换为对应类型（如`void *p=&a; int *q=(int*)p;`）。

#### （4）结构体的核心知识点（数据结构必掌握）

##### ① 结构体的定义与初始化

- 定义格式：用`struct`关键字包裹不同类型的成员，形成 “自定义复合类型”。
	基础格式：

	c

	```c
	struct 结构体名 {
	    成员类型1 成员名1;
	    成员类型2 成员名2;
	    // ... 更多成员
	};
	```
	
	示例（学生结构体）：
	
	c
	
	```c
	struct Student {
	    int id;         // 学号（int类型）
	    char name[20];  // 姓名（字符数组，存储字符串）
	    double score;   // 成绩（double类型）
	};
	```

- 结构体变量的初始化：两种方式，需注意 “字符数组不能直接用字符串赋值，需用`strcpy`”。
	示例：

	c

	```c
	// 1. 定义时初始化
	struct Student s1 = {1001, "Zhang San", 95.5}; 
	// 2. 定义后初始化（需用strcpy给字符数组成员赋值）
	struct Student s2;
	s2.id = 1002;
	strcpy(s2.name, "Li Si"); // 不可直接写s2.name="Li Si"
	s2.score = 88.0;
	```

##### ② 结构体与 typedef 的结合（简化代码）

- 问题：每次声明结构体变量需写`struct 结构体名`（如`struct Student s;`），较繁琐。

- 解决：用`typedef`重定义结构体类型，后续可直接用 “新类型名” 声明变量。
	示例：

	c

	```c
	// 定义结构体时同时用typedef重命名
	typedef struct Student {
	    int id;
	    char name[20];
	    double score;
	} Stu; // 新类型名：Stu（等价于struct Student）
	
	// 后续声明变量，直接用Stu
	Stu s3 = {1003, "Wang Wu", 92.0}; 
	```

##### ③ 结构体指针的应用（数据结构核心）

- 定义：指向结构体变量的指针，存储结构体变量的内存地址（重点用于链表、树等数据结构的节点操作）。
	示例：

	c

	```c
	Stu s = {1001, "Zhang San", 95.5};
	Stu *p = &s; // 结构体指针p指向s的地址
	```
	
- 结构体指针访问成员的两种方式：

	1. `(*指针变量).成员名`：先解引用指针得到结构体变量，再用`.`访问成员（注意括号不可少，`.`优先级高于`*`）。
	2. `指针变量->成员名`：结构体指针专用语法，简化写法（数据结构中高频使用）。
		示例：

	c

	```c
	printf("ID: %d\n", (*p).id);   // 输出1001
	printf("Name: %s\n", p->name); // 输出Zhang San（简化写法，推荐）
	printf("Score: %.1f\n", p->score); // 输出95.5
	```

##### ④ 结构体嵌套（复杂数据结构基础）

- 场景：结构体成员可以是另一个结构体类型（或结构体指针），用于表示 “包含关系”（如 “班级” 结构体包含 “学生” 结构体）。
	示例（结构体嵌套结构体）：

	c

	```c
	// 先定义学生结构体
	typedef struct Student {
	    int id;
	    char name[20];
	} Stu;
	
	// 定义班级结构体（成员包含Stu类型的数组）
	typedef struct Class {
	    int classId;    // 班级编号
	    Stu students[50]; // 班级中的学生（数组存储）
	} Class;
	
	// 使用嵌套结构体
	Class c;
	c.classId = 1;
	c.students[0].id = 1001;
	strcpy(c.students[0].name, "Zhang San");
	```
	
- 关键延伸：结构体成员若为 “结构体指针”（如`typedef struct Node { int data; struct Node *next; } Node;`），则构成链表的节点结构 —— 这是链表的核心定义，后续数据结构学习的基础。

### 4.6 函数与指针 / 结构体的结合（数据结构操作基础）

#### （1）指针作为函数参数（传递地址）

- 核心作用：通过指针将变量的地址传递到函数内部，实现 “函数修改外部变量的值”（值传递无法修改外部变量，地址传递可以）。
	示例（用函数修改外部 int 变量的值）：

	c

	```c
	void changeValue(int *p) { // 形参为int指针
	    *p = 20; // 解引用指针，修改外部变量的值
	}
	
	int main() {
	    int a = 10;
	    changeValue(&a); // 实参传递a的地址
	    printf("%d", a); // 输出20（外部变量被修改）
	    return 0;
	}
	```
	
- 数据结构中的应用：修改链表节点的值、修改数组元素等操作，均需通过 “指针作为函数参数” 实现。

#### （2）结构体 / 结构体指针作为函数参数

- 两种传递方式对比：

	| 传递方式       | 实现方式            | 优缺点                                     | 数据结构中的选择             |
	| -------------- | ------------------- | ------------------------------------------ | ---------------------------- |
	| 结构体值传递   | `void func(Stu s)`  | 优点：简单；缺点：拷贝整个结构体，效率低   | 不推荐（尤其是结构体大时）   |
	| 结构体指针传递 | `void func(Stu *p)` | 优点：仅传递地址，效率高；可修改外部结构体 | 推荐（链表、树节点操作均用） |

	示例（用函数修改结构体成员的值）：

	c

	```c
	// 结构体指针作为函数参数
	void updateScore(Stu *p, double newScore) {
	    p->score = newScore; // 用->修改结构体成员
	}
	
	int main() {
	    Stu s = {1001, "Zhang San", 95.5};
	    updateScore(&s, 98.0); // 传递s的地址
	    printf("New Score: %.1f", s.score); // 输出98.0
	    return 0;
	}
	```

