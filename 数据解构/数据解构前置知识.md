

# 指针、结构体、typedef 核心知识点总结

## 一、数据结构与算法基础回顾

### 1.1 数据结构的本质

- 定义：数据的**新组织形式**，由计算机领域研究者为解决复杂问题设计，用于更高效地管理和操作数据。
- 与算法的关系：数据结构是 “容器”，算法是 “操作容器的方法”（如排序、查找、添加 / 删除数据），二者结合构成程序（即 “数据结构 + 算法 = 程序”）。

## 二、指针核心知识点

### 2.1 指针的基本定义与本质

- 本质：**存储内存地址的变量**，与普通变量的唯一区别是 “普通变量存值，指针变量存地址”。
- 关键概念：
	- 声明场景：`int *p;` 中 `*` 表示 “声明一个指针变量”，`p` 是指针变量名，指向 `int` 类型数据的地址。
	- 非声明场景（间接引用）：`*p` 表示 “通过 `p` 存储的地址，访问该地址对应的内存空间中的值”（又称 “解引用操作符”）。
	- 取地址符：`&a` 表示 “获取变量 `a` 在内存中的地址”，常用于给指针赋值（如 `p = &a;`）。

### 2.2 指针与函数：解决 “值传递无法修改外部变量” 问题

#### 2.2.1 值传递的局限性（反例：无指针的 swap 函数）

- 问题：函数参数传递的是 “变量的值副本”，函数内部修改副本不会影响外部原变量。

- 代码示例：

	c

	```c
	void swap(int a, int b) { // a、b 是外部变量的副本
	    int temp = a;
	    a = b;
	    b = temp;
	}
	int main() {
	    int m = 5, n = 10;
	    swap(m, n); // 传递的是 5 和 10 的副本，m、n 原值不变
	    printf("m=%d, n=%d", m, n); // 输出：m=5, n=10
	    return 0;
	}
	```

#### 2.2.2 地址传递（指针传参）的解决方案

- 原理：传递 “外部变量的地址”，函数内部通过指针访问原变量地址，直接修改原变量的值。

- 代码示例：

	c

	```c
	void swap(int *a, int *b) { // a、b 是存储外部变量地址的指针
	    int temp = *a; // 通过指针访问原变量的值
	    *a = *b;       // 修改原变量的值
	    *b = temp;
	}
	int main() {
	    int m = 5, n = 10;
	    swap(&m, &n); // 传递 m、n 的地址
	    printf("m=%d, n=%d", m, n); // 输出：m=10, n=5
	    return 0;
	}
	```

### 2.3 指针与数组：密切关联的操作

#### 2.3.1 数组与指针的核心关联

- 数组名的本质：数组名默认表示**数组首元素的地址**（即 `a == &a[0]`），无需加取地址符即可赋值给指针。
	- 示例：`int a[5] = {15,22,67,43,8}; int *p = a;`（等价于 `p = &a[0]`）。
- 核心结论：通过数组下标能完成的操作（如访问元素、遍历数组），均可用指针实现，且指针操作通常执行速度更快。

#### 2.3.2 指针的算术运算（关键特性）

- 定义：指针加 / 减整数时，实际偏移量 = 整数 × 指针指向数据类型的字节数（而非单纯加 / 减整数）。
	- 示例：`int *p`（`int` 占 4 字节），`p+1` 表示 “指向当前地址后 4 字节的内存空间”（即下一个 `int` 元素的地址）。
	- 原因：数组在内存中是**连续存储**的，指针算术运算可直接定位到数组的下一个元素。

#### 2.3.3 指针遍历数组示例

c

```c
int a[5] = {15,22,67,43,8};
int *p = a;
int len = sizeof(a) / sizeof(a[0]); // 计算数组长度（5）
for (int i=0; i<len; i++) {
    printf("%d ", *(p+i)); // 通过指针访问第 i 个元素，等价于 a[i]
}
// 输出：15 22 67 43 8
```

### 2.4 内存字节数的注意事项

- 数据类型字节数差异：32 位与 64 位操作系统中，部分数据类型（如指针）的字节数不同（32 位系统指针占 4 字节，64 位占 8 字节）。
- 考研考点关联：题目常结合 “32/64 位系统” 考查指针偏移、内存占用计算，需牢记常见类型字节数（如 `int` 占 4 字节、`char` 占 1 字节、`double` 占 8 字节）。

## 三、结构体核心知识点

### 3.1 结构体的本质与定义

- 本质：**自定义复合数据类型**，用于将多个不同类型的变量（成员）组织成一个整体，解决 “单一基本类型无法表示复杂数据” 的问题（如表示坐标点、学生信息等）。

- 定义语法（“数据类型图纸”）：

	c

	```c
	struct 结构体名 { // 结构体名（如 Point）是自定义类型的标识
	    数据类型1 成员名1; // 成员可不同类型
	    数据类型2 成员名2;
	    // ...
	};
	// 示例：定义表示坐标点的结构体
	struct Point {
	    int x; // x 坐标
	    int y; // y 坐标
	};
	```

### 3.2 结构体变量的声明与初始化

#### 3.2.1 声明方式

- 方式 1：先定义结构体，再声明变量（常用）：

	c

	```c
	struct Point p1; // 声明 struct Point 类型的变量 p1
	```

- 方式 2：定义结构体时直接声明变量：

	c

	```c
	struct Point {
	    int x;
	    int y;
	} p1, p2; // 同时声明 p1、p2 两个变量
	```

#### 3.2.2 初始化与赋值

- 初始化：声明时直接赋值（按成员顺序）：

	c

	```c
	struct Point p1 = {5, 10}; // p1.x=5，p1.y=10
	```

- 赋值：通过 “变量名。成员名”（点操作符）修改成员值：

	c

	```c
	p1.x = 15; // 修改 p1 的 x 坐标为 15
	p1.y = 20; // 修改 p1 的 y 坐标为 20
	```

### 3.3 结构体作为函数返回值

- 场景：封装 “创建并初始化结构体变量” 的逻辑，体现代码复用（如批量创建坐标点）。

- 示例：

	c

	```c
	// 函数：传入 x、y，返回初始化后的 struct Point 变量
	struct Point createPoint(int x, int y) {
	    struct Point temp;
	    temp.x = x;
	    temp.y = y;
	    return temp; // 返回结构体变量
	}
	int main() {
	    struct Point p = createPoint(5, 10); // 调用函数获取结构体
	    printf("x=%d, y=%d", p.x, p.y); // 输出：x=5, y=10
	    return 0;
	}
	```

### 3.4 结构体与指针（高频应用）

#### 3.4.1 结构体指针的定义

- 语法：`struct 结构体名 *指针变量名;`，用于存储结构体变量的地址。

- 示例：

	c

	```c
	struct Point p = {5, 10};
	struct Point *p_ptr = &p; // p_ptr 指向 p 的地址
	```

#### 3.4.2 结构体指针访问成员的两种方式

1. 方式 1：通过解引用 + 点操作符（`(*指针).成员`）：
	- 示例：`(*p_ptr).x = 15;`（修改 p 的 x 坐标为 15）。
	- 注意：`(*p_ptr)` 必须加括号，否则点操作符优先级高于 `*`，会报错。
2. 方式 2：通过箭头操作符（`指针->成员`）（推荐，更简洁）：
	- 示例：`p_ptr->y = 20;`（修改 p 的 y 坐标为 20）。
	- 等价性：`(*p_ptr).成员` 与 `指针->成员` 完全等价，后者是前者的语法糖。

#### 3.4.3 结构体指针的优势

- 避免结构体拷贝：传递结构体指针（地址）时，无需拷贝整个结构体（尤其结构体成员较多时），节省内存和效率。
- 直接修改原结构体：通过指针可直接修改外部结构体变量的成员值（类似指针与函数的地址传递）。

## 四、typedef 关键字（类型别名）

### 4.1 本质与作用

- 本质：给**已有的数据类型**起别名，不创建新类型，仅简化代码书写、提高可维护性。

### 4.2 基本用法（给基本类型起别名）

- 语法：`typedef 原数据类型 别名;`

- 示例：

	c

	```c
	typedef int ZX; // 给 int 起别名 ZX
	ZX a = 5; // 等价于 int a = 5
	typedef char MY_CHAR;
	MY_CHAR c = 'A'; // 等价于 char c = 'A'
	```

### 4.3 关键应用：简化结构体声明

- 问题：默认声明结构体变量时，必须加 `struct` 关键字（如 `struct Point p`），繁琐。
- 解决方案：用 `typedef` 给结构体类型起别名，后续可直接用别名声明变量。

#### 4.3.1 两种实现方式

1. 方式 1：先定义结构体，再用 `typedef` 起别名：

	c

	```c
	struct Point {
	    int x;
	    int y;
	};
	typedef struct Point P; // 给 struct Point 起别名 P
	P p = {5, 10}; // 直接用别名 P 声明变量，无需加 struct
	```

2. 方式 2：定义结构体时直接用 `typedef` 起别名（更简洁）：

	c

	```c
	typedef struct Point { // 直接给结构体类型起别名 P
	    int x;
	    int y;
	} P;
	P p = {5, 10}; // 直接用别名声明变量
	```

3. 方式 3：省略结构体名（仅用别名）：

	c

	```c
	typedef struct { // 省略结构体名，仅通过别名 P 使用
	    int x;
	    int y;
	} P;
	P p = {5, 10};
	```

### 4.4 核心应用场景：批量修改数据类型

- 场景：若程序中大量使用某一数据类型（如 `int`），后续需统一改为 `double`，直接修改 `typedef` 即可，无需逐个修改代码。

- 示例：

	c

	```c
	// 初始：用别名 DATA_TYPE 表示 int
	typedef int DATA_TYPE;
	DATA_TYPE a, b, c; // 均为 int 类型
	
	// 后续需改为 double：仅修改 typedef 一行
	typedef double DATA_TYPE;
	DATA_TYPE a, b, c; // 自动变为 double 类型
	```

## 五、动态内存分配（C 语言核心）

### 5.1 动态内存分配的本质与必要性

- **本质**：在程序运行期间，根据需求**手动向操作系统申请或释放内存**的机制（区别于 “静态内存”—— 编译时确定大小，如数组、局部变量存于栈区）。
- **必要性**：解决静态内存的局限性：
	1. 数组大小编译时固定，无法根据运行时数据动态调整（如用户输入的数组长度）；
	2. 局部变量在函数执行结束后会被自动释放（栈区回收），若需函数外使用数据，需手动管理内存；
	3. 动态内存存于**堆区**，生命周期由程序员控制，灵活度更高。

### 5.2 动态内存分配的核心函数（需包含 `<stdlib.h>` 头文件）

#### 5.2.1 `malloc` 函数：申请指定字节数的内存

- **语法**：`void* malloc(size_t size);`

	- 参数 `size`：需申请的内存字节数（`size_t` 本质是 `unsigned int`）；
	- 返回值：成功时返回**指向申请内存的指针**（`void*` 类型，需强制转换为目标数据类型）；失败时返回 `NULL`（需判断返回值，避免空指针错误）。

- **使用步骤**：

	1. 计算需申请的字节数（如 `n` 个 `int` 需 `n * sizeof(int)` 字节）；
	2. 调用 `malloc` 并强制转换指针类型；
	3. 判断是否申请成功（避免 `NULL` 指针）；
	4. 使用内存；
	5. 释放内存（`free` 函数）。

- **示例：动态申请 5 个 `int` 类型的内存（模拟动态数组）**：

	c

	```c
	#include <stdlib.h>
	#include <stdio.h>
	
	int main() {
	    int n = 5;
	    // 1. 申请 5*4=20 字节内存（int 占 4 字节），强制转为 int*
	    int* arr = (int*)malloc(n * sizeof(int));
	    
	    // 2. 判断申请是否成功（关键！）
	    if (arr == NULL) {
	        printf("内存申请失败！\n");
	        return 1; // 退出程序，避免后续错误
	    }
	    
	    // 3. 使用内存：给动态数组赋值
	    for (int i=0; i<n; i++) {
	        arr[i] = i + 1; // arr[0]=1, arr[1]=2, ..., arr[4]=5
	    }
	    
	    // 4. 打印数组
	    for (int i=0; i<n; i++) {
	        printf("%d ", arr[i]); // 输出：1 2 3 4 5
	    }
	    
	    // 5. 释放内存（堆区内存需手动释放，避免内存泄漏）
	    free(arr);
	    arr = NULL; // 释放后将指针置空，避免野指针
	    
	    return 0;
	}
	```

#### 5.2.2 `calloc` 函数：申请内存并初始化（全 0）

- **语法**：`void* calloc(size_t num, size_t size);`

	- 参数 `num`：需申请的 “元素个数”；`size`：单个元素的字节数；
	- 功能：比 `malloc` 多一步 —— 将申请的内存**全部初始化为 0**；
	- 返回值：同 `malloc`（成功返回指针，失败返回 `NULL`）。

- **对比 `malloc`**：

	- `malloc(n * sizeof(int))`：仅申请内存，内存中是随机垃圾值；
	- `calloc(n, sizeof(int))`：申请内存 + 初始化为 0，适合需 “清空初始值” 的场景（如统计数组、计数器）。

- **示例**：

	c

	```c
	int* arr = (int*)calloc(5, sizeof(int)); // 5 个 int，初始全为 0
	if (arr == NULL) { /* 错误处理 */ }
	for (int i=0; i<5; i++) {
	    printf("%d ", arr[i]); // 输出：0 0 0 0 0
	}
	free(arr);
	arr = NULL;
	```

#### 5.2.3 `realloc` 函数：调整已申请内存的大小（扩容 / 缩容）

- **语法**：`void* realloc(void* ptr, size_t new_size);`

	- 参数 `ptr`：已通过 `malloc/calloc` 申请的内存指针（若为 `NULL`，则等价于 `malloc(new_size)`）；
	- 参数 `new_size`：调整后的内存总字节数（需注意：若 `new_size < 原大小`，可能丢失部分数据）；
	- 返回值：成功返回**指向新内存的指针**（原内存可能被释放，需用新指针接收）；失败返回 `NULL`（原内存不变，避免数据丢失）。

- **核心注意事项**：

	1. 扩容时，若原内存后有足够空间，直接在原地址后追加内存；若空间不足，操作系统会分配新地址，将原数据拷贝到新地址，**原地址会被释放**（因此必须用新指针接收返回值）；
	2. 缩容时，直接截断内存，超出 `new_size` 的数据会丢失。

- **示例：动态扩容数组（从 5 个 int 扩到 8 个）**：

	c

	```c
	int n = 5;
	int* arr = (int*)malloc(n * sizeof(int));
	if (arr == NULL) { /* 错误处理 */ }
	
	// 给初始数组赋值
	for (int i=0; i<n; i++) {
	    arr[i] = i + 1;
	}
	
	// 扩容：从 5*4=20 字节扩到 8*4=32 字节
	int new_n = 8;
	int* new_arr = (int*)realloc(arr, new_n * sizeof(int));
	if (new_arr == NULL) {
	    printf("扩容失败！\n");
	    free(arr); // 原内存未释放，需手动释放
	    return 1;
	}
	arr = new_n; // 更新数组长度
	new_arr = NULL; // 释放临时指针（可选，避免误操作）
	
	// 给新增的 3 个元素赋值
	for (int i=5; i<arr; i++) {
	    new_arr[i] = i + 1; // new_arr[5]=6, new_arr[6]=7, new_arr[7]=8
	}
	
	// 打印扩容后的数组
	for (int i=0; i<arr; i++) {
	    printf("%d ", new_arr[i]); // 输出：1 2 3 4 5 6 7 8
	}
	
	free(new_arr);
	new_arr = NULL;
	```

#### 5.2.4 `free` 函数：释放动态内存

- **语法**：`void free(void* ptr);`
	- 参数 `ptr`：需释放的动态内存指针（必须是 `malloc/calloc/realloc` 返回的指针，不可释放栈区内存如局部变量、数组）；
	- 功能：将内存归还给操作系统，**仅释放内存，不改变指针的值**（指针仍指向原地址，成为 “野指针”）。
- **必须遵守的规则**：
	1. 动态内存必须释放（否则会导致 “内存泄漏”—— 程序运行期间内存被占用，无法回收，长期运行可能耗尽内存）；
	2. 不可重复释放（同一指针调用 `free` 多次，会导致程序崩溃）；
	3. 释放后必须将指针置空（`ptr = NULL`），避免 “野指针”（野指针指向无效内存，操作时可能导致程序崩溃或数据错误）。

### 5.3 动态内存分配的常见问题与解决方案

| 问题类型   | 产生原因                                           | 解决方案                                                     |
| ---------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 内存泄漏   | 动态内存未用 `free` 释放，程序结束前内存一直被占用 | 1. 申请内存后，确保所有分支（如 `if/else`、`return`）都有 `free`； 2. 释放后将指针置空。 |
| 野指针     | 1. 指针未初始化； 2. 内存释放后指针未置空          | 1. 指针声明时初始化为 `NULL`； 2. `free` 后立即 `ptr = NULL`； 3. 使用前判断指针是否为 `NULL`。 |
| 重复释放   | 同一动态内存指针调用 `free` 多次                   | 1. 释放后将指针置空，再次 `free(NULL)` 不会报错； 2. 用标志位记录是否已释放。 |
| 越界访问   | 访问动态内存时超出申请的字节范围                   | 1. 严格控制数组下标 / 访问范围； 2. 记录动态内存的大小，访问前检查。 |
| 空指针访问 | 用 `NULL` 指针访问内存（如 `*NULL`）               | 调用 `malloc/calloc/realloc` 后，必须判断返回值是否为 `NULL`。 |

### 5.4 动态内存与结构体、指针的结合（高频应用）

- **场景**：动态创建结构体变量（如链表节点、动态对象），解决 “结构体变量生命周期固定” 的问题。

- **示例：动态创建结构体变量（坐标点）**：

	c

	```c
	#include <stdlib.h>
	#include <stdio.h>
	
	// 定义结构体
	typedef struct Point {
	    int x;
	    int y;
	} Point;
	
	int main() {
	    // 动态申请 1 个 Point 类型的内存（Point 占 8 字节：2 个 int）
	    Point* p = (Point*)malloc(sizeof(Point));
	    if (p == NULL) {
	        printf("内存申请失败！\n");
	        return 1;
	    }
	    
	    // 给结构体成员赋值（用 -> 操作符，因 p 是指针）
	    p->x = 10;
	    p->y = 20;
	    
	    // 打印结构体成员
	    printf("Point: x=%d, y=%d\n", p->x, p->y); // 输出：Point: x=10, y=20
	    
	    // 释放内存
	    free(p);
	    p = NULL;
	    
	    return 0;
	}
	```

## 六、算法时间复杂度（数据结构核心分析指标）

### 6.1 时间复杂度的定义与意义

- **定义**：衡量算法执行效率的指标，描述 “算法执行时间随输入数据规模（`n`）增长的变化趋势”（而非具体执行时间，因具体时间受硬件、编译器影响）。
- **核心意义**：
	1. 比较不同算法的效率（如排序算法中，`O(nlogn)` 优于 `O(n²)`）；
	2. 预测算法在大规模数据下的性能（如 `n=10⁶` 时，`O(n)` 可执行，`O(n²)` 会超时）。

### 6.2 时间复杂度的表示方法：大 O 表示法（O-notation）

- **定义**：用 `O(f(n))` 表示，其中 `f(n)` 是输入规模 `n` 的函数，代表算法执行次数的 “主导项”（忽略常数、低次项、系数）。
- **大 O 表示法的推导规则**：
	1. **忽略常数项**：如 `O(2n + 3)` → `O(n)`（常数 2 和 3 不影响增长趋势）；
	2. **忽略低次项**：如 `O(n² + 5n + 10)` → `O(n²)`（`n²` 是主导项，`5n` 和 10 随 `n` 增大可忽略）；
	3. **忽略系数**：如 `O(3nlogn)` → `O(nlogn)`（系数 3 不改变增长趋势）；
	4. **常数时间**：若算法执行次数与 `n` 无关（如直接访问数组元素），则时间复杂度为 `O(1)`（而非 `O(常数)`）。

### 6.3 常见的时间复杂度类型（按效率从高到低排序）

| 时间复杂度 | 名称         | 增长趋势                    | 典型算法 / 操作示例                                          |
| ---------- | ------------ | --------------------------- | ------------------------------------------------------------ |
| `O(1)`     | 常数时间     | 不随 `n` 变化               | 1. 访问数组指定下标（如 `arr[5]`）； 2. 基本运算（加减乘除、赋值）； 3. 栈 / 队列的 push/pop（头部操作）。 |
| `O(logn)`  | 对数时间     | 随 `n` 缓慢增长             | 1. 二分查找（有序数组中找元素）； 2. 平衡二叉树的查找 / 插入 / 删除。 |
| `O(n)`     | 线性时间     | 随 `n` 线性增长             | 1. 遍历数组 / 链表（如 for 循环遍历）； 2. 线性查找（无序数组中找元素）； 3. 计算数组总和。 |
| `O(nlogn)` | 线性对数时间 | 介于 `O(n)` 和 `O(n²)` 之间 | 1. 快速排序、归并排序、堆排序（高效排序算法）； 2. 基于排序的查找（如排序后二分）。 |
| `O(n²)`    | 平方时间     | 随 `n` 平方增长             | 1. 嵌套循环（如冒泡排序、插入排序、选择排序）； 2. 遍历二维数组（`for(i=0;i<n;i++) for(j=0;j<n;j++)`）。 |
| `O(2ⁿ)`    | 指数时间     | 随 `n` 指数增长             | 1. 递归实现的斐波那契数列（未优化）； 2. 子集问题（枚举所有子集）。 |
| `O(n!)`    | 阶乘时间     | 随 `n` 阶乘增长             | 1. 全排列问题（枚举所有排列）； 2. 旅行商问题（暴力枚举所有路径）。 |

### 6.4 时间复杂度的分析方法（核心步骤）

#### 步骤 1：确定输入规模 `n`

- `n` 是算法处理的数据量（如数组长度、链表节点数、字符串长度），需先明确 `n` 代表的含义（如排序算法中 `n` 是数组元素个数）。

#### 步骤 2：统计 “基本操作” 的执行次数

- “基本操作”：执行时间固定的操作（如赋值、加减、比较、函数调用），通常以 “最内层循环的执行次数” 为核心统计对象。

#### 步骤 3：根据规则推导大 O 表示法

- 忽略常数、低次项、系数，保留主导项。

### 6.5 实例分析：常见算法的时间复杂度

#### 实例 1：常数时间 `O(1)`—— 访问数组元素

c

```c
int getElement(int arr[], int index) {
    return arr[index]; // 仅 1 次基本操作，与数组长度 n 无关
}
// 时间复杂度：O(1)
```

#### 实例 2：线性时间 `O(n)`—— 遍历数组

c

```c
int sumArray(int arr[], int n) {
    int sum = 0; // 1 次
    for (int i=0; i<n; i++) { // 循环 n 次
        sum += arr[i]; // 每次循环 1 次基本操作
    }
    return sum; // 1 次
}
// 总执行次数：1 + n*1 + 1 = n + 2 → 忽略常数，推导为 O(n)
```

#### 实例 3：平方时间 `O(n²)`—— 嵌套循环（冒泡排序核心逻辑）

c

```c
void bubbleSort(int arr[], int n) {
    for (int i=0; i<n-1; i++) { // 外层循环 n-1 次
        for (int j=0; j<n-1-i; j++) { // 内层循环：第 i 次时执行 n-1-i 次
            if (arr[j] > arr[j+1]) { // 1 次比较
                // 交换元素（3 次赋值）
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
// 总执行次数：(n-1) + (n-2) + ... + 1 = n(n-1)/2 → 主导项 n²，推导为 O(n²)
```

#### 实例 4：对数时间 `O(logn)`—— 二分查找（有序数组）

c

```c
int binarySearch(int arr[], int n, int target) {
    int left = 0, right = n-1;
    while (left <= right) { // 循环次数：每次缩小一半范围，共 log2(n) 次
        int mid = (left + right) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] > target) right = mid - 1;
        else left = mid + 1;
    }
    return -1;
}
// 循环次数：最多 log2(n) 次 → 推导为 O(logn)（忽略底数 2，因 loga(n) = logb(n)/logb(a)，系数可忽略）
```

### 6.6 最好、最坏与平均时间复杂度

- **最好时间复杂度**：算法在 “最理想输入” 下的执行时间（如二分查找中，第一次就找到目标元素，时间复杂度 `O(1)`）。
- **最坏时间复杂度**：算法在 “最糟糕输入” 下的执行时间（如二分查找中，目标元素不在数组中，需遍历到最后，时间复杂度 `O(logn)`）——**工程中优先关注最坏复杂度**（避免极端情况导致程序超时）。
- **平均时间复杂度**：算法在 “所有可能输入” 下的平均执行时间（需考虑每种输入的概率，计算加权平均）—— 更贴近实际，但计算复杂。

#### 示例：线性查找的三种复杂度

c

```c
// 线性查找：在数组中找 target，找到返回下标，否则返回 -1
int linearSearch(int arr[], int n, int target) {
    for (int i=0; i<n; i++) {
        if (arr[i] == target) return i;
    }
    return -1;
}
```

- 最好复杂度：`O(1)`（target 在 arr [0]）；
- 最坏复杂度：`O(n)`（target 不在数组中，或在 arr [n-1]）；
- 平均复杂度：`O(n)`（假设 target 在每个位置的概率相同，平均循环次数为 n/2）。





## 七、算法空间复杂度（与时间复杂度并列的性能指标）

### 7.1 空间复杂度的定义与核心意义

- **定义**：衡量算法执行过程中**所需额外内存空间**随输入数据规模（`n`）增长的变化趋势（不包含输入数据本身占用的空间，仅统计算法 “临时开辟” 的空间）。
- **核心意义**：
	1. 评估算法对内存的占用情况（如嵌入式设备、内存受限场景，需优先选择低空间复杂度算法）；
	2. 平衡时间与空间（部分算法通过 “牺牲空间换时间” 或 “牺牲时间换空间” 优化，如缓存机制 vs 暴力查找）。

### 7.2 空间复杂度的表示方法：大 O 表示法（同时间复杂度）

- **规则**：与时间复杂度一致，忽略常数、低次项、系数，仅保留主导项，用 `O(g(n))` 表示（`g(n)` 为空间增长函数）。
- **关键区分**：
	- **输入空间**：存储输入数据的空间（如数组、链表的原始数据），不计入空间复杂度；
	- **额外空间**：算法执行中临时开辟的空间（如临时变量、递归栈、动态申请的内存），是空间复杂度的统计对象。

### 7.3 常见空间复杂度类型（按占用空间从低到高排序）

| 空间复杂度 | 名称     | 增长趋势        | 典型场景 / 算法示例                                          |
| ---------- | -------- | --------------- | ------------------------------------------------------------ |
| `O(1)`     | 常数空间 | 不随 `n` 变化   | 1. 仅用固定数量的临时变量（如变量交换、线性查找）； 2. 无递归、无动态内存申请。 |
| `O(logn)`  | 对数空间 | 随 `n` 缓慢增长 | 1. 二分查找的临时变量（仅 `left`/`right`/`mid`，与 `logn` 无关？实际更常见于分治算法的临时栈）； 2. 某些递归分治算法（如归并排序的递归栈？需结合具体实现）。 |
| `O(n)`     | 线性空间 | 随 `n` 线性增长 | 1. 动态申请大小为 `n` 的数组 / 结构体（如动态数组、哈希表）； 2. 递归深度为 `n` 的递归算法（如未优化的斐波那契递归）； 3. 数组拷贝（如归并排序的临时合并数组）。 |
| `O(n²)`    | 平方空间 | 随 `n` 平方增长 | 1. 动态申请 `n×n` 的二维数组（如矩阵乘法的临时矩阵）； 2. 存储所有子集的算法（如子集枚举的结果存储）。 |

### 7.4 空间复杂度的分析方法（核心步骤）

#### 步骤 1：明确 “额外空间” 的范围

- 排除输入数据占用的空间（如函数参数中的数组、链表），仅统计算法执行中 “新创建” 的空间（临时变量、递归栈、`malloc` 申请的内存）。

#### 步骤 2：统计额外空间的规模与 `n` 的关系

- 若额外空间是 “固定数量”（与 `n` 无关），则为 `O(1)`；
- 若额外空间随 `n` 线性增长（如临时数组大小为 `n`），则为 `O(n)`；
- 若涉及递归，需统计 “递归栈深度”（递归调用的层数，每层递归需开辟栈帧存储局部变量）。

#### 步骤 3：按大 O 规则简化

- 忽略常数、低次项，保留主导项。

### 7.5 实例分析：常见算法的空间复杂度

#### 实例 1：常数空间 `O(1)`—— 变量交换（临时变量法）

c

```c
void swap(int* a, int* b) {
    int temp = *a; // 仅 1 个临时变量，与 n 无关
    *a = *b;
    *b = temp;
}
// 额外空间：固定 1 个 int 变量 → 空间复杂度 O(1)
```

#### 实例 2：线性空间 `O(n)`—— 动态数组（临时存储）

c

```c
int* copyArray(int arr[], int n) {
    int* new_arr = (int*)malloc(n * sizeof(int)); // 动态申请大小为 n 的数组
    for (int i=0; i<n; i++) {
        new_arr[i] = arr[i];
    }
    return new_arr;
}
// 额外空间：大小为 n 的动态数组 → 空间复杂度 O(n)
```

#### 实例 3：线性空间 `O(n)`—— 递归深度为 `n` 的递归（斐波那契递归）

c

```c
// 递归计算第 n 个斐波那契数（未优化，递归深度为 n）
int fib(int n) {
    if (n <= 2) return 1;
    return fib(n-1) + fib(n-2); // 每次递归调用开辟新栈帧
}
// 递归栈深度：最坏情况下为 n（如计算 fib(5)，需调用 fib(4)→fib(3)→fib(2)，深度 3）
// 额外空间：递归栈帧数量随 n 线性增长 → 空间复杂度 O(n)
```

#### 实例 4：平方空间 `O(n²)`—— 动态二维数组（矩阵存储）

c

```c
// 动态申请 n×n 的二维数组（矩阵）
int** createMatrix(int n) {
    int** matrix = (int**)malloc(n * sizeof(int*)); // 外层指针数组（大小 n）
    for (int i=0; i<n; i++) {
        matrix[i] = (int*)malloc(n * sizeof(int)); // 内层每个数组（大小 n）
    }
    return matrix;
}
// 额外空间：n（外层） + n×n（内层） = n² + n → 主导项 n² → 空间复杂度 O(n²)
```

### 7.6 时间与空间的权衡（工程核心思想）

- **牺牲空间换时间**：通过开辟额外空间减少计算步骤（如哈希表：用 `O(n)` 空间实现 `O(1)` 查找，替代 `O(n)` 线性查找）；
- **牺牲时间换空间**：通过增加计算步骤减少内存占用（如原地排序：冒泡排序用 `O(1)` 空间，替代归并排序的 `O(n)` 空间，但时间复杂度从 `O(nlogn)` 变为 `O(n²)`）。
- **选择依据**：根据场景优先级（如内存受限选低空间复杂度，实时系统选低时间复杂度）。



