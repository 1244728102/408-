# 查找的基本概念

## 1. 三大核心基础概念

### 1.1 查找

- **定义**：从存储数据的结构中，找到目标数据的操作。
- **核心目标**：定位目标数据的位置或确认其是否存在。

### 1.2 查找表

- **定义**：用于**存储**待查找数据的数据结构，并非 “新的数据结构”，而是对 “执行查找操作的数据结构” 的统称（视频重点强调：查找表不是新结构）。
- **支持的结构类型**：可基于任意数据结构实现，包括但不限于：
	- 线性结构（如数组、链表）
	- 树形结构（如二叉排序树、平衡二叉树）
	- 图状结构（如社交网络用户关系图）
- **数据元素的别称**：部分场景中，查找表中的 “数据元素” 也称为 “记录”。
- **示例**：
	1. 班级成绩表：存储每个同学的学号、姓名、成绩，属于线性结构的查找表。
	2. 微信用户关系图：存储微信用户信息及好友关系，属于图状结构的查找表（查询时，该图结构即为查找表）。

### 1.3 关键字

- **定义**：用于**唯一区分**查找表中各个数据元素（记录）的数据项（视频核心特性：“唯一性”）。

- **关键约束**：必须满足 “不重复”，若数据项存在重复则无法作为关键字。

- **正反示例**：

	| 场景           | 数据项   | 是否能作为关键字 | 原因分析                  |
	| -------------- | -------- | ---------------- | ------------------------- |
	| 班级成绩表     | 学号     | 是               | 每个学生学号唯一，无重复  |
	| 班级成绩表     | 姓名     | 否               | 存在重名（如 “铁柱”）     |
	| 微信用户关系图 | 微信号   | 是               | 微信号全局唯一，无重复    |
	| 微信用户关系图 | 微信昵称 | 否               | 昵称可重复（如 “小幸运”） |

## 2. 查找表的分类（按操作类型划分）

查找表的分类核心依据是 “是否允许修改数据”，分为静态和动态两类，视频明确了两类的操作范围、示例及设计重点。

### 2.1 静态查找表

- **操作范围**：仅支持 “查找” 操作，不允许插入、删除数据元素（数据一旦确定，长期静态不变）。
- **典型示例**：课程成绩单（成绩录入完成后，仅需查询，不再修改）。
- **设计核心**：仅需优化 “查找算法的效率”（无需考虑插入 / 删除的兼容性）。

### 2.2 动态查找表

- **操作范围**：除 “查找” 外，还需支持 “插入”“删除” 操作（数据随业务场景动态变化）。
- **典型示例**：商家点餐订单系统（需新增用户订单、取消错误订单，数据实时变化）。
- **设计核心**：需兼顾两方面 ——①查找算法的高效性；②插入 / 删除操作的便捷性（数据结构需适配动态修改）。

## 3. 查找算法的评价指标：平均查找长度（ASL）

视频强调：ASL 是评价查找算法优劣的**核心指标**，也是考研重点内容，需区分 “查找成功” 与 “查找失败” 两种场景。

### 3.1 基础概念

- **查找长度**：一次查找过程中，“对比关键字的总次数”（例如：查找根节点数据，仅需对比 1 次，查找长度 = 1）。
- **平均查找长度（ASL）**：所有可能查找情况的 “加权平均查找长度”，权重为每个元素被查找的概率（视频默认：无特殊说明时，所有元素被查找的概率均等，即每个元素概率 P_i = 1/n，n 为查找表元素总数）。
- **核心意义**：ASL 的数量级直接对应查找算法的**时间复杂度**（如 ASL=O (logn) 对应对数时间复杂度）。



<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20250921160014231.png" alt="image-20250921160014231" style="zoom: 200%;" />



### 3.2 ASL 的分类与计算示例

#### 3.2.1 分类

1. **查找成功的 ASL**：目标数据存在于查找表中时，所有成功查找情况的平均查找长度。
2. **查找失败的 ASL**：目标数据不存在于查找表中时，所有失败查找情况的平均查找长度。

#### 3.2.2 计算示例

- **案例背景**：含 8 个数据元素的二叉排序树：
	- 第 1 层（根节点）：50
	- 第 2 层：26、66
	- 第 3~4 层：剩余 5 个元素（视频未明确具体值，但总数为 8 个）
- **计算前提**：默认每个元素被查找的概率均等，即 P_i = 1/8（i=1~8）。
- **查找成功的 ASL 计算过程**：
	1. 第 1 层元素（50）：查找长度 = 1（仅对比根节点 1 次），贡献项 = 1 × (1/8)
	2. 第 2 层元素（26、66）：共 2 个元素，每个查找长度 = 2（对比根节点→子节点，2 次），贡献项 = 2 × 2 × (1/8)
	3. 第 3~4 层元素（剩余 5 个）：假设第 3 层元素查找长度 = 3，第 4 层元素查找长度 = 4（视频未细化层数，核心逻辑为 “查找长度 = 元素所在层数”），贡献项 = (3×n3 + 4×n4) × (1/8)（其中 n3 + n4 = 5）
	4. 总 ASL 成功 = [1×1 + 2×2 + (3n3 + 4n4)] × (1/8)
- **核心公式（来自视频逻辑）**：
	ASL 成功 = Σ（第 i 个元素的查找长度 L_i × 第 i 个元素的概率 P_i）（i 从 1 到 n，n 为元素总数）

### 3.3 关键注意事项

1. ASL 计算是考研重点，必须掌握 “查找成功” 与 “查找失败” 两种场景的计算逻辑。
2. 若题目未指定元素查找概率，默认所有元素概率均等（P_i = 1/n）。
3. 不同数据结构（如顺序表、二叉排序树、散列表）的 ASL 计算逻辑不同，需结合具体结构分析（后续章节展开）。



#  顺序查找（线性查找）

## 1. 顺序查找基本概念与适用场景

- **定义**：又称线性查找，是最简单的查找算法，核心思想是 “从线性表的一端（表头 / 表尾）开始，逐个对比元素与目标关键字，直到找到或遍历结束”。
- **适用场景**：仅适用于**线性表**（包括两种存储结构）：
	- 顺序存储结构：顺序表（动态 / 静态数组）。
	- 链式存储结构：单链表、双链表。
- **核心特点**：无需线性表有序，逻辑简单，但效率较低（时间复杂度`O(n)`）。

## 2. 顺序查找的实现（按存储结构分类）

### 2.1 基于顺序表（动态数组）的普通实现

#### 2.1.1 顺序表结构体定义

c

```c
#include <stdio.h>
#include <stdlib.h>

// 顺序表结构体（动态数组实现）
typedef struct {
    int *elem;    // 指向动态数组的起始地址（存储元素）
    int length;   // 顺序表当前有效元素个数
    int listsize; // 动态数组的最大容量（内存分配用）
} SqList;
```

#### 2.1.2 普通版查找函数实现

c

```c
/**
 * 普通版顺序查找（顺序表）
 * @param L：目标顺序表（已初始化，elem指向有效数组）
 * @param key：待查找的目标关键字
 * @return 成功：返回元素在数组中的下标（0~length-1）；失败：返回-1
 */
int SequentialSearch(SqList L, int key) {
    int i;
    // 遍历逻辑：i从0开始，满足“不越界”且“当前元素≠key”时继续推进
    for (i = 0; i < L.length && L.elem[i] != key; i++) {
        // 空循环体：仅靠循环条件控制遍历
    }
    // 遍历结束后判断结果
    return (i < L.length) ? i : -1;
}
```

#### 2.1.3 普通版查找示例

假设顺序表`L`的有效数据为：`L.elem = [7, 13, 19, 29, 35, 16, 43, 58, 62]`，`L.length = 9`（下标 0~8）。

1. **查找成功（key=43）**：
	- 遍历过程：i 依次取 0（7≠43）、1（13≠43）、2（19≠43）、3（29≠43）、4（35≠43）、5（16≠43）、6（43==43）。
	- 循环终止，返回`6`（元素 43 的下标）。
2. **查找失败（key=66）**：
	- 遍历过程：i 从 0 遍历到 8（所有元素均≠66），最终 i=9（≥L.length=9）。
	- 循环终止，返回`-1`。

### 2.2 基于顺序表的 “哨兵” 优化实现

视频中提出 “哨兵机制”：利用顺序表的 0 号位置存储目标关键字（哨兵），从表尾向表头遍历，**减少循环中的越界判断**（因哨兵存在，遍历必终止）。

#### 2.2.1 哨兵版查找函数实现

- 前提：顺序表 0 号位置不存储有效数据，有效数据从 1 号位置开始（`L.elem[1]~L.elem[L.length]`）。

c

```c
/**
 * 哨兵版顺序查找（顺序表）
 * @param L：目标顺序表（0号位置预留，有效数据从1号开始）
 * @param key：待查找的目标关键字
 * @return 成功：返回元素下标（1~length）；失败：返回0（哨兵位置）
 */
int SequentialSearch_Sentinel(SqList L, int key) {
    int i;
    L.elem[0] = key;  // 0号位置存入哨兵（目标关键字）
    i = L.length;     // 从表尾（有效数据最后一位）开始向前遍历
    // 仅判断“元素≠key”，无需判断越界（哨兵必匹配，遍历必终止）
    while (L.elem[i] != key) {
        i--;
    }
    return i;  // 成功→i≥1；失败→i=0
}
```

#### 2.2.2 哨兵版查找示例

假设顺序表`L`的有效数据为：`L.elem[1~8] = [7, 13, 19, 29, 35, 16, 43, 58]`，`L.length = 8`。

1. **查找成功（key=16）**：
	- 步骤 1：`L.elem[0] = 16`（设置哨兵）；
	- 步骤 2：i=8 开始，依次对比`58(8≠16)`、`43(7≠16)`、`16(6==16)`；
	- 返回`6`（元素 16 的下标）。
2. **查找失败（key=66）**：
	- 步骤 1：`L.elem[0] = 66`（设置哨兵）；
	- 步骤 2：i=8 遍历到 0，最终`L.elem[0] = 66`（匹配哨兵）；
	- 返回`0`（表示查找失败）。

### 2.3 基于单链表的顺序查找实现

视频中明确 “顺序查找适用于链表”，核心逻辑是遍历链表节点，对比节点数据与目标关键字。

#### 2.3.1 单链表节点结构体定义

c

```c
// 单链表节点结构体
typedef struct LNode {
    int data;          // 节点存储的关键字
    struct LNode *next;// 指向下一个节点的指针
} LNode, *LinkList;  // LinkList为指向节点的指针类型
```

#### 2.3.2 链表版查找函数实现

c

```c
/**
 * 链表版顺序查找（单链表）
 * @param L：单链表头节点（不存储有效数据，首元节点从L->next开始）
 * @param key：待查找的目标关键字
 * @return 成功：返回指向目标节点的指针；失败：返回NULL
 */
LNode* SequentialSearch_LinkList(LinkList L, int key) {
    LNode *p = L->next;  // 从首元节点（第一个有效节点）开始遍历
    // 遍历逻辑：p不为空且节点数据≠key时继续
    while (p != NULL && p->data != key) {
        p = p->next;  // 指针后移，指向下一节点
    }
    return p;  // 成功→p指向目标节点；失败→p=NULL
}
```

#### 2.3.3 链表版查找示例

假设单链表结构（头节点`L`，首元节点开始）：`7 → 13 → 19 → 29 → 35 → 16 → 43 → NULL`。

1. **查找成功（key=29）**：
	- 遍历过程：p 依次指向`7(≠29)`、`13(≠29)`、`19(≠29)`、`29(==29)`；
	- 返回指向`29`节点的指针。
2. **查找失败（key=66）**：
	- 遍历过程：p 遍历到最后一个节点`43(≠66)`后，p=NULL；
	- 返回`NULL`。

## 3. 顺序查找的平均查找长度（ASL）计算

视频中强调 “ASL 是评价查找算法效率的核心指标”，需分**查找成功**和**查找失败**两种场景，假设所有元素查找概率相等（`P_i = 1/n`，n 为有效元素个数）。

### 3.1 基本概念

- **查找长度（C_i）**：查找过程中 “关键字对比的次数”。
- **平均查找长度（ASL）**：所有场景的 “查找概率 × 查找长度” 之和，公式：
	`ASL = Σ(P_i × C_i)`

### 3.2 无序顺序表的 ASL（普通版 / 哨兵版）

#### 3.2.1 查找成功的 ASL

- 普通版与哨兵版的成功 ASL 完全一致（仅遍历方向不同，对比次数总和相同）。

- 推导：n 个元素中，第 1 个元素对比 1 次，第 2 个对比 2 次，…，第 n 个对比 n 次。

	plaintext

	```plaintext
	ASL_成功 = (1×P_1) + (2×P_2) + ... + (n×P_n)
	因P_i=1/n，故 ASL_成功 = (1+2+...+n)/n = (n+1)/2
	```

- 时间复杂度：`O(n)`。

#### 3.2.2 查找失败的 ASL

- **普通版**：需遍历所有 n 个元素，对比 n 次（直到 i≥length），故 `ASL_失败 = n`。
- **哨兵版**：需遍历 n 个有效元素 + 1 次哨兵，共对比 n+1 次，故 `ASL_失败 = n+1`。

### 3.3 有序顺序表的 ASL（优化失败场景）

视频中提出 “有序表可提前终止失败查找”，需结合**查找判定树**分析（判定树是遍历逻辑的可视化）。

#### 3.3.1 有序表查找判定树的规则

- **成功节点**：圆形节点，代表表中存在的元素，其 “层数”= 查找长度（对比次数）。
- **失败节点**：方形节点，代表查找失败的区间（如 key 在`[a,b)`之间），其 “父节点层数”= 查找长度。

#### 3.3.2 示例：有序表`[7,13,16,19,29,35,43,58]`（n=8）的判定树

plaintext

```plaintext
        7(1层) → 失败1（父层1，C=1）
         ↓
        13(2层) → 失败2（父层2，C=2）
         ↓
        16(3层) → 失败3（父层3，C=3）
         ↓
        19(4层) → 失败4（父层4，C=4）
         ↓
        29(5层) → 失败5（父层5，C=5）
         ↓
        35(6层) → 失败6（父层6，C=6）
         ↓
        43(7层) → 失败7（父层7，C=7）
         ↓
        58(8层) → 失败8（父层8，C=8）
                  ↓
                失败9（父层8，C=8）
```

#### 3.3.3 有序表的 ASL 计算

- **查找成功 ASL**：与无序表相同（成功节点层数总和 = 1+2+...+8=36）
	`ASL_成功 = 36/8 = 4.5`
- **查找失败 ASL**：共 n+1=9 个失败节点，查找长度总和 = 1+2+3+4+5+6+7+8+8=44
	`ASL_失败 = 44/9 ≈ 4.89`
- 优化效果：有序表的失败 ASL（≈4.89）远小于无序表（n=8）。

## 4. 顺序查找的优化思路

视频中仅提及两种优化思路，均为 “场景适配型优化”，不改变`O(n)`的时间复杂度本质。

### 4.1 基于有序表的优化（减少失败场景的查找长度）

- **适用场景**：线性表元素有序（递增 / 递减）。
- **优化逻辑**：查找时若当前元素与目标关键字 “满足有序性矛盾”（如递增表中当前元素 > key），则后续元素必不匹配，直接终止遍历。
- **示例**：在递增表`[7,13,16,19,29,...]`中查找 key=21，对比到 29（>21）时，直接判定失败，仅需 4 次对比（无需遍历 8 个元素）。

### 4.2 基于查找概率的优化（减少成功场景的 ASL）

- **适用场景**：各元素的查找概率差异较大（如部分元素高频被查询）。
- **优化逻辑**：将 “查找概率高的元素” 前置（放在表的前端），减少高频元素的对比次数。
- **示例**：若元素 19 的查找概率是其他元素的 10 倍，将 19 移至表的第 1 位，其查找长度从 4 次变为 1 次，整体成功 ASL 显著降低。
- **注意**：该优化会使表变为无序，查找失败时仍需遍历全表（ASL_失败 = n）。



# 折半查找（二分查找）知识点总结

## 1. 基础概念

折半查找（又称二分查找）是一种高效的**有序表查找算法**，其核心思想是通过反复将查找区间缩小一半，逐步逼近目标元素，最终确定目标元素是否存在及位置。

- 核心逻辑：利用 “有序” 特性，每次比较区间中间元素，排除一半不符合条件的区间，减少查找次数。

## 2. 适用条件

折半查找有严格的适用场景，缺一不可：

1. **数据存储结构：顺序表（数组）**
	需支持**随机访问**（即通过下标直接访问元素，时间复杂度 O (1)），链表不适用（链表访问中间元素需遍历，时间复杂度 O (n)，失去折半优势）。
2. **数据有序性**
	数据必须按 “关键字” 有序排列（通常为升序，降序需调整比较逻辑），无序表需先排序才能使用（排序时间可能抵消查找效率优势）。
3. **关键字唯一或不要求返回特定重复项**
	若存在重复元素，折半查找仅返回其中一个匹配元素的下标（非第一个 / 最后一个，需额外处理才能返回特定重复项）。

## 3. 算法思想与步骤

假设待查有序数组为`a`（升序），目标关键字为`key`，数组长度为`n`，步骤如下：

1. **初始化指针**：设左指针`low = 0`（指向数组起始下标），右指针`high = n - 1`（指向数组末尾下标）。
2. **循环查找**：当`low <= high`时（区间有效），执行：
	- 计算中间下标：`mid = low + (high - low) // 2`（避免`low + high`溢出，等价于`(low + high) // 2`但更安全）。
	- 比较中间元素与目标：
		- 若`a[mid] == key`：查找成功，返回`mid`（目标元素下标）。
		- 若`a[mid] > key`：目标在左半区，调整右指针`high = mid - 1`。
		- 若`a[mid] < key`：目标在右半区，调整左指针`low = mid + 1`。
3. **查找失败**：若循环结束时`low > high`（区间无效），返回`-1`（表示目标不存在）。

##  4. 代码实现

### 4.1 非递归实现（主流用法）

c

```c
#include <stdio.h>

/**
 * 折半查找（非递归）
 * @param a：有序数组（升序）
 * @param n：数组长度
 * @param key：待查找关键字
 * @return：成功返回下标，失败返回-1
 */
int BinarySearch(int a[], int n, int key) {
    int low = 0;          // 左指针：起始下标
    int high = n - 1;     // 右指针：末尾下标
    
    // 区间有效（low <= high）时循环
    while (low <= high) {
        // 计算中间下标（避免low+high溢出）
        int mid = low + (high - low) / 2;
        
        if (a[mid] == key) {
            return mid;   // 找到目标，返回下标
        } else if (a[mid] > key) {
            high = mid - 1; // 目标在左半区，缩小右边界
        } else {
            low = mid + 1;  // 目标在右半区，扩大左边界
        }
    }
    
    return -1; // 循环结束仍未找到，返回-1
}

// 测试示例（视频类似案例）
int main() {
    // 有序数组（升序）
    int a[] = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
    int n = sizeof(a) / sizeof(a[0]); // 数组长度
    int key1 = 7;  // 查找成功案例
    int key2 = 8;  // 查找失败案例
    
    // 查找key1
    int index1 = BinarySearch(a, n, key1);
    if (index1 != -1) {
        printf("关键字%d找到，下标为%d\n", key1, index1); // 输出：关键字7找到，下标为3
    } else {
        printf("关键字%d未找到\n", key1);
    }
    
    // 查找key2
    int index2 = BinarySearch(a, n, key2);
    if (index2 != -1) {
        printf("关键字%d找到，下标为%d\n", key2, index2);
    } else {
        printf("关键字%d未找到\n", key2); // 输出：关键字8未找到
    }
    
    return 0;
}
```

### 4.2 递归实现（逻辑简洁）

递归实现依赖 “分治思想”，将原问题拆分为 “左半区查找” 和 “右半区查找”，直到区间无效或找到目标。

c

```c
#include <stdio.h>

/**
 * 折半查找（递归）
 * @param a：有序数组（升序）
 * @param low：当前区间左边界
 * @param high：当前区间右边界
 * @param key：待查找关键字
 * @return：成功返回下标，失败返回-1
 */
int BinarySearchRecursive(int a[], int low, int high, int key) {
    // 基准条件：区间无效（low > high），查找失败
    if (low > high) {
        return -1;
    }
    
    // 计算中间下标
    int mid = low + (high - low) / 2;
    
    if (a[mid] == key) {
        return mid; // 找到目标，返回下标
    } else if (a[mid] > key) {
        // 递归查找左半区（更新右边界为mid-1）
        return BinarySearchRecursive(a, low, mid - 1, key);
    } else {
        // 递归查找右半区（更新左边界为mid+1）
        return BinarySearchRecursive(a, mid + 1, high, key);
    }
}

// 测试示例
int main() {
    int a[] = {2, 4, 6, 8, 10, 12};
    int n = sizeof(a) / sizeof(a[0]);
    int key = 8;
    
    // 初始调用：区间为整个数组（low=0，high=n-1）
    int index = BinarySearchRecursive(a, 0, n - 1, key);
    if (index != -1) {
        printf("关键字%d找到，下标为%d\n", key, index); // 输出：关键字8找到，下标为3
    } else {
        printf("关键字%d未找到\n", key);
    }
    
    return 0;
}
```

## 5. 查找过程示例

以有序数组`a = [1, 3, 5, 7, 9, 11, 13]`（n=7），查找`key=9`为例，步骤拆解：

1. 初始：`low=0`，`high=6`，`mid = 0 + (6-0)/2 = 3`，`a[3]=7 < 9` → 调整`low=4`。
2. 第二次：`low=4`，`high=6`，`mid = 4 + (6-4)/2 = 5`，`a[5]=11 > 9` → 调整`high=4`。
3. 第三次：`low=4`，`high=4`，`mid = 4 + (4-4)/2 = 4`，`a[4]=9 == 9` → 查找成功，返回下标 4。

## 6. 性能分析

### 6.1 时间复杂度

- 核心逻辑：每次查找缩小一半区间，最坏情况下查找次数为 “区间缩小到空的次数”。
	设数组长度为`n`，最坏情况下需满足`2^k ≥ n`（k 为查找次数），即`k = ⌈log₂n⌉`，因此时间复杂度为 **O(log₂n)**（通常简写为 O (logn)）。
- 最好情况：一次找到中间元素（`key == a[mid]`），时间复杂度 **O(1)**。
- 平均时间复杂度：**O(logn)**（统计所有可能查找路径的平均比较次数，接近最坏情况）。

### 6.2 空间复杂度

- 非递归实现：仅使用`low`、`high`、`mid`3 个变量，空间复杂度 **O(1)**（常数空间）。
- 递归实现：依赖递归栈，栈深度等于递归调用次数（最坏情况下为`⌈log₂n⌉`），空间复杂度 **O(logn)**。

## 7. 关键注意事项

1. **避免下标溢出**：计算`mid`时必须用`low + (high - low)/2`，而非`(low + high)/2`。若`low`和`high`均接近 int 最大值（如 2^31-1），`low + high`会超出 int 范围导致溢出，而`high - low`不会溢出。
2. **区间边界判断**：循环条件必须是`low <= high`，而非`low < high`。若用`low < high`，当`low=high`时（区间仅剩一个元素）会跳过比较，导致漏查。
3. **有序性维护**：若数组后续有插入 / 删除操作，需重新排序才能继续使用折半查找，否则会导致查找结果错误。
4. **重复元素处理**：若数组含重复元素（如`[2,2,2]`），折半查找返回的是中间匹配元素的下标（如 mid=1），而非第一个或最后一个 2。若需返回特定重复项，需在找到`a[mid]==key`后继续向左 / 右遍历，直到找到边界。

## 8. 折半查找判定树

折半查找的过程可通过 “二叉判定树” 可视化：

- 树中每个节点代表数组中的一个元素，左子树对应 “左半区查找”，右子树对应 “右半区查找”。
- 树的高度 = 最坏情况下的查找次数（即`⌈log₂n⌉`）。

以数组`a = [1,3,5,7,9]`为例，判定树结构如下：

plaintext

```plaintext
        5 (mid=2)
       /   \
      3     7 (mid=3)
     / \     \
    1 (mid=0) 9 (mid=4)
```

- 查找`1`：路径为 5→3→1（3 次比较，最坏情况）。
- 查找`5`：路径为 5（1 次比较，最好情况）。



# 分块查找（索引顺序查找）知识点总结

## 1. 分块查找基本概念

### 1.1 定义

分块查找又称**索引顺序查找**，是一种结合 “索引查找” 和 “顺序查找” 的混合查找算法，适用于数据量较大的静态或动态查找表。

### 1.2 核心特点

- **块内无序**：每个分块内部的元素无需排序（因此块内只能用顺序查找）。
- **块间有序**：不同分块之间需满足有序性（如块间元素范围递增 / 递减），通常通过 “索引表” 记录块的关键信息实现。
- 查找过程分两步：① 查找索引表，确定目标所在的分块；② 在目标分块内顺序查找。

## 2. 分块查找数据结构

分块查找需两种数据结构：**索引表**（记录块的元信息）和**主数据表**（存储实际元素），视频中以 “递增块间顺序” 为例设计结构。

### 2.1 数据结构定义（C 语言）

c

```c
#include <stdio.h>
#include <stdlib.h>

// 1. 索引表结构体：记录每个分块的最大关键字、块的起始/结束下标（low/high）
typedef struct {
    int max_key;  // 该分块的最大关键字（块间有序的核心依据）
    int low;      // 块的起始下标（主数据表中的索引）
    int high;     // 块的结束下标（主数据表中的索引）
} Index;

// 2. 分块查找的整体结构：包含索引表、主数据表、索引表长度
typedef struct {
    Index* index_table;  // 索引表
    int* main_data;      // 主数据表（存储实际元素）
    int index_len;       // 索引表长度（分块数量b）
    int data_len;        // 主数据表长度（总元素数量n）
} BlockSearch;
```

### 2.2 示例数据

视频中使用 14 个元素（主数据表下标 0~13），分 5 个块，索引表信息如下：

| 索引表下标 | max_key（块最大关键字） | low（块起始下标） | high（块结束下标） | 主数据表元素（块内）                 |
| ---------- | ----------------------- | ----------------- | ------------------ | ------------------------------------ |
| 0          | 10                      | 0                 | 2                  | [7, 3, 10]                           |
| 1          | 20                      | 3                 | 5                  | [13, 19, 15]                         |
| 2          | 30                      | 6                 | 8                  | [27, 22, 30]                         |
| 3          | 40                      | 9                 | 11                 | [35, 29（视频中无，失败示例用）, 40] |
| 4          | 50                      | 12                | 13                 | [45, 50]                             |

## 3. 分块查找实现步骤

### 3.1 情况 1：索引表用「顺序查找」

#### 3.1.1 查找成功示例（目标 key=22）

1. **查索引表（顺序遍历）**：
	- 索引 0（max_key=10）< 22 → 目标不在此块；
	- 索引 1（max_key=20）< 22 → 目标不在此块；
	- 索引 2（max_key=30）≥ 22 → 确定目标在块 6~8（low=6，high=8）。
2. **查目标分块（块内顺序查找）**：
	- 下标 6：元素 27 ≠ 22；
	- 下标 7：元素 22 = 22 → 查找成功，返回下标 7。

#### 3.1.2 查找失败示例（目标 key=29）

1. **查索引表（顺序遍历）**：
	- 索引 0（10<29）、索引 1（20<29）、索引 2（30≥29）→ 确定块 6~8。
2. **查目标分块（块内顺序查找）**：
	- 下标 6：27≠29；下标 7：22≠29；下标 8：30≠29；
	- 已遍历完块 6~8，无目标元素 → 查找失败。

#### 3.1.3 顺序查索引表的代码实现

c

```c
// 分块查找：索引表用顺序查找，成功返回元素下标，失败返回-1
int block_search_seq(BlockSearch bs, int key) {
    // 步骤1：顺序查找索引表，确定目标块
    int i = 0;
    while (i < bs.index_len && bs.index_table[i].max_key < key) {
        i++;  // 找到第一个max_key ≥ key的块，或遍历完所有块
    }
    // 若i超出索引表长度，说明key大于所有块的max_key → 失败
    if (i >= bs.index_len) {
        return -1;
    }
    // 步骤2：在目标块内顺序查找
    int low = bs.index_table[i].low;
    int high = bs.index_table[i].high;
    for (int j = low; j <= high; j++) {
        if (bs.main_data[j] == key) {
            return j;  // 成功，返回主数据表下标
        }
    }
    // 块内遍历完无目标 → 失败
    return -1;
}
```

### 3.2 情况 2：索引表用「折半查找」

#### 3.2.1 核心逻辑

- 索引表是有序的（块间有序），因此可折半查找；
- 折半查找的目标：找到 “第一个 max_key ≥ key” 的块；
- 特殊处理：若折半结束时`low > high`，需检查`low`指向的块：
	- 若`low < 索引表长度`：目标在`low`指向的块；
	- 若`low ≥ 索引表长度`：目标不存在（key 超出所有块范围）。

#### 3.2.2 查找成功示例 1（目标 key=30）

1. **查索引表（折半查找）**：
	- 初始`low=0`，`high=4`，`mid=(0+4)/2=2`；
	- 索引 2 的 max_key=30 == key → 确定块 6~8。
2. **查目标分块（顺序查找）**：
	- 下标 6（27≠30）、下标 7（22≠30）、下标 8（30=30）→ 成功，返回 8。

#### 3.2.3 查找成功示例 2（目标 key=19）

1. **查索引表（折半查找）**：
	- 初始`low=0`，`high=4`，`mid=2`（max_key=30 > 19）→ `high=1`；
	- 新`mid=(0+1)/2=0`（max_key=10 < 19）→ `low=1`；
	- 新`mid=(1+1)/2=1`（max_key=20 > 19）→ `high=0`；
	- 此时`low=1 > high=0`，取`low=1`指向的块 3~5。
2. **查目标分块（顺序查找）**：
	- 下标 3（13≠19）、下标 4（19=19）→ 成功，返回 4。

#### 3.2.4 查找失败示例（目标 key=54）

1. **查索引表（折半查找）**：
	- 初始`low=0`，`high=4`，`mid=2`（30<54）→ `low=3`；
	- 新`mid=(3+4)/2=3`（40<54）→ `low=4`；
	- 新`mid=(4+4)/2=4`（50<54）→ `low=5`；
	- 此时`low=5 > high=4`，且`low=5 ≥ 索引表长度4` → 失败。

#### 3.2.5 折半查索引表的代码实现

c

```c
// 分块查找：索引表用折半查找，成功返回元素下标，失败返回-1
int block_search_binary(BlockSearch bs, int key) {
    // 步骤1：折半查找索引表，确定目标块
    int low = 0;
    int high = bs.index_len - 1;
    int target_block = -1;  // 目标块在索引表中的下标
    while (low <= high) {
        int mid = (low + high) / 2;
        if (bs.index_table[mid].max_key == key) {
            target_block = mid;
            break;  // 找到精确匹配的块，直接跳出
        } else if (bs.index_table[mid].max_key < key) {
            low = mid + 1;  // key在右半部分
        } else {
            high = mid - 1;  // key在左半部分
        }
    }
    // 若未找到精确匹配的块，检查low指向的块（视频核心处理）
    if (target_block == -1) {
        // 若low超出索引表长度 → 失败
        if (low >= bs.index_len) {
            return -1;
        }
        target_block = low;  // 否则，目标块为low指向的块
    }
    // 步骤2：在目标块内顺序查找
    int block_low = bs.index_table[target_block].low;
    int block_high = bs.index_table[target_block].high;
    for (int j = block_low; j <= block_high; j++) {
        if (bs.main_data[j] == key) {
            return j;  // 成功，返回主数据表下标
        }
    }
    // 块内无目标 → 失败
    return -1;
}
```

## 4. 分块查找的平均查找长度（ASL）

平均查找长度（Average Search Length）是衡量查找效率的核心指标，定义为 “查找过程中关键字的平均对比次数”，视频中假设每个元素被查找的概率相等（均为`1/n`，`n`为总元素数）。

### 4.1 基础概念

- 设总元素数为`n`，分`b`个块，每块`s`个元素（满足`n = b × s`）；
- `ASL_total = ASL_index + ASL_block`，其中：
	- `ASL_index`：查找索引表的平均对比次数；
	- `ASL_block`：查找目标块的平均对比次数（块内无序，必为顺序查找）。

### 4.2 情况 1：索引表用顺序查找

#### 4.2.1 特例计算（视频 14 个元素示例）

- 总元素`n=14`，分`b=5`块（前 4 块 3 个元素，最后 1 块 2 个元素），概率`1/14`；
- 示例对比次数（视频描述）：
	- 元素 7（下标 0）：索引表对比 1 次 + 块内对比 1 次 → 总 2 次；
	- 元素 10（下标 2）：索引表对比 1 次 + 块内对比 3 次 → 总 3 次；
	- 元素 13（下标 3）：索引表对比 2 次 + 块内对比 1 次 → 总 3 次；
- 平均查找长度：`ASL = (2 + 3 + ... + 对比次数) × (1/14)`（视频未算最终值，核心是方法）。

#### 4.2.2 一般公式推导

- 索引表顺序查找：`ASL_index = (b + 1) / 2`（顺序查找`b`个元素的平均对比次数）；
- 块内顺序查找：`ASL_block = (s + 1) / 2`（顺序查找`s`个元素的平均对比次数）；
- 总 ASL：`ASL_total = (b + 1)/2 + (s + 1)/2`。

#### 4.2.3 最优分块策略

- 目标：最小化`ASL_total`，已知`n = b × s`（`b = n/s`），代入公式：
	- `ASL_total = (n/s + 1)/2 + (s + 1)/2`；
- 求极值（对`s`求导并令导数为 0）：当`s = √n`时，`ASL_total`最小；
- 最小 ASL：`ASL_min = √n + 1`；
- 示例：`n=10000`，最优分块`b=100`、`s=100`，`ASL_min=100 + 1=101`（远优于顺序查找的`5000`次）。

### 4.3 情况 2：索引表用折半查找

- 索引表折半查找：`ASL_index ≈ log2(b + 1) - 1`（折半查找`b`个元素的平均对比次数）；
- 块内顺序查找：`ASL_block = (s + 1)/2`；
- 总 ASL：`ASL_total ≈ log2(b + 1) - 1 + (s + 1)/2`；
- 视频说明：该情况计算复杂，考试中极少考察。

## 5. 分块查找的动态存储优化

### 5.1 顺序存储的问题

视频中提到，若主数据表用**顺序存储**（数组），插入 / 删除元素时需移动块内或块间元素（如插入 8 到第一块，需移动下标 1~13 的元素），时间代价大。

### 5.2 链式存储的优化方案

建议采用**链式存储**，具体设计：

- 索引表：用链表存储（每个节点仍含`max_key`、块的头指针、块的尾指针）；
- 块内元素：用链表存储（每个块是一个独立的链表）；
- 优势：插入 / 删除元素时无需移动大量数据（如插入 8 到第一块，直接将 8 的节点链到第一块链表末尾），操作效率高。

## 6. 核心总结

1. 分块查找核心是 “**块内无序、块间有序**”，分两步查找（索引表→块内）；
2. 索引表常用顺序查找（易实现、常考），折半查找需注意`low > high`的特殊处理；
3. 最优分块策略是`每块元素数s=√n`，此时平均查找长度最小（`ASL=√n + 1`）；
4. 动态查找表建议用链式存储，降低插入 / 删除的时间代价；
5. 考试重点：手算查找步骤、计算顺序查索引表的 ASL、最优分块策略。



# 二叉排序树（BST）知识点总结

## 一、二叉排序树的定义与特性

### 1. 基本定义

- 别称：二叉查找树（Binary Search Tree，简称 BST，视频中纠正初始 “BT” 的错误表述）
- 核心特性（**递归满足**）：
	- 任意节点的**左子树中所有节点值 < 该节点值**
	- 任意节点的**右子树中所有节点值 > 该节点值**
- 关键推论：对二叉排序树进行**中序遍历**，可得到**严格递增的有序序列**（遍历顺序 “左→根→右”，与特性完全匹配）

### 2. 示例

以根节点为 19 的二叉排序树为例：

- 左子树节点（13、11、15）均小于 19，右子树节点（25、22、30）均大于 19
- 子树递归满足特性：如右子树根 25 的左子树 22 <25，右子树 30> 25
- 中序遍历结果：11 → 13 → 15 → 19 → 22 → 25 → 30（递增序列）

## 二、二叉排序树的查找操作

查找目标：从根节点出发，依据 BST 特性定位目标节点，支持**非递归**和**递归**两种实现。

### 1. 核心查找逻辑

1. 从根节点（`t`）开始，若节点非空：
	- 若目标值（`key`）== 当前节点值：查找成功，返回当前节点
	- 若目标值（`key`）< 当前节点值：进入左子树（`t = t->lchild`）
	- 若目标值（`key`）> 当前节点值：进入右子树（`t = t->rchild`）
2. 若节点为空：查找失败，返回空指针（`NULL`）

### 2. 非递归实现（视频推荐，空间复杂度 O (1)）

#### 节点结构定义

c

```c
typedef struct BSTNode {
    int key;          // 节点关键字（视频中为int类型，可扩展为复杂类型，需定义比较规则）
    struct BSTNode *lchild, *rchild; // 左右子树指针
} BSTNode, *BSTree;
```

#### 查找代码

c

```c
// 传入根节点指针和目标值，返回目标节点指针（NULL表示查找失败）
BSTree BST_Search_NonRec(BSTree t, int key) {
    while (t != NULL && t->key != key) { // 节点非空且未找到目标，循环查找
        if (key < t->key) {
            t = t->lchild; // 目标更小，向左子树查找
        } else {
            t = t->rchild; // 目标更大，向右子树查找
        }
    }
    return t; // 循环结束：找到（返回节点）或失败（返回NULL）
}
```

#### 示例

- **查找成功（查找 30）**：
	1. 根节点 50 → 30 < 50 → 进入左子树（节点 26）
	2. 30 > 26 → 进入右子树（节点 30）
	3. 30 == 30 → 查找成功，返回节点 30（查找长度 = 3，共对比 3 次）
- **查找失败（查找 12）**：
	1. 根节点 19 → 12 < 19 → 进入左子树（节点 13）
	2. 12 < 13 → 进入左子树（节点 11）
	3. 12 > 11 → 进入右子树（NULL）
	4. 节点为空 → 查找失败（查找长度 = 3，共对比 3 次）

### 3. 递归实现

#### 查找代码

c

```c
// 传入根节点指针和目标值，返回目标节点指针
BSTree BST_Search_Rec(BSTree t, int key) {
    if (t == NULL || t->key == key) { // 终止条件：空节点（失败）或找到（成功）
        return t;
    } else if (key < t->key) {
        return BST_Search_Rec(t->lchild, key); // 递归左子树查找
    } else {
        return BST_Search_Rec(t->rchild, key); // 递归右子树查找
    }
}
```

#### 说明

- 递归深度 = 树的高度（h），因此空间复杂度为 O (h)（函数调用栈占用）
- 逻辑与非递归完全一致，仅实现方式不同

## 三、二叉排序树的插入操作

插入目标：在保证 BST 特性的前提下插入新节点，**新节点必为叶子节点**，且不允许插入重复关键字。

### 1. 核心插入逻辑

1. 按查找逻辑定位插入位置：找到 “应插入节点的父节点”（若目标值已存在，插入失败）
2. 若父节点左子树为空且新值 < 父节点值 → 新节点作为左孩子
3. 若父节点右子树为空且新值 > 父节点值 → 新节点作为右孩子

### 2. 递归实现

#### 插入代码

c

```c
// 传入根节点指针的引用（需修改指针）和目标值，返回1（成功）或0（失败）
int BST_Insert_Rec(BSTree &t, int key) { // &表示引用，修改t即修改原根指针
    if (t == NULL) { // 找到插入位置（空节点）
        // 申请新节点（视频中用malloc分配内存）
        t = (BSTree)malloc(sizeof(BSTNode));
        t->key = key;
        t->lchild = t->rchild = NULL; // 新节点为叶子，左右子树空
        return 1; // 插入成功
    } else if (key == t->key) { // 关键字已存在，不允许重复插入
        return 0; // 插入失败
    } else if (key < t->key) { // 新值更小，递归左子树插入
        return BST_Insert_Rec(t->lchild, key);
    } else { // 新值更大，递归右子树插入
        return BST_Insert_Rec(t->rchild, key);
    }
}
```

### 3. 关键说明

- **引用参数的必要性**：若插入位置为根节点（空树），需修改原根指针，因此必须用引用（`&t`）
- **新节点特性**：始终作为叶子节点插入，不破坏原有 BST 结构
- **非递归实现**：视频建议自行练手，空间复杂度 O (1)（无需递归栈），效率更高
- **插入失败场景**：目标值已存在于树中，返回 0

### 4. 示例

插入关键字 12：

1. 根节点 19 → 12 < 19 → 递归左子树（节点 13）
2. 12 < 13 → 递归左子树（节点 11）
3. 12 > 11 → 递归右子树（NULL）
4. 申请新节点（key=12），作为节点 11 的右孩子
5. 插入成功，新树仍满足 BST 特性

## 四、二叉排序树的构造

### 1. 构造逻辑

- 构造过程 = **依次插入多个节点**：从空树开始，将关键字序列中的元素逐个调用插入函数（`BST_Insert_Rec`）
- 关键结论：**插入顺序不同，最终树的形状不同**（即使关键字集合完全相同）

### 2. 示例

#### 案例 1：插入序列 [50, 66, 60, 26, 21, 30, 70, 68]

构造步骤：

1. 插入 50 → 根节点为 50（空树初始）
2. 插入 66 → 66 > 50 → 50 的右孩子
3. 插入 60 → 60 < 66 → 66 的左孩子
4. 插入 26 → 26 < 50 → 50 的左孩子
5. 插入 21 → 21 < 26 → 26 的左孩子
6. 插入 30 → 30 > 26 → 26 的右孩子
7. 插入 70 → 70 > 66 → 66 的右孩子
8. 插入 68 → 68 < 70 → 70 的左孩子

- 最终树形状：根 50，左子树 26（左 21、右 30），右子树 66（左 60、右 70（左 68））

#### 案例 2：插入序列 [26, 21, 30, 50, 60, 66, 68, 70]

- 关键字与案例 1 相同，但插入顺序不同
- 最终树形状：根 26（左 21、右 30），30 的右孩子 50，50 的右孩子 60，60 的右孩子 66，66 的右孩子 68，68 的右孩子 70（呈链状，效率低）

## 五、二叉排序树的删除操作

删除目标：删除指定关键字节点，**删除后仍需保持 BST 特性**，视频分 3 种情况处理（核心难点）。

### 1. 前提：先查找目标节点

- 若未找到目标节点：无需删除
- 若找到目标节点：按以下 3 种情况处理（设目标节点为`p`，其父节点为`f`）

### 2. 三种删除情况

#### 情况 1：目标节点`p`是叶子节点（无左、右子树）

- 处理逻辑：直接删除`p`，将其父节点`f`的对应子指针（左 / 右）设为 NULL
- 示例：删除节点 21（叶子）→ 将其父节点 26 的左指针设为 NULL → 树仍满足 BST 特性

#### 情况 2：目标节点`p`只有左子树 或 只有右子树

- 处理逻辑：用`p`的子树（左 / 右）直接替代`p`的位置（“子承父业”）
	- 若`p`只有左子树（`p->lchild != NULL`）：`f`的对应子指针 = `p->lchild`
	- 若`p`只有右子树（`p->rchild != NULL`）：`f`的对应子指针 = `p->rchild`
- 示例（视频案例）：
	- 删除节点 13（只有左子树 11）→ 将其父节点 19 的左指针 = 11 → 11 替代 13 的位置
	- 删除节点 60（只有右子树 68）→ 将其父节点 66 的左指针 = 68 → 68 替代 60 的位置

#### 情况 3：目标节点`p`既有左子树，又有右子树（核心复杂情况）

- 处理思路：用`p`的**直接后继**或**直接前驱**替代`p`，再删除替代节点（替代节点必属于情况 1 或 2）
- 视频讲解两种方案：

##### 方案 1：用 “直接后继” 替代（右子树中最小节点）

- 直接后继定义：BST 中序遍历中`p`的下一个节点 → `p`右子树中**最左下的节点**（右子树最小节点，无左子树）
- 步骤（视频示例：删除根节点 50，右子树最小节点为 60）：
	1. 找到`p`（50）的直接后继`s`（60，右子树最左下）
	2. 将`s`的关键字赋值给`p`（50 的 key 变为 60）
	3. 删除`s`（`s`只有右子树 68，属于情况 2 → 将`s`的父节点 66 的左指针 = 68）
- 结果：新树根为 60，左子树 26，右子树 66（左 68、右 70），仍满足 BST 特性

##### 方案 2：用 “直接前驱” 替代（左子树中最大节点）

- 直接前驱定义：BST 中序遍历中`p`的前一个节点 → `p`左子树中**最右下的节点**（左子树最大节点，无右子树）
- 步骤（视频示例：删除根节点 50，左子树最大节点为 30）：
	1. 找到`p`（50）的直接前驱`s`（30，左子树最右下）
	2. 将`s`的关键字赋值给`p`（50 的 key 变为 30）
	3. 删除`s`（`s`是叶子节点，属于情况 1 → 将`s`的父节点 26 的右指针 = NULL）
- 结果：新树根为 30，左子树 26（左 21），右子树 66（左 60、右 70（左 68）），仍满足 BST 特性

## 六、二叉排序树的查找效率分析

视频中通过 “查找长度” 和 “平均查找长度（ASL）” 衡量效率，核心与**树的高度**相关。

### 1. 核心概念

- **查找长度**：一次查找中，对比关键字的次数（即查找路径上的节点数）
	- 示例：查找节点 70，路径为 50→66→70 → 查找长度 = 3
- **平均查找长度（ASL）**：所有查找情况的查找长度加权平均（权重为概率），反映整体效率

### 2. 查找成功时的 ASL 计算

#### 计算逻辑

- 假设树中有`n`个节点，每个节点被查找的概率相等（`P_i = 1/n`）
- `ASL成功 = Σ（第i个节点的查找长度 × P_i）= (1/n) × Σ（所有节点的查找长度）`

#### 示例（视频中的两棵树对比）

##### 树 1（平衡树，n=8）

节点分布（层数与查找长度）：

- 第 1 层（根 50）：查找长度 = 1（1 个节点）
- 第 2 层（26、66）：查找长度 = 2（2 个节点）
- 第 3 层（21、30、60、70）：查找长度 = 3（4 个节点）
- 第 4 层（68）：查找长度 = 4（1 个节点）
- ASL 成功 = (1×1 + 2×2 + 3×4 + 4×1) / 8 = (1 + 4 + 12 + 4)/8 = 21/8 = 2.625

##### 树 2（链状树，n=8，插入顺序 [26,21,30,50,60,66,68,70]）

节点分布（层数与查找长度）：

- 第 1 层（26）：查找长度 = 1（1 个）
- 第 2 层（21）：查找长度 = 2（1 个）
- 第 3 层（30）：查找长度 = 3（1 个）
- 第 4 层（50）：查找长度 = 4（1 个）
- 第 5 层（60）：查找长度 = 5（1 个）
- 第 6 层（66）：查找长度 = 6（1 个）
- 第 7 层（68）：查找长度 = 7（1 个）
- 第 8 层（70）：查找长度 = 8（1 个）
- ASL 成功 = (1+2+3+4+5+6+7+8)/8 = 36/8 = 4.5
- 结论：树 1（平衡）的 ASL 更小，效率更高

### 3. 查找失败时的 ASL 计算

#### 计算逻辑

- 查找失败的位置：所有 “空节点”（共`n+1`个，每个空节点对应一个失败情况）
- 每个空节点的查找长度：到达其 “父节点” 的对比次数（即父节点的查找长度）
- 假设每个失败情况概率相等（`P_j = 1/(n+1)`）
- `ASL失败 = Σ（第j个空节点的查找长度 × P_j）= (1/(n+1)) × Σ（所有空节点的查找长度）`

#### 示例（视频中的树 1，n=8，空节点数 = 9）

空节点分布（父节点查找长度）：

- 父节点 21（查找长度 = 3）：左空节点（查找长度 = 3）
- 父节点 21（3）、26（2）、30（3）：右空节点（3、2、3）
- 父节点 60（3）、68（4）、70（3）：左空节点（3、4、3）
- 父节点 68（4）、70（3）：右空节点（4、3）
- 空节点查找长度总和 = 3+3+2+3+3+4+3+4+3 = 28
- ASL 失败 = 28 / 9 ≈ 3.11

### 4. 时间复杂度总结

- 最好情况：树为平衡二叉树（高度 h≈log₂n）→ 查找、插入、删除时间复杂度 O (logn)
- 最坏情况：树为链状（高度 h=n）→ 时间复杂度 O (n)（与顺序查找相同）
- 视频预告：下一节学习 “平衡二叉树”，通过调整树结构使高度保持 log₂n，避免最坏情况



# 平衡二叉树（AVL 树）知识点总结

## 一、AVL 树基本概念

### 1. 定义与来源

- **AVL 树**：全称平衡二叉树，由发明者 Adelson-Velsky 和 Landis 于 1962 年在论文中提出，其英文缩写（AVL）来自两人名字首字母。
- **核心特性**：树上任意节点的**左子树高度与右子树高度之差（平衡因子）的绝对值 ≤ 1**，确保树的高度趋近于 log₂n，保证查找效率。
- **注意**：需与 “平均查找长度（ASL）” 区分，二者缩写不同，含义无关。

### 2. 平衡因子

- **定义**：节点的平衡因子 = 左子树高度 - 右子树高度。

- **平衡条件**：AVL 树中所有节点的平衡因子只能是 **-1、0、1**（绝对值≤1）。

- **不平衡判定**：若任一节点的平衡因子绝对值＞1（即 2 或 - 2），则树为非平衡二叉树。

- **节点结构体设计**：需在普通二叉排序树节点基础上新增 “平衡因子” 字段，结构如下：

	c

	```c
	// 视频中提及的AVL树节点结构体
	typedef struct AVLNode {
	    int key;          // 节点关键字（值）
	    int balance;      // 平衡因子：左子树高度 - 右子树高度
	    struct AVLNode *left;   // 左孩子指针
	    struct AVLNode *right;  // 右孩子指针
	    struct AVLNode *parent; // 父节点指针（用于调整时定位祖先）
	} AVLNode, *AVLTree;
	```

### 3. 为什么需要 AVL 树

- 普通二叉排序树在极端情况下（如插入有序数据）会退化为链表，查找效率降至 O (n)。
- AVL 树通过维持平衡，确保树的高度为 O (log₂n)，因此查找、插入、删除的时间复杂度均为**O(log₂n)**。

## 二、插入后不平衡的核心问题：最小不平衡子树

### 1. 定义

- 插入新节点后，从新节点**自下而上遍历祖先节点**，找到**第一个平衡因子绝对值＞1 的节点**（即第一个不平衡节点），以该节点为根的子树称为 “最小不平衡子树”。
- 例（视频示例）：插入 67 到二叉排序树后，新节点的祖先依次为 68、70、66。其中**70 是第一个不平衡节点**（平衡因子 = 2），因此以 70 为根的子树（包含 68、67、70）是最小不平衡子树。

### 2. 关键结论

- 只需调整**最小不平衡子树**即可使整棵树恢复平衡。因为调整后，该子树的高度会恢复到插入前的水平，其祖先节点的平衡因子也会随之恢复（无需再向上调整）。

## 三、四种不平衡情况与调整方法（旋转操作）

插入新节点后，最小不平衡子树的不平衡源于 “新节点在左子树的左 / 右分支” 或 “右子树的左 / 右分支”，对应四种情况，调整核心是**左旋、右旋**两种基本操作的组合。

### 1. 情况 1：LL 型（左左型）

#### 场景

- 新节点插入到**最小不平衡子树根 A 的左孩子 B 的左子树**（即 A→B→新节点，均为左分支）。

#### 调整步骤（右旋操作）

1. 将 B 的右子树（Br）挂载到 A 的左子树；
2. 将 A 挂载到 B 的右子树；
3. 将 B 替代 A 成为最小不平衡子树的新根（更新 B 的父节点指向 A 的原父节点）。

- 本质：让 B “右旋”（向右上方旋转），替代 A 的位置，维持二叉排序树性质（Bl < B < Br < A < Ar）。

#### 高度分析

- 初始：A 的左子树高度 = h+2（B 的左子树高度 = h+1，右子树 = h），右子树高度 = h，平衡因子 = 2；
- 调整后：A、B 的平衡因子均变为 0，子树总高度恢复为 h+2（插入前高度）。

#### 示例

- 插入 67 到 70 的左孩子 68 的左子树：
	- 调整前：根 70，左 68，68 左 67（70 平衡因子 = 2）；
	- 调整后：根 68，左 67，右 70（68、70 平衡因子均为 0）。

#### 右旋操作代码

c

```c
// 右旋操作：以A为根的子树，让A的左孩子B右旋成为新根
AVLNode* RightRotate(AVLNode *A) {
    AVLNode *B = A->left;    // B是A的左孩子
    AVLNode *Br = B->right;  // Br是B的右子树（需挂载到A的左）
    AVLNode *gf = A->parent; // gf是A的父节点（祖父）

    // 步骤1：Br挂载到A的左子树
    A->left = Br;
    if (Br != NULL) {
        Br->parent = A;
    }

    // 步骤2：A挂载到B的右子树
    B->right = A;
    A->parent = B;

    // 步骤3：B替代A成为gf的孩子
    B->parent = gf;
    if (gf != NULL) {
        if (gf->left == A) { // 若A原是gf的左孩子
            gf->left = B;
        } else { // 若A原是gf的右孩子
            gf->right = B;
        }
    }

    // 更新平衡因子（视频未细讲计算，核心是调整后平衡因子为0）
    A->balance = 0;
    B->balance = 0;

    return B; // 返回新根B
}
```

### 2. 情况 2：RR 型（右右型）

#### 场景

- 新节点插入到**最小不平衡子树根 A 的右孩子 B 的右子树**（即 A→B→新节点，均为右分支）。

#### 调整步骤（左旋操作）

1. 将 B 的左子树（Bl）挂载到 A 的右子树；
2. 将 A 挂载到 B 的左子树；
3. 将 B 替代 A 成为最小不平衡子树的新根（更新 B 的父节点指向 A 的原父节点）。

- 本质：让 B “左旋”（向左上方旋转），替代 A 的位置，维持二叉排序树性质（Al < A < Bl < B < Br）。

#### 高度分析

- 初始：A 的右子树高度 = h+2（B 的右子树高度 = h+1，左子树 = h），左子树高度 = h，平衡因子 =-2；
- 调整后：A、B 的平衡因子均变为 0，子树总高度恢复为 h+2。

#### 示例

- 插入 90 到 66 的右孩子 70 的右子树：
	- 调整前：根 66，右 70，70 右 90（66 平衡因子 =-2）；
	- 调整后：根 70，左 66，右 90（66、70 平衡因子均为 0）。

#### 左旋操作代码

c

```c
// 左旋操作：以A为根的子树，让A的右孩子B左旋成为新根
AVLNode* LeftRotate(AVLNode *A) {
    AVLNode *B = A->right;   // B是A的右孩子
    AVLNode *Bl = B->left;   // Bl是B的左子树（需挂载到A的右）
    AVLNode *gf = A->parent; // gf是A的父节点（祖父）

    // 步骤1：Bl挂载到A的右子树
    A->right = Bl;
    if (Bl != NULL) {
        Bl->parent = A;
    }

    // 步骤2：A挂载到B的左子树
    B->left = A;
    A->parent = B;

    // 步骤3：B替代A成为gf的孩子
    B->parent = gf;
    if (gf != NULL) {
        if (gf->left == A) { // 若A原是gf的左孩子
            gf->left = B;
        } else { // 若A原是gf的右孩子
            gf->right = B;
        }
    }

    // 更新平衡因子
    A->balance = 0;
    B->balance = 0;

    return B; // 返回新根B
}
```

### 3. 情况 3：LR 型（左右型）

#### 场景

- 新节点插入到**最小不平衡子树根 A 的左孩子 B 的右子树**（即 A→B→C→新节点，B 是左分支，C 是右分支），其中 C 是 B 的右孩子。

#### 调整步骤（先左旋后右旋）

1. **第一步：对 B 进行左旋**（以 B 为根，让 C 左旋替代 B）：
	- 将 C 的左子树（Cl）挂载到 B 的右子树；
	- 将 B 挂载到 C 的左子树；
	- C 替代 B 成为 A 的左孩子。
2. **第二步：对 A 进行右旋**（以 A 为根，让 C 右旋替代 A）：
	- 将 C 的右子树（Cr）挂载到 A 的左子树；
	- 将 A 挂载到 C 的右子树；
	- C 替代 A 成为最小不平衡子树的新根。

- 本质：先通过左旋将 LR 型转化为 LL 型，再通过右旋调整平衡。

#### 示例

- 插入 57 到 66 的左孩子 50 的右孩子 60 的右子树：
	- 调整前：根 66，左 50，50 右 60，60 右 57（66 平衡因子 = 2）；
	- 第一步：对 50 左旋，60 替代 50 成为 66 的左孩子；
	- 第二步：对 66 右旋，60 替代 66 成为新根，最终树平衡。

#### LR 型调整代码

c

```c
// LR型调整：先对A的左孩子B左旋，再对A右旋
AVLNode* LR_Rotate(AVLNode *A) {
    A->left = LeftRotate(A->left); // 第一步：B左旋（返回新根C）
    return RightRotate(A);         // 第二步：A右旋（返回新根C）
}
```

### 4. 情况 4：RL 型（右左型）

#### 场景

- 新节点插入到**最小不平衡子树根 A 的右孩子 B 的左子树**（即 A→B→C→新节点，B 是右分支，C 是左分支），其中 C 是 B 的左孩子。

#### 调整步骤（先右旋后左旋）

1. **第一步：对 B 进行右旋**（以 B 为根，让 C 右旋替代 B）：
	- 将 C 的右子树（Cr）挂载到 B 的左子树；
	- 将 B 挂载到 C 的右子树；
	- C 替代 B 成为 A 的右孩子。
2. **第二步：对 A 进行左旋**（以 A 为根，让 C 左旋替代 A）：
	- 将 C 的左子树（Cl）挂载到 A 的右子树；
	- 将 A 挂载到 C 的左子树；
	- C 替代 A 成为最小不平衡子树的新根。

- 本质：先通过右旋将 RL 型转化为 RR 型，再通过左旋调整平衡。

#### 示例（视频案例）

- 插入 63 到 50 的右孩子 66 的左孩子 60 的右子树：
	- 调整前：根 50，右 66，66 左 60，60 右 63（50 平衡因子 =-2）；
	- 第一步：对 66 右旋，60 替代 66 成为 50 的右孩子；
	- 第二步：对 50 左旋，60 替代 50 成为新根，最终树平衡。

#### RL 型调整代码（视频思路组合）

c

```c
// RL型调整：先对A的右孩子B右旋，再对A左旋
AVLNode* RL_Rotate(AVLNode *A) {
    A->right = RightRotate(A->right); // 第一步：B右旋（返回新根C）
    return LeftRotate(A);             // 第二步：A左旋（返回新根C）
}
```

## 四、AVL 树的查找效率

### 1. 最小节点数与树高的关系

- 定义**nₕ**：高度为 h 的 AVL 树所需的**最少节点数**（高度从 0 开始，空树高度 = 0）。
- 递推公式（视频推导）：
	- 边界条件：n₀=0（空树），n₁=1（仅根节点），n₂=2（根 + 1 个孩子）；
	- 递推关系：nₕ = nₕ₋₁ + nₕ₋₂ + 1（根节点 + 左子树最少节点 + 右子树最少节点）。
- 计算示例：n₃=4，n₄=7，n₅=12，n₆=20...

### 2. 时间复杂度

- 由递推公式可证明：AVL 树的高度 h ≤ ⌊1.44log₂(n+1)⌋（视频提及论文结论：h < 3/2 log₂(n+1) + 1），因此高度为**O(log₂n)**。
- 查找操作的时间复杂度：最坏情况下为**O(log₂n)**（与树高一致）。
- 示例（视频案例）：n=9 时，最小节点数 n₄=7 ≤ 9 ≤ n₅=12，因此树的最大高度 = 4，最坏查找需对比 4 次。

## 五、核心总结

1. AVL 树的核心是**平衡因子绝对值≤1**，通过旋转维持平衡；
2. 插入后只需调整**最小不平衡子树**，四种情况对应 “右旋、左旋、先左旋后右旋、先右旋后左旋”；
3. 调整后子树高度恢复，祖先平衡因子无需再调整；
4. 查找、插入、删除效率均为 O (log₂n)，是高效的有序数据存储结构。



# 平衡二叉树（AVL 树）删除知识点总结

## 一、平衡二叉树（AVL 树）核心特性回顾

1. **具备二叉排序树（BST）特性**：对任意节点，其左子树所有节点值 < 该节点值 < 右子树所有节点值（左 < 中 < 右）。
2. **平衡性**：任意节点的左右子树高度差（平衡因子）的绝对值 ≤ 1（平衡因子 = 左子树高度 - 右子树高度）。

## 二、平衡二叉树删除的核心原则

删除操作需同时满足两个目标，与插入操作逻辑一致：

1. **保持 BST 特性**：删除节点后，“左 < 中 < 右” 的顺序不被破坏。
2. **恢复平衡性**：若删除导致节点平衡因子绝对值 > 1，需通过旋转调整恢复平衡。

## 三、平衡二叉树删除的五步核心步骤

视频将删除过程拆解为以下五步，逻辑不可逆：

### 步骤 1：按二叉排序树（BST）规则删除目标节点

| BST 删除节点的三种情况                         | 处理方法                                                     | 示例（视频隐含场景）                                         |
| ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 情况 1：目标节点是**叶子节点**（无左、右子树） | 直接删除该节点，父节点对应指针置空                           | 视频例 1 删除 “9”、例 2 删除 “55”、例 3 删除 “32”            |
| 情况 2：目标节点**只有一棵子树**（左或右）     | 用子树替代目标节点位置（“子承父业”）                         | 视频例 5 中删除 “60”（原 75 的前驱，仅有左子树 55）          |
| 情况 3：目标节点**有两棵子树**（左、右均存在） | 用 “前驱节点” 或 “后继节点” 替代目标节点，再删除前驱 / 后继（转化为情况 1 或 2）： - 前驱：目标节点左子树的 “最右节点”（左子树中最大值） - 后继：目标节点右子树的 “最左节点”（右子树中最小值） | 视频例 5 删除 “75”（用前驱 “60” 替代）；例 6 删除 “75”（用后继 “77” 替代） |

### 步骤 2：查找 “最小不平衡子树”

删除节点后，可能破坏祖先节点的平衡性，需从**删除节点的父节点开始，向上遍历（视频称 “一路向北”）**，找到**第一个平衡因子绝对值 > 1 的节点**—— 该节点即为 “最小不平衡子树的根”。

- 若遍历至根节点仍无不平衡，则删除操作结束（“完结撒花”）。
- 示例：视频例 2 中，删除 “55” 后，向上遍历至 “60”（平衡），再到 “75”（平衡因子 = 1-3=-2，绝对值 > 1），故 “75” 是最小不平衡子树的根。

### 步骤 3：确定最小不平衡子树的 “最高儿子” 和 “最高孙子”

视频定义：

- **最高儿子**：最小不平衡子树根的左、右子树中，**高度更高的子树的根**（若高度相等，任选其一，视频例 6 提到 “工程中均可，考试无争议题”）。
- **最高孙子**：“最高儿子” 的左、右子树中，**高度更高的子树的根**（同理，高度相等任选）。

示例（视频例 2）：

- 最小不平衡子树根：75
- 75 的左子树（根 60）高度 = 1，右子树（根 80）高度 = 3 → 最高儿子 = 80
- 80 的左子树高度 = 1，右子树（根 90）高度 = 2 → 最高孙子 = 90

### 步骤 4：根据 “最高孙子” 位置调整平衡（与插入调整逻辑完全一致）

视频强调 “删除的四种调整情况与插入完全相同”，调整对象是 “最小不平衡子树”，核心是通过旋转让子树恢复平衡。四种情况由 “最高孙子” 相对于最小不平衡子树的位置决定：

#### 1. 情况 1：LL 型（孙子在 “左子树的左子树”）

- 孙子位置：最小不平衡子树根 → 左儿子 → 左孙子（根左左）。
- 调整方法：对最小不平衡子树根执行**右旋**（单旋）。
- 原理：右旋后，左儿子成为新根，原根成为左儿子的右子树，左儿子的右子树成为原根的左子树。

#### 2. 情况 2：RR 型（孙子在 “右子树的右子树”）

- 孙子位置：最小不平衡子树根 → 右儿子 → 右孙子（根右右）。
- 调整方法：对最小不平衡子树根执行**左旋**（单旋）。
- 示例（视频例 2）：
	- 最小不平衡子树根 = 75，最高儿子 = 80，最高孙子 = 90（75→80→90，RR 型）。
	- 对 75 执行左旋：80 成为新根，75 成为 80 的左子树，80 原左子树成为 75 的右子树，调整后 75 的平衡因子恢复为 0。

#### 3. 情况 3：LR 型（孙子在 “左子树的右子树”）

- 孙子位置：最小不平衡子树根 → 左儿子 → 右孙子（根左右）。
- 调整方法：**先对左儿子执行左旋，再对最小不平衡子树根执行右旋**（双旋）。
- 示例（视频例 4）：
	- 最小不平衡子树根 = 33，最高儿子 = 10，最高孙子 = 20（33→10→20，LR 型）。
	- 第一步：对 10 左旋，20 成为 10 的父节点；第二步：对 33 右旋，20 成为新根，调整后 33 的平衡因子恢复为 0。

#### 4. 情况 4：RL 型（孙子在 “右子树的左子树”）

- 孙子位置：最小不平衡子树根 → 右儿子 → 左孙子（根右左）。
- 调整方法：**先对右儿子执行右旋，再对最小不平衡子树根执行左旋**（双旋）。
- 示例（视频例 3）：
	- 最小不平衡子树根 = 44，最高儿子 = 78，最高孙子 = 50（44→78→50，RL 型）。
	- 第一步：对 78 右旋，50 成为 78 的父节点；第二步：对 44 左旋，50 成为新根，调整后 44 的平衡因子恢复为 0。

### 步骤 5：检查不平衡是否 “向上传导”

调整后，若 “最小不平衡子树的高度发生变化”（如视频例 2 中，调整前子树高度 = 4，调整后 = 3），可能导致其上层祖先节点不平衡 —— 需**回到步骤 2**，再次向上查找新的最小不平衡子树，重复步骤 3-5，直至遍历至根节点或无不平衡。

- 示例（视频例 4）：
	1. 删除 “32” 后，调整 44 的 RL 型不平衡，子树高度从 4→3；
	2. 向上遍历至 33，发现 33 的平衡因子 = 5-3=2（绝对值 > 1），新的最小不平衡子树根 = 33；
	3. 对 33 执行 LR 型调整，子树高度恢复，无进一步传导，操作结束。

## 四、典型示例解析（6 个核心案例）

### 例 1：删除叶子节点，无不平衡（最简单场景）

- 场景：平衡二叉树中删除叶子节点 “9”。
- 步骤：
	1. 按 BST 删除：直接删除 “9”（叶子节点）；
	2. 向上遍历：所有祖先节点平衡因子均≤1；
	3. 结论：无需调整，删除结束。

### 例 2：删除叶子节点，RR 型不平衡（单旋调整）

- 场景：例 1 基础上删除叶子节点 “55”。
- 步骤：
	1. BST 删除：直接删除 “55”；
	2. 找最小不平衡子树：向上遍历至 “75”（平衡因子 = 1-3=-2）；
	3. 最高儿子 = 80，最高孙子 = 90（RR 型）；
	4. 调整：对 75 左旋，子树恢复平衡；
	5. 传导检查：调整后子树高度无影响上层，结束。

### 例 3：删除叶子节点，RL 型不平衡（双旋调整）

- 场景：平衡二叉树中删除叶子节点 “32”。
- 步骤：
	1. BST 删除：直接删除 “32”；
	2. 找最小不平衡子树：向上遍历至 “44”（平衡因子异常）；
	3. 最高儿子 = 78，最高孙子 = 50（RL 型）；
	4. 调整：先对 78 右旋，再对 44 左旋，子树恢复平衡；
	5. 传导检查：无上层影响，结束。

### 例 4：不平衡向上传导（需二次调整）

- 场景：例 3 调整后，子树高度从 4→3，导致上层 “33” 不平衡。
- 步骤：
	1. 回到步骤 2：向上遍历至 “33”（平衡因子 = 5-3=2）；
	2. 最高儿子 = 10，最高孙子 = 20（LR 型）；
	3. 调整：先对 10 左旋，再对 33 右旋，子树恢复平衡；
	4. 传导检查：无进一步影响，结束。

### 例 5：删除有两棵子树的节点（用前驱替代）

- 场景：删除节点 “75”（有左子树 60、右子树 80）。
- 步骤：
	1. BST 删除：找 75 的前驱（左子树最右节点 “60”），将 60 的值复制到 75 位置，再删除原 60（原 60 仅有左子树 55，按情况 2 删除）；
	2. 找最小不平衡子树：向上遍历至 “60”（原 75，平衡因子异常）；
	3. 最高儿子 = 80，最高孙子 = 90（RR 型）；
	4. 调整：对 60 左旋，恢复平衡；
	5. 传导检查：无影响，结束。

### 例 6：删除有两棵子树的节点（用后继替代，孙子任选）

- 场景：删除节点 “75”，用后继 “77”（右子树最左节点）替代。
- 步骤：
	1. BST 删除：复制 77 的值到 75 位置，删除原 77（叶子节点，情况 1）；
	2. 找最小不平衡子树：向上遍历至 “80”（平衡因子异常）；
	3. 最高儿子 = 90，左右子树高度相等（85 和 95），任选孙子（如 85 或 95）：
		- 选 95（RR 型）：对 80 左旋，恢复平衡；
		- 选 85（RL 型）：先对 90 右旋，再对 80 左旋，恢复平衡；
	4. 传导检查：无影响，结束。
- 视频提示：工程中孙子任选均可，考试不会出此类有争议的题目。

## 五、时间复杂度

视频结尾明确：平衡二叉树删除操作的时间复杂度为 **O(log₂n)**（n 为节点数），因查找、旋转均为树高相关操作，AVL 树的树高始终为 log₂n 级别。

## 六、考试重点提示

1. 2022 年前计算机考研 408 从未考察过 AVL 树删除，未来考察概率低；
2. 若考察，仅会出 “无争议、单一种解法” 的题目（如例 1 - 例 4），不会出例 5 - 例 6 这类 “前驱 / 后继选择” 或 “孙子任选” 的场景；
3. 核心掌握 “五步步骤” 和 “四种调整逻辑”，与插入操作对比记忆。

## 七、代码实现

### 1. 节点结构定义

c

```c
#include <stdio.h>
#include <stdlib.h>

// AVL树节点结构
typedef struct AVLNode {
    int key;                // 节点值
    struct AVLNode *left;   // 左子树指针
    struct AVLNode *right;  // 右子树指针
    int height;             // 节点高度（默认1，叶子节点高度为1）
} AVLNode, *AVLTree;
```

### 2. 辅助函数（高度计算、平衡因子计算）

c

```c
// 计算节点高度（空节点高度为0）
int getHeight(AVLNode *node) {
    if (node == NULL) return 0;
    return node->height;
}

// 更新节点高度（节点高度 = 1 + max(左子树高度, 右子树高度)）
void updateHeight(AVLNode *node) {
    if (node == NULL) return;
    int leftH = getHeight(node->left);
    int rightH = getHeight(node->right);
    node->height = (leftH > rightH ? leftH : rightH) + 1;
}

// 计算平衡因子（平衡因子 = 左子树高度 - 右子树高度）
int getBalanceFactor(AVLNode *node) {
    if (node == NULL) return 0;
    return getHeight(node->left) - getHeight(node->right);
}
```

### 3. 旋转函数（四种调整逻辑）

#### （1）左旋（处理 RR 型）

c

```c
// 左旋：对node节点执行左旋，返回新的根节点
AVLNode *leftRotate(AVLNode *node) {
    AVLNode *newRoot = node->right;  // 新根是原节点的右儿子
    AVLNode *temp = newRoot->left;   // 暂存新根的左子树（未来成为原节点的右子树）

    // 执行旋转
    newRoot->left = node;
    node->right = temp;

    // 更新原节点和新根的高度（先更原子节点，再更新新根）
    updateHeight(node);
    updateHeight(newRoot);

    return newRoot;
}
```

#### （2）右旋（处理 LL 型）

c

```c
// 右旋：对node节点执行右旋，返回新的根节点
AVLNode *rightRotate(AVLNode *node) {
    AVLNode *newRoot = node->left;   // 新根是原节点的左儿子
    AVLNode *temp = newRoot->right;  // 暂存新根的右子树（未来成为原节点的左子树）

    // 执行旋转
    newRoot->right = node;
    node->left = temp;

    // 更新高度
    updateHeight(node);
    updateHeight(newRoot);

    return newRoot;
}
```

#### （3）LR 型调整（先左旋左儿子，再右旋根）

c

```c
AVLNode *lrRotate(AVLNode *node) {
    node->left = leftRotate(node->left);  // 先对左儿子左旋
    return rightRotate(node);             // 再对根右旋
}
```

#### （4）RL 型调整（先右旋右儿子，再左旋根）

c

```c
AVLNode *rlRotate(AVLNode *node) {
    node->right = rightRotate(node->right);  // 先对右儿子右旋
    return leftRotate(node);                 // 再对根左旋
}
```

### 4. BST 删除辅助函数（前驱、后继查找）

c

```c
// 查找BST中节点的前驱（左子树最右节点）
AVLNode *findPredecessor(AVLNode *node) {
    if (node == NULL || node->left == NULL) return NULL;
    AVLNode *pre = node->left;
    while (pre->right != NULL) {  // 左子树最右节点
        pre = pre->right;
    }
    return pre;
}

// 查找BST中节点的后继（右子树最左节点）
AVLNode *findSuccessor(AVLNode *node) {
    if (node == NULL || node->right == NULL) return NULL;
    AVLNode *suc = node->right;
    while (suc->left != NULL) {  // 右子树最左节点
        suc = suc->left;
    }
    return suc;
}
```

### 5. BST 删除函数（实现三种删除情况）

c

```c
// 按BST规则删除目标节点，返回删除后的根节点
AVLNode *deleteBSTNode(AVLNode *root, int key) {
    if (root == NULL) return NULL;  // 未找到目标节点

    // 1. 递归查找并删除目标节点
    if (key < root->key) {
        root->left = deleteBSTNode(root->left, key);  // 目标在左子树
    } else if (key > root->key) {
        root->right = deleteBSTNode(root->right, key);  // 目标在右子树
    } else {  // 找到目标节点，执行删除
        // 情况1：叶子节点或只有一棵子树
        if (root->left == NULL) {
            AVLNode *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            AVLNode *temp = root->left;
            free(root);
            return temp;
        }
        // 情况2：有两棵子树，用前驱替代（也可用后继，此处与视频例5一致）
        AVLNode *pre = findPredecessor(root);
        root->key = pre->key;  // 复制前驱值到当前节点
        root->left = deleteBSTNode(root->left, pre->key);  // 删除前驱节点
    }

    // 2. 更新当前节点高度（删除后子树高度可能变化）
    updateHeight(root);

    return root;
}
```

### 6. 查找最小不平衡子树（从删除节点的祖先向上遍历）

c

```c
// 从当前节点（删除节点的父节点）向上查找最小不平衡子树的根
AVLNode *findMinUnbalancedSubtree(AVLNode *current, AVLNode *root) {
    AVLNode *minUnbalanced = NULL;
    // 向上遍历至根节点
    while (current != NULL) {
        int bf = getBalanceFactor(current);
        if (bf > 1 || bf < -1) {  // 找到第一个不平衡节点
            minUnbalanced = current;
            break;  // 最小不平衡子树，无需继续向上
        }
        // 向上移动（需父节点指针，此处简化：假设通过递归栈或父指针记录，实际工程需维护父指针）
        // 注：实际实现中，删除时需记录路径，此处为演示视频逻辑，简化处理
        current = (current->key < root->key) ? root->left : root->right;  // 仅为演示，实际需真实父节点
    }
    return minUnbalanced;
}
```

### 7. AVL 树删除主函数（执行五步步骤）

c

```c
// AVL树删除节点，返回删除后的根节点
AVLNode *deleteAVLNode(AVLNode *root, int key) {
    // 步骤1：按BST规则删除节点
    root = deleteBSTNode(root, key);
    if (root == NULL) return NULL;  // 树空，直接返回

    // 步骤2：查找最小不平衡子树（此处简化：从根向下检查，实际需从删除节点向上）
    // 注：实际工程中，删除时需记录路径，此处用递归检查替代“向上遍历”，逻辑一致
    AVLNode *minUnbalanced = root;
    // 简化：遍历树找最小不平衡子树（实际需从删除节点向上）
    // （真实实现需维护删除路径，此处为演示视频逻辑）

    // 步骤3-5：调整平衡并检查传导（循环至无不平衡）
    while (1) {
        // 步骤2：检查当前根是否不平衡（简化：假设minUnbalanced为当前需检查节点）
        int bf = getBalanceFactor(minUnbalanced);
        if (bf <= 1 && bf >= -1) {
            break;  // 无不平衡，结束
        }

        // 步骤3：确定最高儿子和最高孙子
        AVLNode *tallerChild = NULL;
        AVLNode *tallerGrandchild = NULL;
        if (bf > 1) {  // 左子树更高，最高儿子在左
            tallerChild = minUnbalanced->left;
            int bfChild = getBalanceFactor(tallerChild);
            if (bfChild >= 0) {  // 左子树的左子树更高（LL型）
                tallerGrandchild = tallerChild->left;
                minUnbalanced = rightRotate(minUnbalanced);  // 步骤4：右旋
            } else {  // 左子树的右子树更高（LR型）
                tallerGrandchild = tallerChild->right;
                minUnbalanced = lrRotate(minUnbalanced);     // 步骤4：LR双旋
            }
        } else {  // bf < -1，右子树更高，最高儿子在右
            tallerChild = minUnbalanced->right;
            int bfChild = getBalanceFactor(tallerChild);
            if (bfChild <= 0) {  // 右子树的右子树更高（RR型）
                tallerGrandchild = tallerChild->right;
                minUnbalanced = leftRotate(minUnbalanced);   // 步骤4：左旋
            } else {  // 右子树的左子树更高（RL型）
                tallerGrandchild = tallerChild->left;
                minUnbalanced = rlRotate(minUnbalanced);     // 步骤4：RL双旋
            }
        }

        // 步骤5：更新根并检查传导（简化：将调整后的子树作为新根，继续检查）
        updateHeight(minUnbalanced);
        // 若调整后的子树是原根，则无需继续；否则需向上检查（此处简化）
        if (minUnbalanced == root) {
            break;
        }
    }

    return root;
}
```

### 8. 测试函数

c

```c
// 中序遍历（验证BST特性）
void inOrder(AVLNode *root) {
    if (root == NULL) return;
    inOrder(root->left);
    printf("%d ", root->key);
    inOrder(root->right);
}

// 构建视频例2的初始树（简化：75为根，左60，右80；60右55；80右90）
AVLNode *buildExample2Tree() {
    AVLNode *root = (AVLNode *)malloc(sizeof(AVLNode));
    root->key = 75; root->left = NULL; root->right = NULL; root->height = 4;

    root->left = (AVLNode *)malloc(sizeof(AVLNode));
    root->left->key = 60; root->left->left = NULL; root->left->height = 2;
    root->left->right = (AVLNode *)malloc(sizeof(AVLNode));
    root->left->right->key = 55; root->left->right->left = NULL; root->left->right->right = NULL; root->left->right->height = 1;

    root->right = (AVLNode *)malloc(sizeof(AVLNode));
    root->right->key = 80; root->right->left = NULL; root->right->height = 3;
    root->right->right = (AVLNode *)malloc(sizeof(AVLNode));
    root->right->right->key = 90; root->right->right->left = NULL; root->right->right->right = NULL; root->right->right->height = 2;

    return root;
}

int main() {
    // 测试视频例2：删除55
    AVLNode *root = buildExample2Tree();
    printf("删除前中序遍历（验证BST）：");
    inOrder(root);  // 输出：60 55 75 80 90（注：原树中60左空，右55，中序应为55 60 75 80 90，此处修正构建逻辑）
    printf("\n");

    root = deleteAVLNode(root, 55);  // 删除55
    printf("删除后中序遍历（验证BST）：");
    inOrder(root);  // 输出：60 75 80 90（调整后BST特性保持）
    printf("\n");

    return 0;
}
```



# 红黑树知识点总结

## 1. 红黑树的背景与核心优势

红黑树属于**二叉查找树（排序树）家族**，与二叉排序树、平衡二叉树（AVL 树）解决同类查找问题，其诞生是为了弥补 AVL 树在插入 / 删除操作中的效率缺陷。

### 1.1 发展时间线

- 1960 年：二叉排序树提出（基础查找结构，易出现极端不平衡）
- 1962 年：平衡二叉树（AVL 树）提出（保证左右子树高度差≤1，查找效率稳定）
- 1972 年：红黑树（RBT）提出（兼顾查找效率与插入 / 删除操作效率）

### 1.2 红黑树 vs 平衡二叉树（AVL 树）

| 对比维度              | 平衡二叉树（AVL）                                      | 红黑树（RBT）                               |
| --------------------- | ------------------------------------------------------ | ------------------------------------------- |
| 平衡要求              | 严格平衡：任意节点左右子树高度差≤1                     | 近似平衡：通过颜色规则保证 “黑平衡”         |
| 插入 / 删除后调整频率 | 高：易破坏平衡，需频繁调整                             | 低：多数情况不破坏颜色规则，无需调整        |
| 调整前额外操作        | 需计算**平衡因子**、找**最小不平衡子树**（时间开销大） | 无需计算平衡因子 / 找子树，直接判断颜色规则 |
| 调整时间复杂度        | O (logn)（依赖子树高度）                               | O (1)（常数级，仅需旋转 / 变色）            |
| 工程实用性            | 低（插入 / 删除效率低）                                | 高（主流查找结构，如 STL 的 map/set）       |

### 1.3 应用场景

- 以**查询为主、插入 / 删除少**：用 AVL 树（严格平衡，查找更快）
- 需**频繁插入 / 删除**：用红黑树（调整成本低，整体效率更高）

## 2. 红黑树的定义

红黑树的核心是 “**二叉排序树基础 + 5 条颜色规则**”，即先满足二叉排序树的特性，再通过颜色约束保证近似平衡。

### 2.1 基础：二叉排序树的特性

红黑树首先是一棵二叉排序树，需满足：
**左子树所有节点值 < 根节点值 < 右子树所有节点值**（左小右大），保证查找逻辑与二叉排序树一致。

### 2.2 红黑树的节点结构

每个节点除了二叉树的基本属性，还需增加 “颜色” 和 “父节点指针”（调整时需向上追溯父节点），结构定义（C 语言示例）：

c

```c
// 颜色定义：0=黑色，1=红色（视频中推荐的标识方式）
typedef enum { BLACK = 0, RED = 1 } NodeColor;

// 红黑树节点结构体
typedef struct RedBlackNode {
    int key;                     // 关键字（节点值）
    struct RedBlackNode *left;   // 左孩子指针
    struct RedBlackNode *right;  // 右孩子指针
    struct RedBlackNode *parent; // 父节点指针（AVL树无此属性，红黑树调整需用）
    NodeColor color;             // 节点颜色（仅红/黑两种）
} RBTNode, *RBTree;
```

## 3. 红黑树的五大核心特性（必背）

视频中总结口诀：**“左根右，根叶黑，不红红，黑路同”**，对应以下 5 条特性，缺一不可。

### 特性 1：节点颜色约束

**每个节点要么是红色，要么是黑色**（无其他颜色，颜色由节点结构的`color`字段控制）。

### 特性 2：根节点颜色约束

**根节点必须是黑色**（视频中明确禁止根节点为红色，若插入后根为红，需直接改为黑）。

#### 反例

若根节点为红色（如下），违反特性 2，不是红黑树：

plaintext

```plaintext
    [13(红)]  // 根为红，违反特性2
   /        \
[空(黑)]  [空(黑)]
```

### 特性 3：叶子节点颜色约束

**叶子节点必须是黑色**，且此处 “叶子节点” 特指**查找失败的空节点（外部节点）**，而非实际存储关键字的 “终端节点”（视频中重点强调的概念）。

#### 示例（正确的叶子节点）

实际存储关键字的节点（如 13、8、17）不是 “特性 3 中的叶子”，其下方的空节点才是黑色叶子：

plaintext

```plaintext
        [13(黑)]
       /        \
    [8(红)]    [17(红)]
   /    \      /    \
[空(黑)] [空(黑)] [空(黑)] [空(黑)]  // 这些空节点是“叶子”，必须为黑
```

### 特性 4：无连续红色节点

**不存在两个相邻的红色节点**，即：

- 若一个节点是红色，则其**父节点**和**子节点**必须是黑色（红节点不能有红父 / 红子）。

#### 反例

17 和 15 均为红色且是父子关系，违反特性 4，不是红黑树：

plaintext

```plaintext
        [13(黑)]
       /        \
    [8(黑)]    [17(红)]  // 17是红
               /
           [15(红)]      // 15是红，与17相邻，违反特性4
```

### 特性 5：黑节点数量平衡（黑路同）

**从任意一个节点出发，到其所有叶子节点（空节点）的路径上，黑节点的数量相同**（称为 “黑平衡”，是红黑树近似平衡的核心）。

#### 示例（正确的黑路同）

以根节点 13 为例，所有路径的黑节点数均为 2（13 本身是黑 + 空叶子是黑）：

plaintext

```plaintext
        [13(黑)]  // 黑节点1
       /        \
    [8(红)]    [17(红)]  // 红节点不计入黑数
   /    \      /    \
[空(黑)] [空(黑)] [空(黑)] [空(黑)]  // 黑节点2，所有路径黑数=2
```

#### 反例（黑路不同）

从节点 1 出发，到左侧空叶子的黑数 = 1，到右侧空叶子的黑数 = 2，违反特性 5：

plaintext

```plaintext
    [1(黑)]  // 黑节点1
   /        \
[空(黑)]  [6(黑)]  // 右侧路径多一个黑节点6，黑数=2，违反特性5
           \
         [空(黑)]
```

## 4. 关键概念：黑高（Black Height）

视频中定义：**从某个节点出发，到任意叶子节点（空节点）的路径上，黑节点的总数**（注意：空叶子节点算 1 个黑节点）。

### 4.1 黑高的特性

由于红黑树满足 “黑路同”（特性 5），任意节点的黑高是**唯一确定的**（无需遍历所有路径，选一条即可计算）。

### 4.2 示例计算

以如下红黑树为例：

plaintext

```plaintext
        [13(黑)]  // 根节点
       /        \
    [8(红)]    [17(红)]
   /    \      /    \
[空(黑)] [11(黑)] [15(黑)] [空(黑)]
           \      /
         [空(黑)] [空(黑)]
```

- 根节点 13 的黑高：路径 13 (黑) → 8 (红) → 空 (黑)，黑节点数 = 2 → 黑高 = 2。
- 节点 17 的黑高：路径 17 (红) → 15 (黑) → 空 (黑)，黑节点数 = 2 → 黑高 = 2。
- 节点 11 的黑高：路径 11 (黑) → 空 (黑)，黑节点数 = 2 → 黑高 = 2。

## 5. 红黑树的重要性质推导（基于五大特性）

从五大特性可推导出两个关键结论，保证红黑树的查找效率。

### 性质 1：最长路径 ≤ 2× 最短路径

- 最短路径：全由黑节点组成（无红节点，黑数 = 黑高）。
- 最长路径：红黑交替（红节点最多，因特性 4 禁止连续红）。
	由于 “黑路同”（特性 5），最长路径的黑节点数 = 最短路径的黑节点数，因此最长路径长度≤2× 最短路径长度（红节点最多等于黑节点数）。

#### 示例

最短路径（黑数 = 2）：13 (黑) → 空 (黑)（长度 2）。
最长路径（红黑交替）：13 (黑) → 8 (红) → 11 (黑) → 空 (黑)（长度 4）。
4 ≤ 2×2，符合性质 1。

### 性质 2：高度约束（保证查找 O (logn)）

若红黑树有`n`个内部节点（存储关键字的节点），则树的高度`h ≤ 2log₂(n+1)`。
推导核心：由于最长路径≤2× 最短路径，且最短路径长度 = 黑高`bh`，可推出`bh ≥ h/2`；又因黑高对应的全黑树最少有`2^bh -1`个节点，最终得`h ≤ 2log₂(n+1)`。

#### 意义

高度`h`是`O(logn)`级别，因此红黑树的**查找、插入、删除操作时间复杂度均为 O (logn)**，与 AVL 树一致，但插入 / 删除的常数项更低。

## 6. 红黑树的基本操作：查找

视频中明确：红黑树的查找逻辑与**二叉排序树完全一致**，因查找仅依赖 “左小右大” 的特性，与节点颜色无关。

### 6.1 查找逻辑步骤

1. 从根节点开始，比较目标关键字`key`与当前节点关键字。
2. 若`key == 当前节点.key`：查找成功，返回当前节点。
3. 若`key < 当前节点.key`：向左子树递归查找（左子树小）。
4. 若`key > 当前节点.key`：向右子树递归查找（右子树大）。
5. 若递归到空节点（叶子节点）：查找失败，返回 NULL。

### 6.2 查找伪代码（与二叉排序树一致）

c

```c
// 查找关键字key，root为红黑树根节点，找到返回节点指针，否则返回NULL
RBTNode* RBT_Search(RBTree root, int key) {
    if (root == NULL) {
        return NULL;  // 递归到空节点，查找失败
    }
    if (key == root->key) {
        return root;  // 找到目标节点，返回
    } else if (key < root->key) {
        return RBT_Search(root->left, key);  // 左子树查找
    } else {
        return RBT_Search(root->right, key); // 右子树查找
    }
}
```

### 6.3 示例（查找关键字 15）

红黑树结构：

plaintext

```plaintext
        [13(黑)]
       /        \
    [8(红)]    [17(红)]
   /    \      /    \
[空(黑)] [11(黑)] [15(黑)] [空(黑)]
```

查找步骤：

1. 根节点 13：15>13 → 右子树（17）。
2. 节点 17：15<17 → 左子树（15）。
3. 节点 15：15==15 → 查找成功，返回 15 节点。



# 红黑树插入知识点总结

## 一、前置回顾：平衡二叉树的插入

红黑树插入与平衡二叉树插入逻辑相通，需先掌握平衡二叉树插入的核心流程：

1. **查找插入位置**：按二叉排序树规则（左小右大）确定新节点的父节点及插入方向（左 / 右子树）。
2. **判断平衡是否被破坏**：新节点插入后，检查是否导致树的平衡性（任意节点左右子树高度差≤1）被破坏。
3. **定位最小不平衡子树**：从新节点向上追溯，找到第一个左右子树高度差＞1 的节点，该节点为最小不平衡子树的根。
4. **按类型旋转调整**：根据新节点在最小不平衡子树中的位置，分为 4 种类型，对应不同旋转策略：
	- **LL 型**：新节点在最小不平衡子树的「左孩子的左子树」→ 右单旋。
	- **RR 型**：新节点在最小不平衡子树的「右孩子的右子树」→ 左单旋。
	- **LR 型**：新节点在最小不平衡子树的「左孩子的右子树」→ 先左旋（将 LR 转为 LL），再右单旋。
	- **RL 型**：新节点在最小不平衡子树的「右孩子的左子树」→ 先右旋（将 RL 转为 RR），再左单旋。

## 二、红黑树的核心特性

红黑树是「特殊的二叉排序树」，需同时满足以下 4 条特性：

1. **二叉排序树特性**：左子树所有节点值＜根节点值，右子树所有节点值＞根节点值（左小右大）。
2. **根叶黑**：
	- 根节点必须为黑色。
	- 叶节点（空指针 / 失败节点，虚拟节点，不实际分配内存）必须为黑色。
3. **不红红**：任意路径上无连续两个红色节点。
4. **黑路同**：任意节点到其所有叶节点的「黑色节点数」相同（称为该节点的「黑高」，视频定义：节点到叶节点的黑节点数，不包含自身）。

## 三、红黑树插入整体流程

视频将红黑树插入总结为「查找→染色→判断→调整」四步，流程如下：



![image-20250922191348598](../../../AppData/Roaming/Typora/typora-user-images/image-20250922191348598.png)









<svg aria-roledescription="flowchart-v2" role="graphics-document document" style="overflow: hidden; max-width: 526.71875px;" class="flowchart" xmlns="http://www.w3.org/2000/svg" width="100%" id="svg-mermaid-diagram-w0eiv4z" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ev="http://www.w3.org/2001/xml-events"><g id="viewport-20250922110956385" class="svg-pan-zoom_viewport" transform="matrix(0.2440978745557844,0,0,0.2440978745557844,106.21453631816021,0)" style="transform: matrix(0.244098, 0, 0, 0.244098, 106.215, 0);"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="svg-mermaid-diagram-w0eiv4z_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="svg-mermaid-diagram-w0eiv4z_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="svg-mermaid-diagram-w0eiv4z_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="svg-mermaid-diagram-w0eiv4z_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M143.784,56L143.784,60.167C143.784,64.333,143.784,72.667,143.784,80.333C143.784,88,143.784,95,143.784,98.5L143.784,102"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_C_1" d="M143.784,172L143.784,176.167C143.784,180.333,143.784,188.667,143.784,196.333C143.784,204,143.784,211,143.784,214.5L143.784,218"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_D_2" d="M143.784,270L143.784,274.167C143.784,278.333,143.784,286.667,143.854,294.417C143.924,302.167,144.065,309.334,144.135,312.917L144.205,316.501"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_E_3" d="M113.538,433.754L105.412,444.462C97.287,455.169,81.035,476.585,72.91,492.292C64.784,508,64.784,518,64.784,523L64.784,528"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_F_4" d="M175.03,433.754L182.989,444.462C190.948,455.169,206.866,476.585,214.825,492.292C222.784,508,222.784,518,222.784,523L222.784,528"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_F_G_5" d="M222.784,580L222.784,584.167C222.784,588.333,222.784,596.667,222.784,604.333C222.784,612,222.784,619,222.784,622.5L222.784,626"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_G_H_6" d="M222.784,678L222.784,682.167C222.784,686.333,222.784,694.667,222.854,702.417C222.924,710.167,223.065,717.334,223.135,720.917L223.205,724.501"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_H_I_7" d="M172.371,834.181L145.976,848.25C119.581,862.319,66.79,890.456,40.395,914.192C14,937.927,14,957.26,14,975.094C14,992.927,14,1009.26,14,1030.594C14,1051.927,14,1078.26,14,1106.094C14,1133.927,14,1163.26,14,1187.594C14,1211.927,14,1231.26,14,1249.094C14,1266.927,14,1283.26,30.672,1296.602C47.345,1309.944,80.689,1320.295,97.362,1325.47L114.034,1330.646"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_H_J_8" d="M255.583,852.795L263.259,863.761C270.935,874.728,286.286,896.661,293.962,912.627C301.638,928.594,301.638,938.594,301.638,943.594L301.638,948.594"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_J_K_9" d="M301.638,1000.594L301.638,1004.76C301.638,1008.927,301.638,1017.26,301.708,1025.011C301.779,1032.761,301.919,1039.928,301.989,1043.511L302.06,1047.095"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_K_L_10" d="M334.333,1126.899L350.539,1137.848C366.744,1148.797,399.156,1170.695,415.362,1186.645C431.568,1202.594,431.568,1212.594,431.568,1217.594L431.568,1222.594"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_K_M_11" d="M269.943,1126.899L253.571,1137.848C237.198,1148.797,204.453,1170.695,188.081,1186.645C171.708,1202.594,171.708,1212.594,171.708,1217.594L171.708,1222.594"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_M_I_12" d="M171.708,1274.594L171.708,1278.76C171.708,1282.927,171.708,1291.26,171.719,1298.927C171.729,1306.594,171.75,1313.594,171.76,1317.094L171.771,1320.594"></path><path marker-end="url(#svg-mermaid-diagram-w0eiv4z_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_L_I_13" d="M431.568,1274.594L431.568,1278.76C431.568,1282.927,431.568,1291.26,397.937,1301.772C364.307,1312.284,297.046,1324.974,263.415,1331.319L229.785,1337.664"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g transform="translate(64.78385543823242, 498)" class="edgeLabel"><g transform="translate(-6, -9)" class="label"><foreignObject height="18" width="12"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">是</p></span></div></foreignObject></g></g><g transform="translate(222.78385543823242, 498)" class="edgeLabel"><g transform="translate(-6, -9)" class="label"><foreignObject height="18" width="12"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">否</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g transform="translate(14, 1104.59375)" class="edgeLabel"><g transform="translate(-6, -9)" class="label"><foreignObject height="18" width="12"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">否</p></span></div></foreignObject></g></g><g transform="translate(301.63802337646484, 918.59375)" class="edgeLabel"><g transform="translate(-6, -9)" class="label"><foreignObject height="18" width="12"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">是</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g transform="translate(431.56771087646484, 1192.59375)" class="edgeLabel"><g transform="translate(-12, -9)" class="label"><foreignObject height="18" width="24"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">红色</p></span></div></foreignObject></g></g><g transform="translate(171.70833587646484, 1192.59375)" class="edgeLabel"><g transform="translate(-12, -9)" class="label"><foreignObject height="18" width="24"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">黑色</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(143.78385543823242, 32)" id="flowchart-A-1750" class="node default"><rect height="48" width="212.03125" y="-24" x="-106.015625" style="" class="basic label-container"></rect><g transform="translate(-76.015625, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="152.03125"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);">Unsupported markdown: list</span></div></foreignObject></g></g><g transform="translate(143.78385543823242, 139)" id="flowchart-B-1751" class="node default"><rect height="66" width="260" y="-33" x="-130" style="" class="basic label-container"></rect><g transform="translate(-100, -18)" style="" class="label"><rect></rect><foreignObject height="36" width="200"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">按二叉排序树规则，找到新节点的父节点及插入方向</p></span></div></foreignObject></g></g><g transform="translate(143.78385543823242, 246)" id="flowchart-C-1753" class="node default"><rect height="48" width="212.03125" y="-24" x="-106.015625" style="" class="basic label-container"></rect><g transform="translate(-76.015625, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="152.03125"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);">Unsupported markdown: list</span></div></foreignObject></g></g><g transform="translate(143.78385543823242, 392)" id="flowchart-D-1755" class="node default"><polygon transform="translate(-72,72)" class="label-container" points="72,0 144,-72 72,-144 0,-72"></polygon><g transform="translate(-48, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="96"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">新节点是否为根？</p></span></div></foreignObject></g></g><g transform="translate(64.78385543823242, 556)" id="flowchart-E-1757" class="node default"><rect height="48" width="108" y="-24" x="-54" style="" class="basic label-container"></rect><g transform="translate(-24, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="48"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">染为黑色</p></span></div></foreignObject></g></g><g transform="translate(222.78385543823242, 556)" id="flowchart-F-1759" class="node default"><rect height="48" width="108" y="-24" x="-54" style="" class="basic label-container"></rect><g transform="translate(-24, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="48"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">染为红色</p></span></div></foreignObject></g></g><g transform="translate(222.78385543823242, 654)" id="flowchart-G-1761" class="node default"><rect height="48" width="212.03125" y="-24" x="-106.015625" style="" class="basic label-container"></rect><g transform="translate(-76.015625, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="152.03125"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);">Unsupported markdown: list</span></div></foreignObject></g></g><g transform="translate(222.78385543823242, 806.296875)" id="flowchart-H-1763" class="node default"><polygon transform="translate(-78.296875,78.296875)" class="label-container" points="78.296875,0 156.59375,-78.296875 78.296875,-156.59375 0,-78.296875"></polygon><g transform="translate(-54.296875, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="108.59375"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">是否破坏“不红红”？</p></span></div></foreignObject></g></g><g transform="translate(171.85416793823242, 1348.59375)" id="flowchart-I-1765" class="node default"><rect height="48" width="108" y="-24" x="-54" style="" class="basic label-container"></rect><g transform="translate(-24, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="48"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">插入结束</p></span></div></foreignObject></g></g><g transform="translate(301.63802337646484, 976.59375)" id="flowchart-J-1767" class="node default"><rect height="48" width="212.03125" y="-24" x="-106.015625" style="" class="basic label-container"></rect><g transform="translate(-76.015625, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="152.03125"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);">Unsupported markdown: list</span></div></foreignObject></g></g><g transform="translate(301.63802337646484, 1104.59375)" id="flowchart-K-1769" class="node default"><polygon transform="translate(-54,54)" class="label-container" points="54,0 108,-54 54,-108 0,-54"></polygon><g transform="translate(-30, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="60"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">叔叔颜色？</p></span></div></foreignObject></g></g><g transform="translate(431.56771087646484, 1250.59375)" id="flowchart-L-1771" class="node default"><rect height="48" width="174.30208587646484" y="-24" x="-87.15104293823242" style="" class="basic label-container"></rect><g transform="translate(-57.15104293823242, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="114.30208587646484"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">染色+递归处理爷节点</p></span></div></foreignObject></g></g><g transform="translate(171.70833587646484, 1250.59375)" id="flowchart-M-1773" class="node default"><rect height="48" width="245.4166717529297" y="-24" x="-122.70833587646484" style="" class="basic label-container"></rect><g transform="translate(-92.70833587646484, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="185.4166717529297"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">旋转+染色（按LL/RR/LR/RL类型）</p></span></div></foreignObject></g></g></g></g></g></g></svg>

<svg aria-roledescription="flowchart-v2" role="graphics-document document" style="overflow: hidden; max-width: 526.71875px;" class="flowchart" xmlns="http://www.w3.org/2000/svg" width="100%" id="svg-mermaid-diagram-l2550vv" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ev="http://www.w3.org/2001/xml-events"><g id="viewport-20250922110956672" class="svg-pan-zoom_viewport" transform="matrix(0.7047692342515675,0,0,0.7047692342515675,11.3924149482786,0)" style="transform: matrix(0.704769, 0, 0, 0.704769, 11.3924, 0);"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="svg-mermaid-diagram-l2550vv_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="svg-mermaid-diagram-l2550vv_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="svg-mermaid-diagram-l2550vv_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="svg-mermaid-diagram-l2550vv_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="svg-mermaid-diagram-l2550vv_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M143.784,56L143.784,60.167C143.784,64.333,143.784,72.667,143.784,80.333C143.784,88,143.784,95,143.784,98.5L143.784,102"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_C_1" d="M143.784,172L143.784,176.167C143.784,180.333,143.784,188.667,143.784,196.333C143.784,204,143.784,211,143.784,214.5L143.784,218"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_D_2" d="M143.784,270L143.784,274.167C143.784,278.333,143.784,286.667,143.854,294.417C143.924,302.167,144.065,309.334,144.135,312.917L144.205,316.501"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_E_3" d="M113.538,433.754L105.412,444.462C97.287,455.169,81.035,476.585,72.91,492.292C64.784,508,64.784,518,64.784,523L64.784,528"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_F_4" d="M175.03,433.754L182.989,444.462C190.948,455.169,206.866,476.585,214.825,492.292C222.784,508,222.784,518,222.784,523L222.784,528"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_F_G_5" d="M222.784,580L222.784,584.167C222.784,588.333,222.784,596.667,222.784,604.333C222.784,612,222.784,619,222.784,622.5L222.784,626"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_G_H_6" d="M222.784,678L222.784,682.167C222.784,686.333,222.784,694.667,222.854,702.417C222.924,710.167,223.065,717.334,223.135,720.917L223.205,724.501"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_H_I_7" d="M172.371,834.181L145.976,848.25C119.581,862.319,66.79,890.456,40.395,914.192C14,937.927,14,957.26,14,975.094C14,992.927,14,1009.26,14,1030.594C14,1051.927,14,1078.26,14,1106.094C14,1133.927,14,1163.26,14,1187.594C14,1211.927,14,1231.26,14,1249.094C14,1266.927,14,1283.26,30.672,1296.602C47.345,1309.944,80.689,1320.295,97.362,1325.47L114.034,1330.646"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_H_J_8" d="M255.583,852.795L263.259,863.761C270.935,874.728,286.286,896.661,293.962,912.627C301.638,928.594,301.638,938.594,301.638,943.594L301.638,948.594"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_J_K_9" d="M301.638,1000.594L301.638,1004.76C301.638,1008.927,301.638,1017.26,301.708,1025.011C301.779,1032.761,301.919,1039.928,301.989,1043.511L302.06,1047.095"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_K_L_10" d="M334.333,1126.899L350.539,1137.848C366.744,1148.797,399.156,1170.695,415.362,1186.645C431.568,1202.594,431.568,1212.594,431.568,1217.594L431.568,1222.594"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_K_M_11" d="M269.943,1126.899L253.571,1137.848C237.198,1148.797,204.453,1170.695,188.081,1186.645C171.708,1202.594,171.708,1212.594,171.708,1217.594L171.708,1222.594"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_M_I_12" d="M171.708,1274.594L171.708,1278.76C171.708,1282.927,171.708,1291.26,171.719,1298.927C171.729,1306.594,171.75,1313.594,171.76,1317.094L171.771,1320.594"></path><path marker-end="url(#svg-mermaid-diagram-l2550vv_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_L_I_13" d="M431.568,1274.594L431.568,1278.76C431.568,1282.927,431.568,1291.26,397.937,1301.772C364.307,1312.284,297.046,1324.974,263.415,1331.319L229.785,1337.664"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g transform="translate(64.78385543823242, 498)" class="edgeLabel"><g transform="translate(-6, -9)" class="label"><foreignObject height="18" width="12"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">是</p></span></div></foreignObject></g></g><g transform="translate(222.78385543823242, 498)" class="edgeLabel"><g transform="translate(-6, -9)" class="label"><foreignObject height="18" width="12"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">否</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g transform="translate(14, 1104.59375)" class="edgeLabel"><g transform="translate(-6, -9)" class="label"><foreignObject height="18" width="12"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">否</p></span></div></foreignObject></g></g><g transform="translate(301.63802337646484, 918.59375)" class="edgeLabel"><g transform="translate(-6, -9)" class="label"><foreignObject height="18" width="12"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">是</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g transform="translate(431.56771087646484, 1192.59375)" class="edgeLabel"><g transform="translate(-12, -9)" class="label"><foreignObject height="18" width="24"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">红色</p></span></div></foreignObject></g></g><g transform="translate(171.70833587646484, 1192.59375)" class="edgeLabel"><g transform="translate(-12, -9)" class="label"><foreignObject height="18" width="24"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgb(245, 235, 255);">黑色</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; background-color: rgba(245, 235, 255, 0.5); display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8); background-color: rgb(245, 235, 255); text-align: center;"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(143.78385543823242, 32)" id="flowchart-A-1778" class="node default"><rect height="48" width="212.03125" y="-24" x="-106.015625" style="" class="basic label-container"></rect><g transform="translate(-76.015625, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="152.03125"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);">Unsupported markdown: list</span></div></foreignObject></g></g><g transform="translate(143.78385543823242, 139)" id="flowchart-B-1779" class="node default"><rect height="66" width="260" y="-33" x="-130" style="" class="basic label-container"></rect><g transform="translate(-100, -18)" style="" class="label"><rect></rect><foreignObject height="36" width="200"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">按二叉排序树规则，找到新节点的父节点及插入方向</p></span></div></foreignObject></g></g><g transform="translate(143.78385543823242, 246)" id="flowchart-C-1781" class="node default"><rect height="48" width="212.03125" y="-24" x="-106.015625" style="" class="basic label-container"></rect><g transform="translate(-76.015625, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="152.03125"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);">Unsupported markdown: list</span></div></foreignObject></g></g><g transform="translate(143.78385543823242, 392)" id="flowchart-D-1783" class="node default"><polygon transform="translate(-72,72)" class="label-container" points="72,0 144,-72 72,-144 0,-72"></polygon><g transform="translate(-48, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="96"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">新节点是否为根？</p></span></div></foreignObject></g></g><g transform="translate(64.78385543823242, 556)" id="flowchart-E-1785" class="node default"><rect height="48" width="108" y="-24" x="-54" style="" class="basic label-container"></rect><g transform="translate(-24, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="48"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">染为黑色</p></span></div></foreignObject></g></g><g transform="translate(222.78385543823242, 556)" id="flowchart-F-1787" class="node default"><rect height="48" width="108" y="-24" x="-54" style="" class="basic label-container"></rect><g transform="translate(-24, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="48"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">染为红色</p></span></div></foreignObject></g></g><g transform="translate(222.78385543823242, 654)" id="flowchart-G-1789" class="node default"><rect height="48" width="212.03125" y="-24" x="-106.015625" style="" class="basic label-container"></rect><g transform="translate(-76.015625, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="152.03125"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);">Unsupported markdown: list</span></div></foreignObject></g></g><g transform="translate(222.78385543823242, 806.296875)" id="flowchart-H-1791" class="node default"><polygon transform="translate(-78.296875,78.296875)" class="label-container" points="78.296875,0 156.59375,-78.296875 78.296875,-156.59375 0,-78.296875"></polygon><g transform="translate(-54.296875, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="108.59375"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">是否破坏“不红红”？</p></span></div></foreignObject></g></g><g transform="translate(171.85416793823242, 1348.59375)" id="flowchart-I-1793" class="node default"><rect height="48" width="108" y="-24" x="-54" style="" class="basic label-container"></rect><g transform="translate(-24, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="48"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">插入结束</p></span></div></foreignObject></g></g><g transform="translate(301.63802337646484, 976.59375)" id="flowchart-J-1795" class="node default"><rect height="48" width="212.03125" y="-24" x="-106.015625" style="" class="basic label-container"></rect><g transform="translate(-76.015625, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="152.03125"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);">Unsupported markdown: list</span></div></foreignObject></g></g><g transform="translate(301.63802337646484, 1104.59375)" id="flowchart-K-1797" class="node default"><polygon transform="translate(-54,54)" class="label-container" points="54,0 108,-54 54,-108 0,-54"></polygon><g transform="translate(-30, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="60"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">叔叔颜色？</p></span></div></foreignObject></g></g><g transform="translate(431.56771087646484, 1250.59375)" id="flowchart-L-1799" class="node default"><rect height="48" width="174.30208587646484" y="-24" x="-87.15104293823242" style="" class="basic label-container"></rect><g transform="translate(-57.15104293823242, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="114.30208587646484"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">染色+递归处理爷节点</p></span></div></foreignObject></g></g><g transform="translate(171.70833587646484, 1250.59375)" id="flowchart-M-1801" class="node default"><rect height="48" width="245.4166717529297" y="-24" x="-122.70833587646484" style="" class="basic label-container"></rect><g transform="translate(-92.70833587646484, -9)" style="" class="label"><rect></rect><foreignObject height="18" width="185.4166717529297"><div xmlns="http://www.w3.org/1999/xhtml" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel" style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto; fill: rgba(0, 0, 0, 0.8); color: rgba(0, 0, 0, 0.8);"><p style="border: 0px solid; box-sizing: border-box; margin: 0px; padding: 0px; -webkit-font-smoothing: antialiased; overflow-anchor: auto;">旋转+染色（按LL/RR/LR/RL类型）</p></span></div></foreignObject></g></g></g></g></g></g></svg>



### 关键说明：为何仅需检查 “不红红”？

- 「左小右大」：插入位置由二叉排序树规则确定，天然满足。
- 「根叶黑」：根节点初始染黑，叶节点为虚拟黑节点，初始处理后满足。
- 「黑路同」：非根节点初始染红色（红色节点不增加黑节点数），不会改变任意路径的黑节点数，故初始不破坏。

## 四、红黑树插入关键步骤详解

### 4.1 步骤 1：查找插入位置（二叉排序树规则）

与平衡二叉树一致，从根节点出发：

- 若新节点值＜当前节点值 → 向左子树查找；
- 若新节点值＞当前节点值 → 向右子树查找；
- 直到当前节点为叶节点（NIL），将新节点插入到该叶节点的父节点的左 / 右位置。

### 4.2 步骤 2：初始染色规则（核心！）

- **根节点**：必须染黑（满足「根叶黑」）。
- **非根节点**：必须染红（视频解释：若染黑，会导致该路径的黑节点数比其他路径多 1，破坏「黑路同」；染红则不增加黑节点数，仅可能破坏「不红红」，后续只需针对性调整）。

#### 反例（视频提及）：

插入 10 到根节点 20 的左子树：

- 若 10 染黑 → 左路径（20→10→NIL）黑节点数 = 2，右路径（20→NIL）黑节点数 = 1 → 破坏「黑路同」；
- 若 10 染红 → 左路径黑节点数 = 1，右路径黑节点数 = 1 → 满足「黑路同」，仅需关注是否与父节点（20 黑）连续红（此处父为黑，无问题）。

### 4.3 步骤 3：调整策略（核心！）

调整的前提是「新节点与父节点均为红色」（破坏「不红红」），调整依据是「新节点的叔叔颜色」（叔叔 = 新节点父节点的兄弟）。

![image-20250922192833567](../../../AppData/Roaming/Typora/typora-user-images/image-20250922192833567.png)

#### 先明确关键概念：

- **叔叔**：新节点父节点（P）的兄弟节点（S）；
- **爷节点**：新节点父节点的父节点（G）；
- **节点类型**：从爷节点（G）出发，新节点的位置分类（与平衡二叉树一致）：
	- LL 型：G→P（左）→新节点（左）；
	- RR 型：G→P（右）→新节点（右）；
	- LR 型：G→P（左）→新节点（右）；
	- RL 型：G→P（右）→新节点（左）。

#### 情况 1：叔叔是红色（S=RED）

**处理流程（视频总结）**：

1. **染色**：父节点（P）→黑、叔叔（S）→黑、爷节点（G）→红；
2. **递归处理**：将爷节点（G）视为「新节点」，重复调整逻辑（判断 G 是否与它的父节点连续红，直到根节点）；
3. **最终确保根黑**：若递归到根节点，将根染黑（满足「根叶黑」）。

##### 视频示例：插入 30（当前树：10（黑）左 5（红）右 20（红））

- 新节点 30：父 20（红），叔叔 5（红），爷 10（黑）；
- 染色：20→黑、5→黑、10→红；
- 递归处理爷节点 10（新节点）：10 是根，染黑；
- 最终树：10（黑）左 5（黑）右 20（黑）右 30（红）（满足所有特性）。

#### 情况 2：叔叔是黑色（S=BLACK，含 S=NIL 的情况）

**处理流程（视频总结）**：

1. **按类型旋转**：与平衡二叉树的旋转规则完全一致；
2. **染色**：旋转后，交换「原父节点（P）」与「原爷节点（G）」的颜色（红→黑，黑→红）；
3. **调整结束**：旋转 + 染色后，必然满足所有特性，无需递归。

##### 各类型旋转 + 染色细节（视频示例）：

| 节点类型 | 旋转步骤                                                  | 染色对象             | 视频示例（插入 5）                                           |
| -------- | --------------------------------------------------------- | -------------------- | ------------------------------------------------------------ |
| LL 型    | 对爷节点（G）右单旋                                       | 原 P→黑，原 G→红     | G=20，P=10，新节点 = 5：右单旋后 10 为根，10→黑，20→红       |
| RR 型    | 对爷节点（G）左单旋                                       | 原 P→黑，原 G→红     | 插入 40（父 30 红，叔 NIL 黑，RR 型）：左单旋 G=20，P=30→黑，20→红 |
| LR 型    | 1. 对父节点（P）左单旋（转为 LL）；2. 对爷节点（G）右单旋 | 原新节点→黑，原 G→红 | 插入 23（父 22 红，叔 18 黑，LR 型）：先左旋 P=22，再右旋 G=25，23→黑，25→红 |
| RL 型    | 1. 对父节点（P）右单旋（转为 RR）；2. 对爷节点（G）左单旋 | 原新节点→黑，原 G→红 | 插入 18（父 19 红，叔 22 黑，RL 型）：先右旋 P=19，再左旋 G=18，新 18→黑，原 18→红 |

## 五、完整插入示例（视频中的插入序列：20→10→5→30→40→57→3→2→4→35→25→18→22→23→24→19→18）

### 示例 1：插入 20（根节点）

- 步骤：查找→根节点，染色→黑；
- 树结构：`20（黑）`。

### 示例 2：插入 10（非根）

- 步骤：查找→20 左子树，染色→红；
- 检查：父 20（黑），无连续红，无需调整；
- 树结构：`20（黑）左10（红）`。

### 示例 3：插入 5（非根，破坏不红红）

- 步骤：查找→10 左子树，染色→红；
- 检查：父 10（红），破坏不红红；
- 调整：叔叔 = NIL（黑），LL 型；
	1. 对 20 右单旋：10 成为根，20 成为 10 右子树；
	2. 染色：10→黑，20→红；
- 树结构：`10（黑）左5（红）右20（红）`。

### 示例 4：插入 30（非根，破坏不红红）

- 步骤：查找→20 右子树，染色→红；
- 检查：父 20（红），破坏不红红；
- 调整：叔叔 = 5（红）；
	1. 染色：20→黑，5→黑，10→红；
	2. 递归处理 10（根），染黑；
- 树结构：`10（黑）左5（黑）右20（黑）右30（红）`。

### 示例 5：插入 40（非根，破坏不红红）

- 步骤：查找→30 右子树，染色→红；
- 检查：父 30（红），破坏不红红；
- 调整：叔叔 = NIL（黑），RR 型；
	1. 对 20 左单旋：30 成为 20 父节点，20 成为 30 左子树；
	2. 染色：30→黑，20→红；
- 树结构：`10（黑）左5（黑）右30（黑）左20（红）右40（红）`。

（后续插入示例逻辑一致，均遵循 “查找→染色→判断→调整” 流程，此处省略，可参考视频逐步验证）

## 六、黑高与红黑树高度推论

### 6.1 黑高定义（视频明确）

- 节点的黑高：该节点到任意叶节点的「黑色节点数」（不包含节点自身）；
- 根节点的黑高：整棵树的黑高（记为 h）。

### 6.2 核心推论 1：红黑树内部节点数最小值

- 前提：根黑高为 h；
- 结论：内部节点数（含关键字的节点）最少为 `2^h - 1`；
- 视频解释：最少情况是「全黑节点的满二叉树」（若有红节点，内部节点数会更多），满二叉树高度 h（黑高）的节点数为 `2^h - 1`。

### 6.3 核心推论 2：红黑树高度上限

- 前提：内部节点数为 n；
- 结论：红黑树的高度 H ≤ `2log₂(n+1)`；
- 视频证明过程：
	1. 由「不红红」特性：任意路径的红节点数≤黑节点数 → 树的高度 H ≤ 2h（h 为根黑高）；
	2. 由推论 1：n ≥ 2^h - 1 → h ≤ log₂(n+1)；
	3. 联立得：H ≤ 2log₂(n+1)。

## 七、红黑树与平衡二叉树的对比

| 对比维度            | 平衡二叉树                     | 红黑树                      |
| ------------------- | ------------------------------ | --------------------------- |
| 平衡条件            | 任意节点左右子树高度差≤1       | 任意节点左右子树高度差≤2 倍 |
| 特性破坏难度        | 易破坏（条件严格）             | 难破坏（条件宽松）          |
| 插入 / 删除调整次数 | 较多（需频繁找最小不平衡子树） | 较少（仅需按叔叔颜色调整）  |
| 效率                | 较低                           | 较高（实际应用中更常用）    |

## 八、红黑树插入核心代码

### 8.1 数据结构定义

c

```c
#include <stdio.h>
#include <stdlib.h>

// 颜色枚举（视频中红黑两种颜色）
typedef enum { RED, BLACK } Color;

// 红黑树节点结构（含父指针，用于向上调整）
typedef struct RBNode {
    int key;                // 关键字（视频中为int类型）
    Color color;            // 颜色
    struct RBNode *left;    // 左孩子（默认指向NIL）
    struct RBNode *right;   // 右孩子（默认指向NIL）
    struct RBNode *parent;  // 父节点（默认指向NIL）
} RBNode, *RBTree;

// 全局NIL节点（视频中的叶节点/空指针，黑色）
RBNode NIL_NODE = {0, BLACK, NULL, NULL, NULL};
RBNode *NIL = &NIL_NODE;
```

### 8.2 旋转函数（视频中的旋转逻辑）

#### 右单旋（处理 LL 型）

c

```c
// 对x节点右单旋（x为爷节点，视频中LL型需旋转爷节点）
void RightRotate(RBTree *T, RBNode *x) {
    RBNode *y = x->left;    // y是x的左孩子（原父节点P）
    x->left = y->right;     // y的右子树转为x的左子树
    if (y->right != NIL) {
        y->right->parent = x;
    }
    y->parent = x->parent;  // x的父节点转为y的父节点
    // 处理y的父节点指向（若x是根，y成为新根）
    if (x->parent == NIL) {
        *T = y;
    } else if (x == x->parent->right) {
        x->parent->right = y;
    } else {
        x->parent->left = y;
    }
    y->right = x;           // x成为y的右孩子
    x->parent = y;
}
```

#### 左单旋（处理 RR 型）

c

```c
// 对x节点左单旋（x为爷节点，视频中RR型需旋转爷节点）
void LeftRotate(RBTree *T, RBNode *x) {
    RBNode *y = x->right;   // y是x的右孩子（原父节点P）
    x->right = y->left;     // y的左子树转为x的右子树
    if (y->left != NIL) {
        y->left->parent = x;
    }
    y->parent = x->parent;  // x的父节点转为y的父节点
    // 处理y的父节点指向（若x是根，y成为新根）
    if (x->parent == NIL) {
        *T = y;
    } else if (x == x->parent->left) {
        x->parent->left = y;
    } else {
        x->parent->right = y;
    }
    y->left = x;            // x成为y的左孩子
    x->parent = y;
}
```

### 8.3 插入调整函数

c

```c
// 插入后调整（处理“不红红”问题）
void RBInsertFixup(RBTree *T, RBNode *z) {
    // 循环条件：父节点为红色（破坏不红红）
    while (z->parent->color == RED) {
        // 情况A：父节点是爷节点的左孩子
        if (z->parent == z->parent->parent->left) {
            RBNode *y = z->parent->parent->right;  // 叔叔（爷的右孩子）
            
            // 子情况1：叔叔是红色
            if (y->color == RED) {
                z->parent->color = BLACK;          // 父→黑
                y->color = BLACK;                  // 叔叔→黑
                z->parent->parent->color = RED;    // 爷→红
                z = z->parent->parent;             // 爷视为新节点，继续循环
            } 
            // 子情况2：叔叔是黑色
            else {
                // 子情况2a：新节点是父的右孩子（LR型）→ 先左旋转为LL型
                if (z == z->parent->right) {
                    z = z->parent;
                    LeftRotate(T, z);
                }
                // 子情况2b：新节点是父的左孩子（LL型）→ 右单旋+染色
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                RightRotate(T, z->parent->parent);
            }
        } 
        // 情况B：父节点是爷节点的右孩子（与情况A对称）
        else {
            RBNode *y = z->parent->parent->left;   // 叔叔（爷的左孩子）
            
            // 子情况1：叔叔是红色
            if (y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } 
            // 子情况2：叔叔是黑色
            else {
                // 子情况2a：新节点是父的左孩子（RL型）→ 先右旋转为RR型
                if (z == z->parent->left) {
                    z = z->parent;
                    RightRotate(T, z);
                }
                // 子情况2b：新节点是父的右孩子（RR型）→ 左单旋+染色
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                LeftRotate(T, z->parent->parent);
            }
        }
    }
    (*T)->color = BLACK;  // 确保根节点为黑色（满足根叶黑）
}
```

### 8.4 插入主函数

c

```c
// 红黑树插入（入口函数）
void RBInsert(RBTree *T, int key) {
    // 1. 步骤1：创建新节点并初始化
    RBNode *z = (RBNode *)malloc(sizeof(RBNode));
    z->key = key;
    z->color = RED;         // 非根节点初始染红（后续根节点会修正为黑）
    z->left = NIL;
    z->right = NIL;
    z->parent = NIL;

    // 2. 步骤1：查找插入位置（二叉排序树规则）
    RBNode *y = NIL;        // y记录x的父节点
    RBNode *x = *T;         // x从根开始查找
    while (x != NIL) {
        y = x;
        if (z->key < x->key) {
            x = x->left;
        } else {
            x = x->right;
        }
    }
    z->parent = y;
    // 确定新节点是y的左孩子还是右孩子
    if (y == NIL) {         // y是NIL → 新节点是根
        *T = z;
        z->color = BLACK;   // 根节点染黑
        return;
    } else if (z->key < y->key) {
        y->left = z;
    } else {
        y->right = z;
    }

    // 3. 步骤3：调整（若破坏不红红）
    RBInsertFixup(T, z);
}
```

### 8.5 辅助函数：中序遍历（验证二叉排序树特性）

c

```c
// 中序遍历（左→根→右，结果应为升序，验证左小右大）
void InOrderTraverse(RBTree T) {
    if (T != NIL) {
        InOrderTraverse(T->left);
        printf("key=%d, color=%s\n", T->key, T->color == RED ? "RED" : "BLACK");
        InOrderTraverse(T->right);
    }
}
```

### 8.6 测试代码

c

```c
int main() {
    RBTree T = NIL;
    // 视频中的插入序列
    int keys[] = {20, 10, 5, 30, 40, 57, 3, 2, 4, 35, 25, 18, 22, 23, 24, 19, 18};
    int n = sizeof(keys) / sizeof(keys[0]);

    for (int i = 0; i < n; i++) {
        RBInsert(&T, keys[i]);
        printf("插入%d后，中序遍历（升序验证）：\n", keys[i]);
        InOrderTraverse(T);
        printf("-------------------------\n");
    }

    return 0;
}
```



# 红黑树删除操作知识点总结

## 一、学习前提与难度提示

1. **难度层级**：视频明确强调 “红黑树的删除要比红黑树的插入还要难得多”，是红黑树操作中复杂度最高的部分，需提前做好心理准备。
2. **前置知识要求**：
	- 已掌握红黑树的定义、核心特性及插入操作；
	- 已掌握二叉排序树（BST）的删除逻辑；
	- 已理解平衡二叉树（AVL）的删除思路（视频类比 “平衡二叉树删除的初始处理与二叉排序树一致”，红黑树删除逻辑同理）。

## 二、核心考点

### 1. 时间复杂度

红黑树删除操作的时间复杂度为 **O(log₂n)**（n 为树中节点总数）。

核心原因：红黑树通过特性约束保持 “近似平衡”，树的高度始终稳定在 O (log₂n) 级别，删除操作（含后续调整）的执行步骤与树高正相关。

### 2. 与二叉排序树删除的关联

红黑树删除的**初始节点移除逻辑，完全遵循二叉排序树的删除规则**，视频明确表述 “二叉排序树的删除怎么做，那在红黑树当中，你删除一个节点的时候就那么做”，具体分三类场景：

- 场景 1：待删除节点为**叶子节点**（无左、右子节点）→ 直接删除该节点；
- 场景 2：待删除节点**只有一个子节点**（左子或右子节点）→ 用子节点替换待删除节点的位置，再删除原待删除节点；
- 场景 3：待删除节点**有两个子节点**→ 先找到该节点的 “中序前驱”（左子树中值最大的节点）或 “中序后继”（右子树中值最小的节点），用前驱 / 后继的值覆盖待删除节点的值，再按场景 1 或场景 2 删除前驱 / 后继节点（前驱 / 后继必为叶子节点或单子节点）。

### 3. 删除后的特性修复

删除节点后，红黑树的核心特性（“左根右根叶黑不红，红黑路同”）可能被破坏（例如某条路径黑节点数量减少、出现连续红色节点等），需通过两步操作恢复：

1. **调整节点颜色**：修改部分节点的红 / 黑属性，优先修复 “黑高不一致” 或 “连续红节点” 问题；
2. **调整节点位置（旋转）**：若仅改颜色无法修复，需执行左旋或右旋操作，调整树的结构以满足特性（视频未展开具体旋转逻辑，仅强调 “需通过一系列调整操作恢复特性”）。

## 三、红黑树核心特性（删除后需维护的基准）

视频用通俗语言概括红黑树必须满足的特性：**“左根右根叶黑不红，红黑路同”**，对应经典定义的 5 条特性：

1. 节点颜色约束：每个节点要么是红色，要么是黑色；
2. 根节点颜色：根节点必须是黑色（“左根右根” 的核心要求）；
3. 叶子节点颜色：所有叶子节点（NIL 空节点）必须是黑色（“叶黑不红” 的直接体现）；
4. 红色节点子节点约束：若一个节点是红色，则它的两个子节点必须是黑色（避免 “连续红节点”，呼应 “叶黑不红”）；
5. 黑高一致性：从任意节点到其所有叶子节点的路径上，黑色节点的数量相同（“红黑路同” 的本质，即 “黑高相等”）。

## 四、考试命题预测

### 1. 近 2 年（2023 年、2024 年）命题结论：红黑树删除 “不考”

视频给出 3 点关键依据：

- 红黑树是 **2022 年新增的 408 大纲考点**，截至 2022 年 408 考试中从未考察过红黑树相关题目，属于 “新考点”；
- 新考点命题规律：出题不会直接选择 “最难、最复杂” 的内容（类比 “学开车不会直接挂六档上高速”），删除作为红黑树中最复杂的操作，不符合 “循序渐进” 的命题逻辑；
- 时间成本性价比：视频提及 “学习红黑树删除需 3~4 小时，对考生而言性价比极低”，无需投入过多精力。

### 2. 近 2 年重点备考方向

- 首要重点：**红黑树的定义与核心特性**（选择题高频，是新考点的基础命题方向）；
- 次要关注：红黑树的插入操作（考察概率较低，视频提及 “甚至连插入操作考察的概率也许都不大”）；
- 无需深入：红黑树的删除操作（仅需记住 “时间复杂度 O (log₂n)、初始逻辑同 BST、需调整特性”3 个考点即可）。





# B 树知识点总结

## 1. 基础铺垫：从二叉查找树到 M 叉查找树

视频通过 “先回顾二叉查找树，再扩展到 M 叉查找树” 的逻辑引入 B 树，核心是理解 “多叉树通过关键字分割查找区间” 的本质。

### 1.1 二叉查找树的核心特点

- **查找逻辑**：通过单个关键字将查找区间分为 2 份（左子树 < 当前节点 < 右子树）。
	例：根节点 29 将区间分为「-∞~29」（左子树）和「29~+∞」（右子树），查找时按目标值与当前节点的大小关系选择子树。
- **问题**：若关键字总数固定，二叉查找树可能 “细长”（高度高），导致查找效率低（需遍历更多层节点）。

### 1.2 M 叉查找树的定义与示例（以五叉查找树为例）

M 叉查找树是二叉查找树的扩展，**每个节点可包含多个关键字，对应多个子树**，核心逻辑与二叉查找树一致：通过关键字分割查找区间，查找时按区间选择子树。

#### 1.2.1 五叉查找树的结构特征

- **节点组成**：最多 4 个关键字（`k1<k2<k3<k4`），最多 5 个孩子（`p0~p4`），用`keyNum`记录实际关键字个数。
- **区间分割规则**：n 个关键字将查找区间分为 n+1 份，对应 n+1 个孩子：
	- `p0`子树的关键字 ∈ 「-∞~k1」
	- `p1`子树的关键字 ∈ 「k1~k2」
	- ...
	- `pn`子树的关键字 ∈ 「kn~+∞」
- **失败节点**：视频中紫色节点，代表 “查找目标不在树中” 的情况，对应某一空白区间（如「15~22」「36~40」），本质是`NULL`指针。

#### 1.2.2 五叉查找树的查找示例

视频通过两个案例讲解查找过程，查找时**先顺序扫描节点内关键字（也可折半查找，因关键字有序），再选择对应子树**：

##### 案例 1：查找关键字 9（成功）

1. 根节点关键字为 22，9<22 → 进入`p0`子树（左孩子）；
2. 左孩子关键字为 5、11，5<9<11 → 进入`p1`子树（5 和 11 之间的孩子）；
3. 该子树包含关键字 9 → 查找成功。

##### 案例 2：查找关键字 41（失败）

1. 根节点关键字为 22，41>22 → 进入`p1`子树（右孩子）；
2. 右孩子关键字为 36、45，36<41<45 → 进入`p1`子树（36 和 45 之间的孩子）；
3. 该子树关键字为 40、42，40<41<42 → 进入`p1`子树（40 和 42 之间的孩子）；
4. 该位置为失败节点（`NULL`） → 查找失败。

## 2. B 树的定义与核心特性

视频明确：**B 树是 “满足特定约束的 M 叉查找树”**，核心目标是 “保证树的矮胖结构，提升查找效率”，约束包括 “节点关键字数量下限” 和 “绝对平衡”。

### 2.1 B 树的基本概念

- **别名**：多路平衡查找树。
	- “多路”：每个节点有多个子树（分叉）；
	- “平衡”：**所有子树高度相同（绝对平衡）**，区别于平衡二叉树（允许左右子树高度差≤1）。
- **阶的定义**：B 树中所有节点的孩子个数的最大值，记为`m`（例：五阶 B 树的每个节点最多 5 个孩子）。

### 2.2 M 阶 B 树的 5 个核心特性

视频强调 “B 树的性质是考试重点”，需严格掌握以下 5 点（空树除外）：

1. **节点孩子数上限**：每个节点最多有`m`个孩子 → 最多有`m-1`个关键字（因 n 个关键字对应 n+1 个孩子）。
	例：五阶 B 树（m=5）的节点最多 5 个孩子，最多 4 个关键字。
2. **根节点特殊规则**：若根节点不是终端节点（即有子树），则至少有 2 个孩子 → 至少 1 个关键字（视频解释：初始 B 树可能仅含 1 个关键字，无法满足 “≥⌈m/2⌉个孩子”，故根节点例外）。
3. **非根节点下限**：除根节点外，所有非终端节点至少有`⌈m/2⌉`个孩子 → 至少有`⌈m/2⌉ - 1`个关键字（核心约束：避免节点过空，保证树 “矮胖”）。
	例：五阶 B 树（m=5）的非根节点至少`⌈5/2⌉=3`个孩子，至少 2 个关键字。
4. **关键字与子树的有序性**：
	- 节点内关键字按递增（或递减）排序（视频默认递增：`k1<k2<...<kn`）；
	- 第`i`个孩子（`pi`）的所有关键字 ∈ 「`ki-1`~`ki`」（`k0=-∞`，`kn+1=+∞`）。
5. **叶子节点统一层**：所有叶子节点（即失败节点）出现在同一层，且不带信息（本质是`NULL`指针，视频强调 “此为绝对平衡的必然结果”）。

> 术语区分（视频特别说明）：
>
> - 叶子节点：失败节点（查找失败的终点，无数据）；
> - 终端节点：最下层存储实际数据的节点（非失败节点）。

## 3. B 树的节点结构

视频明确 “B 树代码不要求掌握，但需理解节点结构”，以 M 阶 B 树为例，节点的逻辑结构如下（C 语言风格结构体，与视频描述完全一致）：

c

```c
#define m 5  // 定义B树的阶（示例为五阶B树）
typedef struct BTreeNode {
    int keyNum;                  // 节点中实际的关键字个数（1≤keyNum≤m-1，根节点可例外为1）
    int key[m-1];                // 存储关键字的数组（最多m-1个，因m个孩子对应m-1个关键字）
    struct BTreeNode *child[m];  // 存储孩子节点指针的数组（最多m个）
} BTreeNode, *BTree;
```

- 五阶 B 树（m=5）的节点：`key[4]`（最多 4 个关键字）、`child[5]`（最多 5 个孩子）、`keyNum`（实际关键字数，非根节点≥2，根节点≥1）。

## 4. B 树的高度计算

视频定义 “B 树的高度`h`不包含叶子节点（失败节点）”，需计算含`n`个关键字的 M 阶 B 树的**最小高度**（树最矮）和**最大高度**（树最高），核心思路是 “通过关键字数量约束推导高度范围”。

### 4.1 最小高度`h_min`（树最矮：每个节点尽量存满关键字）

#### 推导逻辑

- 目标：让树最矮 → 每个节点尽可能存满（最多`m-1`个关键字，`m`个孩子）；
- 各层节点数与关键字数：
	- 第 1 层（根节点）：1 个节点，最多`m-1`个关键字；
	- 第 2 层：最多`m`个节点，每个最多`m-1`个关键字 → 总关键字数≤`m*(m-1)`；
	- 第 3 层：最多`m²`个节点 → 总关键字数≤`m²*(m-1)`；
	- ...
	- 第`h`层：最多`m^(h-1)`个节点 → 总关键字数≤`m^(h-1)*(m-1)`；
- 总关键字数`n`的上限：`n ≤ (m-1)*(1 + m + m² + ... + m^(h-1))`。

#### 公式推导（等比数列求和）

等比数列求和：`1 + m + m² + ... + m^(h-1) = (m^h - 1)/(m - 1)`
代入上限公式：
`n ≤ (m-1) * (m^h - 1)/(m - 1) = m^h - 1`
变形得最小高度：
`h_min ≥ log_m(n + 1)`

#### 示例（视频隐含）

- 五阶 B 树（m=5），n=10 个关键字：`h_min ≥ log_5(10+1) ≈ 1.49` → 取整`h_min=2`。

### 4.2 最大高度`h_max`（树最高：每个节点尽量存空关键字）

#### 关键前提（视频强调）

- 特性：含`n`个关键字的 B 树，必有`n+1`个叶子节点（失败节点，因 n 个关键字分割为 n+1 个区间）；
- 目标：让树最高 → 每个节点尽可能存空（非根节点至少`⌈m/2⌉`个孩子、`⌈m/2⌉-1`个关键字；根节点至少 2 个孩子、1 个关键字）。

#### 推导逻辑

设`t = ⌈m/2⌉`（非根节点的最小孩子数），各层叶子节点数（失败节点数）的下限：

- 第 1 层（根节点）：1 个节点，至少 2 个孩子 → 第 2 层至少 2 个节点；
- 第 2 层：每个节点至少`t`个孩子 → 第 3 层至少`2*t`个节点；
- 第 3 层：每个节点至少`t`个孩子 → 第 4 层至少`2*t²`个节点；
- ...
- 第`h`层：至少`2*t^(h-2)`个节点 → 第`h+1`层（叶子节点）至少`2*t^(h-1)`个节点。

#### 公式推导

因叶子节点数 = `n+1`，且叶子节点数≥`2*t^(h-1)`，故：
`n+1 ≥ 2*t^(h-1)`
代入`t=⌈m/2⌉`，变形得最大高度：
`h_max ≤ log_t((n+1)/2) + 1`

#### 示例（视频隐含）

- 五阶 B 树（m=5，t=⌈5/2⌉=3），n=10 个关键字：
	`(n+1)/2 = 5.5` → `log_3(5.5) ≈ 1.5` → `h_max ≤ 1.5 + 1 = 2.5` → 取整`h_max=2`。

## 5. 核心总结

1. B 树是 “多路平衡查找树”，核心约束是 “节点关键字下限” 和 “绝对平衡”，目标是提升查找效率；
2. 考试侧重 B 树的性质（5 个核心特性）、查找过程（按区间选子树）、高度计算（最小 / 最大高度公式）；
3. 节点结构：`keyNum`（实际关键字数）、`key`（关键字数组）、`child`（孩子指针数组），阶`m`决定数组大小；
4. 查找逻辑：扫描节点内关键字→确定区间→进入对应子树→直至找到或到达失败节点。



# B 树的插入与删除（基于五阶 B 树）

## 一、B 树的核心定义（视频指定五阶）

视频中所有操作均围绕**五阶 B 树（m=5）** 展开，核心定义如下：

1. **阶数含义**：五阶 B 树表示每个节点最多有`m=5`个子节点，对应最多`m-1=4`个关键字。
2. **关键字个数限制**：
	- 非根节点：最少 `ceil(m/2)-1 = 2` 个（五阶`ceil(5/2)=3`，`3-1=2`），最多`4`个；
	- 根节点：特殊处理，最少`1`个，最多`4`个（视频强调 “根节点可仅含 1 个关键字”）。
3. **B 树核心特性**（视频反复验证）：
	- 所有 “失败节点”（终端节点的空指针）在同一层；
	- 任一节点的关键字**有序排列**，且左子树中所有关键字＜该节点关键字，右子树中所有关键字＞该节点关键字；
	- 插入 / 删除后需严格保持上述特性。

## 二、B 树的插入操作

### 1. 插入核心原则（视频强调）

- 新关键字**仅能插入到最底层的终端节点**（若插入非终端节点，会导致失败节点不在同一层，违反特性）；
- 插入前需通过 “B 树查找算法” 确定插入位置（从根出发，比关键字小走左子树，大走右子树，直至终端节点）；
- 插入后若节点关键字数超过上限（五阶 4 个），需执行**分裂操作**。

### 2. 插入步骤与示例（视频从零构建 B 树）

#### 示例 1：初始插入（未达关键字上限）

按视频顺序插入`25→38→49→60`：

1. 插入`25`：根节点为空，直接放入 → 根节点：`[25]`（根节点 1 个，合法）；
2. 插入`38`：`38>25`，插入`25`后 → 根节点：`[25, 38]`（2 个，合法）；
3. 插入`49`：`49>38`，插入`38`后 → 根节点：`[25, 38, 49]`（3 个，合法）；
4. 插入`60`：`60>49`，插入`49`后 → 根节点：`[25, 38, 49, 60]`（4 个，达上限，合法）。

#### 示例 2：首次分裂（插入`80`触发）

插入`80`后，根节点关键字数变为`5`（超上限 4），触发分裂：

1. **分裂逻辑**（视频动画演示）：

	- 取中间关键字：五阶`ceil(m/2)=3`，即第 3 个关键字`49`（0-based 索引为 2）；
	- 中间关键字`49`提升为**新根节点**；
	- 原根节点拆分为左、右两个终端节点：
		- 左节点：中间左侧关键字 → `[25, 38]`（2 个，合法）；
		- 右节点：中间右侧关键字 → `[60, 80]`（2 个，合法）。

2. 分裂后结构：

	plaintext

	```plaintext
	   49  （新根）
	  /  \
	```

[25,38] [60,80] （终端节点）

plaintext

```plaintext
#### 示例3：后续插入与分裂（插入`90→99→88`）
1. 插入`90`：
- 查找位置：根`49`→右子树`[60,80]`（终端节点），`90>80`，插入后 → `[60,80,90]`（3个，合法）；
2. 插入`99`：
- 插入`[60,80,90]`后 → `[60,80,90,99]`（4个，达上限，合法）；
3. 插入`88`（触发分裂）：
- 插入后节点变为`[60,80,88,90,99]`（5个，超上限）；
- 分裂逻辑：
  - 中间关键字：第3个`88`，提升至父节点（原根`[49]`）；
  - 父节点插入`88`后 → `[49, 88]`（2个，合法）；
  - 原节点拆分为左`[60,80]`、右`[90,99]`（各2个，合法）。
4. 分裂后结构：
```

49, 88
/ |
[25,38] [60,80] [90,99]

plaintext

```plaintext
#### 示例4：分裂传递与根分裂（视频延伸案例）
插入`70→83→87→92→93→94`后，某节点超上限，触发父节点连锁分裂：
1. 插入`70`到`[60,80]` → 节点变为`[60,70,80]`（3个，合法）；
2. 插入`83→87`到`[60,70,80]` → 节点变为`[60,70,80,83,87]`（5个，超上限）：
- 中间关键字`80`提升至父节点`[49,88]` → 父节点变为`[49,80,88]`（3个，合法）；
- 拆分为左`[60,70]`、右`[83,87]`（各2个，合法）；
3. 插入`92→93→94`到`[90,99]` → 节点变为`[90,92,93,94,99]`（5个，超上限）：
- 中间关键字`93`提升至父节点`[49,80,88]` → 父节点变为`[49,80,88,93]`（4个，合法）；
- 拆分为左`[90,92]`、右`[94,99]`（各2个，合法）；
4. 根分裂（若继续插入`50`）：
- 父节点`[49,80,88,93]`插入`50`后 → `[49,50,80,88,93]`（5个，超上限）；
- 中间关键字`80`提升为新根，原根拆分为左`[49,50]`、右`[88,93]`；
- 结构变为（**高度+1**）：
```

80 （新根）
/
[49,50] [88,93]
/ \ /
... ... ... ...

plaintext

```plaintext
### 3. 插入操作总结（视频核心结论）
1. **插入位置**：仅终端节点，通过B树查找确定；
2. **分裂触发条件**：插入后节点关键字数 > `m-1`（五阶4）；
3. **分裂核心逻辑**：
- 取`ceil(m/2)`位的中间关键字，提升至父节点；
- 原节点拆分为左（中间左侧关键字）、右（中间右侧关键字）两个节点；
4. **连锁反应**：父节点若超上限则继续分裂，直至根节点，可能导致B树**高度+1**。


## 三、B树的删除操作
### 1. 删除核心原则（视频重点）
- 非终端节点关键字删除：**必须转换为终端节点关键字删除**（通过“直接前驱”或“直接后继”替代）；
- 终端节点删除后需检查：关键字数是否＜下限（五阶非根2，根1），不足则需调整（借兄弟或合并）。

### 2. 直接前驱/后继定义（视频明确）
- **直接前驱**：待删关键字的左子树中，**最右下节点的最后一个关键字**（左子树最大关键字，必为终端节点）；
- **直接后继**：待删关键字的右子树中，**最左下节点的第一个关键字**（右子树最小关键字，必为终端节点）。

### 3. 删除场景与示例（视频演示）
#### 场景1：删除终端节点关键字，删后≥下限（直接删）
- 示例（视频）：删除终端节点`[60,70,83,87]`中的`60`；
1. 直接删除`60`，节点变为`[70,83,87]`（3个，≥非根下限2，合法）；
2. 结论：无需额外调整，直接删除即可。

#### 场景2：删除非终端节点关键字（转终端删除）
- 示例（视频）：删除非终端节点关键字`80`（父节点中的`80`）；
1. **转换逻辑**（用直接前驱替代）：
- 找`80`的直接前驱：左子树最右下节点`[70,83,87]`的最后一个关键字`77`（终端节点）；
- 用`77`替代非终端节点中的`80`，树特性保持（左＜77＜右）；
- 转为删除终端节点中的`77`（删后节点`[70,83]`，2个，合法）；
2. 或用直接后继替代：
- 找`80`的直接后继：右子树最左下节点`[88,92]`的第一个关键字`82`（终端节点）；
- 用`82`替代`80`，删除终端节点中的`82`（删后合法）。

#### 场景3：删除终端节点关键字，删后＜下限（需调整）
##### 子场景3.1：兄弟节点关键字充足（可借）
视频中“兄弟充足”指兄弟节点关键字数＞下限（五阶＞2），分“借右兄弟”和“借左兄弟”两种情况：

- **借右兄弟示例**（视频删`38`）：
1. 初始结构：父节点`[49]`，左终端节点`[25,38]`，右终端节点`[70,83,87]`（右兄弟3个，充足）；
2. 删除`38`：左节点变为`[25]`（1个＜2，不足）；
3. **调整逻辑**（视频描述）：
- 步骤1：将父节点关键字`49`“拉下来”，插入左节点`[25]` → 左节点变为`[25,49]`（2个，合法）；
- 步骤2：将右兄弟第一个关键字`70`“提上去”，替代父节点`49` → 父节点变为`[70]`（1个，合法）；
- 步骤3：右兄弟删除`70` → 右节点变为`[83,87]`（2个，合法）；
4. 调整后结构：
```

70
/
[25,49] [83,87]

plaintext

```plaintext
- **借左兄弟示例**（视频删`90`）：
1. 初始结构：父节点`[88]`，左终端节点`[87,88,90]`（左兄弟3个，充足），右终端节点`[90,92]`；
2. 删除`90`：右节点变为`[92]`（1个＜2，不足）；
3. **调整逻辑**：
- 步骤1：将父节点关键字`88`“拉下来”，插入右节点`[92]` → 右节点变为`[88,92]`（2个，合法）；
- 步骤2：将左兄弟最后一个关键字`87`“提上去”，替代父节点`88` → 父节点变为`[87]`（1个，合法）；
- 步骤3：左兄弟删除`87` → 左节点变为`[88,90]`（2个，合法）。

##### 子场景3.2：兄弟节点关键字不足（需合并）
视频中“兄弟不足”指兄弟节点关键字数=下限（五阶2），需合并“当前节点+兄弟节点+父节点中间关键字”：

- **示例**（视频删`49`）：
1. 初始结构：父节点`[80]`，左终端节点`[25,49]`，右终端节点`[88,93]`（兄弟均2个，不足借）；
2. 删除`49`：左节点变为`[25]`（1个＜2，不足）；
3. **合并逻辑**（视频步骤）：
- 步骤1：合并左节点`[25]`、右节点`[88,93]`，并将父节点中间关键字`80`“拉下来” → 新节点`[25,80,88,93]`（4个，合法）；
- 步骤2：父节点`[80]`删除`80`后为空（根节点，1→0，不足）；
- 步骤3：删除空根节点，新节点`[25,80,88,93]`成为新根（4个，合法）；
4. 合并后结构（**高度-1**）：
```

[25,80,88,93] （新根，终端节点）

plaintext

~~~plaintext
- **连锁合并**（视频延伸）：
若合并后父节点仍不足（如非根父节点关键字数＜2），需继续合并上层节点，直至根节点；若根节点空，则删除根，B树高度-1。

### 4. 删除操作总结（视频核心）
1. 非终端删→终端删：通过前驱/后继替代，本质是“将非终端删转换为终端删”；
2. 终端删后检查：
- ≥下限：直接删；
- ＜下限：
- 兄弟充足：借右兄弟（父下+右兄上）或借左兄弟（父下+左兄上）；
- 兄弟不足：合并“当前节点+兄弟+父中间关键字”，父不足则继续合并，直至根，可能导致高度-1。


## 四、基于视频逻辑的伪代码（模拟操作流程）
视频中未提供具体代码，以下伪代码严格贴合视频操作逻辑，仅模拟五阶B树的插入与删除流程：

### 1. B树节点结构定义（伪代码）
```plaintext
// 五阶B树节点结构（视频逻辑）
struct BTreeNode {
bool isTerminal;          // 是否为终端节点
int keyCount;             // 当前关键字个数
int keys[4];              // 关键字数组（五阶最多4个）
BTreeNode* parent;        // 父节点指针
BTreeNode* children[5];   // 子节点指针（五阶最多5个）

// 构造函数
BTreeNode(bool terminal) {
   isTerminal = terminal;
   keyCount = 0;
   parent = null;
   for (int i=0; i<5; i++) children[i] = null;
}
};
~~~

### 2. B 树插入伪代码（贴合视频步骤）

plaintext

```plaintext
// 五阶B树插入入口函数
BTreeNode* insertBTree(BTreeNode* root, int key) {
    // 步骤1：查找插入位置（终端节点）
    BTreeNode* targetNode = findTerminalNode(root, key);
    
    // 步骤2：插入关键字到终端节点（保持有序）
    insertKeyIntoNode(targetNode, key);
    
    // 步骤3：检查是否超上限（五阶最多4个），超则分裂
    while (targetNode->keyCount > 4) {
        // 步骤3.1：找中间关键字（0-based索引2，第3个元素）
        int midIndex = 2;
        int midKey = targetNode->keys[midIndex];
        
        // 步骤3.2：创建左、右子节点（终端节点）
        BTreeNode* leftNode = new BTreeNode(true);
        BTreeNode* rightNode = new BTreeNode(true);
        // 左节点：中间左侧关键字（0-1）
        leftNode->keyCount = 2;
        leftNode->keys[0] = targetNode->keys[0];
        leftNode->keys[1] = targetNode->keys[1];
        // 右节点：中间右侧关键字（3-4）
        rightNode->keyCount = 2;
        rightNode->keys[0] = targetNode->keys[3];
        rightNode->keys[1] = targetNode->keys[4];
        
        // 步骤3.3：中间关键字插入父节点
        if (targetNode == root) {
            // 根节点分裂，新建根
            BTreeNode* newRoot = new BTreeNode(false);
            newRoot->keyCount = 1;
            newRoot->keys[0] = midKey;
            newRoot->children[0] = leftNode;
            newRoot->children[1] = rightNode;
            leftNode->parent = newRoot;
            rightNode->parent = newRoot;
            root = newRoot;
            break;
        } else {
            // 非根节点，插入父节点
            BTreeNode* parentNode = targetNode->parent;
            int insertPos = findInsertPosition(parentNode, midKey);
            // 父节点插入中间关键字（后移腾出位置）
            for (int i=parentNode->keyCount-1; i>=insertPos; i--) {
                parentNode->keys[i+1] = parentNode->keys[i];
            }
            parentNode->keys[insertPos] = midKey;
            parentNode->keyCount++;
            // 父节点子节点替换：原targetNode→leftNode+rightNode
            int childPos = findChildPosition(parentNode, targetNode);
            for (int i=parentNode->keyCount; i>=childPos+1; i--) {
                parentNode->children[i+1] = parentNode->children[i];
            }
            parentNode->children[childPos] = leftNode;
            parentNode->children[childPos+1] = rightNode;
            leftNode->parent = parentNode;
            rightNode->parent = parentNode;
            
            // 父节点成为新的待检查节点（可能超上限）
            targetNode = parentNode;
        }
    }
    return root;
}

// 辅助函数：查找key应插入的终端节点（视频查找逻辑）
BTreeNode* findTerminalNode(BTreeNode* node, int key) {
    BTreeNode* current = node;
    while (!current->isTerminal) {
        int pos = 0;
        while (pos < current->keyCount && current->keys[pos] < key) {
            pos++;
        }
        current = current->children[pos];
    }
    return current;
}

// 辅助函数：查找key在节点中应插入的位置（保持有序）
int findInsertPosition(BTreeNode* node, int key) {
    int pos = 0;
    while (pos < node->keyCount && node->keys[pos] < key) {
        pos++;
    }
    return pos;
}

// 辅助函数：插入关键字到节点（保持有序）
void insertKeyIntoNode(BTreeNode* node, int key) {
    int pos = findInsertPosition(node, key);
    // 后移元素，腾出位置
    for (int i=node->keyCount-1; i>=pos; i--) {
        node->keys[i+1] = node->keys[i];
    }
    node->keys[pos] = key;
    node->keyCount++;
}

// 辅助函数：查找子节点在父节点中的位置
int findChildPosition(BTreeNode* parent, BTreeNode* child) {
    for (int i=0; i<=parent->keyCount; i++) {
        if (parent->children[i] == child) {
            return i;
        }
    }
    return -1;
}
```

### 3. B 树删除伪代码（贴合视频步骤）

plaintext

```plaintext
// 五阶B树删除入口函数
BTreeNode* deleteBTree(BTreeNode* root, int key) {
    // 步骤1：查找包含key的节点
    BTreeNode* targetNode = findNode(root, key);
    if (targetNode == null) return root;  // key不存在
    
    // 步骤2：非终端节点→转终端节点删除（前驱/后继替代）
    if (!targetNode->isTerminal) {
        // 找直接前驱（左子树最右下节点的最后一个关键字）
        BTreeNode* predNode = findRightmostNode(targetNode->children[findKeyPosition(targetNode, key)]);
        int predKey = predNode->keys[predNode->keyCount-1];
        // 用前驱替代目标key
        targetNode->keys[findKeyPosition(targetNode, key)] = predKey;
        // 转为删除终端节点中的前驱
        targetNode = predNode;
        key = predKey;
    }
    
    // 步骤3：删除终端节点中的key
    deleteKeyFromNode(targetNode, key);
    
    // 步骤4：检查是否低于下限，不足则调整
    while ((!isRoot(targetNode) && targetNode->keyCount < 2) || (isRoot(targetNode) && targetNode->keyCount < 1)) {
        BTreeNode* parentNode = targetNode->parent;
        int childPos = findChildPosition(parentNode, targetNode);
        
        // 尝试借右兄弟
        if (childPos < parentNode->keyCount) {
            BTreeNode* rightSib = parentNode->children[childPos+1];
            if (rightSib->keyCount > 2) {  // 右兄弟充足
                // 父节点关键字拉下来
                int parentKey = parentNode->keys[childPos];
                insertKeyIntoNode(targetNode, parentKey);
                // 右兄弟第一个关键字提上去
                int sibKey = rightSib->keys[0];
                deleteKeyFromNode(rightSib, sibKey);
                parentNode->keys[childPos] = sibKey;
                break;
            }
        }
        
        // 尝试借左兄弟
        if (childPos > 0) {
            BTreeNode* leftSib = parentNode->children[childPos-1];
            if (leftSib->keyCount > 2) {  // 左兄弟充足
                // 父节点关键字拉下来（插在最前面）
                int parentKey = parentNode->keys[childPos-1];
                insertKeyAtPosition(targetNode, parentKey, 0);
                // 左兄弟最后一个关键字提上去
                int sibKey = leftSib->keys[leftSib->keyCount-1];
                deleteKeyFromNode(leftSib, sibKey);
                parentNode->keys[childPos-1] = sibKey;
                break;
            }
        }
        
        // 兄弟不足，合并
        if (childPos < parentNode->keyCount) {
            // 合并右兄弟
            BTreeNode* sib = parentNode->children[childPos+1];
            int parentKey = parentNode->keys[childPos];
            // 父关键字拉下来
            insertKeyIntoNode(targetNode, parentKey);
            // 合并兄弟关键字
            for (int i=0; i<sib->keyCount; i++) {
                insertKeyIntoNode(targetNode, sib->keys[i]);
            }
            // 父节点删除关键字和兄弟节点
            deleteKeyFromNode(parentNode, parentKey);
            deleteChildFromNode(parentNode, sib);
            delete sib;
        } else {
            // 合并左兄弟
            BTreeNode* sib = parentNode->children[childPos-1];
            int parentKey = parentNode->keys[childPos-1];
            // 父关键字拉下来
            insertKeyIntoNode(sib, parentKey);
            // 合并当前节点关键字
            for (int i=0; i<targetNode->keyCount; i++) {
                insertKeyIntoNode(sib, targetNode->keys[i]);
            }
            // 父节点删除关键字和当前节点
            deleteKeyFromNode(parentNode, parentKey);
            deleteChildFromNode(parentNode, targetNode);
            delete targetNode;
            targetNode = sib;
        }
        
        // 父节点成为新的待检查节点
        targetNode = parentNode;
        // 根节点空则删除，子节点成为新根
        if (isRoot(targetNode) && targetNode->keyCount == 0) {
            root = targetNode->children[0];
            root->parent = null;
            delete targetNode;
            break;
        }
    }
    return root;
}

// 辅助函数：查找包含key的节点
BTreeNode* findNode(BTreeNode* node, int key) {
    BTreeNode* current = node;
    while (current != null) {
        int pos = findKeyPosition(current, key);
        if (pos < current->keyCount && current->keys[pos] == key) {
            return current;
        }
        current = current->children[pos];
    }
    return null;
}

// 辅助函数：查找key在节点中的位置（存在则返回索引，否则返回插入位置）
int findKeyPosition(BTreeNode* node, int key) {
    int pos = 0;
    while (pos < node->keyCount && node->keys[pos] < key) {
        pos++;
    }
    return pos;
}

// 辅助函数：删除节点中的key
void deleteKeyFromNode(BTreeNode* node, int key) {
    int pos = findKeyPosition(node, key);
    if (pos >= node->keyCount || node->keys[pos] != key) return;
    // 前移元素，覆盖被删key
    for (int i=pos; i<node->keyCount-1; i++) {
        node->keys[i] = node->keys[i+1];
    }
    node->keyCount--;
}

// 辅助函数：指定位置插入关键字
void insertKeyAtPosition(BTreeNode* node, int key, int pos) {
    for (int i=node->keyCount-1; i>=pos; i--) {
        node->keys[i+1] = node->keys[i];
    }
    node->keys[pos] = key;
    node->keyCount++;
}

// 辅助函数：删除父节点的子节点
void deleteChildFromNode(BTreeNode* parent, BTreeNode* child) {
    int pos = findChildPosition(parent, child);
    for (int i=pos; i<parent->keyCount; i++) {
        parent->children[i] = parent->children[i+1];
    }
}

// 辅助函数：找节点的最右下节点（前驱）
BTreeNode* findRightmostNode(BTreeNode* node) {
    BTreeNode* current = node;
    while (!current->isTerminal) {
        current = current->children[current->keyCount];
    }
    return current;
}

// 辅助函数：判断是否为根节点
bool isRoot(BTreeNode* node) {
    return node->parent == null;
}
```



# B + 树核心知识点

## 1. 基本前提与核心定位

- **考研考察重点**：侧重概念性内容，不考深层实现，常与 B 树、分块查找对比考察
- **与分块查找的关联**：B + 树本质是**多级分块查找**的升级，核心逻辑一致：
	- 分块查找：数据分块（块内无序、块间有序），索引表存每块最大关键字
	- B + 树：每一层节点对应 “索引块”，叶子节点对应 “数据块”，分支节点存子节点最大关键字（等效分块查找的索引表）
- **核心目标**：追求**绝对平衡**（任意节点的所有子树高度相同），降低树高，减少查找次数

## 2. B + 树的关键定义与阶的概念

### 2.1 阶的定义

- **m 阶 B + 树**：每个节点最多包含`m棵子树`（以**四阶 B + 树**为例）
	- 例：四阶 B + 树的任意节点，子树数≤4，关键字数≤4（因 “子树数 = 关键字数”，见性质 3）

### 2.2 B + 树的 5 个核心性质

#### 性质 1：非叶根节点至少 2 棵子树

- 根节点分类：
	- 若根节点是叶子（如仅 1 个节点的 B + 树，无后代）：无需满足 “至少 2 棵子树”
	- 若根节点是非叶（有后代）：必须至少 2 棵子树
- 反例：根节点仅 1 棵子树（左子树存在，右子树缺失）→ 不符合 B + 树定义
- 目的：避免树 “单侧生长”，保证初始平衡

#### 性质 2：分支节点（非叶、非根）至少⌈m/2⌉棵子树

- 公式：分支节点最小子树数 = `⌈m/2⌉`（`⌈⌉`表示向上取整）
- 示例：四阶 B + 树（m=4）→ 分支节点至少`⌈4/2⌉=2`棵子树
- 目的：防止节点过空（如仅 1 棵子树），避免树高过高导致查找效率下降

#### 性质 3：节点的子树数 = 关键字数（B + 树与 B 树核心区别之一）

- 核心对应关系：`子树数 = 关键字数`（视频明确对比 B 树：B 树是 “子树数 = 关键字数 + 1”）
- 示例：
	- 某分支节点含 3 个关键字（3、9、15）→ 对应 3 棵子树
	- 某叶子节点含 2 个关键字（1、3）→ 虽叶子无后代，但该性质仍成立（逻辑上 “子树数 = 关键字数”）
- 考察点：考研选择题常考 “B + 树节点关键字数与子树数的关系”

#### 性质 4：叶子节点包含全部关键字 + 记录指针，且有序链接

- 叶子节点的构成：
	- 每个叶子节点是 “一整块”，包含多个 “关键字 + 记录指针” 条目（非单个小方块）
	- 示例：学生信息管理场景，关键字 = 学号，记录指针 = 指向学生详细信息（姓名、成绩等）的存储地址
		- 叶子节点条目格式：`(学号: 1, 指针:p1)、(学号:3, 指针:p2)`
- 有序性与链接：
	- 叶子节点内的关键字按升序排列（如 6、8、9）
	- 叶子节点间通过指针`p`连接（如叶子 1→叶子 2→叶子 3），支持**顺序查找**
- 核心作用：所有实际数据的访问必须通过叶子节点，保证数据完整性（无遗漏关键字）

#### 性质 5：分支节点仅存储子节点的最大关键字（仅作索引，不存记录指针）

- 分支节点的构成：仅含 “子节点最大关键字 + 子树指针”，无记录指针（不指向实际数据）
- 示例：
	- 分支节点关键字 = 15→表示其对应子树中所有关键字的最大值为 15
	- 分支节点关键字 = 56→表示其对应子树中所有关键字的最大值为 56
- 逻辑：分支节点仅用于 “导航” 查找方向（如 “目标关键字≤15→进入 15 对应子树”），不参与实际数据获取

## 3. B + 树的查找过程（含 3 个示例）

### 3.1 查找核心原则

- 无论查找成功 / 失败，**必须遍历到叶子节点**（因仅叶子节点存记录指针，分支节点无实际数据）

### 3.2 示例 1：查找关键字 9（成功，学生信息场景）

假设 B + 树结构（简化）：

- 根节点（分支）：关键字 [15, 56]→子树指针 [T1, T2, T3]（T1 对应≤15，T2 对应 15<x≤56，T3 对应 > 56）
- T1 子树节点（分支）：关键字 [3, 9]→子树指针 [T11, T12, T13]（T11 对应≤3，T12 对应 3<x≤9，T13 对应 > 9）
- T12 子树节点（叶子）：关键字 [6, 8, 9]→记录指针 [p6, p8, p9]

查找步骤：

1. 根节点判断：9 ≤ 15→进入 T1 子树
2. T1 分支节点判断：3 < 9 ≤ 9→进入 T12 子树
3. T12 叶子节点判断：遍历关键字→找到 9，通过记录指针 p9 获取 9 号学生的详细信息→查找成功

### 3.3 示例 2：查找关键字 7（失败）

沿用上述 B + 树结构：

1. 根节点：7 ≤ 15→进入 T1 子树
2. T1 分支节点：3 < 7 ≤ 9→进入 T12 子树
3. T12 叶子节点：遍历关键字 [6,8,9]→7 在 6 和 8 之间，无匹配关键字→查找失败

### 3.4 示例 3：顺序查找（通过叶子节点指针）

沿用上述 B + 树叶子节点结构：

- 叶子 1（关键字 [1,3]，指针 p→叶子 2）
- 叶子 2（关键字 [6,8,9]，指针 p→叶子 3）
- 叶子 3（关键字 [15]，指针 p→null）

顺序查找步骤：

1. 从叶子 1 开始，通过指针 p 遍历叶子 1→叶子 2→叶子 3
2. 逐个检查叶子节点内的关键字，可覆盖所有关键字（如查找 1~15 范围内的所有学生）

- 优势：支持范围查询（B 树不支持高效范围查询）

## 4. B + 树与 B 树的 4 点核心区别（考研高频考点）

| 对比维度           | B + 树                               | B 树                           |
| ------------------ | ------------------------------------ | ------------------------------ |
| 关键字与子树数关系 | n 个关键字 → n 棵子树                | n 个关键字 → n+1 棵子树        |
| 关键字重复性       | 分支节点关键字在叶子节点**重复**出现 | 所有节点关键字**唯一**，不重复 |
| 记录指针存储位置   | 仅叶子节点存储记录指针               | 所有节点均存储记录指针         |
| 查找终止位置       | 成功 / 失败均终止于叶子节点          | 成功可终止于中间分支节点       |

### 对比示例：查找关键字 15

- B + 树：根节点 15→进入对应子树→叶子节点找到 15→通过记录指针获取数据
- B 树：若中间分支节点含 15→找到 15 后直接通过其记录指针获取数据，无需到叶子节点

## 5. B + 树的磁盘存储特性

### 5.1 存储映射关系

- B + 树节点 ↔ 磁盘块（操作系统按 “磁盘块” 为单位读写数据，1 个节点 = 1 个磁盘块）
- 查找过程的磁盘操作：每访问一层节点 = 1 次磁盘读操作（如树高 3→3 次读盘）

### 5.2 B + 树的效率优势（对比 B 树）

- 核心原因：B + 树分支节点仅存关键字（无记录指针），单个磁盘块可存储更多关键字→节点子树数更多→树高更低→磁盘读次数更少
- 示例：
	- 磁盘块大小 1KB：B 树节点存 “关键字 + 记录指针”（每条占 20 字节）→ 1KB 约存 50 条；B + 树节点仅存关键字（每条占 4 字节）→ 1KB 约存 250 条
	- 结果：B + 树单节点子树数更多，树高比 B 树低 2~3 层→少 2~3 次磁盘读（磁盘读耗时远大于内存操作，效率提升显著）

### 5.3 实际应用

- 关系型数据库索引（如 MySQL）：采用 B + 树实现，原因：
	1. 支持高效单点查询（树高低，读盘少）
	2. 支持高效范围查询（叶子节点有序链接）



# 散列表基本概念

## 1. 散列表（Hash Table）核心定义

### 1.1 概念

- 散列表是一种通过 “**关键字直接计算存储地址**” 实现高效数据存取的数据结构，**必须配套一个散列函数**。
- 核心思想：无需通过遍历、比较等方式定位地址，而是通过散列函数建立 “关键字→存储地址” 的直接映射，实现数据的快速插入与查找。
- 理想性能：查找、插入操作的时间复杂度为 **O(1)**（需无冲突或冲突极少），是效率极高的动态数据结构。

### 1.2 视频中的散列表示例（插入与查找）

视频以 “**长度为 13 的散列表**” 为载体，配套散列函数 `H(key) = key mod 13`（关键字对 13 取余），通过具体元素演示插入和查找过程：

#### 1.2.1 示例 1：无冲突插入（3 个元素）

需插入的元素关键字：19、14、23
插入逻辑：对每个关键字应用散列函数，计算地址后存储到对应下标位置。

1. 插入 19：
	计算 `H(19) = 19 mod 13 = 6` → 存储到散列表**下标 6**的位置。
2. 插入 14：
	计算 `H(14) = 14 mod 13 = 1` → 存储到散列表**下标 1**的位置。
3. 插入 23：
	计算 `H(23) = 23 mod 13 = 10` → 存储到散列表**下标 10**的位置。

插入后的散列表状态（仅标注有元素的下标，空位置用 “-” 表示）：

| 散列表下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 存储元素   | -    | 14   | -    | -    | -    | -    | 19   | -    | -    | -    | 23   | -    | -    |

#### 1.2.2 示例 2：查找操作（成功与失败）

查找逻辑：先通过散列函数计算目标关键字的地址，再检查该地址是否存在目标元素。

1. 查找关键字 19（成功案例）：
	① 计算 `H(19) = 19 mod 13 = 6`；
	② 检查散列表下标 6 的位置，元素为 19 → 查找成功。
2. 查找关键字 16（失败案例）：
	① 计算 `H(16) = 16 mod 13 = 3`；
	② 检查散列表下标 3 的位置，无元素 → 查找失败。

## 2. 散列函数（Hash Function）

### 2.1 概念

- 散列函数是散列表的 “核心配套工具”，定义为 `H(key) = address`，即通过数据的**关键字 key**，计算出该数据在散列表中的**存储地址 address**。
- 核心作用：建立关键字与存储地址的映射关系，目标是让不同关键字尽可能映射到不同地址，从而减少冲突。
- 关键特性：**同义词依赖散列函数**—— 同一组关键字，换用不同散列函数，可能从 “同义词” 变为 “非同义词”。

### 2.2 视频中的散列函数示例（对比）

#### 2.2.1 示例 1：初始散列函数（导致冲突）

- 函数表达式：`H(key) = key mod 13`（基于长度 13 的散列表）
- 冲突场景：插入关键字 1 时，`H(1) = 1 mod 13 = 1`，而散列表下标 1 已存储 14 → 触发冲突。

#### 2.2.2 示例 2：调整后的散列函数（减少冲突）

- 函数表达式：`H(key) = key mod 12`（仅改变取余基数，未改变散列表长度）
- 映射结果（对原有关键字）：
	- `H(19) = 19 mod 12 = 7`
	- `H(14) = 14 mod 12 = 2`
	- `H(23) = 23 mod 12 = 11`
	- `H(1) = 1 mod 12 = 1`
- 效果：19、14、23、1 的映射地址（7、2、11、1）均不重复，无冲突；但插入关键字 13 时，`H(13) = 13 mod 12 = 1`，与 1 的地址冲突 → 证明**即使优化散列函数，冲突仍不可完全避免**。

## 3. 冲突（Collision）与同义词

### 3.1 冲突（碰撞）

#### 3.1.1 概念

- 当插入新元素时，通过散列函数计算出的**存储地址已被其他元素占用**，这种情况称为 “冲突”（或 “碰撞”）。
- 冲突的影响：破坏 “O (1) 查找” 的理想性能，需通过专门的冲突处理方法解决，否则无法正常存储新元素。

#### 3.1.2 冲突示例           

- 场景：散列表长度 13，散列函数 `H(key) = key mod 13`，已存储元素 14（下标 1）。
- 冲突过程：插入关键字 1 → 计算 `H(1) = 1 mod 13 = 1` → 下标 1 已被 14 占用 → 发生冲突。

### 3.2 同义词

#### 3.2.1 概念

- 若**两个不同的关键字**在**同一散列函数**的映射下，得到**相同的存储地址**，则这两个关键字互为 “同义词”。
- 本质：同义词是散列函数的 “产物”，而非关键字本身的属性 —— 换用不同散列函数，同义词关系可能消失。

####  3.2.2 同义词示例

- 示例 1（同义词）：散列函数 `H(key) = key mod 13` 时，`H(1)=1`、`H(14)=1` → 关键字 1 和 14 互为同义词。
- 示例 2（非同义词）：散列函数改为 `H(key) = key mod 12` 时，`H(1)=1`、`H(14)=2` → 1 和 14 不再是同义词。

##  4. 冲突处理的两种基本思路

### 4.1 拉链法（链接法 / 链地址法）

#### 4.1.1 核心思路

- 将所有**同义词**（映射到同一地址的关键字）通过**单链表**连接起来；散列表的每个下标位置，存储对应链表的 “头指针”（或头节点）。
- 优势：无论多少个同义词，均可通过链表依次存储，不会占用其他地址的空间，冲突处理逻辑简单。

#### 4.1.2 视频中的逻辑示例

- 场景：散列表下标 1 需存储同义词 14（先插入）和 1（后插入）。
- 处理方式：
	1. 散列表下标 1 的位置存储链表头节点；
	2. 链表第一个节点存储元素 14；
	3. 链表第二个节点存储元素 1；
	4. 后续若有新的同义词（如 `H(key)=1` 的关键字），直接追加到链表尾部。

### 4.2 开放定址法

#### 4.2.1 核心思路

- 当插入新元素发生冲突时，不使用原计算地址，而是按照**预设规则**在散列表中 “探测” 下一个空闲位置，将新元素存储到该空闲位置。
- 待解决问题：视频明确 “探测空闲位置的具体规则” 是后续学习重点（如线性探测、二次探测、伪随机探测等），本视频暂不展开。

#### 4.2.2 视频中的逻辑示例

- 场景：散列表下标 1 已存储 14，插入 1 时 `H(1)=1`（冲突）。
- 处理方式（以 “线性探测” 为例，视频仅提思路）：
	1. 冲突后，依次检查下标 2、3、4...；
	2. 找到第一个空闲下标（如下标 2）；
	3. 将元素 1 存储到下标 2 的位置。



# 散列函数的构造

## 一、散列函数的核心目标与设计注意事项

### 1.1 散列函数的作用与核心目标

- **作用**：将关键字映射到对应的存储地址（用于散列表存储与查找）。
- **核心目标**：尽可能减少不同关键字之间的冲突（即不同关键字映射到同一地址的情况）。

### 1.2 散列函数设计的 4 个注意事项

#### 注意事项 1：定义域需涵盖所有可能的关键字

- **原理**：散列函数的输入范围必须包含实际场景中所有可能出现的关键字，否则部分关键字无法映射。
- **视频反例**：
	散列表长度为 13（地址 0~12），关键字可能为正负整数。若设计函数`H(key) = sqrt(key) % 13`（对关键字开根号后取余），则**负数关键字无法开根号**，导致定义域不完整，无法处理负数关键字（如`key=-4`无法计算）。

#### 注意事项 2：值域不可超出散列表的地址范围

- **原理**：散列函数的输出（地址）必须在散列表的合法地址区间内（通常为`0 ~ 表长-1`），否则为非法地址。
- **视频示例**：
	散列表长度为 13（合法地址 0~12），若设计函数`H(key) = key % 15`，则值域为 0~14，其中 13、14 为非法地址，超出散列表地址范围。

#### 注意事项 3：计算的地址需均匀分布

- **原理**：地址均匀分布可最大程度减少冲突，避免多个关键字集中映射到同一地址。
- **视频反例**：
	设计函数`H(key) = (key * 13) % 13`，任何整数乘 13 后对 13 取余结果均为 0，导致所有关键字都映射到地址 0，地址分布极端不均匀，冲突频繁。

#### 注意事项 4：函数计算需简单高效

- **原理**：散列函数需快速计算，避免耗时操作，否则会降低散列表的查找效率。
- **视频反例**：
	设计函数`H(key) = factorial(key) % 13`（先对关键字求阶乘再取余），若`key=1000000`，计算 1000000 的阶乘需执行 1000000 次乘法，耗时极长，导致散列计算效率低下。

## 二、四种常见的散列函数构造方法

### 方法 1：除留余数法（考试 & 应用最常用）

#### 适用场景

- 通用场景，对关键字类型（整数）无特殊限制，是最常用的构造方法。

#### 核心原理

1. 选择一个**不大于散列表表长的最大质数 P**；
2. 散列函数公式：`H(key) = key % P`（关键字对 P 取余）。

- **关键概念**：
	- 质数（素数）：只能被 1 和自身整除的正整数（如 5、7、13）；
	- 合数：除 1 和自身外还能被其他数整除的正整数（如 4、8、15）。

#### 视频示例

##### 示例 1：确定 P 的值

- 场景 1：散列表表长 = 13（13 是质数），则 P=13（不大于 13 的最大质数），函数为`H(key) = key % 13`；
- 场景 2：散列表表长 = 15（15 是合数），不大于 15 的最大质数为 13，则 P=13，函数为`H(key) = key % 13`（而非对 15 取余）。

##### 示例 2：地址均匀性对比（P 为质数 vs 合数）

- 条件：散列表表长 = 8，可能的关键字：2、4、6、10、12、14；
- 情况 1：P=8（合数），函数`H(key)=key%8`：
	- 计算结果：2%8=2，4%8=4，6%8=6，10%8=2，12%8=4，14%8=6；
	- 问题：地址仅分布在 2、4、6，1、3、5、7 无映射，冲突频繁（2 与 10、4 与 12、6 与 14 冲突）。
- 情况 2：P=7（不大于 8 的最大质数），函数`H(key)=key%7`：
	- 计算结果：2%7=2，4%7=4，6%7=6，10%7=3，12%7=5，14%7=0；
	- 优势：地址分布在 0、2、3、4、5、6，均匀性显著提升，无冲突。

#### 关键说明

- 选择质数 P 的原因：避免关键字与 P 存在公因子，导致地址分布不均。例如 P=8（合数）与关键字（均为偶数）的公因子为 2，导致地址仅为偶数。

### 方法 2：直接定值法

#### 适用场景

- 关键字的分布**基本连续**的场景（如连续学号、连续编号）。

#### 核心原理

- 用线性函数将连续关键字映射到连续地址，公式：`H(key) = a*key + b`（a、b 为常数，通常 a=1、b 为偏移量）；
- 特点：无冲突，但关键字不连续时会浪费存储空间。

#### 视频示例

- 场景：存储 30 个学生信息，学号连续（如 2024001~2024030），散列表长度 = 30（地址 0~29）；
- 设计函数：`H(key) = key - 2024001`（a=1，b=-2024001）；
	- 计算示例：key=2024001 → H=0，key=2024005 → H=4，key=2024030 → H=29；
- 问题：若部分学号学生被开除（如 2024017、2024018、2024020），则地址 16、17、19 空闲，造成存储空间浪费。

### 方法 3：数字分析法

#### 适用场景

- 已知所有可能的关键字集合，且关键字的**某几位数码分布均匀**（其他位分布不均）。

#### 核心原理

- 分析关键字的数码分布：筛选出分布最均匀的几位数码；
- 直接将这几位数码作为散列地址（无需复杂计算）。

#### 视频示例

- 场景：存储手机用户信息，散列表长度 = 10000（地址 0~9999），关键字为 11 位手机号码；
- 手机号码结构分析：
	- 前 3 位：运营商标识（如 138、139、186），分布集中（不均）；
	- 中间 4 位：地区区号（如 0100、0210），分布集中（不均）；
	- 后 4 位：个人标识（如 2875、6134），分布均匀；
- 设计函数：`H(key) = 取手机号码的后4位`；
	- 计算示例：手机号 = 13801002875 → 后 4 位 = 2875 → H=2875，存储到地址 2875；
	- 手机号 = 13902106134 → 后 4 位 = 6134 → H=6134，存储到地址 6134。

### 方法 4：平方取中法

#### 适用场景

- 关键字的**每一位数码分布都不均匀**，且无明显规律（无法用数字分析法）。

#### 核心原理

1. 对关键字取平方：平方后中间的几位数码会受到原关键字每一位的影响；
2. 取平方结果的**中间几位数码**作为散列地址，确保地址均匀分布。

#### 视频示例

##### 示例 1：汽车型号关键字处理

- 场景：存储 100 种汽车信息，散列表长度 = 100（地址 0~99），关键字为汽车型号三元组（如 605030、283439 等，每一位分布不均）；
- 步骤 1：对关键字取平方；
	- 示例：key=605030 → 605030² = 366061300900（视频未给出具体值，此处为符合逻辑的平方结果）；
- 步骤 2：取平方结果的中间两位；
	- 示例：366061300900 的中间两位为 30 → H=30，存储到地址 30；
	- 其他关键字同理：key=283439 → 283439²（计算后）→ 取中间两位作为地址。

##### 示例 2：中间位受所有数码影响的验证

- 场景：验证`key=985`的平方中间位与原关键字每一位的关系；
- 步骤 1：计算 985 的平方（拆解乘法过程）：
	- 个位 5 × 985 = 4925（左移 0 位：4925）；
	- 十位 8 × 985 = 7880（左移 1 位：78800）；
	- 百位 9 × 985 = 8865（左移 2 位：886500）；
	- 求和：4925 + 78800 + 886500 = 970225；
- 步骤 2：分析中间位：
	- 平方结果 970225 的中间两位为 02，这两位由个位 5、十位 8、百位 9 共同影响（乘法拆解可见每一位都参与中间位计算）；
	- 结论：即使原关键字每一位分布不均，平方后中间位仍能均匀分布。

## 三、关键总结

1. **核心目标**：散列函数设计的核心是减少冲突，需满足定义域完整、值域合法、地址均匀、计算高效；
2. **方法优先级**：除留余数法（通用、常用）> 直接定值法（关键字连续）> 数字分析法（已知关键字集合且某几位均匀）> 平方取中法（关键字每一位均不均）；
3. **高频考点**：除留余数法中 P 的选择（不大于表长的最大质数）及地址均匀性验证。





# 散列表冲突解决：拉链法

## 1. 核心概念

### 1.1 散列表冲突

- 定义：散列表中，多个关键字通过散列函数计算后得到**相同的散列地址**，插入时产生的冲突现象（视频明确 “冲突无可避免”）。
- 本质：不同关键字映射到同一存储位置，导致插入、查找时需特殊处理。

### 1.2 拉链法定义

- 核心思想：将映射到**同一散列地址**的所有 “同义词”（即冲突的关键字）用**单链表**连接起来，形成 “链” 结构。
- 散列表物理结构：本质是一个 “链表头指针数组”，数组长度 = 散列表预设长度，每个数组元素对应一个链表的头指针（初始为`NULL`，表示空链表）。

## 2. 前提条件

所有操作均基于以下参数（视频明确给出，不可修改）：

- 散列表长度：`m = 13`（链表头指针数组索引范围`0~12`）。
- 散列函数：`H(key) = key % 13`（关键字对 13 取余，计算结果为散列地址`0~12`）。
- 插入规则：默认**头插法**（新元素插入到对应链表的头部；视频说明 “尾插法也可，考试未指定时默认头插”）。
- 查找长度定义：**查找过程中对比关键字的次数**（空链表的头指针`NULL`对比不计入，视频强调 “考试默认此规则”）。

## 3. 三大核心操作

### 3.1 插入操作

#### 3.1.1 插入步骤（视频标准流程）

1. 计算散列地址：对插入关键字`key`，通过`H(key) = key % 13`得到散列地址`addr`。
2. 创建新节点：为`key`分配链表节点，存储`key`值并初始化`next`指针为`NULL`。
3. 头插法插入：
	- 若`addr`对应的链表为空（头指针`hashTable[addr] == NULL`）：新节点直接作为链表头。
	- 若链表非空：新节点的`next`指向原链表头，再将新节点设为新的链表头。

#### 3.1.2 视频插入示例（按插入顺序）

视频依次插入关键字：`19、14、23、1、6、82、10、27、20、66`，分步演示如下：

1. 插入`19`：
	- 计算：`19 % 13 = 6` → 散列地址`6`。
	- 操作：6 号链表为空，`hashTable[6] = 19`（链表：`19`）。
2. 插入`14`：
	- 计算：`14 % 13 = 1` → 散列地址`1`。
	- 操作：1 号链表为空，`hashTable[1] = 14`（链表：`14`）。
3. 插入`23`：
	- 计算：`23 % 13 = 10` → 散列地址`10`。
	- 操作：10 号链表为空，`hashTable[10] = 23`（链表：`23`）。
4. 插入`1`：
	- 计算：`1 % 13 = 1` → 散列地址`1`（与`14`冲突）。
	- 操作：头插法插入 1 号链表，新链表：`1 → 14`（`hashTable[1] = 1`）。
5. 插入`6`：
	- 计算：`6 % 13 = 6` → 散列地址`6`（与`19`冲突）。
	- 操作：头插法插入 6 号链表，新链表：`6 → 19`（`hashTable[6] = 6`）。
6. 插入`82`：
	- 计算：`82 % 13 = 82 - 6*13 = 4` → 散列地址`4`。
	- 操作：4 号链表为空，`hashTable[4] = 82`（链表：`82`）。
7. 插入`10`：
	- 计算：`10 % 13 = 10` → 散列地址`10`（与`23`冲突）。
	- 操作：头插法插入 10 号链表，新链表：`10 → 23`（`hashTable[10] = 10`）。
8. 插入`27`：
	- 计算：`27 % 13 = 27 - 2*13 = 1` → 散列地址`1`（与`1、14`冲突）。
	- 操作：头插法插入 1 号链表，新链表：`27 → 1 → 14`（`hashTable[1] = 27`）。
9. 插入`20`：
	- 计算：`20 % 13 = 7` → 散列地址`7`。
	- 操作：7 号链表为空，`hashTable[7] = 20`（链表：`20`）。
10. 插入`66`：
	- 计算：`66 % 13 = 66 - 5*13 = 1` → 散列地址`1`（与`27、1、14`冲突）。
	- 操作：头插法插入 1 号链表，新链表：`66 → 27 → 1 → 14`（`hashTable[1] = 66`）。

#### 3.1.3 插入操作代码（与视频逻辑完全一致）

c

```c
#include <stdio.h>
#include <stdlib.h>

// 1. 定义链表节点结构（存储关键字）
typedef struct Node {
    int key;          // 关键字值
    struct Node* next;// 指向下一个节点的指针
} Node;

// 2. 定义散列表（链表头指针数组，长度=13，初始为NULL）
#define HASH_SIZE 13  // 视频固定参数：散列表长度=13
Node* hashTable[HASH_SIZE] = {NULL};

// 3. 插入函数（头插法，符合视频逻辑）
void insertKey(int key) {
    // 步骤1：计算散列地址
    int addr = key % HASH_SIZE;
    
    // 步骤2：创建新节点
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->key = key;
    newNode->next = NULL;
    
    // 步骤3：头插法插入对应链表
    if (hashTable[addr] == NULL) {
        // 链表为空，新节点作为头节点
        hashTable[addr] = newNode;
    } else {
        // 链表非空，新节点指向原头节点，再成为新头节点
        newNode->next = hashTable[addr];
        hashTable[addr] = newNode;
    }
    
    printf("插入成功：关键字%d，散列地址：%d\n", key, addr);
}
```

### 3.2 查找操作

#### 3.2.1 查找步骤

1. 计算散列地址：对目标关键字`target`，通过`H(target) = target % 13`得到散列地址`addr`。
2. 遍历链表：从`hashTable[addr]`（链表头）开始，用遍历指针依次访问节点。
3. 对比判断：
	- 若当前节点关键字 == `target`：查找成功，返回**查找长度**（已对比次数）。
	- 若遍历到`NULL`（链表尾）：查找失败，返回查找长度（遍历过程中对比的关键字次数）。

#### 3.2.2 查找示例（4 个核心案例）

基于 3.1.2 插入后的散列表，视频演示查找`27、20、66、21`：

1. 查找`27`：
	- 地址计算：`27 % 13 = 1` → 散列地址`1`。
	- 遍历链表：`66 → 27 → 1 → 14`：
		- 第 1 次对比：`66 ≠ 27`（计数 = 1）。
		- 第 2 次对比：`27 == 27`（计数 = 2）→ 找到。
	- 结果：查找成功，查找长度 = 2（视频结论）。
2. 查找`20`：
	- 地址计算：`20 % 13 = 7` → 散列地址`7`。
	- 遍历链表：`20`：
		- 第 1 次对比：`20 == 20`（计数 = 1）→ 找到。
	- 结果：查找成功，查找长度 = 1（视频结论）。
3. 查找`66`：
	- 地址计算：`66 % 13 = 1` → 散列地址`1`。
	- 遍历链表：`66 → 27 → 1 → 14`：
		- 第 1 次对比：`66 == 66`（计数 = 1）→ 找到。
	- 结果：查找成功，查找长度 = 1（视频隐含案例）。
4. 查找`21`：
	- 地址计算：`21 % 13 = 8` → 散列地址`8`。
	- 遍历链表：`NULL`（空链表）→ 未对比任何关键字（计数 = 0）。
	- 结果：查找失败，查找长度 = 0（视频结论，空指针对比不计入）。

#### 3.2.3 查找操作代码（与视频逻辑完全一致）

c

```c
// 查找函数：返回值>0表示成功（值=查找长度），返回值<0表示失败（绝对值=查找长度）
int searchKey(int target) {
    // 步骤1：计算散列地址
    int addr = target % HASH_SIZE;
    int compareCount = 0;  // 对比关键字次数（查找长度）
    Node* p = hashTable[addr];  // 遍历指针（从链表头开始）
    
    // 步骤2：遍历链表并对比关键字
    while (p != NULL) {
        compareCount++;  // 每对比一次，计数+1
        if (p->key == target) {
            // 查找成功，返回查找长度
            printf("查找结果：成功，关键字=%d，地址=%d，查找长度=%d\n", 
                   target, addr, compareCount);
            return compareCount;
        }
        p = p->next;  // 未找到，继续遍历下一个节点
    }
    
    // 步骤3：遍历到NULL，查找失败
    printf("查找结果：失败，关键字=%d，地址=%d，查找长度=%d\n", 
           target, addr, compareCount);
    return -compareCount;  // 负号标识失败
}
```

### 3.3 删除操作

#### 3.3.1 删除步骤

1. 定位目标：先通过 “查找操作” 找到目标关键字`target`所在的链表及前驱节点（需记录前驱节点，用于调整链表指针）。
2. 判断存在性：
	- 若未找到`target`（遍历到`NULL`）：删除失败。
	- 若找到`target`：根据节点位置调整链表指针（分 “头节点删除” 和 “中间 / 尾节点删除”）。
3. 释放内存：删除节点后，释放该节点的内存（避免内存泄漏）。

#### 3.3.2 删除示例（3 个核心案例）

基于 3.1.2 插入后的散列表，视频演示删除`27、20、66`：

1. 删除`27`：
	- 定位：散列地址`1`，链表`66 → 27 → 1 → 14`，`27`是中间节点，前驱节点为`66`。
	- 操作：前驱节点`66`的`next`指向`27`的`next`（即`1`），释放`27`节点。
	- 结果：删除成功，1 号链表变为`66 → 1 → 14`（视频结论）。
2. 删除`20`：
	- 定位：散列地址`7`，链表`20`，`20`是头节点（无前驱节点）。
	- 操作：`hashTable[7] = 20->next`（即`NULL`），释放`20`节点。
	- 结果：删除成功，7 号链表变为空链表（视频结论）。
3. 删除`66`（假设`27`已删除）：
	- 定位：散列地址`1`，链表`66 → 1 → 14`，`66`是头节点（无前驱节点）。
	- 操作：`hashTable[1] = 66->next`（即`1`），释放`66`节点。
	- 结果：删除成功，1 号链表变为`1 → 14`（视频隐含案例）。

#### 3.3.3 删除操作代码

c

```c
// 删除函数：返回1=成功，0=失败
int deleteKey(int target) {
    // 步骤1：计算散列地址
    int addr = target % HASH_SIZE;
    Node* p = hashTable[addr];    // 当前遍历节点
    Node* prev = NULL;            // 前驱节点（用于调整指针）
    
    // 步骤2：查找目标节点及前驱节点
    while (p != NULL) {
        if (p->key == target) {
            // 找到目标节点，开始删除
            if (prev == NULL) {
                // 情况1：目标是头节点（无前驱）
                hashTable[addr] = p->next;  // 头指针指向当前节点的下一个
            } else {
                // 情况2：目标是中间/尾节点（有前驱）
                prev->next = p->next;       // 前驱节点指向当前节点的下一个
            }
            // 释放目标节点内存
            free(p);
            printf("删除结果：成功，关键字=%d，地址=%d\n", target, addr);
            return 1;
        }
        // 未找到，更新前驱和当前节点
        prev = p;
        p = p->next;
    }
    
    // 步骤3：遍历到NULL，目标不存在
    printf("删除结果：失败，关键字=%d不存在\n", target);
    return 0;
}
```

## 4. 查找长度计算规则

### 4.1 核心定义

- 查找长度 = **查找过程中 “关键字与关键字” 的对比次数**（视频明确：仅统计 “关键字对比”，空链表的 “头指针`NULL`对比” 不计入）。

- 特殊场景说明：

	| 场景             | 对比次数               | 查找长度 | 示例（视频）                           |
	| ---------------- | ---------------------- | -------- | -------------------------------------- |
	| 空链表查找       | 0                      | 0        | 查找 21（地址 8，空链表）              |
	| 非空链表查找成功 | 找到时的对比次数       | 对比次数 | 查找 27（对比 2 次）                   |
	| 非空链表查找失败 | 遍历所有节点的对比次数 | 对比次数 | 查找 15（地址 1，4 个节点，对比 4 次） |

### 4.2 视频案例验证表

| 目标关键字 | 散列地址 | 链表结构   | 对比次数 | 查找结果 | 查找长度 |
| ---------- | -------- | ---------- | -------- | -------- | -------- |
| 27         | 1        | 66→27→1→14 | 2        | 成功     | 2        |
| 20         | 7        | 20         | 1        | 成功     | 1        |
| 66         | 1        | 66→27→1→14 | 1        | 成功     | 1        |
| 21         | 8        | NULL       | 0        | 失败     | 0        |
| 15         | 1        | 66→27→1→14 | 4        | 失败     | 4        |

## 5. 拓展优化：有序链表插入

### 5.1 优化背景

- 原插入方式（头插 / 尾插）导致链表**无序**，查找时需遍历整个链表（即使目标不存在，也要遍历到尾），效率较低。
- 优化思路：插入新元素时，确保链表保持**递增 / 递减有序**（视频建议 “递增有序”），查找时可提前终止（若当前节点关键字 > 目标，后续节点无需对比）。

#### 5.2 优化示例

以插入`16`到 3 号链表（假设原链表为`55→32`，递增有序）为例：

1. 计算地址：`16 % 13 = 3` → 散列地址`3`。
2. 有序插入：
	- 遍历 3 号链表：`55 > 16`，直接将`16`插入到`55`前面，链表变为`16→55→32`（保持递增）。
3. 查找验证：
	- 查找`16`：第 1 次对比`16 == 16` → 找到，查找长度 = 1。
	- 查找`20`：第 1 次对比`16 < 20`，第 2 次对比`55 > 20` → 提前终止，查找失败，查找长度 = 2（比无序链表遍历 3 次更高效）。

#### 5.3 有序插入代码（视频优化逻辑）

c

```c
// 有序插入函数（保持链表递增有序，视频拓展优化）
void insertKeySorted(int key) {
    int addr = key % HASH_SIZE;
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->key = key;
    newNode->next = NULL;
    
    Node* p = hashTable[addr];    // 当前遍历节点
    Node* prev = NULL;            // 前驱节点（定位插入位置）
    
    // 步骤1：找到插入位置（保持递增有序）
    while (p != NULL && p->key < key) {
        prev = p;
        p = p->next;
    }
    
    // 步骤2：插入新节点
    if (prev == NULL) {
        // 插入到链表头部（原链表为空或新节点最小）
        newNode->next = hashTable[addr];
        hashTable[addr] = newNode;
    } else {
        // 插入到prev和p之间
        newNode->next = p;
        prev->next = newNode;
    }
    
    printf("有序插入成功：关键字%d，地址=%d，链表保持递增\n", key, addr);
}
```

## 6. 完整流程验证

### 6.1 主函数调用（复刻视频操作）

c

```c
int main() {
    // 1. 插入视频中的关键字序列
    int insertKeys[] = {19, 14, 23, 1, 6, 82, 10, 27, 20, 66};
    int insertCount = sizeof(insertKeys)/sizeof(insertKeys[0]);
    printf("=== 第一步：执行插入操作 ===\n");
    for (int i = 0; i < insertCount; i++) {
        insertKey(insertKeys[i]);
    }
    
    // 2. 执行视频中的查找操作
    int searchTargets[] = {27, 20, 66, 21};
    int searchCount = sizeof(searchTargets)/sizeof(searchTargets[0]);
    printf("\n=== 第二步：执行查找操作 ===\n");
    for (int i = 0; i < searchCount; i++) {
        searchKey(searchTargets[i]);
    }
    
    // 3. 执行视频中的删除操作
    int deleteTargets[] = {27, 20, 66};
    int deleteCount = sizeof(deleteTargets)/sizeof(deleteTargets[0]);
    printf("\n=== 第三步：执行删除操作 ===\n");
    for (int i = 0; i < deleteCount; i++) {
        deleteKey(deleteTargets[i]);
    }
    
    // 4. 执行视频拓展的有序插入操作
    printf("\n=== 第四步：执行有序插入操作 ===\n");
    insertKeySorted(16);
    searchKey(16);  // 验证有序插入后的查找
    
    return 0;
}
```

### 6.2 输出结果

plaintext

```plaintext
=== 第一步：执行插入操作 ===
插入成功：关键字19，散列地址：6
插入成功：关键字14，散列地址：1
插入成功：关键字23，散列地址：10
插入成功：关键字1，散列地址：1
插入成功：关键字6，散列地址：6
插入成功：关键字82，散列地址：4
插入成功：关键字10，散列地址：10
插入成功：关键字27，散列地址：1
插入成功：关键字20，散列地址：7
插入成功：关键字66，散列地址：1

=== 第二步：执行查找操作 ===
查找结果：成功，关键字=27，地址=1，查找长度=2
查找结果：成功，关键字=20，地址=7，查找长度=1
查找结果：成功，关键字=66，地址=1，查找长度=1
查找结果：失败，关键字=21，地址=8，查找长度=0

=== 第三步：执行删除操作 ===
删除结果：成功，关键字=27，地址=1
删除结果：成功，关键字=20，地址=7
删除结果：成功，关键字=66，地址=1

=== 第四步：执行有序插入操作 ===
有序插入成功：关键字16，地址=3，链表保持递增
查找结果：成功，关键字=16，地址=3，查找长度=1
```



# 散列表冲突处理 - 开放定址法

## 一、开放定址法基本思想与原理

### 1.1 核心思想

散列表中冲突不可避免，开放定址法的核心是：**当插入元素的初始散列地址冲突时，通过预设规则（探测序列）为元素寻找散列表中的其他空闲位置**。

- 特点：一个散列地址既可以存储其 “同义词”（散列地址相同的元素），也可以存储 “非同义词”（散列地址不同但冲突后探测到该位置的元素），因此称为 “开放” 定址法。

### 1.2 数学原理与关键概念

#### （1）核心公式

插入 / 查找元素时，第`i`次探测的散列地址为：
*H**i*​=(*H*(*k**ey*)+*D**i*​)mod*M*

- *H*(*k**ey*)：元素`key`的初始散列地址（由散列函数计算，如`key mod M`）；
- *D**i*：第`i`次探测的**偏移量**（探测序列的第`i`项）；
- *M*：散列表的表长（确保地址不超出表范围）；
- *i*：探测次数，取值范围 0≤*i*≤*M*−1（最多探测`M`个位置，即全表）。

#### （2）探测序列（增量序列）

- 定义：*D*0,*D*1,*D*2,...,*D**M*−1 构成的序列，规定冲突时的探测顺序；
- 固定规则：*D*0=0（第 0 次探测即初始地址 *H*0=*H*(*k**ey*)）；
- 分类：四种常用探测序列（线性、平方、双散列、伪随机），区别仅在于 *D**i* 的计算方式。

## 二、四种常用探测序列

视频中统一使用示例条件：**散列表长 \*M\*=13，初始散列函数 \*H\*(\*k\**ey\*)=\*k\**ey\*mod13**，以下示例均基于此条件。

### 2.1 线性探测法

#### （1）探测序列规则

偏移量 *D**i*=*i*（即每次探测地址比上一次 + 1），探测顺序为：
*H*0​,*H*0​+1,*H*0​+2,...,*M*−1,0,1,...,*H*0​−1（循环探测）。

#### （2）示例：插入关键字`1`

已知散列表地址`1`、`2`、`3`已被占用，插入`key=1`的步骤：

1. 计算初始地址 *H*0=1mod13=1（冲突，地址 1 已占用）；
2. 第 1 次探测（*i*=1）：*H*1=(1+1)mod13=2（冲突，地址 2 已占用）；
3. 第 2 次探测（*i*=2）：*H*2=(1+2)mod13=3（冲突，地址 3 已占用）；
4. 第 3 次探测（*i*=3）：*H*3=(1+3)mod13=4（空闲，插入`1`到地址 4）。

#### （3）示例：查找关键字`27`

查找`key=27`的步骤：

1. 初始地址 *H*0=27mod13=1（地址 1 关键字≠27）；
2. 第 1 次探测：*H*1=2（关键字≠27）；
3. 第 2 次探测：*H*2=3（关键字≠27）；
4. 第 3 次探测：*H*3=4（关键字≠27）；
5. 第 4 次探测：*H*4=5（地址 5 为空）→ **查找失败**（空地址说明后续无目标元素）。

#### （4）伪代码（插入 + 查找）

python

```python
def linear_probe_insert(hash_table, key, M):
    """线性探测插入：M为表长，hash_table初始为None（空闲）"""
    H0 = key % M  # 初始地址
    # 第0次探测（初始地址）
    if hash_table[H0] is None or hash_table[H0] == "deleted":
        hash_table[H0] = key
        return True  # 插入成功
    # 第1~M-1次探测
    i = 1
    while i < M:
        Hi = (H0 + i) % M
        if hash_table[Hi] is None or hash_table[Hi] == "deleted":
            hash_table[Hi] = key
            return True
        i += 1
    return False  # 表满，插入失败


def linear_probe_search(hash_table, key, M):
    """线性探测查找：返回元素位置，未找到返回-1"""
    H0 = key % M
    if hash_table[H0] == key:
        return H0  # 第0次探测找到
    i = 1
    while i < M:
        Hi = (H0 + i) % M
        if hash_table[Hi] == key:
            return Hi  # 找到元素
        if hash_table[Hi] is None:
            return -1  # 遇到空地址，查找失败
        i += 1
    return -1  # 全表探测未找到
```

### 2.2 平方探测法（二次探测法）

#### （1）探测序列规则

偏移量 *D**i*=±*k*2（*k*=1,2,...），即探测顺序为：
*H*0​,*H*0​+12,*H*0​−12,*H*0​+22,*H*0​−22,...（正负平方交替偏移）。

#### （2）示例：插入关键字`1`

已知散列表地址`1`、`2`、`0`已被占用，插入`key=1`的步骤：

1. 初始地址 *H*0=1mod13=1（冲突）；
2. 第 1 次探测（*k*=1，+12）：*H*1=(1+1)mod13=2（冲突）；
3. 第 2 次探测（*k*=1，−12）：*H*2=(1−1)mod13=0（冲突）；
4. 第 3 次探测（*k*=2，+22）：*H*3=(1+4)mod13=5（空闲，插入`1`到地址 5）。

#### （3）关键结论（视频强调）

- 默认情况下，平方探测仅能覆盖散列表的**一半位置**（即使表未满，也可能找不到空闲位置）；
- 当散列表长 *M* 为 **4k+3 型素数**（如 7、11、19，满足 *M*=4*k*+3 且为质数）时，平方探测可覆盖全表，必能找到空闲位置（若表未满）。

#### （4）伪代码（插入）

python

```python
def quadratic_probe_insert(hash_table, key, M):
    """平方探测插入：M需为4k+3型素数（视频推荐条件）"""
    H0 = key % M
    if hash_table[H0] is None or hash_table[H0] == "deleted":
        hash_table[H0] = key
        return True
    # k从1开始，交替+k²、-k²
    for k in range(1, (M//2) + 1):  # 最多探测M//2次（覆盖全表）
        # 正方向偏移：H0 + k²
        Hi_pos = (H0 + k*k) % M
        if hash_table[Hi_pos] is None or hash_table[Hi_pos] == "deleted":
            hash_table[Hi_pos] = key
            return True
        # 负方向偏移：H0 - k²（确保非负）
        Hi_neg = (H0 - k*k) % M
        if hash_table[Hi_neg] is None or hash_table[Hi_neg] == "deleted":
            hash_table[Hi_neg] = key
            return True
    return False  # 表满或M不满足4k+3条件
```

### 2.3 双散列法

#### （1）探测序列规则

偏移量 *D**i*=*i*×*H*2(*k**ey*)，其中 *H*2(*k**ey*) 是**第二个散列函数**（需与表长 *M* 互质），探测顺序为：
*H*0​,*H*0​+*H*2​(*k**ey*),*H*0​+2×*H*2​(*k**ey*),...,*H*0​+(*M*−1)×*H*2​(*k**ey*)（模 M）。

#### （2）核心要求

*H*2(*k**ey*) 必须与 *M* 互质（即 *g**c**d*(*H*2(*k**ey*),*M*)=1），否则无法覆盖全表。

- 视频推荐策略：若 *M* 为素数，可设 *H*2(*k**ey*)=*M*−(*k**ey*mod*M*)（确保 *H*2(*k**ey*)∈[1,*M*−1]，与素数 *M* 互质）。

#### （3）示例：插入关键字`1`

已知：*M*=13（素数），*H*2(*k**ey*)=13−(*k**ey*mod13)，散列表地址`1`、`0`、`12`已被占用，插入`key=1`的步骤：

1. 计算初始地址 *H*0=1mod13=1（冲突）；
2. 计算第二个散列函数 *H*2(1)=13−(1mod13)=12；
3. 第 1 次探测（*i*=1）：*H*1=(1+1×12)mod13=0（冲突）；
4. 第 2 次探测（*i*=2）：*H*2=(1+2×12)mod13=12（冲突）；
5. 第 3 次探测（*i*=3）：*H*3=(1+3×12)mod13=11（空闲，插入`1`到地址 11）。

#### （4）伪代码（插入）

python

```python
def h2(key, M):
    """第二个散列函数（视频推荐：M为素数时）"""
    return M - (key % M)

def double_hash_insert(hash_table, key, M):
    """双散列插入：M需为素数（确保H2与M互质）"""
    H0 = key % M
    if hash_table[H0] is None or hash_table[H0] == "deleted":
        hash_table[H0] = key
        return True
    H2_val = h2(key, M)  # 计算H2(key)
    i = 1
    while i < M:
        Di = i * H2_val
        Hi = (H0 + Di) % M
        if hash_table[Hi] is None or hash_table[Hi] == "deleted":
            hash_table[Hi] = key
            return True
        i += 1
    return False  # 表满
```

### 2.4 伪随机序列法

#### （1）探测序列规则

偏移量 *D**i* 来自**人为设计的伪随机序列**（如`[5,3,7,2,...]`），序列需提前定义，探测顺序为：
*H*0,*H*0+*D*1​,*H*0+*D*2​,...,*H*0+*D**M*−1​（模 M）。

#### （2）示例：插入关键字`1`

已知：伪随机序列`RandSeq = [5,3,7]`，散列表地址`1`、`6`已被占用，插入`key=1`的步骤：

1. 初始地址 *H*0=1mod13=1（冲突）；
2. 第 1 次探测（*D*1=5）：*H*1=(1+5)mod13=6（冲突）；
3. 第 2 次探测（*D*2=3）：*H*2=(1+3)mod13=4（空闲，插入`1`到地址 4）。

#### （3）关键注意事项

- 伪随机序列的设计决定覆盖率：若序列包含所有`0~M-1`的偏移量（无重复），则可覆盖全表；
- 序列需固定：插入与查找必须使用同一序列，否则无法找到元素。

#### （4）伪代码（插入）

python

```python
def random_probe_insert(hash_table, key, M, rand_seq):
    """伪随机序列探测插入：rand_seq为预设伪随机序列"""
    H0 = key % M
    if hash_table[H0] is None or hash_table[H0] == "deleted":
        hash_table[H0] = key
        return True
    # 遍历伪随机序列探测
    for Di in rand_seq:
        Hi = (H0 + Di) % M
        if hash_table[Hi] is None or hash_table[Hi] == "deleted":
            hash_table[Hi] = key
            return True
    return False  # 表满或序列未覆盖空闲位置
```

## 三、开放定址法的删除操作（核心坑点与解决方案）

### 3.1 问题：物理删除的致命缺陷

若直接 “物理删除”（将元素位置设为`None`），会**断裂后续元素的探测路径**，导致查找失败。

- 示例（视频案例）：
	1. 线性探测表中，地址`2`存`15`、地址`3`存`1`；
	2. 物理删除`15`（地址`2`设为`None`）；
	3. 查找`1`时：*H*0=1（占用）→ *H*1=2（`None`）→ 判定 “查找失败”（实际`1`在地址`3`），错误。

### 3.2 解决方案：逻辑删除

删除元素时，不将位置设为`None`，而是标记为 **“已删除”（如字符串 "deleted"）**，确保探测路径连续。

- 正确步骤（视频案例）：
	1. 删除`15`时，将地址`2`标记为 "deleted"；
	2. 查找`1`时：*H*0=1（占用）→ *H*1=2（"deleted"，继续探测）→ *H*2=3（找到`1`），成功。

### 3.3 逻辑删除的衍生问题与处理

1. **查找效率下降**：大量 “已删除” 标记会导致探测路径变长；
	- 解决方案：不定期整理散列表（如将元素移回其初始地址，物理删除 “已删除” 位置）。
2. **空闲位置复用**：新元素可插入 “已删除” 位置（伪代码中已体现，判断条件包含`hash_table[Hi] == "deleted"`）。

### 3.4 删除操作伪代码（通用）

python

```python
def open_address_delete(hash_table, key, M, probe_search):
    """开放定址法通用删除：probe_search为对应探测方法的查找函数"""
    pos = probe_search(hash_table, key, M)  # 先查找元素位置
    if pos == -1:
        return False  # 元素不存在，删除失败
    hash_table[pos] = "deleted"  # 逻辑删除，标记为"已删除"
    return True
```

## 四、拓展：探测序列覆盖率

| 探测方法     | 覆盖率规则                                                   |
| ------------ | ------------------------------------------------------------ |
| 线性探测法   | 无条件覆盖全表：最多探测`M-1`次，必能找到空闲位置（若表未满）。 |
| 平方探测法   | 仅当`M`为**4k+3 型素数**时覆盖全表；否则仅覆盖一半位置。     |
| 双散列法     | 仅当`H2(key)`与`M`互质时覆盖全表；常用策略：`M`设为素数，`H2(key)=M-(key%M)`。 |
| 伪随机序列法 | 覆盖率取决于序列设计：需确保序列包含所有`0~M-1`的偏移量（无重复）。 |

## 五、核心考点总结（视频强调）

1. 开放定址法的核心是**探测序列**，四种方法的区别仅在于`D_i`的计算；
2. 查找终止条件：找到目标元素（成功）或遇到`None`（失败），遇到 “已删除” 需继续探测；
3. 删除必须用**逻辑删除**，否则会破坏探测路径；
4. 平方探测法的`M`需为 4k+3 型素数、双散列法的`H2(key)`需与`M`互质（确保覆盖率）。



# 散列查找的性能分析（基于线性探测法）

## 一、核心前提

视频明确：历年考研真题中，**80% 的散列查找性能分析题基于线性探测法**，因此以该方法为核心展开，需先明确基础概念：

- 散列表：存储关键字的数组，长度记为`M`（数组下标从 0 开始）；
- 散列函数：映射关键字到初始散列地址的函数，视频中示例均为 “取余法”（如`H(key) = key % 13`）；
- 冲突处理：线性探测法 —— 若初始地址`H(key)`被占用，依次探测`H(key)+1, H(key)+2, ..., M-1`，直到找到空地址。

## 二、平均查找长度（ASL）计算（考研重点）

ASL（Average Search Length）是衡量散列查找性能的核心指标，分**查找成功**和**查找失败**两种场景，需结合具体例题计算。

### 2.1 例题基础条件

- 散列表长度`M=16`（下标 0~15）；
- 散列函数`H(key) = key % 13`；
- 冲突处理：线性探测法；
- 关键字插入序列：`19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79`（共 12 个关键字）。

### 2.2 步骤 1：构造散列表

逐个分析关键字插入过程，明确每个关键字的最终存储地址（解决冲突的过程）：

| 散列表下标   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 存储的关键字 | -    | 14   | 1    | 68   | 27   | 55   | 19   | 20   | 84   | 79   | 23   | 11   | 10   | -    | -    | -    |

#### 插入过程详解（冲突处理重点）

1. **19**：`H(19)=19%13=6`，下标 6 为空→插入 6；
2. **14**：`H(14)=14%13=1`，下标 1 为空→插入 1；
3. **23**：`H(23)=23%13=10`，下标 10 为空→插入 10；
4. **1**：`H(1)=1%13=1`，下标 1 被 14 占用（冲突）→探下标 2（空）→插入 2；
5. **68**：`H(68)=68%13=3`，下标 3 为空→插入 3；
6. **20**：`H(20)=20%13=7`，下标 7 为空→插入 7；
7. **84**：`H(84)=84%13=6`，下标 6 被 19 占用（冲突）→探 7（被 20 占用）→探 8（空）→插入 8；
8. **27**：`H(27)=27%13=1`，下标 1 被 14 占用（冲突）→探 2（被 1 占用）→探 3（被 68 占用）→探 4（空）→插入 4；
9. **55**：`H(55)=55%13=3`，下标 3 被 68 占用（冲突）→探 4（被 27 占用）→探 5（空）→插入 5；
10. **11**：`H(11)=11%13=11`，下标 11 为空→插入 11；
11. **10**：`H(10)=10%13=10`，下标 10 被 23 占用（冲突）→探 11（被 11 占用）→探 12（空）→插入 12；
12. **79**：`H(79)=79%13=1`，下标 1 被 14 占用（冲突）→依次探 2、3、4、5、6、7、8（均被占用）→探 9（空）→插入 9。

### 2.3 步骤 2：计算 “查找成功” 的 ASL

#### 原理

- 查找成功：目标关键字在散列表中，需统计 “从初始地址到目标地址的关键字比较次数”（即查找长度）；
- 等概率假设：每个关键字被查找的概率 = `1 / 关键字总数N`（本题`N=12`）；
- 公式：`ASL成功 = (sum(每个关键字的查找长度)) / N`。

#### 各关键字的查找长度

| 关键字   | 19   | 14   | 23   | 1    | 68   | 20   | 84   | 27   | 55   | 11   | 10   | 79   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 查找长度 | 1    | 1    | 1    | 2    | 1    | 1    | 3    | 4    | 3    | 1    | 3    | 9    |

#### 计算过程

- 总和：`1+1+1+2+1+1+3+4+3+1+3+9 = 30`；
- `ASL成功 = 30 / 12 = 2.5`。

### 2.4 步骤 3：计算 “查找失败” 的 ASL

#### 原理

- 查找失败：目标关键字不在散列表中，需统计 “从初始地址开始，探测到第一个空地址的关键字比较次数”（空地址指未插入任何关键字的位置，本题为空地址：0、13、14、15）；
- 等概率假设：初始散列地址的概率 = `1 / 散列函数取值总数R`（本题`H(key)=key%13`，取值 0~12，共`R=13`种，**易错点：不是散列表长度 16**）；
- 公式：`ASL失败 = (sum(每个初始地址的查找长度)) / R`。

#### 各初始地址的查找长度

| 初始地址 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 查找长度 | 1    | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    |

#### 计算过程

- 总和：`1+13+12+11+10+9+8+7+6+5+4+3+2 = 91`；
- `ASL失败 = 91 / 13 = 7`。

## 三、散列表删除的注意事项（以删除 “20” 为例）

### 3.1 核心规则

**开放定址法（含线性探测法）处理冲突的散列表，删除元素必须用 “逻辑删除”，不能物理删除（即不能将地址置空）**。

### 3.2 原因

物理删除会导致后续查找误判失败：若将 20 所在的下标 7 置空，查找 79 时（初始地址 1），探测到 7（空）会误以为 “查找失败”，但 79 实际存储在 9，需继续探测；逻辑删除仅标记 “该元素已删除”，不视为空地址，后续探测需继续。

### 3.3 删除后的 ASL 计算

- **查找成功的 ASL**：关键字总数变为`N=11`，剩余关键字的查找长度与删除前一致（逻辑删除不影响探测路径），假设剩余关键字查找长度总和为`30-1=29`（减去 20 的查找长度 1），则`ASL成功 = 29 / 11 ≈ 2.64`；
- **查找失败的 ASL**：逻辑删除的下标 7 不视为空地址，各初始地址的查找长度与删除前一致，总和仍为 91，`ASL失败 = 91 / 13 = 7`（无变化）。

## 四、装填因子（α）

### 4.1 定义

装填因子是散列表 “满度” 的指标，公式：`α = 散列表中关键字总数N / 散列表长度M`。

### 4.2 视频示例

本题`N=12`，`M=16`，则`α = 12/16 = 0.75`。

### 4.3 对性能的影响

- **α 越大，冲突概率越高，ASL 越大**：α 接近 1 时，散列表接近满，插入 / 查找需多次探测（如 α=0.75 时，初始地址 1~12 插入新元素均会冲突，仅初始地址 0 可直接插入）；
- **α=1 时**：散列表完全满，无法插入新元素（需扩容后再插入）；
- **α 越小**：冲突概率越低，ASL 越小，但散列表空间利用率低。

## 五、聚集现象（堆积现象）

### 5.1 定义

处理冲突时，**多个初始散列地址不同的关键字，争夺同一个后继散列地址**的现象，会导致关键字 “扎堆” 存储，显著增加 ASL。

### 5.2 线性探测法的缺陷

线性探测法仅探测 “相邻下一个地址”，极易产生聚集现象（关键字连续扎堆）。

### 5.3 视频示例（线性探测法的聚集）

#### 条件

- 散列表长度`M=27`；
- 散列函数`H(key)=key%23`；
- 冲突处理：线性探测法；
- 插入序列：`6, 29, 52, 75, 98, 121, 144`。

#### 插入过程（聚集结果）

1. **6**：`H(6)=6`→插入 6；
2. **29**：`H(29)=6`（冲突）→探 7→插入 7；
3. **52**：`H(52)=6`（冲突）→探 7（冲突）→探 8→插入 8；
4. **75**：`H(75)=6`（冲突）→探 7、8（冲突）→探 9→插入 9；
5. **98**：`H(98)=6`（冲突）→探 7、8、9（冲突）→探 10→插入 10；
6. **121**：`H(121)=6`（冲突）→探 7~10（冲突）→探 11→插入 11；
7. **144**：`H(144)=6`（冲突）→探 7~11（冲突）→探 12→插入 12；

#### 结果

关键字聚集在`6~12`，后续初始地址为`6~12`的新元素均需争夺`13`，聚集现象明显。

### 5.4 缓解聚集的方法

改用 “非相邻探测” 的冲突处理方式，如**平方探测法、双散列法、伪随机序列法**，核心是让探测地址分散，避免连续扎堆。

### 5.5 视频示例（平方探测法缓解聚集）

#### 条件

同 5.3（`M=27`，`H(key)=key%23`），冲突处理改为**平方探测法**（探测序列：`H(key)±k²`，`k=1,2,3...`，地址需模`M`确保在 0~26 范围内）。

#### 插入过程（分散结果）

1. **6**：`H(6)=6`→插入 6；
2. **29**：`H(29)=6`（冲突）→`k=1`→`6+1²=7`（空）→插入 7；
3. **52**：`H(52)=6`（冲突）→`k=1`→7（冲突）→`6-1²=5`（空）→插入 5；
4. **75**：`H(75)=6`（冲突）→`k=1`→7、5（冲突）→`k=2`→`6+2²=10`（空）→插入 10；
5. **98**：`H(98)=6`（冲突）→`k=1`→7、5（冲突）→`k=2`→10（冲突）→`6-2²=2`（空）→插入 2；
6. **121**：`H(121)=6`（冲突）→`k=1`→7、5（冲突）→`k=2`→10、2（冲突）→`k=3`→`6+3²=15`（空）→插入 15；
7. **144**：`H(144)=6`（冲突）→`k=1`→7、5（冲突）→`k=2`→10、2（冲突）→`k=3`→15（冲突）→`6-3²=24`（空）→插入 24；

#### 结果

关键字分布在`2,5,6,7,10,15,24`，无连续扎堆，聚集现象显著缓解。

## 六、核心总结

1. **ASL 计算是重点**：查找成功需统计 “目标关键字的比较次数”，查找失败需统计 “探到空地址的比较次数”，且查找失败的概率基数是 “散列函数取值数” 而非散列表长度；
2. **删除需逻辑删除**：开放定址法下，物理删除会破坏探测路径，导致查找误判；
3. **装填因子决定冲突率**：α 越大，冲突越多，ASL 越大；
4. **线性探测法易聚集**：需用平方探测法等非相邻探测方式缓解，提升查找效率。