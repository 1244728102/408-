# 排序的基本概念

## 1. 排序的定义与应用场景

### 1.1 排序的核心定义

排序是将一组**数据元素**按照其**关键字**（排序的依据字段）的**递增或递减顺序**重新排列的过程，最终需保证关键字序列满足 “有序性”（要么从小到大，要么从大到小）。
需特别注意：此前章节默认 “关键字唯一”，但排序场景中**关键字可能重复**（如相同分数、相同战力），这是后续 “稳定性” 概念的核心前提。

### 1.2 典型应用示例

通过实际场景帮助理解排序的实用价值，示例均来自视频：

1. **王者荣耀荣耀战力排行榜**：以 “荣耀战力” 为关键字，按 “递减顺序” 排序（战力越高排名越靠前），存在多个玩家战力相同的情况；
2. **2019 年国内大佬财富排行**：以 “财富值” 为关键字，按 “递减顺序” 排序，直观体现排序在数据筛选、展示中的核心作用。

## 2. 排序算法的评价指标

评价排序算法需关注 3 个核心维度，其中 “稳定性” 是排序算法特有的关键指标，前两者为通用算法评价指标。

### 2.1 时间复杂度

- 定义：算法执行过程中**基本操作的执行次数**（与数据规模`n`的函数关系），反映算法 “运行快慢”；
- 视频说明：后续学习具体排序算法（如冒泡、快排）时，会分别分析其 “最好情况”“最坏情况”“平均情况” 的时间复杂度，是排序算法性能对比的核心依据之一。

### 2.2 空间复杂度

- 定义：算法执行过程中**额外占用的存储空间**（与数据规模`n`的函数关系），反映算法 “内存消耗”；
- 视频说明：例如是否需要额外数组、栈、队列等辅助空间，是区分 “原地排序”（空间复杂度`O(1)`，无需额外空间）与 “非原地排序”（如归并排序需`O(n)`额外空间）的关键。

### 2.3 稳定性（排序算法特有指标）

#### 2.3.1 稳定性的定义

假设待排序序列中存在**关键字相同的两个元素**（记为元素 A 和元素 B，且排序前 A 在 B 的左侧）：

- 若排序后，A 仍保持在 B 的左侧（两者相对位置不变），则该排序算法为**稳定排序算法**；
- 若排序后，A 可能出现在 B 的右侧（两者相对位置可能改变），则该排序算法为**不稳定排序算法**。

#### 2.3.2 视频中的经典示例（紫色 3 与红色 3）

- 待排序序列（关键字相同元素的初始位置）：`[..., 紫色3（A）, ..., 红色3（B）, ...]`（A 在 B 左侧）；
- 稳定排序结果：`[..., 紫色3（A）, 红色3（B）, ...]`（A 与 B 的相对位置不变）；
- 不稳定排序的可能结果：`[..., 红色3（B）, 紫色3（A）, ...]`（A 与 B 的相对位置改变）。

#### 2.3.3 稳定性的 “优劣判断”（ “无绝对好坏，需结合需求”）

- 若场景**不要求**保留关键字相同元素的原始顺序（如仅按 “成绩” 排序，不关心同分数学生的先后），则稳定 / 不稳定算法均可使用；
- 若场景**要求**保留关键字相同元素的原始顺序（如先按 “班级” 排序，再按 “成绩” 排序，需保证同班内学生的原始顺序不被打乱），则必须使用稳定算法；
- 若待排序序列中**所有元素的关键字均唯一**（无重复），则稳定与不稳定算法的排序结果完全一致，此时 “稳定性” 无实际意义。

## 3. 排序算法的分类（按数据存储位置）

视频中将排序算法分为 “内部排序” 和 “外部排序” 两大类，本章节先学习内部排序，后续小节再深入外部排序。

### 3.1 内部排序

#### 3.1.1 定义

所有待排序数据可**全部放入内存**中进行排序（数据量较小，内存容量足以容纳）。

- 视频示例：程序中定义的基础数据类型数组（如`int arr[1000]`），数据全部存储在内存中，排序过程仅对内存中的数据进行操作。

#### 3.1.2 核心关注指标

因内存读写速度极快（视频未提及具体数值，但暗示 “内存操作无 IO 瓶颈”），设计内部排序算法时，**重点关注时间复杂度和空间复杂度**，无需额外考虑外存 IO 耗时。

### 3.2 外部排序

#### 3.2.1 定义

待排序数据量**过大**（如超过 8GB 的超大文件），无法一次性全部放入内存，需借助**外存（如磁盘）** 分批次处理：先将部分数据读入内存排序，再写回磁盘；重复该过程，直至所有数据排序完成。

#### 3.2.2 核心关注指标（与内部排序的关键差异）

磁盘读写速度远慢于内存（机械硬盘读写速度约 100MB/s，内存读写速度约 60GB/s，两者相差约 600 倍），因此外部排序除关注时间复杂度和空间复杂度外，**更需优先关注 “读写磁盘的次数”**—— 减少磁盘 IO 次数是降低外部排序总耗时的核心手段（磁盘 IO 是外部排序的性能瓶颈）。

## 4. 推荐的排序算法可视化学习工具

推荐 “美国旧金山大学算法可视化网站”，用于直观理解排序算法的执行流程，具体功能如下：

### 4.1 网站核心功能

1. **生成随机待排序数组**：点击 “render my array” 可随机生成新的待排序数组（数组元素以 “竖条” 形式展示，竖条高度对应关键字大小）；
2. **选择排序算法模拟**：支持选择多种排序算法（如 “Bubble Sort（冒泡排序）”），点击后可动态演示算法的每一步执行过程；
3. **调节执行速度与单步调试**：通过滑块调节模拟速度，支持 “暂停”“Step Forward（单步执行）”，便于观察算法细节（如元素交换、比较过程）；
4. **支持多类算法可视化**：除排序算法外，还可模拟 B 树、哈希表、迪杰斯特拉算法、普利姆算法、拓扑排序等，且**排序算法的逻辑与考研大纲要求完全一致**。

### 4.2 使用优势

无需配置任何开发环境，通过浏览器（含手机浏览器）即可直接访问，适合通过 “可视化动态过程” 理解复杂排序算法（如快速排序、堆排序）的执行逻辑。



# 插入排序知识点总结

## 1. 插入排序核心思想

- **核心逻辑**：不断将待排序的记录，按照关键字大小插入到**前面已排好序的子序列**中，直到所有记录插入完成。
- **起始点**：从第 2 个元素（索引为 1，假设数组从 0 开始）开始处理，因为第 1 个元素（索引 0）默认是 “已排好序的子序列”。
- **核心操作**：对当前待插入元素，依次与前面有序子序列的元素对比，将 “比当前元素大” 的元素依次后移，腾出位置后插入当前元素。

## 2. 直接插入排序（基础实现）

视频中讲解了两种直接插入排序实现：普通版（用临时变量）和带哨兵版（用数组第 0 位存临时值）。

### 2.1 普通实现（无哨兵）

#### 2.1.1 代码实现（与视频完全一致）

假设排序对象为`int`型数组`a`，共`n`个元素，按**递增顺序**排序：

c

```c
void InsertSort(int a[], int n) {
    int i, j, temp; // i：当前待插入元素的索引；j：有序子序列的遍历指针；temp：保存当前待插入元素
    // 从第2个元素（i=1）开始处理，i遍历到最后一个元素（i=n-1）
    for (i = 1; i < n; i++) {
        // 只有当前元素比前一个元素小，才需要调整（若更大则已在正确位置，无需移动）
        if (a[i] < a[i - 1]) {
            temp = a[i]; // 保存当前元素，防止后续移动时被覆盖
            // 从有序子序列的末尾（i-1）往前遍历，比temp大的元素依次后移
            for (j = i - 1; j >= 0 && a[j] > temp; j--) {
                a[j + 1] = a[j]; // 元素后移
            }
            // 跳出循环时，j指向“第一个比temp小的元素”，插入位置为j+1
            a[j + 1] = temp;
        }
    }
}
```

#### 2.1.2 示例演示

视频中初始数组：`a = [49, 38, 65, 97, 76, 13, 27, 49]`（共 8 个元素，n=8），步骤如下：

1. **处理 i=1（元素 38）**：
	- 38 < 49（前一个元素），temp=38；
	- j=0，a[0]=49 > 38 → a[1]=49，j=-1；
	- 插入到 j+1=0 位置 → a 变为`[38, 49, 65, 97, 76, 13, 27, 49]`。
2. **处理 i=2（元素 65）**：
	- 65 > 49（前一个元素）→ 无需调整，数组不变。
3. **处理 i=3（元素 97）**：
	- 97 > 65 → 无需调整，数组不变。
4. **处理 i=4（元素 76）**：
	- 76 < 97，temp=76；
	- j=3，a[3]=97 > 76 → a[4]=97，j=2；
	- a [2]=65 ≤ 76 → 插入到 j+1=3 位置 → a 变为`[38, 49, 65, 76, 97, 13, 27, 49]`。
5. **处理 i=5（元素 13）**：
	- 13 < 97，temp=13；
	- j=4（97>13→a[5]=97）→ j=3（76>13→a[4]=76）→ j=2（65>13→a[3]=65）→ j=1（49>13→a[2]=49）→ j=0（38>13→a[1]=38）→ j=-1；
	- 插入到 j+1=0 位置 → a 变为`[13, 38, 49, 65, 76, 97, 27, 49]`。
6. **处理 i=6（元素 27）**：
	- 27 < 97，temp=27；
	- j=5（97>27→a[6]=97）→ j=4（76>27→a[5]=76）→ j=3（65>27→a[4]=65）→ j=2（49>27→a[3]=49）→ j=1（38>27→a[2]=38）→ j=0（13≤27）；
	- 插入到 j+1=1 位置 → a 变为`[13, 27, 38, 49, 65, 76, 97, 49]`。
7. **处理 i=7（元素 49，下划线区分）**：
	- 49 < 97，temp=49；
	- j=6（97>49→a[7]=97）→ j=5（76>49→a[6]=76）→ j=4（65>49→a[5]=65）→ j=3（49≤49）；
	- 插入到 j+1=4 位置 → 最终数组`[13, 27, 38, 49, 49, 65, 76, 97]`。

### 2.2 带哨兵实现（优化循环判断）

#### 2.2.1 核心优化点

- **哨兵位置**：数组从**索引 1**开始存储数据，索引 0 作为 “哨兵”（临时存储待插入元素）；
- **减少判断**：无需在循环中判断`j >= 0`（哨兵`a[0]`会与自身比较，自然终止循环），略微提升效率。

#### 2.2.2 代码实现

c

```c
void SentinelInsertSort(int a[], int n) {
    int i, j; // i：当前待插入元素的索引（从2开始，a[1]默认有序）；j：有序子序列遍历指针
    // 从第2个元素（i=2）开始处理，n为数据元素个数（a[1]~a[n]是数据）
    for (i = 2; i <= n; i++) {
        // 只有当前元素比前一个小，才需要调整
        if (a[i] < a[i - 1]) {
            a[0] = a[i]; // 哨兵位置保存当前待插入元素
            // 从有序子序列末尾（i-1）往前遍历，比哨兵大的元素后移
            for (j = i - 1; a[j] > a[0]; j--) {
                a[j + 1] = a[j]; // 元素后移
            }
            // 插入到j+1位置（跳出循环时a[j] <= a[0]）
            a[j + 1] = a[0];
        }
    }
}
```

#### 2.2.3 示例演示

初始数组（a [0] 为哨兵，a [1]~a [8] 为数据）：`a = [0, 49, 38, 65, 97, 76, 13, 27, 49]`（n=8）

1. **处理 i=2（元素 38）**：
	- 38 < 49 → a[0] = 38；
	- j=1，a[1]=49 > 38 → a[2]=49，j=0；
	- a [0]=38 不大于 a [0] → 插入到 j+1=1 位置 → a [1]=38，数组变为`[38, 38, 49, 65, 97, 76, 13, 27, 49]`。
2. 后续步骤与普通实现逻辑一致，最终哨兵位置不影响结果，数据区（a [1]~a [8]）为`[13, 27, 38, 49, 49, 65, 76, 97]`。

## 3. 直接插入排序算法性能

### 3.1 空间复杂度

- **复杂度**：`O(1)`；
- **原因**：仅使用常数级辅助空间（普通版的`temp`，带哨兵版的`a[0]`，均与数据规模`n`无关）。

### 3.2 时间复杂度

时间开销主要来自 “关键字对比” 和 “元素移动”，分三种情况：

| 情况     | 条件             | 对比次数                   | 移动次数                                 | 时间复杂度 |
| -------- | ---------------- | -------------------------- | ---------------------------------------- | ---------- |
| 最好情况 | 数组已按递增有序 | `n-1`（每个元素只比 1 次） | `0`（无需移动）                          | `O(n)`     |
| 最坏情况 | 数组按递减逆序   | `n(n-1)/2`                 | `n(n-1)/2 + (n-1)`（移动次数比对比多 1） | `O(n²)`    |
| 平均情况 | 元素随机分布     | 约`n²/4`                   | 约`n²/4`                                 | `O(n²)`    |

- 视频强调：平均时间复杂度按 “最好 + 最坏” 取平均计算，最终为`O(n²)`。

### 3.3 稳定性

- **结论**：**稳定排序**；
- **原因**：当遇到与待插入元素相等的元素时，视频中明确 “不移动相等元素”（如示例中最后处理的 49，与前面的 49 相等，插入到其后，保持原有相对顺序）。

## 4. 折半插入排序（优化查找效率）

### 4.1 核心思路

- **优化点**：前面的有序子序列支持 “随机访问”（数组），可用**折半查找**快速确定插入位置，减少 “关键字对比次数”；
- **局限性**：元素移动次数与直接插入排序一致（仍需平移元素），因此时间复杂度未本质改变。

### 4.2 代码实现（与视频完全一致）

数组从索引 1 存储数据，索引 0 为临时存储位：

c

```c
void BinaryInsertSort(int a[], int n) {
    int i, j, low, high, mid; // low/high：折半查找的边界；mid：中间位置
    // 从第2个元素（i=2）开始处理，n为数据元素个数（a[1]~a[n]）
    for (i = 2; i <= n; i++) {
        a[0] = a[i]; // 保存待插入元素（临时存储，非哨兵，仅用于对比）
        low = 1;     // 折半查找的左边界（有序子序列起点）
        high = i - 1;// 折半查找的右边界（有序子序列终点）
        
        // 折半查找插入位置（核心：相等时往右侧找，保证稳定性）
        while (low <= high) {
            mid = (low + high) / 2; // 中间位置（整数除法）
            if (a[mid] > a[0]) {    // 中间元素比待插入元素大，往左找
                high = mid - 1;
            } else {                // 中间元素<=待插入元素，往右找（保证稳定性）
                low = mid + 1;
            }
        }
        // 插入位置为high+1，将high+1到i-1的元素后移
        for (j = i - 1; j >= high + 1; j--) {
            a[j + 1] = a[j];
        }
        // 插入待插入元素
        a[high + 1] = a[0];
    }
}
```

### 4.3 示例演示

假设有序子序列为`[50, 60, 70]`（a [1]~a [3]），待插入元素为 60（a [4]=60）：

1. `a[0] = 60`，low=1，high=3；
2. 第一次循环：mid=(1+3)/2=2 → a [2]=60 <= 60 → low=3；
3. 第二次循环：mid=(3+3)/2=3 → a [3]=70 > 60 → high=2；
4. 跳出循环（low=3 > high=2），插入位置为 high+1=3；
5. 将 a [3]（70）后移到 a [4]，插入 60 到 a [3] → 有序子序列变为`[50, 60, 60, 70]`，保持稳定性。

### 4.4 性能分析

- **空间复杂度**：`O(1)`（与直接插入排序一致）；
- **时间复杂度**：仍为`O(n²)`（对比次数减少，但移动次数不变，总开销仍由移动次数主导）；
- **稳定性**：稳定（折半查找时，相等元素往右侧找，保证原有顺序）。

## 5. 链表的插入排序

### 5.1 核心限制与优化

- **限制**：链表不支持随机访问，无法用折半查找，只能**顺序遍历对比**；
- **优化**：移动元素无需 “平移”，仅需修改指针指向，减少元素移动开销。

### 5.2 实现思路

1. 构建一个**带头节点的空有序链表**（初始仅含头节点）；
2. 遍历原无序链表，依次取出每个节点；
3. 在有序链表中顺序查找 “第一个比当前节点大” 的前驱节点；
4. 修改指针，将当前节点插入到前驱节点之后；
5. 重复步骤 2~4，直到原链表遍历完成。

### 5.3 性能分析

- **时间复杂度**：`O(n²)`（对比次数仍为`O(n²)`，移动（指针修改）为`O(1)`）；
- **空间复杂度**：`O(1)`（仅需几个指针变量，无额外空间开销）；
- **稳定性**：稳定（相等元素插入到其后，保持相对顺序）。



# 希尔排序知识点总结

## 1. 希尔排序的核心思想

- **优化基础**：直接插入排序在 “元素基本有序” 时效率极高（移动元素次数少），希尔排序以此为核心进行优化。
- **核心逻辑**：不直接对全局表排序，而是先通过 “增量划分” 让表 “部分有序”，再逐步缩小增量逼近 “全局有序”，具体步骤：
	1. 设定**增量 d**，将相距 d 的元素归为同一子表；
	2. 对每个子表执行**直接插入排序**；
	3. 逐步减小 d（每次按规则缩小，直到 d=1）；
	4. 当 d=1 时，对全局表执行直接插入排序（此时表已基本有序，效率高）。
- **命名来源**：由计算机科学家希尔（Shell）发明，因此得名。

## 2. 增量序列的选择

增量 d 是希尔排序的关键，视频中明确介绍了两类常用增量序列，且强调 “考试常考自定义增量”。

### 2.1 希尔本人建议的经典增量序列

- **规则**：初始增量为元素总数的一半（d₀ = n/2），后续每次将增量减半（dₖ₊₁ = dₖ/2），直到 d=1。
- **示例**：若元素总数 n=8，增量序列为 **4 → 2 → 1**。

### 2.2 考试常考的自定义增量序列

- **规则**：增量序列由题目直接给定（非固定减半），需按题目要求的 d 依次处理。
- **示例**：题目可能指定增量序列为 **3 → 1**，需先按 d=3 排序，再按 d=1 排序。

## 3. 希尔排序过程示例

视频中所有案例均基于**1-based 索引**（元素位置从 1 开始，与代码中的数组索引逻辑一致），初始序列统一为：`[49, 38, 65, 97, 76, 13, 27, 49]`（共 8 个元素，位置 1~8）。

### 3.1 案例 1：经典增量序列（d=4 → 2 → 1）

#### 第一趟：d=4（n/2=8/2=4）

- **子表划分**：相距 4 的元素为同一子表，共 4 个子表：
	- 子表 1：位置 1（49）、位置 5（76）
	- 子表 2：位置 2（38）、位置 6（13）
	- 子表 3：位置 3（65）、位置 7（27）
	- 子表 4：位置 4（97）、位置 8（49）
- **子表插入排序**：
	- 子表 1（49,76）：已有序，不变；
	- 子表 2（38,13）：排序后为（13,38）→ 位置 2 和 6 交换；
	- 子表 3（65,27）：排序后为（27,65）→ 位置 3 和 7 交换；
	- 子表 4（97,49）：排序后为（49,97）→ 位置 4 和 8 交换。
- **第一趟结果**：`[49, 13, 27, 49, 76, 38, 65, 97]`

#### 第二趟：d=2（4/2=2）

- **子表划分**：相距 2 的元素为同一子表，共 2 个子表：
	- 子表 1：位置 1（49）、位置 3（27）、位置 5（76）、位置 7（65）
	- 子表 2：位置 2（13）、位置 4（49）、位置 6（38）、位置 8（97）
- **子表插入排序**：
	- 子表 1（49,27,76,65）：排序后为（27,49,65,76）→ 调整位置 1、3、5、7；
	- 子表 2（13,49,38,97）：排序后为（13,38,49,97）→ 调整位置 2、4、6、8。
- **第二趟结果**：`[27, 13, 49, 38, 65, 49, 76, 97]`

#### 第三趟：d=1（2/2=1）

- **子表划分**：d=1 时所有元素归为同一子表（全局表）；
- **全局直接插入排序**：此时表已基本有序，排序后得到最终结果：
	- **最终结果**：`[13, 27, 38, 49, 49, 65, 76, 97]`

### 3.2 案例 2：考试常考增量序列（d=3 → 1）

#### 第一趟：d=3

- **子表划分**：相距 3 的元素为同一子表，共 3 个子表：
	- 子表 1：位置 1（49）、位置 4（97）、位置 7（27）
	- 子表 2：位置 2（38）、位置 5（76）、位置 8（49）
	- 子表 3：位置 3（65）、位置 6（13）
- **子表插入排序**：
	- 子表 1（49,97,27）：排序后为（27,49,97）→ 调整位置 1、4、7；
	- 子表 2（38,76,49）：排序后为（38,49,76）→ 调整位置 2、5、8；
	- 子表 3（65,13）：排序后为（13,65）→ 调整位置 3、6。
- **第一趟结果**：`[27, 38, 13, 49, 49, 65, 97, 76]`

#### 第二趟：d=1

- **全局直接插入排序**：最终结果与案例 1 一致：`[13, 27, 38, 49, 49, 65, 76, 97]`

## 4. 希尔排序的代码实现

视频中采用**1-based 数组索引**（数组 arr [0] 未使用，元素存储在 arr [1]~arr [n]），核心逻辑为 “按增量划分子表，轮流处理子表的直接插入排序”，代码如下（C 语言风格）：

### 4.1 完整代码

c

```c
#include <stdio.h>
#define MAX_SIZE 100  // 定义数组最大容量（适配视频案例）

/**
 * 希尔排序函数
 * @param arr：待排序数组（1-based索引，arr[1]~arr[n]存储元素）
 * @param n：待排序元素的个数
 */
void ShellSort(int arr[], int n) {
    int d;          // 当前排序的增量
    int i, j;       // i：当前处理元素的索引；j：子表中前驱元素的索引
    int temp;       // 暂存当前待插入元素（避免移动时覆盖）

    // 1. 增量循环：从n/2开始，每次减半，直到d>=1
    for (d = n / 2; d >= 1; d /= 2) {
        // 2. 元素处理循环：从d+1开始（子表的第二个元素，直接插入排序从第二个元素开始）
        for (i = d + 1; i <= n; i++) {
            temp = arr[i];  // 3. 暂存当前元素（防止后续移动元素时被覆盖）
            j = i - d;      // 4. j指向当前元素在子表中的前一个元素（相距d）

            // 5. 子表内查找插入位置：j不越界且前驱元素>当前元素，需后移
            while (j >= 1 && arr[j] > temp) {
                arr[j + d] = arr[j];  // 前驱元素后移d个位置（子表内的“后移”）
                j -= d;              // j继续向前找子表的前一个元素
            }

            // 6. 将当前元素插入到正确位置（j+d）
            arr[j + d] = temp;
        }
    }
}

// 测试函数（与视频案例1的初始序列一致）
int main() {
    // 1-based索引：arr[1]~arr[8]为待排序元素，arr[0]未使用
    int arr[MAX_SIZE] = {0, 49, 38, 65, 97, 76, 13, 27, 49};
    int n = 8;  // 待排序元素的个数
    int i;

    // 打印初始序列
    printf("初始序列：");
    for (i = 1; i <= n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // 执行希尔排序
    ShellSort(arr, n);

    // 打印排序后序列
    printf("排序后序列：");
    for (i = 1; i <= n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```

### 4.2 代码逻辑说明

1. **增量控制**：外层`for`循环控制增量 d，从`n/2`开始逐步减半，确保最终 d=1（全局排序）；
2. **子表处理顺序**：中层`for`循环通过`i从d+1到n`，自动轮流处理所有子表（如 d=4 时，i=5 处理子表 1，i=6 处理子表 2，i=7 处理子表 3，i=8 处理子表 4），与视频 “轮流切换子表” 的逻辑一致；
3. **子表内插入**：内层`while`循环在当前子表中查找插入位置，核心是 “前驱元素大于当前元素则后移”，最终将暂存的`temp`插入到正确位置；
4. **无额外空间**：仅使用`d、i、j、temp`4 个辅助变量，符合视频中 “原地排序” 的结论。

## 5. 希尔排序的算法性能

### 5.1 空间复杂度

- **O(1)**（常数级辅助空间）：仅使用 4 个固定辅助变量，无额外数组或链表存储，属于原地排序。

### 5.2 时间复杂度

- **难以用数学证明确切值**：因增量序列的选择会显著影响时间复杂度，视频中明确 “目前无通用数学证明”；
- **最坏情况**：当 d=1 时，退化为直接插入排序，时间复杂度为**O(n²)**（如初始序列完全逆序）；
- **实际性能**：当 n 不是特别大时，时间复杂度约为**O(n^1.3)**，优于直接插入排序的 O (n²)。

### 5.3 稳定性

- **不稳定排序**：视频中通过案例验证：
	- 假设初始序列为`[65（A）, 49, 65（B）]`（A、B 为两个相同的 65，区分相对位置）；
	- 当 d=2 时，子表为`[65（A）, 65（B）]`和`[49]`，若初始序列为`[65（A）, 50, 49, 65（B）]`：
		- d=2 时子表 1 为`[65（A）, 49]`，排序后变为`[49, 65（A）]`，导致 65（A）和 65（B）的相对位置改变，因此不稳定。

### 5.4 适用场景

- **仅适用于顺序表（数组）**：需根据增量 d 随机访问元素（如`arr[j+d]`、`arr[j-d]`），链表无法高效实现随机访问（需遍历查找相距 d 的元素），会导致希尔排序的优势消失；
- **不适用于链表**：视频中明确 “希尔排序无法基于链表实现”。

## 6. 考试重点提示

1. **核心考点**：给定初始序列和增量序列，求每一趟排序后的结果（如案例 2 中 d=3→1 的过程），需熟练掌握 “子表划分 + 子表插入排序” 的步骤；
2. **代码考察**：频率较低，但需理解 “增量控制 + 子表插入” 的核心逻辑，视频强调 “代码是逻辑的外化，只要逻辑清晰，临场可写代码”；
3. **易错点**：增量序列的选择（非固定减半）、1-based 与 0-based 索引的区分（视频案例均为 1-based，代码需对应）。



# 冒泡排序知识点总结

## 1. 冒泡排序的归属与交换排序定义

- **分类**：冒泡排序属于**交换排序**的一种（视频提及同属交换排序的还有快速排序，本视频先讲解更简单的冒泡排序）。
- **交换排序核心逻辑**：通过比较两个元素的**关键字（即元素值）**，根据两者的大小关系决定是否交换这两个元素的位置，最终使序列达到有序状态。

## 2. 冒泡排序的核心原理（类比与执行过程）

### 2.1 “冒泡” 的类比

视频用 “小鱼吐泡泡” 类比：自然界中泡泡会向上浮动，冒泡排序中**较小的元素会像泡泡一样逐步 “浮动” 到最终的有序位置**（视频默认实现 “小元素向前冒”，也可变种为 “大元素向后冒”）。

### 2.2 核心规则

1. **排序方向**：视频默认从**后往前**依次对比相邻元素（即从数组末尾向开头遍历）。
2. **交换条件**：以最终目标 “递增序列” 为例，若相邻元素为**逆序**（前一个元素 > 后一个元素），则交换位置；若元素相等，不交换（用于保证稳定性）。
3. **一趟排序**：将所有 “未确定最终位置” 的元素完整对比一遍，称为 “一趟排序”；每趟排序会确定**1 个最小元素（向前冒）或 1 个最大元素（向后冒）** 的最终位置。
4. **提前终止优化**：若某一趟排序中**未发生任何一次交换**，说明数组已完全有序，可直接终止算法（避免冗余遍历）。

### 2.3 排序过程示例（以递增序列为目标）

#### 初始数组

假设初始未排序数组为：`[49, 38, 56, 97, 76, 13, 27, 49]`（共 8 个元素，记为`n=8`）。

#### 第一趟排序（确定最小元素 13 的最终位置）

从后往前对比相邻元素（索引从`6→7`开始，逐步向前到`0→1`），过程如下：

1. 对比索引 6（27）和 7（49）：27 < 49 → 不交换；
2. 对比索引 5（13）和 6（27）：13 < 27 → 不交换；
3. 对比索引 4（76）和 5（13）：76 > 13 → 交换，数组变为`[49, 38, 56, 97, 13, 76, 27, 49]`；
4. 对比索引 3（97）和 4（13）：97 > 13 → 交换，数组变为`[49, 38, 56, 13, 97, 76, 27, 49]`；
5. 对比索引 2（56）和 3（13）：56 > 13 → 交换，数组变为`[49, 38, 13, 56, 97, 76, 27, 49]`；
6. 对比索引 1（38）和 2（13）：38 > 13 → 交换，数组变为`[49, 13, 38, 56, 97, 76, 27, 49]`；
7. 对比索引 0（49）和 1（13）：49 > 13 → 交换，数组变为`[13, 49, 38, 56, 97, 76, 27, 49]`。

- **结果**：最小元素 13 冒到最前面（索引 0），其最终位置确定，后续趟次无需处理。

#### 第二趟排序（确定第二小元素 27 的最终位置）

无需处理已确定位置的 13（索引 0），从后往前对比索引`1→7`的元素，过程如下：

1. 对比索引 6（27）和 7（49）：27 < 49 → 不交换；
2. 对比索引 5（76）和 6（27）：76 > 27 → 交换，数组变为`[13, 49, 38, 56, 97, 27, 76, 49]`；
3. 对比索引 4（97）和 5（27）：97 > 27 → 交换，数组变为`[13, 49, 38, 56, 27, 97, 76, 49]`；
4. 对比索引 3（56）和 4（27）：56 > 27 → 交换，数组变为`[13, 49, 38, 27, 56, 97, 76, 49]`；
5. 对比索引 2（38）和 3（27）：38 > 27 → 交换，数组变为`[13, 49, 27, 38, 56, 97, 76, 49]`；
6. 对比索引 1（49）和 2（27）：49 > 27 → 交换，数组变为`[13, 27, 49, 38, 56, 97, 76, 49]`。

- **结果**：第二小元素 27 冒到索引 1，其最终位置确定。

#### 后续趟次（简述）

- 第三趟：确定第三小元素 38 的位置，数组变为`[13, 27, 38, 49, 56, 97, 76, 49]`；
- 第四趟：确定第四小元素 49（原索引 0）的位置，数组调整为`[13, 27, 38, 49, 49, 56, 76, 97]`；
- 第五趟：遍历过程中未发生任何交换，判定数组已完全有序，算法终止。

## 3. 冒泡排序的代码实现

视频中代码逻辑为 “从后往前冒小元素”，包含交换函数、两层循环、`flag`提前终止优化，具体如下：

### 3.1 交换函数（swap）

功能：通过中间变量`temp`交换两个元素的值，是冒泡排序的基础辅助函数。

c

```c
#include <stdbool.h> // 用于bool类型（flag变量需此头文件）
#include <stdio.h>   // 若需测试打印，需此头文件

// 交换两个整数的地址对应的值（指针传递，实现真正交换）
void swap(int *a, int *b) {
    int temp;  // 定义中间变量，暂存a的值
    temp = *a; // 第一步：将a指向的元素值赋给temp
    *a = *b;   // 第二步：将b指向的元素值赋给a
    *b = temp; // 第三步：将temp中暂存的原a值赋给b
}
```

### 3.2 冒泡排序主体函数（bubbleSort）

核心逻辑：

- 外层循环`i`：标记 “已排好序的元素个数”（`i`从 0 开始，最多到`n-2`，因`i=n-1`时只剩 1 个元素，无需排序）；
- 内层循环`j`：从数组末尾（`n-1`）向前遍历，对比相邻元素，逆序则交换；
- 标志位`flag`：初始为`false`，若某趟发生交换则设为`true`；若一趟结束后`flag`仍为`false`，说明数组有序，直接终止。

c

```c
// 冒泡排序主体函数：arr为待排序数组，n为数组元素个数
void bubbleSort(int arr[], int n) {
    int i, j;       // 循环变量：i控制趟数，j控制每趟的对比
    bool flag;      // 标记某一趟是否发生交换（优化用）

    // 外层循环：每趟确定1个元素的最终位置，最多n-1趟
    for (i = 0; i < n - 1; i++) {
        flag = false; // 初始化：假设本趟无交换

        // 内层循环：从后往前对比未排序元素（j > i，因i及之前已排序）
        for (j = n - 1; j > i; j--) {
            // 若前一个元素 > 后一个元素（逆序，目标为递增序列），则交换
            if (arr[j - 1] > arr[j]) {
                swap(&arr[j - 1], &arr[j]); // 调用交换函数
                flag = true;                // 标记本趟发生了交换
            }
            // 关键：若arr[j-1] == arr[j]，不交换，保证稳定性
        }

        // 若本趟无任何交换，说明数组已完全有序，提前终止算法
        if (!flag) {
            break;
        }
    }
}
```

### 3.3 代码测试示例

若需验证代码功能，可添加`main`函数测试

c

```c
int main() {
    // 视频中初始数组
    int arr[] = {49, 38, 56, 97, 76, 13, 27, 49};
    int n = sizeof(arr) / sizeof(arr[0]); // 计算数组元素个数

    printf("排序前数组：");
    for (int k = 0; k < n; k++) {
        printf("%d ", arr[k]);
    }

    bubbleSort(arr, n); // 调用冒泡排序函数

    printf("\n排序后数组（递增）：");
    for (int k = 0; k < n; k++) {
        printf("%d ", arr[k]);
    }

    return 0;
}
```

- **输出结果**：
	排序前数组：49 38 56 97 76 13 27 49
	排序后数组（递增）：13 27 38 49 49 56 76 97

## 4. 冒泡排序的性能分析

### 4.1 空间复杂度

- **结果**：**O(1)**（常数级空间）。
- **原因**：仅使用有限的辅助变量（`i`、`j`、`flag`、`temp`），空间占用与数组规模`n`无关，无额外动态内存分配。

### 4.2 时间复杂度

时间复杂度由 “比较次数” 和 “交换次数” 决定，视频明确区分两者，并给出不同场景下的复杂度：

| 场景               | 趟数      | 比较次数                     | 交换次数                         | 时间复杂度 |
| ------------------ | --------- | ---------------------------- | -------------------------------- | ---------- |
| 最好情况（已有序） | 1 趟      | n-1 次（仅 1 趟完整对比）    | 0 次（无交换）                   | O(n)       |
| 最坏情况（逆序）   | n-1 趟    | (n-1)+(n-2)+...+1 = n(n-1)/2 | 与比较次数相同（每次比较都交换） | O(n²)      |
| 平均情况           | 约 n/2 趟 | 约 n²/4 次                   | 约 n²/8 次                       | O(n²)      |

#### 关键补充

- **交换次数 vs 移动次数**：1 次`swap`函数调用对应**3 次元素移动**（`a→temp`、`b→a`、`temp→b`）。若考题问 “元素移动次数”，需将交换次数 ×3（例如：最坏情况下移动次数为 3×n (n-1)/2）。

## 5. 冒泡排序的稳定性

- **结论**：**冒泡排序是稳定的排序算法**（视频明确提及）。
- **原因**：排序过程中，仅当`arr[j-1] > arr[j]`（逆序）时才交换元素；若`arr[j-1] == arr[j]`，则不交换，确保相等元素的相对位置在排序后不变。

#### 稳定性示例

- 初始数组：`[49, 38, 56, 97, 76, 13, 27, 49]`（两个 49，分别在索引 0 和 7）；
- 排序后数组：`[13, 27, 38, 49, 49, 56, 76, 97]`（原索引 0 的 49 仍在原索引 7 的 49 前面，相对位置未变）。

## 6. 冒泡排序在链表中的应用

### 6.1 可行性

视频明确：冒泡排序的思想可应用于链表（链表无需随机访问，仅需遍历相邻节点，符合冒泡排序 “对比相邻元素” 的核心逻辑）。

### 6.2 核心思路（以递增序列为目标，大元素向后冒）

1. 从链表头节点开始，用指针`p`遍历 “未排序部分” 的链表；
2. 对比`p`指向的节点与`p->next`指向的节点的值：
	- 若`p->data > p->next->data`（逆序），则交换两个节点的位置（需处理前驱节点的指针，避免链表断裂）；
	- 若相等或顺序正确，`p`后移，继续对比下一组相邻节点；
3. 每趟排序会将当前未排序部分的**最大元素 “冒” 到链表末尾**，其最终位置确定；
4. 重复上述过程，直到某一趟未发生交换，链表有序。



# 快速排序知识点总结

## 1. 快速排序的归属与核心思想

### 1.1 分类

快速排序属于**交换排序**（与冒泡排序同属此类），视频明确其 “平均表现性能是所有内部排序算法中最优秀的”。

### 1.2 核心思想

- **核心目标**：每一次 “划分” 操作确定一个 “枢轴元素（基准元素）” 的最终位置，而非像冒泡排序那样确定最大 / 最小元素。
- **划分规则**：以枢轴元素为基准，将待排序序列划分为左右两部分：
	- 左半部分所有元素 **小于** 枢轴元素；
	- 右半部分所有元素 **大于等于** 枢轴元素（视频默认规则，确保逻辑一致性）；
- **递归逻辑**：划分后，对左右两个子表 **递归执行上述划分操作**，直到子表仅含 1 个元素（无需排序）。

## 2. 核心操作：划分过程

视频以初始数组 `[49, 38, 65, 97, 76, 13, 27, 49]`（8 个元素，索引 0-7）为例，完整演示划分过程，步骤如下：

### 2.1 初始设置

- **待排序序列**：`[49, 38, 65, 97, 76, 13, 27, 49]`（索引 0-7）；
- **枢轴选择**：选序列第一个元素（`arr[low]`）即 `49` 作为枢轴，用变量 `pivot` 保存；
- **指针初始化**：`low = 0`（指向序列头部），`high = 7`（指向序列尾部）。

### 2.2 划分步骤（双指针移动）

#### Step 1：移动 high 指针，找小于枢轴的元素

- 循环条件：`low < high` 且 `arr[high] >= pivot`（右半部分需满足 “大于等于枢轴”）；
- 过程：
	- `high=7`，`arr[7]=49 >=49` → `high--`（指向 6）；
	- `high=6`，`arr[6]=27 <49` → 跳出循环；
	- 将 `arr[high]=27` 赋值给 `arr[low]`（此时 `low=0`），数组变为：`[27, 38, 65, 97, 76, 13, 27, 49]`；
	- 此时 `high=6` 位置 “空出”，切换到移动 low 指针。

#### Step 2：移动 low 指针，找大于枢轴的元素

- 循环条件：`low < high` 且 `arr[low] <= pivot`（左半部分需满足 “小于等于枢轴”）；
- 过程：
	- `low=0`，`arr[0]=27 <=49` → `low++`（指向 1）；
	- `low=1`，`arr[1]=38 <=49` → `low++`（指向 2）；
	- `low=2`，`arr[2]=65 >49` → 跳出循环；
	- 将 `arr[low]=65` 赋值给 `arr[high]`（此时 `high=6`），数组变为：`[27, 38, 65, 97, 76, 13, 65, 49]`；
	- 此时 `low=2` 位置 “空出”，切换到移动 high 指针。

#### Step 3：重复移动指针，直到 low=high

- 再次移动 high：`high=6`，`arr[6]=65 >=49` → `high--`（指向 5）；`arr[5]=13 <49` → 跳出循环，将 13 赋值给 `arr[2]`，数组变为 `[27, 38, 13, 97, 76, 13, 65, 49]`，`high=5` 空出；
- 再次移动 low：`low=2`，`arr[2]=13 <=49` → `low++`（指向 3）；`arr[3]=97 >49` → 跳出循环，将 97 赋值给 `arr[5]`，数组变为 `[27, 38, 13, 97, 76, 97, 65, 49]`，`low=3` 空出；
- 再次移动 high：`high=5`，`arr[5]=97 >=49` → `high--`（指向 4）；`arr[4]=76 >=49` → `high--`（指向 3）；此时 `low=3`，`high=3` → 指针相遇，跳出循环。

#### Step 4：放置枢轴元素

将初始保存的 `pivot=49` 赋值给 `arr[low]`（即 `arr[3]`），最终划分结果：
`[27, 38, 13, 49, 76, 97, 65, 49]`

- 枢轴 `49` 的最终位置为索引 3；
- 左子表：`[27, 38, 13]`（索引 0-2，均小于 49）；
- 右子表：`[76, 97, 65, 49]`（索引 4-7，均大于等于 49）。

## 3. 递归处理子表

划分后对左右子表递归执行 “划分”，直到子表长度为 1，视频重点演示以下过程：

### 3.1 左子表处理（索引 0-2：`[27, 38, 13]`）

- **枢轴选择**：`arr[0]=27`；
- **指针初始化**：`low=0`，`high=2`；
- **划分步骤**：
	1. 移动 high：`high=2`，`arr[2]=13 <27` → 将 13 赋值给 `arr[0]`，数组变为 `[13, 38, 13]`，`high=2` 空出；
	2. 移动 low：`low=0`，`arr[0]=13 <=27` → `low++`（指向 1）；`arr[1]=38 >27` → 将 38 赋值给 `arr[2]`，数组变为 `[13, 38, 38]`，`low=1` 空出；
	3. 移动 high：`high=2` → `high--`（指向 1），`low=high=1` → 放置枢轴 27 到 `arr[1]`；
- **结果**：左子表划分后为 `[13, 27, 38]`，枢轴 27 在索引 1；其子表（0-0、2-2）仅含 1 元素，无需继续递归。

### 3.2 右子表处理（索引 4-7：`[76, 97, 65, 49]`）

- **枢轴选择**：`arr[4]=76`；
- **指针初始化**：`low=4`，`high=7`；
- **划分步骤**：
	1. 移动 high：`high=7`，`arr[7]=49 <76` → 赋值给 `arr[4]`，数组变为 `[49, 97, 65, 49]`（索引 4-7），`high=7` 空出；
	2. 移动 low：`low=4`，`arr[4]=49 <=76` → `low++`（指向 5）；`arr[5]=97 >76` → 赋值给 `arr[7]`，数组变为 `[49, 97, 65, 97]`，`low=5` 空出；
	3. 移动 high：`high=7` → `high--`（指向 6）；`arr[6]=65 <76` → 赋值给 `arr[5]`，数组变为 `[49, 65, 65, 97]`，`high=6` 空出；
	4. 移动 low：`low=5` → `low++`（指向 6），`low=high=6` → 放置枢轴 76 到 `arr[6]`；
- **结果**：右子表划分后为 `[49, 65, 76, 97]`，枢轴 76 在索引 6；其子表（4-5、7-7）继续递归，最终全部有序。

### 3.3 最终有序数组

```
[13, 27, 38, 49, 49, 65, 76, 97]
```

## 4. 代码实现

视频明确给出快速排序的核心代码（`partition` 划分函数、`quickSort` 递归函数），并详细讲解函数调用栈逻辑，代码如下：

### 4.1 划分函数（partition）

功能：对 `arr[low..high]` 进行划分，返回枢轴元素的最终位置。

c

```c
#include <stdio.h>

// 划分函数：返回枢轴元素的最终位置
int partition(int arr[], int low, int high) {
    // 步骤1：选择arr[low]作为枢轴，保存到pivot
    int pivot = arr[low];
    
    // 步骤2：双指针移动，直到low == high
    while (low < high) {
        // 子步骤1：移动high，找小于pivot的元素
        while (low < high && arr[high] >= pivot) {
            high--; // 元素>=pivot，high左移，留在右半部分
        }
        arr[low] = arr[high]; // 将找到的小元素放到low位置
        
        // 子步骤2：移动low，找大于pivot的元素
        while (low < high && arr[low] <= pivot) {
            low++; // 元素<=pivot，low右移，留在左半部分
        }
        arr[high] = arr[low]; // 将找到的大元素放到high位置
    }
    
    // 步骤3：将枢轴放到最终位置（low == high）
    arr[low] = pivot;
    return low; // 返回枢轴位置
}
```

### 4.2 快速排序主函数（quickSort）

功能：递归调用 `partition` 划分序列，处理左右子表。

c

```c
// 快速排序主函数：对arr[low..high]进行排序
void quickSort(int arr[], int low, int high) {
    if (low < high) { // 子表长度>1时才需要排序
        // 步骤1：划分，得到枢轴位置p（视频中简写为p=privet position）
        int p = partition(arr, low, high);
        
        // 步骤2：递归处理左子表（low..p-1）
        quickSort(arr, low, p - 1);
        
        // 步骤3：递归处理右子表（p+1..high）
        quickSort(arr, p + 1, high);
    }
    // 子表长度==1（low>=high），直接返回，无需处理
}
```

### 4.3 测试示例

c

```c
// 测试函数
int main() {
    // 视频中初始待排序数组
    int arr[] = {49, 38, 65, 97, 76, 13, 27, 49};
    int n = sizeof(arr) / sizeof(arr[0]); // 数组长度n=8
    
    printf("排序前数组：");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    
    // 调用快速排序，初始处理范围0..n-1（0..7）
    quickSort(arr, 0, n - 1);
    
    printf("\n排序后数组：");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    
    return 0;
}
```

#### 测试输出

plaintext

```plaintext
排序前数组：49 38 65 97 76 13 27 49 
排序后数组：13 27 38 49 49 65 76 97 
```

### 4.4 函数调用栈分析

视频通过 “函数调用栈” 记录递归过程，核心逻辑如下：

1. **第一层调用**：`quickSort(arr, 0, 7)` → 调用 `partition(0,7)` 返回 `p=3` → 压栈记录 “执行到 quickSort 第 97 行”（视频中代码行号）；
2. **第二层调用**：处理左子表 `quickSort(arr, 0, 2)` → 调用 `partition(0,2)` 返回 `p=1` → 压栈记录 “执行到 quickSort 第 97 行”；
3. **第三层调用**：处理左子表 `quickSort(arr, 0, 0)` → `low=high`，直接返回；
4. **第三层返回**：处理右子表 `quickSort(arr, 2, 2)` → `low=high`，直接返回；
5. **第二层返回**：处理右子表 `quickSort(arr, 4, 7)` → 调用 `partition(4,7)` 返回 `p=6` → 压栈记录 “执行到 quickSort 第 97 行”；
6. 重复上述逻辑，直到所有子表处理完毕，栈逐步弹出，递归结束。

## 5. 性能分析

### 5.1 时间复杂度

视频明确：时间复杂度取决于**递归层数**（即划分后子表的分布，对应 “二叉树高度”）。

| 场景     | 划分情况                        | 递归层数（二叉树高度） | 时间复杂度 | 示例                            |
| -------- | ------------------------------- | ---------------------- | ---------- | ------------------------------- |
| 最好情况 | 每次划分均匀（左 = 右）         | O(log₂n)               | O(nlog₂n)  | 随机序列，枢轴选中间值          |
| 最坏情况 | 每次划分极端（左 = 0 或右 = 0） | O(n)                   | O(n²)      | 有序 / 逆序序列，选首元素为枢轴 |
| 平均情况 | 划分较均匀                      | 接近 O (log₂n)         | O(nlog₂n)  | 实际应用中大多数场景            |

- **关键解释**：每一层递归的总比较次数为 O (n)（所有子表元素总和为 n），因此总时间 = 层数 × 每层时间，即 O (层数 ×n)。

### 5.2 空间复杂度

空间复杂度由**递归调用栈的深度**决定（无额外动态内存分配）：

- 最好情况：O (log₂n)（递归层数为 log₂n）；
- 最坏情况：O (n)（递归层数为 n）；
- 平均情况：O (log₂n)（接近最好情况）。

## 6. 稳定性分析

### 6.1 结论

**快速排序是不稳定的排序算法**。

### 6.2 视频示例验证

以序列 `[2, 1, 2₁]`（`2₁` 表示第二个 2，标记以区分相对位置）为例：

1. **初始设置**：low=0，high=2，枢轴 = pivot=arr [0]=2；
2. **划分步骤**：
	- 移动 high：`high=2`，`arr[2]=2₁ >=2` → `high--`（指向 1）；`arr[1]=1 <2` → 赋值给 `arr[0]`，数组变为 `[1, 1, 2₁]`；
	- 移动 low：`low=0`，`arr[0]=1 <=2` → `low++`（指向 1）；`arr[1]=1 <=2` → `low++`（指向 2）；`low=high=2`；
	- 放置枢轴：`arr[2]=2`，最终数组变为 `[1, 2₁, 2]`；
3. **结果**：原序列中 `2` 在 `2₁` 之前，排序后 `2₁` 在 `2` 之前，**相对位置改变**，证明算法不稳定。

## 7. 算法优化

视频指出：优化的核心目标是 “避免划分极端情况（最坏情况）”，即让枢轴尽可能接近序列中间值。

### 7.1 三数取中法

- **逻辑**：选择序列的 “头部（arr [low]）、中部（arr [(low+high)/2]）、尾部（arr [high]）” 三个元素，取其中值作为枢轴；
- **作用**：确保枢轴不是序列的最大 / 最小值，避免有序 / 逆序序列的最坏情况。

### 7.2 随机选择枢轴法

- **逻辑**：随机在 `arr[low..high]` 中选择一个元素作为枢轴（需将选中元素与 `arr[low]` 交换，保持 partition 函数逻辑一致）；
- **作用**：从概率上避免每次选到最大 / 最小值，即使面对有序 / 逆序序列，也能大概率实现均匀划分。

## 8. 408 考试中 “一趟排序” 与 “一次划分” 的区别

视频明确区分两种定义，避免混淆：

| 概念     | 定义                                                         | 确定元素个数 | 对应操作                       |
| -------- | ------------------------------------------------------------ | ------------ | ------------------------------ |
| 一次划分 | 对**一个连续子表**调用一次 partition 函数，确定一个枢轴的最终位置 | 1 个         | partition(arr, low, high)      |
| 一趟排序 | 对**所有未确定最终位置的元素**进行一次完整处理（可能包含多个划分） | 多个         | 递归树中 “一层” 的所有划分操作 |

### 示例

- **一次划分**：仅处理 `[49, 38, 65, 97, 76, 13, 27, 49]`（0-7），确定 49 的位置；
- **一趟排序**：处理 “所有未确定位置的元素”，即第一层划分（确定 49）+ 第二层划分（确定 27 和 76），共确定 3 个元素的位置。



# 简单选择排序

## 1. 所属分类

简单选择排序是**选择排序**大类下的基础算法，后续需学习的**堆排序**也基于选择排序的核心思想（即 “每趟选最值加入有序序列”）。

## 2. 核心思想

每一趟处理时，在**待排序元素序列**中选取关键字**最小（或最大）** 的元素，将其移动到待排序序列的**起始位置**（加入左侧的有序序列）；重复此过程，直到待排序序列仅剩 1 个元素（无需处理，天然为最大值）。

核心特点：通过 “选最值 + 交换” 实现排序，每趟仅需 1 次元素交换（找到最值后统一交换）。

## 3. 排序过程（示例演示）

假设初始待排序序列为 `[49, 38, 65, 97, 76, 13, 27, 49]`（共 8 个元素，`n=8`，需执行 `n-1=7` 趟），每趟操作如下：

| 趟数 | 待排序序列（起始位置 i）       | 找到的最小元素          | 交换操作（最小元素 ↔ 待排序起始元素） | 排序后序列（有序 + 待排序）   |
| ---- | ------------------------------ | ----------------------- | ------------------------------------- | ----------------------------- |
| 1    | i=0：[49,38,65,97,76,13,27,49] | 13（下标 5）            | 49（下标 0） ↔ 13（下标 5）           | [13] + [38,65,97,76,49,27,49] |
| 2    | i=1：[38,65,97,76,49,27,49]    | 27（下标 5）            | 38（下标 1） ↔ 27（下标 5）           | [13,27] + [65,97,76,49,38,49] |
| 3    | i=2：[65,97,76,49,38,49]       | 38（下标 4）            | 65（下标 2） ↔ 38（下标 4）           | [13,27,38] + [97,76,49,65,49] |
| 4    | i=3：[97,76,49,65,49]          | 49（下标 2，靠左的 49） | 97（下标 3） ↔ 49（下标 2）           | [13,27,38,49] + [76,97,65,49] |
| 5    | i=4：[76,97,65,49]             | 49（下标 3，剩余的 49） | 76（下标 4） ↔ 49（下标 3）           | [13,27,38,49,49] + [97,65,76] |
| 6    | i=5：[97,65,76]                | 65（下标 1）            | 97（下标 5） ↔ 65（下标 1）           | [13,27,38,49,49,65] + [97,76] |
| 7    | i=6：[97,76]                   | 76（下标 1）            | 97（下标 6） ↔ 76（下标 1）           | [13,27,38,49,49,65,76] + [97] |

**最终排序结果**：`[13, 27, 38, 49, 49, 65, 76, 97]`

## 4. 代码实现

核心逻辑：用变量`i`标记待排序序列的起始位置，遍历待排序序列找到最小元素的下标`min_idx`，将`arr[i]`与`arr[min_idx]`交换，`i`递增至`n-2`（共`n-1`趟）。

c

```c
#include <stdio.h>

// 辅助函数：交换两个整数的值（地址传递）
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 简单选择排序核心函数
// arr：待排序数组；n：数组元素个数
void simpleSelectionSort(int arr[], int n) {
    // i：待排序序列的起始下标，共需n-1趟（i从0到n-2）
    for (int i = 0; i < n - 1; i++) {
        int min_idx = i; // 初始假设待排序序列的第一个元素为最小值，记录其下标
        // j：遍历待排序序列（从i+1到n-1），寻找真正的最小值下标
        for (int j = i + 1; j < n; j++) {
            // 若当前元素比记录的最小值小，更新最小值下标
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        // 将找到的最小值与待排序序列的起始元素交换（加入有序序列）
        swap(&arr[i], &arr[min_idx]);
    }
}

// 辅助函数：打印数组元素
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// 主函数：测试简单选择排序
int main() {
    // 测试用例：与“排序过程示例”完全一致的初始序列
    int arr[] = {49, 38, 65, 97, 76, 13, 27, 49};
    int n = sizeof(arr) / sizeof(arr[0]); // 计算数组元素个数
    
    printf("初始序列：");
    printArray(arr, n);
    
    // 执行排序
    simpleSelectionSort(arr, n);
    
    printf("排序后序列：");
    printArray(arr, n);
    
    return 0;
}
```

**代码运行结果**：

plaintext

```plaintext
初始序列：49 38 65 97 76 13 27 49 
排序后序列：13 27 38 49 49 65 76 97 
```

## 5. 性能分析

### 5.1 空间复杂度

仅使用**有限个辅助变量**（如`i`、`j`、`min_idx`、`temp`），辅助空间不随输入规模`n`变化，因此空间复杂度为 **O(1)**（属于 “原地排序” 算法）。

### 5.2 时间复杂度

时间复杂度由**关键字比较次数**决定（元素交换次数最多为`n-1`次，可忽略）：

- 无论初始序列状态（有序、逆序、乱序），均需执行`n-1`趟排序；
- 第`i`趟（`i从0开始`）需比较`n - i - 1`次，总比较次数为：
	`(n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ n²/2`。

因此，时间复杂度为 **O(n²)**，且**不随初始序列状态改变**（这与插入排序、冒泡排序不同 —— 后两者在有序序列下时间复杂度可优化至 O (n)）。

## 6. 稳定性分析

### 稳定性定义

排序后，若两个**关键字相等**的元素，其相对位置与排序前一致，则算法 “稳定”；否则 “不稳定”。

### 示例验证

假设初始序列为 `[_2, 2, 1]`（用下划线`_`区分两个值为 2 的元素，`_2`为排序前靠左的元素）：

1. 第 1 趟：扫描找到最小元素`1`，与待排序序列起始元素`_2`交换；
2. 排序后序列：`[1, 2, _2]`。

**结果**：排序前`_2`在`2`左侧，排序后`_2`在`2`右侧，相对位置改变。
**结论**：简单选择排序是**不稳定的排序算法**。

## 7. 链表适配性

简单选择排序的思想同样适用于**链表存储**的元素，实现逻辑如下：

1. 初始化 “有序链表” 为空，“待排序链表” 为原始链表；
2. 遍历 “待排序链表”，找到关键字最小的节点；
3. 将最小节点从 “待排序链表” 中删除，插入到 “有序链表” 的末尾；
4. 重复步骤 2~3，直到 “待排序链表” 为空。



# 堆排序知识点总结

## 1. 堆排序的基本定位

- **归属类别**：选择排序的一种，核心思想与简单选择排序一致 —— 每趟从待排序元素中选关键字最大 / 最小的元素，加入有序序列。
- **核心依赖**：基于 “堆” 这种数据结构实现，是数据结构与排序逻辑结合的典型算法，也是考研高频考点。

## 2. 堆的核心定义

堆是物理结构与逻辑结构分离的数据结构，需从两个视角理解：

### 2.1 物理结构（内存视角）

- 表现为**连续存储的数组**，元素在内存中依次排列（无间隙）。
- 数组下标是后续计算节点关系的关键（视频中数组下标从 1 开始，`a[1]`为堆顶，`a[0]`仅用于临时存储）。

### 2.2 逻辑结构（数据关系视角）

- 本质是**顺序存储的完全二叉树**，数组下标对应完全二叉树的节点编号，节点间的逻辑关系通过下标计算。

- 核心节点关系（视频中明确的公式，下标从 1 开始）：

	| 节点类型         | 下标计算规则（设当前节点下标为`i`，总节点数为`n`） |
	| ---------------- | -------------------------------------------------- |
	| 左孩子节点       | 左孩子下标 = `2*i`                                 |
	| 右孩子节点       | 右孩子下标 = `2*i + 1`                             |
	| 父节点           | 父节点下标 = `i // 2`（向下取整）                  |
	| 分支节点（非叶） | 下标范围：`i ≤ n//2`（需调整的节点）               |
	| 叶子节点         | 下标范围：`i > n//2`（无需调整，天然满足堆特性）   |

	**示例**：若`n=8`（总节点数 8），则分支节点下标为`1~4`，叶子节点下标为`5~8`。

### 2.3 堆的两种类型（大根堆 / 小根堆）

视频中以 “所有子树的根节点与子节点的关系” 定义，结合完全二叉树逻辑结构：

| 类型             | 核心特性（逻辑结构视角）                  | 数组视角（下标从 1 开始）                          | 视频示例（大根堆）                             |
| ---------------- | ----------------------------------------- | -------------------------------------------------- | ---------------------------------------------- |
| 大根堆（大顶堆） | 任意子树的根节点值 ≥ 其左右子树所有节点值 | 对所有`i ≤ n//2`，`a[i] ≥ a[2i]`且`a[i] ≥ a[2i+1]` | 序列`[87,78,65,45,53,32,17,9]`（数组下标 1~8） |
| 小根堆（小顶堆） | 任意子树的根节点值 ≤ 其左右子树所有节点值 | 对所有`i ≤ n//2`，`a[i] ≤ a[2i]`且`a[i] ≤ a[2i+1]` | （视频提示：可类比大根堆推导）                 |

- 对比二叉排序树：二叉排序树是 “左子树 ≤ 根 ≤ 右子树”，堆是 “根 ≥ 所有子树（大根堆）” 或 “根 ≤ 所有子树（小根堆）”，逻辑完全不同。

## 3. 大根堆的建立（核心步骤）

视频中以初始序列`[53,17,78,9,45,65,32,87]`（数组下标 1~8）为例，讲解 “从分支节点从后往前调整，小元素不断下坠” 的建堆逻辑。

### 3.1 建堆核心原则

1. **调整范围**：仅处理分支节点（`i`从`n//2`到`1`，视频中`n=8`，故`i=4→3→2→1`）；
2. **调整逻辑**：对每个分支节点，若其值小于左右孩子中的最大值，则与最大值孩子交换，直到该节点值≥左右孩子（或成为叶子节点）—— 即 “小元素下坠”。

### 3.2 手动建堆示例

初始序列（下标 1~8）：`a[1]=53, a[2]=17, a[3]=78, a[4]=9, a[5]=45, a[6]=65, a[7]=32, a[8]=87`，`n=8`，`n//2=4`。

#### 步骤 1：调整 4 号节点（`a[4]=9`）

- 4 号节点的左孩子：`2*4=8`（`a[8]=87`），无右孩子（`2*4+1=9>8`）；
- 因`9 < 87`，交换`a[4]`与`a[8]`；
- 交换后：`a[4]=87, a[8]=9`，4 号节点成为叶子，调整结束。

#### 步骤 2：调整 3 号节点（`a[3]=78`）

- 3 号节点的左孩子`6`（`a[6]=65`）、右孩子`7`（`a[7]=32`）；
- 左右孩子最大值为`65`（左孩子），但`78 > 65`，无需交换，调整结束。

#### 步骤 3：调整 2 号节点（`a[2]=17`）

- 2 号节点的左孩子`5`（`a[5]=45`）、右孩子`6`（`a[6]=65`）；
- 左右孩子最大值为`65`（右孩子），因`17 < 65`，交换`a[2]`与`a[6]`；
- 交换后：`a[2]=65, a[6]=17`，2 号节点无后续下坠（孩子均为叶子），调整结束。

#### 步骤 4：调整 1 号节点（`a[1]=53`）

- 1 号节点的左孩子`2`（`a[2]=65`）、右孩子`3`（`a[3]=78`）；
- 左右孩子最大值为`78`（右孩子），因`53 < 78`，交换`a[1]`与`a[3]`；交换后：`a[1]=78, a[3]=53`；
- **下坠继续**：53 成为 3 号节点，其左孩子`6`（`a[6]=17`）、右孩子`7`（`a[7]=32`）；最大值为`32`（右孩子），但`53 > 32`，无需交换；
- 最终大根堆序列（下标 1~8）：`[78,65,53,87,45,17,32,9]`（后续视频中此处修正为最终大根堆`[87,78,65,45,53,32,17,9]`，需以实际调整后堆顶最大为准则）。

### 3.3 建堆代码实现

视频中定义 “调整以`k`为根的子树为大根堆” 的函数，数组下标从 1 开始，`a[0]`存临时值。

c

```c
// 函数功能：调整以a[k]为根的子树为大根堆（length为当前堆的总节点数）
void HeadAdjust(int a[], int k, int length) {
    a[0] = a[k]; // 将当前根节点值存入临时位置a[0]，避免覆盖
    // i初始指向k的左孩子，循环实现“小元素下坠”
    for (int i = 2 * k; i <= length; i *= 2) {
        // 步骤1：找到左右孩子中的最大值（i指向最大值孩子）
        if (i < length && a[i] < a[i + 1]) { 
            i++; // 若右孩子存在且更大，i指向右孩子
        }
        // 步骤2：判断当前根节点（a[0]）是否≥最大值孩子
        if (a[0] >= a[i]) {
            break; // 满足大根堆，无需继续下坠，退出循环
        } else {
            a[k] = a[i]; // 将最大值孩子的值赋给当前根节点
            k = i;       // 更新k为i（小元素下坠到i位置，准备下一轮判断）
        }
    }
    a[k] = a[0]; // 将临时存储的小元素放入最终位置k
}

// 函数功能：将初始数组建立为大根堆
void BuildMaxHeap(int a[], int length) {
    // 从最后一个分支节点（length//2）开始，向前调整所有分支节点
    for (int i = length / 2; i >= 1; i--) {
        HeadAdjust(a, i, length); // 调用调整函数
    }
}
```

## 4. 堆排序的执行过程

视频中基于大根堆实现排序，核心逻辑：每趟将堆顶（最大元素）与堆底元素交换，再调整剩余元素为大根堆，重复`n-1`趟。

### 4.1 排序核心原则

1. **交换堆顶与堆底**：堆顶是当前最大元素，与堆底（待排序序列的最后一个元素）交换后，最大元素进入有序序列（堆底位置固定）；
2. **调整剩余元素**：交换后堆顶为原堆底元素（较小），需调用`HeadAdjust`调整剩余`n-1`个元素为大根堆；
3. **终止条件**：执行`n-1`趟后，仅剩 1 个元素，无需调整，序列有序。
4. **序列方向**：基于大根堆排序最终得到**递增序列**；基于小根堆排序得到**递减序列**。

### 4.2 手动排序示例（n=8 示例还原）

以大根堆`[87,78,65,45,53,32,17,9]`（下标 1~8）为例，执行 7 趟排序：

#### 第 1 趟

- 交换堆顶`a[1]=87`与堆底`a[8]=9` → 序列：`[9,78,65,45,53,32,17,87]`；
- 调整剩余`7`个元素（`length=7`）：9 从堆顶下坠，最终大根堆：`[78,53,65,45,9,32,17,87]`；
- 有序序列：`[87]`。

#### 第 2 趟

- 交换堆顶`a[1]=78`与堆底`a[7]=17` → 序列：`[17,53,65,45,9,32,78,87]`；
- 调整剩余`6`个元素（`length=6`）：17 下坠，最终大根堆：`[65,53,32,45,9,17,78,87]`；
- 有序序列：`[78,87]`。

#### 第 3~7 趟（核心逻辑一致）

- 每趟交换堆顶与当前堆底，调整剩余元素为大根堆；
- 最终有序序列（递增）：`[9,17,32,45,53,65,78,87]`。

### 4.3 堆排序完整代码

先调用`BuildMaxHeap`建堆，再执行`n-1`趟排序。

c

```c
// 函数功能：堆排序（基于大根堆，最终得到递增序列）
void HeapSort(int a[], int length) {
    // 步骤1：建立初始大根堆
    BuildMaxHeap(a, length);
    
    // 步骤2：执行n-1趟排序（i从length到2，每趟固定一个最大元素）
    for (int i = length; i >= 2; i--) {
        // 交换堆顶（a[1]，当前最大元素）与堆底（a[i]，待排序序列最后一个元素）
        int temp = a[1];
        a[1] = a[i];
        a[i] = temp;
        
        // 调整剩余i-1个元素为大根堆（堆顶为a[1]，需下坠）
        HeadAdjust(a, 1, i - 1);
    }
}

// 完整调用示例（视频隐含逻辑）
#include <stdio.h>
int main() {
    // 数组下标1~8为有效元素，a[0]为临时存储
    int a[] = {0, 53, 17, 78, 9, 45, 65, 32, 87}; 
    int length = 8; // 有效元素个数
    
    HeapSort(a, length);
    
    // 输出排序后的递增序列
    printf("堆排序结果（递增）：");
    for (int i = 1; i <= length; i++) {
        printf("%d ", a[i]); // 输出：9 17 32 45 53 65 78 87
    }
    return 0;
}
```

## 5. 时间复杂度与空间复杂度

视频中通过完全二叉树性质推导，核心结论如下：

### 5.1 时间复杂度

- **建堆阶段**：`O(n)`
	推导关键：每个分支节点下坠层数最多为 “树高`h-1`”（`h=⌊log₂n⌋+1`），所有节点下坠的总次数为`O(n)`（视频中提到 “关键字对比次数不超过 4n”）。
- **排序阶段**：`O(nlogn)`
	推导关键：共`n-1`趟，每趟调整堆的时间为`O(logn)`（堆高`h=O(logn)`），总时间为`(n-1)*O(logn)=O(nlogn)`。
- **整体时间复杂度**：`O(nlogn)`（取更高阶的排序阶段复杂度）。

### 5.2 空间复杂度

- `O(1)`（常数级）
	仅使用固定临时变量（如`a[0]`、`temp`、循环变量`i`/`k`），无额外动态空间开销。

## 6. 算法稳定性

- **结论**：堆排序是**不稳定排序**。
- **视频示例验证**：以初始序列`[1, 2, 2]`（下标 1~3，带下划线区分相同元素：`[1, 2₁, 2₂]`）为例：
	1. 建堆过程：分支节点为`i=1`（`n=3`，`n//2=1`）；
	2. 1 的左孩子`2`（`2₁`）、右孩子`3`（`2₂`），左右孩子值相等，视频代码中`i`不递增（仅右孩子 > 左孩子时`i++`），故优先交换左孩子`2₁`与根节点`1`；
	3. 交换后大根堆：`[2₁, 1, 2₂]`；
	4. 排序第一趟：交换堆顶`2₁`与堆底`2₂` → 序列`[2₂, 1, 2₁]`；
	5. 调整剩余元素为大根堆后排序，最终序列：`[1, 2₂, 2₁]`；
	6. 相同元素`2₁`与`2₂`的相对位置发生变化，证明不稳定。





# 堆的插入与删除

## 一、前提知识回顾

1. 堆的类型与核心性质
	- **小根堆**：任意节点的值 **小于其左右孩子节点的值**，即 “父节点 < 左孩子 && 父节点 < 右孩子”；
	- **大根堆**：任意节点的值 **大于其左右孩子节点的值**，即 “父节点> 左孩子 && 父节点 > 右孩子”；
	- 堆的存储形式：用数组存储完全二叉树，节点下标规律（视频明确提及）：
		若当前节点下标为 `i`（数组从 1 开始计数，表尾为堆底），则其父节点下标为 `i // 2`（向下取整），左孩子下标为 `2i`，右孩子下标为 `2i + 1`。
2. 核心目标：插入 / 删除元素后，需通过 “上升” 或 “下坠” 调整，恢复堆的性质，且调整过程需计算**关键字对比次数**。

## 二、堆的插入操作（以小根堆为例）

### 1. 插入核心逻辑

插入操作分两步：**“堆底放置 → 向上调整”**

- 第一步：新元素直接放入数组表尾（即堆的最底层），保证堆的 “完全二叉树” 结构；
- 第二步：新元素与父节点比较，若符合 “小根堆父节点更小” 的反向条件（新元素 < 父节点），则与父节点交换，逐步 “上升”，直到新元素 ≥ 父节点（符合小根堆性质）或到达堆顶，停止调整。

### 2. 视频实例演示

#### 实例 1：插入元素 13 到小根堆

假设原小根堆已存储在数组下标 1~8（蓝色部分，视频未给出完整原数组，关键节点值：下标 1=9、下标 2=17、下标 4=32），插入步骤如下：

1. **堆底放置**：新元素 13 放入数组下标 9（表尾，堆底）；
2. **第一次上升调整**：
	- 13 的父节点下标 = 9 // 2 = 4（值 32）；
	- 对比：13 < 32 → 不符合小根堆性质，交换 13 与 32，13 上升至下标 4；
3. **第二次上升调整**：
	- 13 当前下标 4，父节点下标 = 4 // 2 = 2（值 17）；
	- 对比：13 < 17 → 交换 13 与 17，13 上升至下标 2；
4. **第三次上升调整**：
	- 13 当前下标 2，父节点下标 = 2 // 2 = 1（值 9）；
	- 对比：13 > 9 → 符合小根堆性质，停止调整。

**关键字对比次数**：3 次（13 vs 32、13 vs 17、13 vs 9）。

#### 实例 2：插入元素 46 到小根堆

1. **堆底放置**：新元素 46 放入数组新表尾（下标 10）；
2. **上升调整**：
	- 46 的父节点下标 = 10 // 2 = 5（值 45，视频提及）；
	- 对比：46 > 45 → 符合小根堆性质，无需交换，停止调整。

**关键字对比次数**：1 次（46 vs 45）。

## 三、堆的删除操作（以小根堆为例）

### 1. 删除核心逻辑

删除操作分两步：**“堆底元素替换 → 向下调整”**

- 第一步：用数组表尾元素（堆底）替换被删除元素的位置，保证堆的 “完全二叉树” 结构（避免出现空洞）；
- 第二步：替换元素（原堆底元素）与左右子节点比较，若符合 “小根堆父节点更小” 的反向条件（替换元素 > 子节点），则选择**更小的子节点**与之交换，逐步 “下坠”，直到替换元素 ≤ 所有子节点（符合小根堆性质）或到达堆底，停止调整。

### 2. 实例演示

#### 实例 1：删除元素 13（小根堆中）

假设被删除元素 13 位于数组下标 2，堆底元素为 46（下标 10），删除步骤如下：

1. **堆底元素替换**：用 46 替换下标 2 的 13，原堆底元素 46 的位置（下标 10）废弃；
2. **第一次下坠调整**：
	- 46 当前下标 2，左孩子下标 4（值 17）、右孩子下标 5（值 45）；
	- 第一步：对比两个子节点（17 vs 45），选择更小的子节点 17（第一次对比）；
	- 第二步：对比 46 vs 17 → 46 > 17 → 交换，46 下坠至下标 4；
3. **第二次下坠调整**：
	- 46 当前下标 4，左孩子下标 8（值 32）、右孩子下标 9（视频提及为无效值或更大值）；
	- 第一步：对比两个子节点（假设仅 32 有效或 32 更小），选择 32（第三次对比）；
	- 第二步：对比 46 vs 32 → 46 > 32 → 交换，46 下坠至下标 8；
4. **停止调整**：46 已到堆底（无更多子节点），符合小根堆性质。

**关键字对比次数**：4 次（17 vs 45、46 vs 17、32 vs 子节点、46 vs 32，视频明确统计）。

#### 实例 2：删除元素 65（小根堆中）

1. **堆底元素替换**：用堆底元素 46 替换 65 的位置（假设下标 3）；
2. **下坠调整**：
	- 46 当前下标 3，左孩子下标 6（值 78）、右孩子下标 7（值 87）；
	- 第一步：对比两个子节点（78 vs 87），选择更小的 78（第一次对比）；
	- 第二步：对比 46 vs 78 → 46 < 78 → 符合小根堆性质，无需交换；
3. **停止调整**。

**关键字对比次数**：2 次（78 vs 87、46 vs 78）。

## 四、关键字对比次数计算规则

调整过程中，对比次数需根据节点的子节点数量判断（考试高频考点）：

1. **下坠调整（核心场景）**：
	- 若当前节点有**两个子节点**：需 2 次对比（① 子节点间比较，选符合堆性质的子节点；② 当前节点与选中子节点比较）；
	- 若当前节点有**一个子节点**：需 1 次对比（仅当前节点与子节点比较）；
2. **上升调整**：
	- 每次仅与父节点比较，每上升 1 层对应 1 次对比，总次数 = 上升层数 + 1（如插入 13 上升 2 层，对比 3 次）。

## 五、核心原则与适配性

1. **通用原则**：
	- 插入必 “上升”：新元素从堆底开始，向堆顶方向调整；
	- 删除必 “下坠”：替换元素从被删除位置开始，向堆底方向调整；
2. **大根堆适配**：
	- 逻辑与小根堆一致，仅比较方向相反：
		- 插入时：新元素 > 父节点 → 交换上升；
		- 删除时：替换元素 < 子节点 → 选择更大的子节点交换下坠；
3. **时间复杂度**：调整过程由堆的高度决定（堆高度为 log₂n，n 为元素个数），故插入 / 删除时间复杂度均为 O (log n)。



# 归并排序知识点总结

## 一、归并的基本概念

归并（Merge）的核心是**将多个已有序的序列合并为一个整体有序的序列**，是归并排序的基础操作。视频中重点讲解了 “二路归并” 和 “多路归并”，其中内部排序（内存中完成的排序）主要使用**二路归并**。

### 1.1 二路归并（核心）

#### 定义

将**两个相邻的有序子序列**合并为一个有序序列的过程，是归并排序的核心操作。

#### 实现逻辑

假设存在两个有序子序列：

- 左序列：`[10, 16, 24, 37, 45]`（指针`i`指向起始位置）
- 右序列：`[7, 12, 21, 24, 33]`（指针`j`指向起始位置）
- 结果序列：大小为两序列之和（指针`k`指向起始位置，用于存放合并后的元素）

步骤：

1. 对比`i`和`j`指向的元素，将**更小的元素**放入`k`指向的位置；
2. 放入元素后，对应指针（`i`或`j`）和结果指针`k`均向后移动 1 位；
3. 重复步骤 1-2，直到其中一个子序列的元素全部处理完毕；
4. 将剩余子序列的所有元素直接复制到结果序列的末尾。

#### 示例过程

| 步骤 | i 指向元素 | j 指向元素 | 放入 k 的元素 | i/j 移动 | k 移动 | 结果序列（部分）                |
| ---- | ---------- | ---------- | ------------- | -------- | ------ | ------------------------------- |
| 1    | 10         | 7          | 7             | j→j+1    | k→k+1  | [7]                             |
| 2    | 10         | 12         | 10            | i→i+1    | k→k+1  | [7, 10]                         |
| 3    | 16         | 12         | 12            | j→j+1    | k→k+1  | [7, 10, 12]                     |
| 4    | 16         | 21         | 16            | i→i+1    | k→k+1  | [7, 10, 12, 16]                 |
| 5    | 24         | 21         | 21            | j→j+1    | k→k+1  | [7, 10, 12, 16, 21]             |
| 6    | 24         | 24         | 24（左序列）  | i→i+1    | k→k+1  | [7, 10, 12, 16, 21, 24]         |
| 7    | 37         | 24         | 24（右序列）  | j→j+1    | k→k+1  | [7, 10, 12, 16, 21, 24, 24]     |
| 8    | 37         | 33         | 33            | j→j+1    | k→k+1  | [7, 10, 12, 16, 21, 24, 24, 33] |
| 9    | 37         | 右序列结束 | -             | -        | -      | 直接复制左序列剩余元素：37、45  |

最终结果：`[7, 10, 12, 16, 21, 24, 24, 33, 37, 45]`

### 1.2 多路归并（扩展）

#### 定义

将**m 个有序子序列**合并为一个有序序列的过程（如四路归并、八路归并），常用于外部排序（需借助磁盘等外部存储的排序）。

#### 核心特点（视频结论）

- 若进行`m`路归并，每次选择最小元素需**对比`m-1`次关键字**（如四路归并需对比 3 次）；
- 归并路数`m`越多，每次选最小元素的对比次数越多，因此内部排序优先用二路归并。

## 二、归并排序的核心思想

归并排序基于**分治法（Divide and Conquer）** ，核心是 “先拆分、后合并”，步骤如下：

1. **拆分（Divide）**：将初始无序序列从中间拆分为两个子序列，再递归拆分每个子序列，直到每个子序列仅含**1 个元素**（单个元素默认有序）；
2. **合并（Conquer）**：从最小的有序子序列开始，两两进行二路归并，逐步合并为更大的有序子序列，直到合并为一个完整的有序序列。

### 示例：初始序列`[49, 38, 65, 97, 76, 13, 27]`的排序过程

#### 1. 拆分阶段（递归拆分）

- 第 1 次拆分：`[49, 38, 65, 97]` 和 `[76, 13, 27]`
- 第 2 次拆分：`[49, 38]`、`[65, 97]`、`[76, 13]`、`[27]`
- 第 3 次拆分：`[49]`、`[38]`、`[65]`、`[97]`、`[76]`、`[13]`、`[27]`（拆分结束，均为单个元素）

#### 2. 合并阶段（二路归并）

- 第 1 趟合并（合并单个元素）：`[38, 49]`、`[65, 97]`、`[13, 76]`、`[27]` → 结果：`[38, 49, 65, 97, 13, 76, 27]`
- 第 2 趟合并（合并 2 元素子序列）：`[38, 49, 65, 97]`、`[13, 27, 76]` → 结果：`[38, 49, 65, 97, 13, 27, 76]`
- 第 3 趟合并（合并 4/3 元素子序列）：`[13, 27, 38, 49, 65, 76, 97]` → 最终有序序列

## 三、核心操作：合并两个相邻有序子序列（Merge 函数）

视频中明确给出了 Merge 函数的实现逻辑，用于合并数组中`low~mid`和`mid+1~high`两个相邻的有序子序列。

### 3.1 函数功能

输入数组`a`，以及两个子序列的范围（`low`：左子序列起始，`mid`：左子序列结束，`high`：右子序列结束），将两个有序子序列合并为一个有序序列，结果存回数组`a`。

### 3.2 实现步骤

1. 定义**辅助数组`b`**（大小与原数组`a`一致，用于临时存储元素，避免原数组元素被覆盖）；
2. 将原数组`a`中`low~high`范围的元素**复制到辅助数组`b`**（保持元素顺序不变）；
3. 定义三个指针：
	- `i = low`：指向辅助数组`b`中左子序列（`low~mid`）的起始位置；
	- `j = mid + 1`：指向辅助数组`b`中右子序列（`mid+1~high`）的起始位置；
	- `k = low`：指向原数组`a`中待存放合并元素的位置；
4. 循环对比`b[i]`和`b[j]`，将更小的元素放入`a[k]`，并移动对应指针（`i`或`j`）和`k`；
5. 处理剩余元素：若左子序列未处理完（`i <= mid`），将`b[i~mid]`复制到`a[k~high]`；若右子序列未处理完（`j <= high`），将`b[j~high]`复制到`a[k~high]`。

### 3.3 完整代码

c

```c
// 合并数组a中low~mid和mid+1~high两个相邻的有序子序列
void Merge(int a[], int low, int mid, int high) {
    // 1. 定义辅助数组b（假设原数组a的最大长度为1000，可根据实际调整）
    int b[1000];
    // 2. 将a[low~high]的元素复制到b[low~high]
    for (int k = low; k <= high; k++) {
        b[k] = a[k];
    }
    // 3. 定义三个指针
    int i = low;       // 左子序列（b[low~mid]）的起始指针
    int j = mid + 1;   // 右子序列（b[mid+1~high]）的起始指针
    k = low;           // 原数组a的目标指针
    // 4. 对比并合并两个子序列
    while (i <= mid && j <= high) {
        if (b[i] <= b[j]) {  // 相等时优先取左子序列元素，保证稳定性
            a[k] = b[i];
            i++;
        } else {
            a[k] = b[j];
            j++;
        }
        k++;
    }
    // 5. 处理左子序列剩余元素
    while (i <= mid) {
        a[k] = b[i];
        i++;
        k++;
    }
    // 处理右子序列剩余元素（若有）
    while (j <= high) {
        a[k] = b[j];
        j++;
        k++;
    }
}
```

## 四、归并排序的完整递归实现

归并排序通过递归实现 “拆分 - 合并” 流程，核心是先递归拆分序列，再调用 Merge 函数合并有序子序列。

### 4.1 函数功能

输入数组`a`和待排序范围（`low`：起始位置，`high`：结束位置），通过递归拆分和合并，使`a[low~high]`成为有序序列。

### 4.2 实现逻辑

1. 终止条件：若`low >= high`（序列长度为 1 或 0，无需排序），直接返回；
2. 拆分：计算中间位置`mid = (low + high) / 2`（向下取整）；
3. 递归排序左子序列：调用`MergeSort(a, low, mid)`，使`a[low~mid]`有序；
4. 递归排序右子序列：调用`MergeSort(a, mid+1, high)`，使`a[mid+1~high]`有序；
5. 合并：调用`Merge(a, low, mid, high)`，将两个有序子序列合并为一个有序序列。

### 4.3 完整代码

c

```c
// 归并排序主函数：对数组a的low~high范围进行排序
void MergeSort(int a[], int low, int high) {
    if (low < high) {  // 序列长度>1时才需要拆分合并
        int mid = (low + high) / 2;  // 计算中间位置（向下取整）
        MergeSort(a, low, mid);      // 递归排序左子序列
        MergeSort(a, mid + 1, high); // 递归排序右子序列
        Merge(a, low, mid, high);    // 合并左右两个有序子序列
    }
}

// （需包含上文定义的Merge函数）
void Merge(int a[], int low, int mid, int high) {
    int b[1000];
    for (int k = low; k <= high; k++) {
        b[k] = a[k];
    }
    int i = low, j = mid + 1, k = low;
    while (i <= mid && j <= high) {
        if (b[i] <= b[j]) {
            a[k] = b[i];
            i++;
        } else {
            a[k] = b[j];
            j++;
        }
        k++;
    }
    while (i <= mid) {
        a[k] = b[i];
        i++;
        k++;
    }
    while (j <= high) {
        a[k] = b[j];
        j++;
        k++;
    }
}

// 测试示例（视频隐含场景）
#include <stdio.h>
int main() {
    int a[] = {49, 38, 65, 97, 76, 13, 27};
    int n = sizeof(a) / sizeof(a[0]);  // 数组长度
    MergeSort(a, 0, n - 1);            // 对整个数组排序（0~n-1）
    // 输出排序结果
    for (int i = 0; i < n; i++) {
        printf("%d ", a[i]);
    }
    // 输出：13 27 38 49 65 76 97
    return 0;
}
```

## 五、归并排序的算法效率分析

### 5.1 时间复杂度

#### 核心推导

- **每趟归并时间**：O (n)。无论哪一趟归并，都需遍历所有元素（合并 n 个元素，对比和复制操作均为 O (n)）；
- **归并趟数**：O (log₂n)。将 n 个元素拆分为单个元素需 log₂n 趟（如 n=7 时，趟数为 3，即 log₂7≈2.8→向上取整为 3）；
- **总时间复杂度**：每趟时间 × 趟数 = O (n) × O (log₂n) = **O(nlog₂n)**。

#### 特点

- 最好、最坏、平均时间复杂度均为**O(nlog₂n)**（无论初始序列是否有序，都需完整拆分和合并，无额外开销）。

### 5.2 空间复杂度

#### 核心来源

1. **辅助数组`b`**：大小与原数组一致，占 O (n) 空间（必须开销，无法优化）；
2. **递归栈**：递归调用深度为 O (log₂n)（拆分 n 个元素的递归深度为 log₂n），占 O (logn) 空间。

#### 结论

空间复杂度由高阶项决定，即**O(n)**（O(n) + O(logn) ≈ O(n)）。

### 5.3 稳定性

#### 结论：稳定

#### 原因

Merge 函数中，当`b[i] == b[j]`（左右子序列元素相等）时，优先选择左子序列的`b[i]`放入原数组，保证了相等元素的**相对顺序不变**（如左子序列的 24 和右子序列的 24，合并后仍保持左 24 在前、右 24 在后）。



# 基数排序知识点总结

## 1. 基数排序核心概念

### 1.1 本质特点

- **非比较类排序**：不同于冒泡、快排、堆排等基于 “关键字大小比较” 的算法，基数排序通过 “分配 + 收集” 操作实现排序，不直接比较元素大小。
- **核心思想**：将元素的关键字拆分为多个独立的 “位”（或 “部分”），按 “权重递增次序”（从对关键字影响最小的位到影响最大的位）依次对每个位执行 “分配→收集” 操作，最终实现全局有序。

### 1.2 关键字拆分规则

- **拆分方式**：将每个关键字拆分为 `d` 个部分（如 3 位数拆分为 “个位、十位、百位”，`d=3`）。
	- **最低位（LSB）**：对关键字整体值影响最小的位（如个位），权重最低。
	- **最高位（MSB）**：对关键字整体值影响最大的位（如百位），权重最高。
- **处理次序**：必须按 “权重递增” 处理（先最低位，后最高位），确保高位排序时不破坏低位已排好的顺序。

### 1.3 基数与辅助队列

- **基数 `r`**：每个关键字位的取值范围大小（如个位取值为 0~9，`r=10`；月份取值 1~12，`r=12`）。
- **辅助队列**：需创建 `r` 个**链队列**（链式存储，避免数组浪费空间），每个队列对应一个关键字位的取值（如 `r=10` 时，队列 `q0~q9` 分别对应取值 0~9）。
	- 链队列结构：每个队列包含 “队头指针（front）” 和 “队尾指针（rear）”，用于快速插入（队尾）和提取（队头）元素。

## 2. 基数排序执行步骤（以 “递减排序” 为例）

视频中以 **初始无序序列**：`[520, 211, 438, 888, 168, 007, 666, 996, 985]` 为例（3 位数，`d=3`，`r=10`），目标是排为递减序列。

### 2.1 核心原则

- **分配**：按当前处理的 “关键字位” 取值，将元素依次插入对应队列的**队尾**（保持元素原有相对顺序）。
- **收集**：为实现递减排序，从取值最大的队列（`q9`）到取值最小的队列（`q0`）依次提取元素，拼接成新序列；若为递增排序，则反向收集（`q0` 到 `q9`）。

### 2.2 第一趟：按 “个位” 处理（权重最低）

#### 2.2.1 分配（个位取值→对应队列）

| 元素 | 个位取值 | 插入队列                                |
| ---- | -------- | --------------------------------------- |
| 520  | 0        | q0                                      |
| 211  | 1        | q1                                      |
| 438  | 8        | q8                                      |
| 888  | 8        | q8（队尾）                              |
| 168  | 8        | q8（队尾）                              |
| 007  | 7        | q7                                      |
| 666  | 6        | q6                                      |
| 996  | 6        | q6（队尾）                              |
| 985  | 5        | q3（视频口误，实际个位为 5，应插入 q5） |

#### 2.2.2 收集（q9→q0，空队列跳过）

收集顺序：`q8（438→888→168）→ q7（007）→ q6（666→996）→ q5（985）→ q1（211）→ q0（520）`
收集后序列：`[438, 888, 168, 007, 666, 996, 985, 211, 520]`（按 “个位递减” 排序）。

### 2.3 第二趟：按 “十位” 处理（权重中等）

基于第一趟收集后的序列，按 “十位” 取值分配。

#### 2.3.1 分配（十位取值→对应队列）

| 元素 | 十位取值 | 插入队列   |
| ---- | -------- | ---------- |
| 438  | 3        | q3         |
| 888  | 8        | q8         |
| 168  | 6        | q6         |
| 007  | 0        | q0         |
| 666  | 6        | q6（队尾） |
| 996  | 9        | q9         |
| 985  | 8        | q8（队尾） |
| 211  | 1        | q1         |
| 520  | 2        | q2         |

#### 2.3.2 收集（q9→q0）

收集顺序：`q9（996）→ q8（888→985）→ q6（168→666）→ q3（438）→ q2（520）→ q1（211）→ q0（007）`
收集后序列：`[996, 888, 985, 168, 666, 438, 520, 211, 007]`（按 “十位递减” 排序，且十位相同时保持 “个位递减”）。

### 2.4 第三趟：按 “百位” 处理（权重最高）

基于第二趟收集后的序列，按 “百位” 取值分配。

#### 2.4.1 分配（百位取值→对应队列）

| 元素 | 百位取值 | 插入队列   |
| ---- | -------- | ---------- |
| 996  | 9        | q9         |
| 888  | 8        | q8         |
| 985  | 9        | q9（队尾） |
| 168  | 1        | q1         |
| 666  | 6        | q6         |
| 438  | 4        | q4         |
| 520  | 5        | q5         |
| 211  | 2        | q2         |
| 007  | 0        | q0         |

#### 2.4.2 收集（q9→q0）

收集顺序：`q9（996→985）→ q8（888）→ q6（666）→ q5（520）→ q4（438）→ q2（211）→ q1（168）→ q0（007）`
**最终有序序列**：`[996, 985, 888, 666, 520, 438, 211, 168, 007]`（全局递减有序）。

## 3. 算法性能分析

| 性能指标   | 结果         | 分析                                                         |
| ---------- | ------------ | ------------------------------------------------------------ |
| 时间复杂度 | O(d×(n + r)) | - `d`：关键字拆分的位数（如 3 位数 `d=3`）； - 每趟 “分配” 需遍历 `n` 个元素（O (n)）； - 每趟 “收集” 需遍历 `r` 个队列（O (r)）； - 共 `d` 趟，总时间为 O (d×(n + r))。 |
| 空间复杂度 | O(r)         | 需额外创建 `r` 个链队列，每个队列仅需 “队头 + 队尾”2 个指针（O (1) per 队列），总空间为 O (r)。 |
| 稳定性     | 稳定         | 分配时元素按顺序插入队尾，收集时保持队列内元素相对位置，相同关键字的元素不会交换顺序（视频总结 “基你太稳”）。 |

### 稳定性验证

初始序列含两个相同元素 `[12, 12_下划线]`（下划线区分相对位置）：

1. 分配：按个位（2）插入 `q2`，先插入 `12`，再插入 `12_下划线`，队列内顺序为 `12→12_下划线`。
2. 收集：提取队列元素时保持顺序，最终序列仍为 `12→12_下划线`，相对位置不变，证明稳定。

## 4. 适用场景与反例

### 4.1 适用场景

需满足 **3 个条件**：

1. 关键字可拆分为 `d` 个部分（`d` 较小）；
2. 每个部分的取值范围 `r` 较小；
3. 元素个数 `n` 较大。

**示例**：1 万个学生按年龄递减排序

- 关键字：出生年月日（拆分为 “日、月、年”，`d=3`）；
- `r` 分别为 31（日）、12（月）、15（年，1991~2005）；
- `n=10000`（较大）；
- 时间复杂度：O (3×(10000 + 31)) ≈ 3 万，远优于 O (n²) 或 O (nlogn) 算法。

### 4.2 反例

1. **5 人身份证号排序**：
	- 关键字：18 位身份证（`d=18`，较大）；
	- `n=5`（较小）；
	- 需 18 趟处理，效率低于简单排序（如冒泡）。
2. **中国人名字排序**：
	- 关键字：名字（拆分为 “姓、名 1、名 2”，`d=3`，较小）；
	- `r` 极大（汉字数量上万，每个部分的取值范围大）；
	- 需创建上万个辅助队列，空间复杂度极高。
3. **特殊情况**：10 亿人身份证号排序
	- `d=18`（仍大），但 `n=10^9`（极大）；
	- 时间复杂度 O (18×(10^9 + 10)) ≈ 1.8×10^10，优于 O (nlogn)（约 10^9×30 = 3×10^10），此时适用。

## 5. 代码实现（链式存储版）

“基数排序几乎不考代码，但需理解链式存储逻辑”，以下为视频提及的 C 语言实现（基于单链表和链队列）。

### 5.1 数据结构定义

c

```c
#include <stdio.h>
#include <stdlib.h>

// 1. 单链表节点结构（存储排序元素）
typedef struct Node {
    int data;          // 关键字（如3位数）
    struct Node *next; // 指向下一个节点
} Node, *LinkList;

// 2. 链队列结构（每个辅助队列的队头+队尾指针）
typedef struct {
    Node *front; // 队头指针（取元素）
    Node *rear;  // 队尾指针（插元素）
} Queue, *LinkQueue;

// 3. 辅助队列数组（r=10，对应0~9的取值）
#define R 10
LinkQueue queues[R];
```

### 5.2 初始化函数

c

```c
// 初始化单个链队列
void InitQueue(LinkQueue *q) {
    // 创建头节点（空节点，简化操作）
    (*q) = (LinkQueue)malloc(sizeof(Queue));
    (*q)->front = (*q)->rear = (Node*)malloc(sizeof(Node));
    (*q)->front->next = NULL;
}

// 初始化所有辅助队列（r=10）
void InitAllQueues() {
    for (int i = 0; i < R; i++) {
        InitQueue(&queues[i]);
    }
}

// 初始化单链表（将无序序列转为链表）
void InitLinkList(LinkList *L, int arr[], int n) {
    (*L) = (LinkList)malloc(sizeof(Node));
    (*L)->next = NULL;
    Node *p = (*L); // 尾指针，用于插入

    for (int i = 0; i < n; i++) {
        Node *newNode = (Node*)malloc(sizeof(Node));
        newNode->data = arr[i];
        newNode->next = NULL;
        p->next = newNode;
        p = p->next;
    }
}
```

### 5.3 分配与收集函数

c

```c
// 获取关键字的第k位数值（k=0：个位，k=1：十位，k=2：百位）
int GetKeyBit(int data, int k) {
    int divisor = 1;
    for (int i = 0; i < k; i++) {
        divisor *= 10;
    }
    return (data / divisor) % 10;
}

// 分配操作：按第k位数值，将链表元素插入对应队列
void Distribute(LinkList L, int k) {
    Node *p = L->next; // 遍历链表的指针
    while (p != NULL) {
        // 1. 暂存当前节点（避免断链）
        Node *temp = p;
        p = p->next;
        temp->next = NULL;

        // 2. 获取当前节点的第k位数值，确定插入队列
        int bit = GetKeyBit(temp->data, k);
        LinkQueue q = queues[bit];

        // 3. 插入队尾
        q->rear->next = temp;
        q->rear = temp;
    }
    // 清空原链表（仅保留头节点）
    L->next = NULL;
}

// 收集操作：从q9到q0依次提取元素，拼接回原链表（递减排序）
void Collect(LinkList L) {
    Node *p = L; // 链表的尾指针，用于拼接

    // 从大到小遍历队列（q9 → q0）
    for (int i = R-1; i >= 0; i--) {
        LinkQueue q = queues[i];
        if (q->front->next != NULL) { // 队列非空
            // 1. 将队列元素接入链表尾
            p->next = q->front->next;
            // 2. 更新链表尾指针为队列尾
            p = q->rear;
            // 3. 清空当前队列（重置队头队尾）
            q->front->next = NULL;
            q->rear = q->front;
        }
    }
}
```

### 5.4 基数排序主函数

c

```c
// 基数排序（d：关键字拆分数，如3位数d=3）
void RadixSort(LinkList L, int d) {
    // 1. 初始化所有辅助队列
    InitAllQueues();

    // 2. 按权重递增处理每个位（k=0：个位，k=1：十位，k=2：百位）
    for (int k = 0; k < d; k++) {
        Distribute(L, k); // 分配
        Collect(L);       // 收集
    }

    // 3. 释放辅助队列（可选，避免内存泄漏）
    for (int i = 0; i < R; i++) {
        free(queues[i]->front);
        free(queues[i]);
    }
}

// 打印链表（验证结果）
void PrintLinkList(LinkList L) {
    Node *p = L->next;
    while (p != NULL) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

// 主函数（视频示例测试）
int main() {
    // 视频中的初始无序序列
    int arr[] = {520, 211, 438, 888, 168, 7, 666, 996, 985};
    int n = sizeof(arr) / sizeof(arr[0]);
    int d = 3; // 3位数，拆分为3个部分

    // 初始化链表
    LinkList L;
    InitLinkList(&L, arr, n);

    // 基数排序（递减）
    RadixSort(L, d);

    // 打印结果（应与视频最终序列一致）
    printf("基数排序（递减）结果：");
    PrintLinkList(L); // 输出：996 985 888 666 520 438 211 168 7

    // 释放链表（可选）
    Node *p = L, *q;
    while (p != NULL) {
        q = p;
        p = p->next;
        free(q);
    }

    return 0;
}
```

## 6. 核心考点

- **手动模拟**：考研 / 考试主要考察 “分配 + 收集” 的手动步骤（如给定序列，写出每趟后的结果），几乎不考代码。
- **非比较排序**：区别于其他排序算法的核心特征，需明确 “不直接比较关键字大小”。
- **稳定性与性能**：记住 “稳定” 特性及时间 / 空间复杂度公式，能结合场景判断是否适用。



# 计数排序（Counting Sort）知识点总结

## 1. 计数排序背景

- 定位：**408 计算机考研大纲未明确要求，但历年真题需用到其思想**，属于补充必学考点。
- 核心价值：通过 “统计元素出现次数 + 确定元素位置” 实现排序，无需元素间比较，是一种 “非比较类排序”。

## 2. 核心思想（附示例）

### 2.1 核心逻辑

通过**统计 “小于等于当前元素的总个数”** ，确定该元素在排序结果中的最终位置。
本质：用 “计数” 替代 “比较”，直接映射元素的排序位置。

### 2.2 生活化示例

某小学班级英语成绩：假设班级成绩包含「咸鱼（16 分）、卧龙（<16 分）、凤雏（<16 分）、郑楠（83 分）」等。

- 求咸鱼（16 分）的排名：统计 “小于等于 16 分” 的人数（卧龙、凤雏、咸鱼共 3 人）→ 咸鱼排第 3（倒数第三）。
- 求郑楠（83 分）的排名：统计 “小于等于 83 分” 的人数（共 5 人）→ 郑楠排第 5。
	→ 此逻辑即为计数排序的核心。

## 3. 算法实现步骤（附详细示例）

视频中以**待排序数组 A = [2,4,3,0,2,3,0,3]** 为例（长度 n=8，元素取值范围 0~4，即 k=5），分 3 步实现排序。

### 3.1 步骤 1：统计每个元素的出现次数（辅助数组 C）

- 目标：用辅助数组 C（长度 = k，下标对应 A 中元素的取值），存储 A 中每个元素的出现次数。
- 操作：遍历 A，对每个元素`A[i]`，执行`C[A[i]] += 1`。
- 示例过程：
	- 初始 C = [0,0,0,0,0]（k=5，下标 0~4）。
	- 遍历 A：
		- A[0]=2 → C[2] = 1；A[1]=4 → C[4]=1；A[2]=3 → C[3]=1；A[3]=0 → C[0]=1；
		- A[4]=2 → C[2]=2；A[5]=3 → C[3]=2；A[6]=0 → C[0]=2；A[7]=3 → C[3]=3；
	- 结果：C = [2, 0, 2, 3, 1]（含义：0 出现 2 次，1 出现 0 次，2 出现 2 次，3 出现 3 次，4 出现 1 次）。

### 3.2 步骤 2：将 C 转化为 “小于等于当前下标的元素总数”

- 目标：让`C[i]`表示 A 中 “小于等于 i” 的元素总个数，为后续确定位置做准备。
- 操作：从下标 1 开始，执行`C[i] = C[i] + C[i-1]`。
- 示例过程：
	- C 初始（步骤 1 结果）：[2, 0, 2, 3, 1]
	- i=1：C[1] = C[1] + C[0] = 0+2=2；
	- i=2：C[2] = C[2] + C[1] = 2+2=4；
	- i=3：C[3] = C[3] + C[2] = 3+4=7；
	- i=4：C[4] = C[4] + C[3] = 1+7=8；
	- 结果：C = [2, 2, 4, 7, 8]（含义：≤0 的有 2 个，≤1 的有 2 个，≤2 的有 4 个，≤3 的有 7 个，≤4 的有 8 个）。

### 3.3 步骤 3：从后往前遍历 A，将元素放入目标数组 B（保证稳定性）

- 目标：利用步骤 2 的 C 数组，将 A 中每个元素`A[i]`放入排序结果数组 B 的正确位置。
- 关键操作：
	1. 从后往前遍历 A（`i从n-1到0`），保证**相同元素的相对顺序不变（稳定性）** ；
	2. 对每个`A[i]`，执行：
		- `C[A[i]] -= 1`（确定`A[i]`在 B 中的下标，因数组下标从 0 开始）；
		- `B[C[A[i]]] = A[i]`（将`A[i]`放入 B 的对应位置）。
- 示例过程（视频中用颜色区分相同元素：0→黄 / 绿，2→灰 / 黑，3→白 / 红 / 蓝，4→紫）：
	- 初始 B = [0,0,0,0,0,0,0,0]，C = [2,2,4,7,8]（步骤 2 结果）。
	- 遍历 A（从后往前，i=7 到 0）：
		1. i=7，A [7]=3：C [3] -=1 → 6；B [6] = 3（蓝色 3）；
		2. i=6，A [6]=0：C [0] -=1 →1；B [1] =0（绿色 0）；
		3. i=5，A [5]=3：C [3] -=1 →5；B [5] =3（红色 3）；
		4. i=4，A [4]=2：C [2] -=1 →3；B [3] =2（黑色 2）；
		5. i=3，A [3]=0：C [0] -=1 →0；B [0] =0（黄色 0）；
		6. i=2，A [2]=3：C [3] -=1 →4；B [4] =3（白色 3）；
		7. i=1，A [1]=4：C [4] -=1 →7；B [7] =4（紫色 4）；
		8. i=0，A [0]=2：C [2] -=1 →2；B [2] =2（灰色 2）；
	- 最终 B = [0,0,2,2,3,3,3,4]（排序完成，相同元素相对顺序与原数组一致，稳定）。

## 4. 完整 C 语言代码

c

```c
// 计数排序函数
// A：待排序数组；B：排序结果数组；n：数组长度；k：A中元素的最大值（取值范围0~k）
void CountingSort(int A[], int B[], int n, int k) {
    // 1. 初始化辅助数组C（长度k+1，因元素取值0~k）
    int C[k + 1];
    for (int i = 0; i <= k; i++) {
        C[i] = 0; // 初始化为0，统计次数前清零
    }

    // Step1：统计A中每个元素的出现次数
    for (int i = 0; i < n; i++) {
        C[A[i]]++; // A[i]的值作为C的下标，计数+1
    }

    // Step2：将C转化为“小于等于当前下标的元素总数”
    for (int i = 1; i <= k; i++) {
        C[i] = C[i] + C[i - 1]; // 累加前一个位置的计数
    }

    // Step3：从后往前遍历A，将元素放入B的正确位置（保证稳定性）
    for (int i = n - 1; i >= 0; i--) {
        C[A[i]]--; // 确定当前元素在B中的下标（下标从0开始）
        B[C[A[i]]] = A[i]; // 将A[i]放入B的对应位置
    }
}

// 测试示例（视频隐含测试用例）
#include <stdio.h>
int main() {
    int A[] = {2, 4, 3, 0, 2, 3, 0, 3}; // 待排序数组
    int n = sizeof(A) / sizeof(A[0]); // 数组长度n=8
    int k = 4; // A中元素最大值为4（取值0~4）
    int B[n]; // 排序结果数组

    CountingSort(A, B, n, k);

    // 输出排序结果
    printf("排序后数组：");
    for (int i = 0; i < n; i++) {
        printf("%d ", B[i]); // 预期输出：0 0 2 2 3 3 3 4
    }
    return 0;
}
```

## 5. 性能分析

### 5.1 时间复杂度

- 总时间复杂度：**O(n + k)**
	拆解：
	- 初始化 C 数组：O (k)；
	- Step1（统计次数）：O (n)；
	- Step2（处理 C 数组）：O (k)；
	- Step3（排序）：O (n)；
		总和：O (k + n + k + n) = O (n + k)（常数项忽略）。
- 推论：
	- 若 k 与 n 同数量级（如 k≤n），则时间复杂度≈O (n)，优于快排 / 堆排（O (nlogn)）；
	- 若 k 远大于 n（如 k≥nlogn），则时间复杂度≈O (k)，性能劣于快排 / 堆排。

### 5.2 空间复杂度

- 总空间复杂度：**O(n + k)**
	拆解：
	- 结果数组 B：O (n)（存储排序后的数据）；
	- 辅助数组 C：O (k)（存储计数信息）；
		属于 “空间换时间” 的算法。

### 5.3 稳定性

- 结论：**稳定排序**。
- 原因：Step3 中 “从后往前遍历 A”，相同元素会按原数组的相对顺序依次放入 B 中。
	示例：原数组 A 中 3 的顺序为「白 3、红 3、蓝 3」，排序后 B 中 3 的顺序仍为「白 3、红 3、蓝 3」，相对顺序不变。

## 6. 适用条件

1. **关键字类型**：待排序元素的关键字必须是**整数**（需用关键字作为辅助数组 C 的下标）；
2. **取值范围**：元素取值范围需明确且较小（0~k，k 最好与 n 同数量级）；
3. **场景适配**：适合数据范围可控的场景（如学生成绩、年龄、ID 等），不适合取值范围极广的数据（如浮点数、大整数）。

## 7. 历年真题应用

### 7.1 2013 年 41 题（找主元素）

#### 题目要求

- 给定长度为 n 的整数数组 A，元素取值 0~n-1；
- 若存在元素 x，其出现次数 > n/2，则 x 为 “主元素”，输出 x；否则输出 - 1。

#### 计数排序思想解法

- 核心：用计数排序的 Step1（统计次数）实现。
- 步骤：
	1. 定义辅助数组 C（长度 n，下标 0~n-1），初始化 C [i]=0；
	2. 遍历 A，统计每个元素的出现次数（C [A [i]]++）；
	3. 遍历 C，若存在 C [x]>n/2，则输出 x；否则输出 - 1。
- 时间复杂度：O (n)，空间复杂度：O (n)，性能最优。

### 7.2 2018 年 41 题（找未出现的最小正整数）

#### 题目要求

- 给定长度为 n 的整数数组 A，设计高效算法找到 A 中 “未出现的最小正整数”（如 A=[0,1,3]，输出 2；A=[3,4,-1,1]，输出 2）。

#### 计数排序思想解法

- 核心：利用 “长度为 n 的数组，未出现的最小正整数必在 1~n+1 之间”（因 1~n+1 共 n+1 个数，数组仅能存 n 个，必缺一个）。
- 步骤：
	1. 定义辅助数组 C（长度 n+2，下标 0~n+1），初始化 C [i]=0；
	2. 遍历 A，仅统计 “1~n+1” 范围内的元素（负数、0、>n+1 的数忽略），执行 C [x]++（x 为 A 中符合条件的元素）；
	3. 从 i=1 开始遍历 C，第一个 C [i]=0 的 i 即为 “未出现的最小正整数”。
- 时间复杂度：O (n)，空间复杂度：O (n)，满足题目 “时间尽可能高效” 的要求。

## 8. 代码拓展思路

视频中提到 “考试代码简洁即可，实战需增强通用性”，核心拓展方向：

- 无需严格限制元素取值为 0~k：
	1. 先遍历 A，找到元素的最小值 min 和最大值 max；
	2. 辅助数组 C 的长度设为`max - min + 1`；
	3. 统计时，用`A[i] - min`作为 C 的下标（映射到 0~(max-min) 范围）；
	4. 排序后，再将 B 中的元素加 min 恢复原值。
- 作用：支持含负数、取值范围非 0 开始的数据（如 A=[-2,1,3,-1,2]，min=-2，max=3，C 长度 = 6）。



# 外部排序知识点总结

## 一、外存与内存的数据交换原理

视频中明确外存特指**机械硬盘（磁盘）**，其数据交换的核心是 “以磁盘块为单位”，具体原理如下：

### 1. 磁盘存储的基本单位：磁盘块

- 磁盘的存储单元以**磁盘块**为最小管理单位，操作系统对磁盘空间的分配、读写均基于磁盘块。
- 常见磁盘块大小：1KB、4KB（视频示例用 1KB）。
- 磁盘块内可存放多个数据记录（视频示例中每块含 3 个记录，记录以 “关键字” 标识）。

### 2. 数据交换三步骤

由于磁盘无法直接修改数据，必须通过内存缓冲区完成，具体流程如下：

1. **读块到内存**：在内存中开辟与磁盘块大小一致的 “缓冲区”（如 1KB），将目标磁盘块（如磁盘块 4）的全部数据读入缓冲区。
	*示例*：磁盘块 4 存有关键字`[35, 12, 48]`，读入内存缓冲区后，缓冲区数据与磁盘块 4 完全一致。
2. **内存中修改数据**：通过程序代码对缓冲区中的数据进行修改（如排序、更新关键字）。
	*示例*：将缓冲区中`[35, 12, 48]`排序为`[12, 35, 48]`。
3. **写块回外存**：将修改后的缓冲区数据以 “整块” 形式写回磁盘，可覆盖原磁盘块（如写回磁盘块 4）或写入其他磁盘块（如写回磁盘块 11）。

### 核心结论

- 磁盘读写**必须以块为单位**（每次读 1 块、写 1 块，无法读写块内部分数据）。
- 外存与内存的交换本质是 “磁盘块→内存缓冲区→磁盘块” 的全量块传输。

## 二、外部排序的定义

- **适用场景**：待排序数据**存储在外存（磁盘）** 中，且数据总量远超内存容量（内存无法一次性装入所有数据）。
- **核心区别（与内部排序）**：
	- 内部排序：数据全在内存，无需与外存交互；
	- 外部排序：数据主要在外存，排序过程依赖 “分块读写 + 内存处理” 的循环。

## 三、外部排序的实现步骤（  示例：16 块数据，每块 3 个记录）

视频中外部排序基于**归并排序思想**，分为两大核心步骤：“生成初始归并段” 和 “多趟归并”。

### 1. 步骤 1：生成初始归并段

初始归并段是 “外存中局部有序的子序列”，生成逻辑是 “分块读入内存→内部排序→写回外存”。

#### 具体流程（视频示例）

- 内存配置：2 个输入缓冲区（每块 1KB）+ 1 个输出缓冲区（1KB）。
- 处理逻辑：
	1. 读入 2 个磁盘块（如块 1、块 2）到两个输入缓冲区；
	2. 对两个缓冲区中的所有记录（共 6 个）执行**内部排序**（如快速排序、插入排序）；
	3. 将排序后的记录分块写入输出缓冲区，满 1KB 后写回外存，形成 1 个 “初始归并段”；
	4. 重复上述步骤，直到所有 16 块数据处理完毕。

#### 示例结果

- 16 块数据→每次处理 2 块→生成`16÷2=8个初始归并段`（每个归并段含 2 块数据，内部有序）。
- 读写次数计算：每块数据需 “读 1 次 + 写 1 次”，总次数 = 16 块 ×2=32 次。

### 2. 步骤 2：多趟归并（以二路归并为例）

多趟归并的目标是将 “多个初始归并段” 逐步合并为 “一个全局有序的文件”，核心是 “分块读入归并段→内存归并→写回外存”。

#### 示例：8 个初始归并段→3 趟二路归并

##### 归并规则

- 内存配置：2 个输入缓冲区（对应两个待归并段）+ 1 个输出缓冲区；
- 归并逻辑：
	1. 分别读两个归并段的首个磁盘块到两个输入缓冲区；
	2. 对比两个缓冲区中的记录关键字，选择**最小关键字**写入输出缓冲区；
	3. 若输出缓冲区满（1KB），立即写回外存；
	4. 若某输入缓冲区空，立即读对应归并段的下一个磁盘块到该缓冲区；
	5. 重复步骤 2-4，直到两个归并段完全合并为 1 个新归并段。

##### 三趟归并过程

| 归并趟数 | 输入归并段数量    | 输出归并段数量    | 每趟读写次数 | 核心操作                                          |
| -------- | ----------------- | ----------------- | ------------ | ------------------------------------------------- |
| 第 1 趟  | 8 个（每段 2 块） | 4 个（每段 4 块） | 16×2=32 次   | 8 个归并段两两合并（如段 1 & 段 2，段 3 & 段 4…） |
| 第 2 趟  | 4 个（每段 4 块） | 2 个（每段 8 块） | 16×2=32 次   | 4 个归并段两两合并（如段 1 & 段 2，段 3 & 段 4）  |
| 第 3 趟  | 2 个（每段 8 块） | 1 个（16 块）     | 16×2=32 次   | 2 个归并段合并为全局有序文件                      |

#### 总读写次数

初始归并段生成（32 次）+ 3 趟归并（3×32=96 次）= **128 次**（视频中假设每次读写 10ms，总耗时 1280ms=1.28 秒）。

## 四、外部排序的时间开销

视频中明确外部排序的时间由三部分构成，其中**读写外存时间占比最大**：

| 时间组成部分                | 说明                                                         | 耗时特点                 |
| --------------------------- | ------------------------------------------------------------ | ------------------------ |
| 1. 读写外存时间（核心）     | 与磁盘块读写次数成正比，每次读写需机械硬盘寻址、旋转延迟（耗时较长） | 占总时间的 80% 以上      |
| 2. 初始归并段的内部排序时间 | 对读入内存的块数据执行内部排序（如快速排序）                 | 内存操作，耗时极短       |
| 3. 多趟归并的内部归并时间   | 对比输入缓冲区中的关键字，选择最小元素写入输出缓冲区         | 内存操作，耗时远小于外存 |

## 五、外部排序的优化思路

优化核心目标：**减少读写外存次数**，而读写次数与 “归并趟数” 正相关，因此优化围绕 “减少归并趟数” 展开。

### 1. 优化方向 1：采用多路归并（增加归并路数 k）

#### 核心原理

归并趟数`s`与归并路数`k`、初始归并段数`r`的关系为：
`s = ⌈log_k r⌉`（向上取整，如 r=8 时，k=2→s=3，k=4→s=2）。
`k`越大，`s`越小，读写外存次数越少。

#### 视频示例：四路归并（k=4）

- 初始归并段`r=8`，归并趟数`s=2`（原二路归并 s=3）：
	1. 第 1 趟：8 个归并段→4 路合并→生成`⌈8/4⌉=2个归并段`（读写 32 次）；
	2. 第 2 趟：2 个归并段→二路合并→生成 1 个有序文件（读写 32 次）。
- 总读写次数：初始 32 次 + 2×32=64 次 = **96 次**（比二路归并减少 32 次）。

#### 多路归并的注意事项（k 并非越大越好）

- 内存开销增加：k 路归并需`k个输入缓冲区`（如 k=100 需 100 个 1KB 缓冲区，内存占用增加）；
- 内部归并比较次数增加：每次选择最小元素需比较`k-1次`（如 k=4 需 3 次比较，k=100 需 99 次比较）；
- 解决方案：后续通过 “败者树” 优化比较次数（视频预告内容）。

### 2. 优化方向 2：减少初始归并段数量 r

#### 核心原理

初始归并段数量`r = 总磁盘块数 ÷ 每次读入内存的块数`。
若增大 “每次读入内存的块数”（即增大输入缓冲区数量），则`r`减少，进而减少归并趟数`s`。

#### 视频示例

- 原配置：2 个输入缓冲区→每次读 2 块→r=16÷2=8；
- 优化后：4 个输入缓冲区→每次读 4 块→r=16÷4=4；
- 归并趟数：r=4，k=4→s=1（1 趟四路归并即可完成）；
- 总读写次数：初始 16×2=32 次 + 1×32=32 次 = **64 次**（大幅减少）。

#### 进阶方案

视频预告：通过 “置换 - 选择排序” 算法，可突破 “每次读入块数” 的限制，生成更长的初始归并段，进一步减少`r`。

## 六、多路平衡归并的定义纠正

课本对 “k 路平衡归并” 的定义存在矛盾，视频给出**正确定义**：需同时满足以下两个特性：

1. 最多将`k个归并段`合并为 1 个新归并段；
2. 每趟归并中，若`m个归并段`参与，则生成的新归并段数量为`⌈m/k⌉`（向上取整）。

#### 正例与反例（以 k=4 为例）

| 案例               | 参与归并段数 m | 生成新归并段数 | 是否满足平衡归并 | 原因                                          |
| ------------------ | -------------- | -------------- | ---------------- | --------------------------------------------- |
| 视频正确案例       | 8              | ⌈8/4⌉=2        | 是               | 8 个→2 个，2 个→⌈2/4⌉=1 个，每趟均满足`⌈m/k⌉` |
| 反例（非平衡归并） | 8              | 3              | 否               | 8 个→3 个，不满足`⌈8/4⌉=2`，不符合定义 2      |



#  败者树知识点总结

## 1. 败者树的背景与问题引入

败者树是为解决**k 路平衡归并排序**中 “选最小 / 最大元素对比次数过多” 的问题而设计的数据结构，核心目标是减少内部归并的时间开销，平衡 “增加归并路数 k 以减少磁盘读写” 的优化方向。

### 1.1 多路归并的核心矛盾

- **优化方向**：外部排序中，增加归并路数`k`可减少归并趟数，从而减少磁盘读写次数（磁盘 I/O 是外部排序的主要时间开销）。
- **矛盾点**：传统 k 路归并中，每次从`k`个归并段的当前元素中选最小 / 最大元素，需进行`k-1`次关键字对比（逐次两两对比）。
	- **示例**：8 路归并选最小元素时，需对比`8-1=7`次（如 27→12→1→17→2→98→11→4，最终确定 1 为最小）。
- **解决方案**：引入败者树，将每次选最小 / 最大元素的对比次数从`k-1`降至`⌈log₂k⌉`（完全二叉树的高度相关）。

## 2. 败者树的核心概念（基于 “七龙珠比赛” 示例）

视频用 “8 名选手争夺冠军” 的例子类比败者树的构造过程，直观解释 “失败者记录” 与 “胜利者晋级” 的核心逻辑。

### 2.1 示例场景

8 名选手（阿乐、天津饭、狼人、成龙、饺子、无限、孙悟空、巴布特），比赛规则：两两 PK，失败者留在当前 “节点”，胜利者晋级下一轮，最终决出冠军（最强者）。

### 2.2 败者树构造过程（比赛流程）

| 回合 | 参赛选手         | 胜负结果           | 非叶子节点记录（失败者）  | 晋级者         |
| ---- | ---------------- | ------------------ | ------------------------- | -------------- |
| 1    | 阿乐 vs 天津饭   | 阿乐败，天津饭胜   | 阿乐（对应 “归并段 1”）   | 天津饭         |
| 2    | 狼人 vs 成龙     | 狼人败，成龙胜     | 狼人（对应 “归并段 2”）   | 成龙           |
| 3    | 饺子 vs 无限     | 饺子败，无限胜     | 饺子（对应 “归并段 3”）   | 无限           |
| 4    | 巴布特 vs 孙悟空 | 巴布特败，孙悟空胜 | 巴布特（对应 “归并段 4”） | 孙悟空         |
| 5    | 天津饭 vs 成龙   | 成龙败，天津饭胜   | 成龙（对应 “归并段 2”）   | 天津饭         |
| 6    | 无限 vs 孙悟空   | 无限败，孙悟空胜   | 无限（对应 “归并段 3”）   | 孙悟空         |
| 7    | 天津饭 vs 孙悟空 | 孙悟空败，天津饭胜 | 孙悟空（对应 “归并段 4”） | 天津饭（冠军） |

- **结果**：构造出一棵完全二叉树，非叶子节点记录 “失败者”，根节点对应 “胜利者（冠军）”。

### 2.3 冠军替换与树调整（核心优势）

若冠军（天津饭）退赛，由派大星顶替其位置，无需重新进行 7 次比赛，仅需沿 “派大星所在叶子节点→根节点” 的路径向上对比：

1. 派大星 vs 阿乐（第 1 回合失败者）→ 派大星胜；
2. 派大星 vs 成龙（第 5 回合失败者）→ 派大星胜；
3. 派大星 vs 孙悟空（第 7 回合失败者）→ 孙悟空胜；

- **结果**：新冠军为孙悟空，仅需 3 次对比（`⌈log₂8⌉=3`）。

## 3. 败者树的结构定义

败者树本质是一棵**完全二叉树**，节点分为两类，核心是 “记录失败者，传递胜利者”。

| 节点类型   | 数量                   | 含义与作用                                                   |
| ---------- | ---------------------- | ------------------------------------------------------------ |
| 叶子节点   | `k`个（`k`为归并路数） | 虚拟节点（不实际存储），每个叶子节点对应一个归并段的 “当前待选元素”（即归并段的当前最小元素）。 |
| 非叶子节点 | `k-1`个                | 存储 “其左右子树比赛中的失败者所在的归并段编号”（而非元素值），用于后续调整时快速定位对比对象。 |
| 根节点     | 1 个                   | 存储 “最终胜利者所在的归并段编号”（即当前`k`个元素中的最小 / 最大元素对应的归并段）。 |

- **核心规则**：每一轮比赛的胜利者晋级，与上层节点的胜利者继续比赛；失败者的归并段编号记录在当前非叶子节点中。

## 4. 败者树在 k 路归并中的应用（8 路归并示例）

视频以 “8 路归并选最小元素” 为例，详细演示败者树的构造、调整过程。

### 4.1 示例前提

8 个归并段，初始待选元素（每个归并段的当前最小元素）如下：

| 归并段编号 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 当前元素   | 27   | 12   | 1    | 17   | 2    | 98   | 11   | 4    |

### 4.2 步骤 1：构造初始败者树（选第一个最小元素）

#### 4.2.1 层次化比赛（从叶子到根）

1. **第一层非叶子节点**（对应叶子节点 1-2、3-4、5-6、7-8）：
	- 归并段 1（27）vs 归并段 2（12）：27 败→ 节点记录 “1”（归并段编号），晋级者 2；
	- 归并段 3（1）vs 归并段 4（17）：17 败→ 节点记录 “4”，晋级者 3；
	- 归并段 5（2）vs 归并段 6（98）：98 败→ 节点记录 “6”，晋级者 5；
	- 归并段 7（11）vs 归并段 8（4）：11 败→ 节点记录 “7”，晋级者 8；
2. **第二层非叶子节点**（对应第一层 1-2、3-4 节点）：
	- 归并段 2（12）vs 归并段 3（1）：12 败→ 节点记录 “2”，晋级者 3；
	- 归并段 5（2）vs 归并段 8（4）：4 败→ 节点记录 “8”，晋级者 5；
3. **根节点**（对应第二层 1-2 节点）：
	- 归并段 3（1）vs 归并段 5（2）：2 败→ 节点记录 “5”，根节点记录 “3”；

#### 4.2.2 结果

- 初始最小元素来自**归并段 3**，值为 1；
- 初始构造对比次数：`8-1=7`次（`k-1`次，仅需 1 次构造）。

### 4.3 步骤 2：替换元素并调整败者树（选下一个最小元素）

归并段 3 的元素 “1” 被选出后，下一个待选元素为 “6”（归并段 3 的下一个元素），需调整败者树：

1. **更新叶子节点**：归并段 3 的当前元素更新为 6；
2. **向上对比调整**（沿归并段 3→根节点的路径）：
	- 归并段 3（6）vs 归并段 4（17，第一层节点记录的败者）：17 败→ 第一层节点保持 “4”，晋级者 3；
	- 归并段 3（6）vs 归并段 2（12，第二层节点记录的败者）：12 败→ 第二层节点保持 “2”，晋级者 3；
	- 归并段 3（6）vs 归并段 5（2，根节点记录的败者）：6 败→ 根节点更新为 “5”，新胜利者为归并段 5；
3. **结果**：新的最小元素来自**归并段 5**，值为 2；
	- 调整对比次数：3 次（`⌈log₂8⌉=3`次）。

## 5. 败者树的性能优势

### 5.1 对比次数公式

| 操作                 | 对比次数    | 说明                                              |
| -------------------- | ----------- | ------------------------------------------------- |
| 初始构造败者树       | `k-1`次     | 仅需执行 1 次，为所有后续操作奠定基础。           |
| 每次替换元素后选最小 | `⌈log₂k⌉`次 | 核心优势，对比次数与`k`的对数相关，而非线性相关。 |

### 5.2 实例对比（1024 路归并）

| 归并方式      | 每次选最小元素的对比次数 | 差异倍数 |
| ------------- | ------------------------ | -------- |
| 传统 k 路归并 | 1024-1=1023 次           | 102 倍   |
| 败者树优化    | ⌈log₂1024⌉=10 次         | 1 倍     |

- **结论**：`k`越大，败者树的优化效果越显著，尤其适合外部排序中 “大 k 路归并” 场景。

## 6. 败者树的代码实现思路

视频明确 “考研以手算为主，代码仅需了解思路”，核心是用**int 数组**存储非叶子节点的 “败者归并段编号”，虚拟叶子节点对应归并段的当前元素。

### 6.1 核心数据结构

- `loserTree[]`：int 数组，长度为`k`（`k`为归并路数），存储非叶子节点的 “败者归并段编号”，根节点记录 “胜利者编号”；
- `data[]`：int 数组，长度为`k`，存储每个归并段的 “当前待选元素”（对应虚拟叶子节点）；
- 归并段编号：从 0 或 1 开始（视频示例用 1，课本示例用 0，此处统一为 0 开始）。

### 6.2 初始化函数（构造初始败者树）

c

```c
/**
 * @brief 初始化败者树（选最小元素）
 * @param loserTree 败者树数组（存储败者归并段编号，根节点存胜利者）
 * @param data 各归并段当前待选元素数组
 * @param k 归并路数（叶子节点数）
 */
void initLoserTree(int loserTree[], int data[], int k) {
    // 1. 初始化叶子节点的“初始胜利者”为自身归并段编号
    int winner[k]; // 临时存储每一层的胜利者编号
    for (int i = 0; i < k; i++) {
        winner[i] = i; // 初始时，每个归并段的胜利者是自己
    }

    // 2. 从最底层非叶子节点开始，逐层向上比赛（完全二叉树性质）
    int lastNonLeaf = (k - 2) / 2; // 最底层非叶子节点的起始下标（0-based）
    for (int i = lastNonLeaf; i >= 0; i--) {
        int leftChild = 2 * i + 1;  // 左孩子胜利者的下标
        int rightChild = 2 * i + 2; // 右孩子胜利者的下标

        // 处理右孩子不存在的情况（叶子节点数为奇数）
        if (rightChild >= k) {
            loserTree[i] = -1;       // 无败者，标记为-1
            winner[i] = winner[leftChild]; // 胜利者为左孩子
        } else {
            // 对比左右孩子的元素，选较小的为胜利者
            if (data[winner[leftChild]] > data[winner[rightChild]]) {
                loserTree[i] = winner[leftChild]; // 左孩子败，记录其编号
                winner[i] = winner[rightChild];   // 右孩子胜，晋级
            } else {
                loserTree[i] = winner[rightChild]; // 右孩子败，记录其编号
                winner[i] = winner[leftChild];    // 左孩子胜，晋级
            }
        }
    }

    // 3. 根节点记录最终胜利者（即初始最小元素的归并段编号）
    loserTree[k - 1] = winner[0]; // 视频中约定根节点存在数组末尾
}
```

### 6.3 调整函数

c

```c
/**
 * @brief 调整败者树（胜利者归并段的元素被替换后）
 * @param loserTree 败者树数组
 * @param data 各归并段当前待选元素数组
 * @param k 归并路数
 * @param win 胜利者归并段编号（元素被替换的归并段）
 * @param newData 该归并段的新待选元素
 */
void adjustLoserTree(int loserTree[], int data[], int k, int win, int newData) {
    // 1. 更新该归并段的当前元素
    data[win] = newData;

    // 2. 从该归并段对应的父节点开始，向上调整
    int parent = (win - 1) / 2; // 父节点下标（完全二叉树叶子节点的父节点）
    while (parent >= 0) {
        int currentLoser = loserTree[parent]; // 父节点记录的败者编号

        // 对比当前win（新元素）和currentLoser（原败者）
        if (currentLoser == -1) {
            // 父节点无败者，当前win即为胜利者
            loserTree[parent] = -1;
            win = win; // 胜利者不变
        } else {
            if (data[win] > data[currentLoser]) {
                // win败，更新父节点的败者为win，胜利者变为currentLoser
                int temp = loserTree[parent];
                loserTree[parent] = win;
                win = temp;
            } else {
                // currentLoser败，父节点状态不变，无需继续向上
                break;
            }
        }

        // 继续向上找父节点
        parent = (parent - 1) / 2;
    }

    // 3. 更新根节点的胜利者编号
    loserTree[k - 1] = win;
}
```

### 6.4 代码关键说明

1. **虚拟叶子节点**：叶子节点不实际存储在`loserTree`数组中，仅通过`data`数组关联归并段的当前元素；
2. **编号一致性**：`loserTree`存储的是 “归并段编号”，而非元素值，减少空间开销且便于定位；
3. **课本示例适配**：若为 5 路归并（课本示例），`loserTree`长度为 5，`LS0`（下标 0）为根节点，`LS1~LS4`（下标 1~4）为非叶子节点，归并段`B0~B4`对应虚拟叶子节点。

## 7. 关键注意事项

1. **胜负判定规则**：视频中均为 “选最小元素”（元素小者胜），若需 “选最大元素”，只需将对比条件（`data[a] > data[b]`）改为`data[a] < data[b]`；
2. **归并段编号**：需确保`loserTree`记录的编号与`data`数组的归并段编号完全一致，避免混淆；
3. **考研考察重点**：以 “手算构造初始败者树” 和 “手算调整过程” 为主，代码仅需理解数组存储逻辑和调整路径。



#  置换 - 选择排序知识点总结

## 1. 传统构造初始归并段的方法（称 “土办法”）

### 1.1 核心原理

外部排序中，传统方法通过 “内存工作区 + 输入 / 输出缓冲区” 构造初始归并段，步骤如下：

1. 利用**输入缓冲区**读入数据（最多读入`l`个记录，`l`为内存工作区的容量上限）；
2. 在**内存工作区**中对这`l`个记录执行内部排序；
3. 通过**输出缓冲区**将排序后的`l`个记录写入外存，形成 1 个**初始归并段**；
4. 重复上述步骤，直到所有待排序记录处理完毕。

### 1.2 关键公式

初始归并段的数量`r`由总记录数`n`和内存工作区容量`l`决定：
`r = n / l`（整除，即每个归并段长度≤`l`）

### 1.3 局限性

- 初始归并段长度**无法突破内存工作区容量**（每个归并段最多`l`个记录）；
- 初始归并段数量`r`完全由`l`决定，`l`越小则`r`越大；
- 外部排序的`k`路归并趟数`s = ⌈log_k r⌉`，`r`增大会导致`s`增多，磁盘 IO 次数增加，效率降低。

### 1.4 视频示例

假设待排序文件总记录数`n=24`，内存工作区容量`l=3`（最多存 3 个记录）：
传统方法的初始归并段数量`r=24/3=8`，即需构造 8 个长度为 3 的初始归并段。

## 2. 置换 - 选择排序（突破内存限制的初始归并段构造算法）

### 2.1 定义

置换 - 选择排序是外部排序中构造初始归并段的优化算法，核心是通过 “**选择最小记录输出 + 置换新记录 + 判断能否加入当前归并段**” 的循环，使初始归并段长度突破内存工作区容量`l`，减少归并段数量`r`。

### 2.2 前提假设

- 待排序总记录数`n=24`（无具体值，按步骤逻辑推导记录序列）；
- 内存工作区容量`l=3`（最多容纳 3 个记录）；
- 目标：构造**递增有序**的初始归并段；
- 关键变量`minimax`：记录当前归并段中 “最后输出的记录关键字”，用于判断新记录能否加入当前归并段（新记录关键字 > `minimax`则可加入，否则暂存内存，标为 “红色记录”，待下一个归并段）。

### 2.3 详细步骤

#### 2.3.1 核心规则

1. 每次从内存工作区中选择**关键字最小**的记录；
2. 若该记录关键字 > `minimax`：输出到当前归并段，更新`minimax`，并从待排序文件读入新记录置换空位；
3. 若该记录关键字≤`minimax`：标为 “红色记录”（无法加入当前归并段），跳过并选择次小记录；
4. 当内存工作区中**所有记录均为红色记录**时，当前归并段构造结束，开启新归并段（解冻红色记录，重置`minimax`）。

#### 2.3.2 步骤 1：构造第一个初始归并段（归并段 1）

1. **初始读入**：从待排序文件读入前 3 个记录到内存工作区，假设为`[4,6,7]`，`minimax`未初始化；
2. **第一次选择输出**：
	- 工作区最小关键字为`4`，输出到归并段 1（归并段 1：`[4]`）；
	- 设`minimax=4`（记录当前归并段最后输出的关键字）；
	- 读入下一个记录`9`，置换空位，工作区变为`[6,7,9]`；
3. **第二次选择输出**：
	- 工作区最小关键字为`6`，`6>4`（`minimax`），输出到归并段 1（归并段 1：`[4,6]`）；
	- 更新`minimax=6`；
	- 读入下一个记录`11`，置换空位，工作区变为`[7,9,11]`；
4. **第三次选择输出**：
	- 最小关键字`7>6`，输出（归并段 1：`[4,6,7]`），更新`minimax=7`；
	- 读入`13`，工作区变为`[9,11,13]`；
5. **第四次选择输出**：
	- 最小关键字`9>7`，输出（归并段 1：`[4,6,7,9]`），更新`minimax=9`；
	- 读入`10`，工作区变为`[11,13,10]`；
6. **第五次选择输出**：
	- 最小关键字`10>9`，输出（归并段 1：`[4,6,7,9,10]`），更新`minimax=10`；
	- 读入`14`，工作区变为`[11,13,14]`；
7. **后续循环**：
	- 输出`11`（`11>10`）→ 读入`16`；输出`13`（`13>11`）→ 读入`22`；输出`14`（`14>13`）→ 读入`2`；
	- 此时工作区为`[16,22,2]`，最小关键字`2≤14`（`minimax`），标`2`为红色；选择次小`16>14`，输出→ 更新`minimax=16`；读入`30`；
	- 输出`22>16`→ 更新`minimax=22`；读入`3`（`3≤22`，标红）；工作区变为`[30,2(红),3(红)]`；
	- 输出`30>22`→ 更新`minimax=30`；读入`17`（`17≤30`，标红）；
8. **归并段 1 结束**：工作区全为红色记录（`2,3,17`），归并段 1 长度为`10`（突破`l=3`）。

#### 2.3.3 步骤 2：构造第二个初始归并段（归并段 2）

1. **重置**：解冻工作区红色记录（`[2,3,17]`），重置`minimax`；
2. **第一次输出**：最小关键字`2`，输出（归并段 2：`[2]`），设`minimax=2`；读入`19`，工作区变为`[3,17,19]`；
3. **第二次输出**：`3>2`，输出（归并段 2：`[2,3]`），更新`minimax=3`；读入`20`，工作区变为`[17,19,20]`；
4. **后续循环**：
	- 输出`17>3`→ 读入`5`（`5≤17`，标红）；输出`19>17`→ 读入`36`；输出`20>19`→ 读入`12`（`12≤20`，标红）；
	- 工作区变为`[5(红),36,12(红)]`，输出`36>20`→ 更新`minimax=36`；读入`1`（`1≤36`，标红）；
5. **归并段 2 结束**：工作区全为红色记录（`5,12,1`），归并段 2 长度为`7`。

#### 2.3.4 步骤 3：构造第三个初始归并段（归并段 3）

1. **重置**：解冻工作区红色记录（`[5,12,1]`），重置`minimax`；
2. **循环输出**：
	- 输出`1`（最小）→ 设`minimax=1`；读入剩余记录（`24-10-7=7`个）；
	- 依次选择最小记录，判断是否 > `minimax`，输出并置换，直到所有记录处理完；
3. **归并段 3 结束**：长度为`7`，所有记录处理完毕。

#### 2.3.5 最终结果

视频示例中，置换 - 选择排序构造的初始归并段数量`r=3`（归并段 1：10 个记录，归并段 2：7 个，归并段 3：7 个），远少于传统方法的`r=8`。

### 2.4 归并段结束的唯一条件

内存工作区中**所有记录的关键字均≤当前`minimax`**（即全为红色记录），无法再向当前归并段添加记录，当前归并段结束，开启新归并段。

## 3. 缓冲区底层细节

无论是传统方法还是置换 - 选择排序，输入 / 输出均以 “**磁盘块**” 为单位（非单个记录），目的是减少磁盘 IO 次数：

- **输入缓冲区**：一次读入一整块数据到输入缓冲区，再从缓冲区逐个将记录送入内存工作区（避免频繁读磁盘）；
- **输出缓冲区**：输出的记录先存入输出缓冲区，当缓冲区满（凑齐一整块）时，再一次性写入外存（避免频繁写磁盘）。

## 4. 置换 - 选择排序的优势

1. **突破内存限制**：初始归并段长度可远大于内存工作区容量`l`；
2. **减少归并段数量**：视频示例中`r`从`8`降至`3`，显著降低`r`；
3. **提升外部排序效率**：`k`路归并趟数`s=⌈log_k r⌉`，`r`减小→`s`减少→磁盘 IO 次数减少→效率提升。

## 5. 代码说明

视频中未展示置换 - 选择排序的编程语言代码（或伪代码），以下为基于视频原理推导的**伪代码**（严格符合视频逻辑，无额外扩展）：

plaintext

```plaintext
// 置换-选择排序伪代码（构造初始归并段）
// 输入：待排序文件F（总记录数n），内存工作区容量l，k路归并目标
// 输出：初始归并段集合S

1. 初始化：
   - 输入缓冲区B_in（存磁盘块数据）；
   - 输出缓冲区B_out（存待写入外存的记录）；
   - 内存工作区W（容量l，存储当前处理的记录，含“红色标记”字段）；
   - 变量minimax（初始为-∞，记录当前归并段最后输出的关键字）；
   - 归并段计数器count=0；
   - 归并段集合S=空；

2. 首次填充内存工作区：
   - 从F读一整块数据到B_in；
   - 从B_in向W填充l个记录，W中所有记录“红色标记”=false；

3. 循环构造归并段：
   while F未读完 或 W中存在非红色记录：
      // 步骤1：选择当前归并段的输出记录（W中最小的非红色记录）
      selected = 从W中选择关键字最小且“红色标记”=false的记录；
      
      // 步骤2：判断能否加入当前归并段
      if selected.关键字 > minimax：
          // 能加入：输出到缓冲区，更新minimax
          将selected加入B_out；
          minimax = selected.关键字；
          
          // 步骤3：置换新记录（从输入缓冲区补充）
          if B_in中还有未送入W的记录：
              new_record = 从B_in取一个记录；
          else if F未读完：
              从F读一整块数据到B_in；
              new_record = 从B_in取一个记录；
          else：
              new_record = null； // F已读完，无新记录
          
          // 替换W中的selected位置
          if new_record != null：
              W中替换selected为new_record，new_record.红色标记=false；
          else：
              W中删除selected（空位不补充）；
          
          // 步骤4：输出缓冲区满则写入外存
          if B_out已满：
              将B_out写入外存，形成当前归并段的一部分；
              清空B_out；
      
      else：
          // 不能加入：标记为红色，跳过
          selected.红色标记 = true；
      
      // 步骤5：判断当前归并段是否结束（W全为红色或空）
      is_all_red = true；
      for each record in W：
          if record.红色标记 == false：
              is_all_red = false；
              break；
      if is_all_red 或 W为空：
          // 当前归并段结束
          count += 1；
          // 输出缓冲区剩余记录写入外存，形成完整归并段
          if B_out不为空：
              将B_out写入外存，作为第count个归并段；
              清空B_out；
          // 加入归并段集合
          S.add(第count个归并段)；
          // 重置状态，准备下一个归并段
          minimax = -∞；
          // 解冻红色记录（重置为非红色）
          for each record in W：
              record.红色标记 = false；

4. 返回初始归并段集合S；
```



# 最佳归并树知识点总结

## 1. 核心概念与基础关联

### 1.1 初始归并段

- 定义：通过**置换选择排序**构造的待归并数据段，其长度以 “磁盘块数” 为单位（视频示例：`r2=5`表示 r2 归并段占 5 个磁盘块）。
- 视频示例（二路归并场景）：初始归并段集合为 `{r1(2), r2(5), r3(1), r4(6), r5(2)}`，括号内数字为磁盘块数。

### 1.2 磁盘 IO 的计算规则

- 读写单位：磁盘以 “单个磁盘块” 为最小读写单元，读 1 个块记 1 次 “读操作”，写 1 个块记 1 次 “写操作”。
- 单次归并 IO 计算：
	对`m个归并段（长度分别为L₁, L₂, ..., Lₘ）`进行 k 路归并时：
	- 读次数 = L₁ + L₂ + ... + Lₘ（需将所有归并段数据读入内存）
	- 写次数 = L₁ + L₂ + ... + Lₘ（归并后生成新段，写入磁盘）
	- 单次归并总 IO = 2 × (L₁+L₂+...+Lₘ)
- 总 IO 次数：所有归并步骤的 IO 次数之和（即所有 “单次归并总 IO” 累加）。

### 1.3 归并树与带权路径长度（WPL）的核心关联

- 归并树定义：以初始归并段为**叶子节点**，每次归并生成的新段为**父节点**，形成的 k 叉树（二路归并对应二叉树，三路归并对应三叉树）。
- 带权路径长度（WPL）：所有叶子节点的 “权值（初始归并段长度）× 该节点到根节点的路径长度” 之和，公式为：
	`WPL = Σ(Li × Pi)`（Li 为第 i 个初始归并段长度，Pi 为该段到根的路径长度，即路径上的边数）。
- 视频核心结论：**总磁盘 IO 次数 = 2 × 归并树的 WPL**
	原因：WPL 等价于 “所有归并步骤的读次数之和”，而写次数之和与读次数之和相等，故总 IO 为 WPL 的 2 倍。

## 2. 二路归并的最佳归并树（本质：二叉哈夫曼树）

### 2.1 目标

通过构造 “WPL 最小的二叉树（哈夫曼树）”，实现二路归并过程中磁盘 IO 次数最少。

### 2.2 二叉哈夫曼树构造规则

1. 初始：将所有初始归并段的长度作为独立节点，构成森林。
2. 迭代：每次从森林中选择**权值最小的 2 个节点**，作为左右子节点构造新父节点（新节点权值 = 两子节点权值之和），将新节点加入森林，删除原两个节点。
3. 终止：森林中仅剩 1 个节点（根节点），树构造完成。

### 2.3 视频示例：二路归并最佳归并树构造与计算

#### 示例输入

初始归并段长度：`[2, 5, 1, 6, 2]`（对应 r1=2、r2=5、r3=1、r4=6、r5=2）

#### 构造步骤

1. 第一次选最小 2 节点：1（r3）、2（r1）→ 新节点 3，森林变为`[3, 5, 6, 2]`（剩余 2 为 r5）。
2. 第二次选最小 2 节点：2（r5）、3 → 新节点 5，森林变为`[5, 5, 6]`（剩余 5 为 r2）。
3. 第三次选最小 2 节点：5（r2）、5 → 新节点 10，森林变为`[10, 6]`（剩余 6 为 r4）。
4. 第四次选最小 2 节点：6（r4）、10 → 新节点 16（根节点），构造完成。

#### 归并树结构（视频图示）

plaintext

```plaintext
        16（根）
       /  \
     10    6（r4，P=1）
    /  \
   5    5
  /     \
5（r2，P=2） 2（r5，P=3）
         /
        3
       /  \
1（r3，P=4） 2（r1，P=4）
```

（注：P 为路径长度，实际 WPL 计算以 “每次归并的读次数之和” 为准，更简洁：3+5+10+16=34）

#### WPL 与 IO 计算

- WPL = 3（第一次归并读次数） + 5（第二次） + 10（第三次） + 16（第四次） = 34
- 总 IO 次数 = 2 × 34 = 68（读 34 次，写 34 次）

#### 对比非最佳方案

非最佳归并顺序：`r2(5)与r3(1)→6 → r4(6)与r5(2)→8 → 6与8→14 → r1(2)与14→16`

- WPL = 6 + 8 + 14 + 16 = 44
- 总 IO 次数 = 2×44 = 88（比最佳方案多 20 次 IO）

## 3. 多路归并的最佳归并树（k≥3，以三路为例）

### 3.1 核心规则

- 本质：构造**k 叉哈夫曼树**，每次选择**权值最小的 k 个节点**合并，生成新父节点（新节点权值 = k 个节点权值之和）。
- 关键问题：当初始归并段数量（n₀）无法构成 “严格 k 叉树” 时，需补充**长度为 0 的虚段**（虚段不实际占用磁盘，仅用于满足树结构）。

### 3.2 严格 k 叉树的判定条件

#### 推导依据（k 叉树性质）

1. 总结点数量：`n = n₀ + nₖ`（仅含度 0 节点：初始归并段 + 虚段；度 k 节点：合并生成的节点）。
2. 总分支数量：`k×nₖ = n - 1`（每个度 k 节点产生 k 个分支，总分支数 = 总结点 - 1，根节点无父分支）。

#### 联立推导

将`n = n₀ + nₖ`代入`k×nₖ = n - 1`，得：
`n₀ = (k-1)×nₖ + 1` → `nₖ = (n₀ - 1)/(k-1)`

- 若`(n₀ - 1) % (k-1) == 0`：nₖ为整数，无需补虚段。
- 若`(n₀ - 1) % (k-1) != 0`：需补虚段，补段数量`m = (k-1) - (n₀ - 1) % (k-1)`。

### 3.3 视频示例 1：三路归并（无虚段，n₀=9）

#### 示例输入

初始归并段长度：`[2, 3, 6, 9, 12, 17, 18, 24, 30]`（k=3，n₀=9）

#### 构造步骤

1. 选最小 3 节点：2、3、6 → 新节点 11，森林变为`[9, 12, 17, 18, 24, 30, 11]`。
2. 选最小 3 节点：9、11、12 → 新节点 32，森林变为`[17, 18, 24, 30, 32]`。
3. 选最小 3 节点：17、18、24 → 新节点 59，森林变为`[30, 32, 59]`。
4. 选最小 3 节点：30、32、59 → 新节点 121（根节点），构造完成。

#### WPL 与 IO 计算

- WPL = 2×3 + 3×3 + 6×3 + 9×2 + 12×2 + 17×2 + 18×2 + 24×2 + 30×1
	= 6+9+18+18+24+34+36+48+30 = 223
- 总 IO 次数 = 2×223 = 446

### 3.4 视频示例 2：三路归并（需补虚段，n₀=8）

#### 示例输入

初始归并段长度：`[2, 3, 6, 9, 12, 17, 18, 24]`（k=3，n₀=8）

#### 虚段数量计算

- 余数`u = (8-1) % (3-1) = 7%2 = 1`
- 补段数量`m = 2 - 1 = 1`（补 1 个长度为 0 的虚段）

#### 构造步骤（含虚段 ）

1. 补虚段后，归并段变为`[0, 2, 3, 6, 9, 12, 17, 18, 24]`（n₀=9）。
2. 选最小 3 节点：0、2、3 → 新节点 5，森林变为`[5, 6, 9, 12, 17, 18, 24]`。
3. 选最小 3 节点：5、6、9 → 新节点 20，森林变为`[12, 17, 18, 20, 24]`。
4. 选最小 3 节点：12、17、18 → 新节点 47，森林变为`[20, 24, 47]`。
5. 选最小 3 节点：20、24、47 → 新节点 91（根节点），构造完成。

#### WPL 与 IO 计算

- WPL = 0×3 + 2×3 + 3×3 + 6×2 + 9×2 + 12×2 + 17×2 + 18×2 + 24×1
	= 0+6+9+12+18+24+34+36+24 = 163
- 总 IO 次数 = 2×163 = 326（比不补虚段的 386 次 IO 减少 60 次）

## 4. 最佳归并树构造的代码实现

### 4.1 核心逻辑

1. 输入初始归并段列表和归并路数 k。
2. 计算需补充的虚段数量 m，将 m 个 0 加入初始列表。
3. 使用**最小堆（优先队列）** 每次提取 k 个最小元素，合并为新元素，累加 WPL（新元素值即本次归并的读次数）。
4. 输出 WPL 和总 IO 次数。

### 4.2 Python 代码（视频

python

```python
import heapq

def compute_best_merge_tree(merge_segments, k):
    """
    计算k路最佳归并树的WPL和总IO次数
    :param merge_segments: 初始归并段长度列表（整数）
    :param k: 归并路数（k≥2）
    :return: (WPL, 总IO次数, 补虚段数量)
    """
    if not merge_segments or k < 2:
        return (0, 0, 0)
    
    # 步骤1：计算需补充的虚段数量m
    n0 = len(merge_segments)
    remainder = (n0 - 1) % (k - 1)
    m = (k - 1) - remainder if remainder != 0 else 0
    
    # 步骤2：补充虚段并构建最小堆
    heap = merge_segments.copy()
    heap.extend([0] * m)  # 加入m个虚段（长度0）
    heapq.heapify(heap)  # 转换为最小堆
    
    # 步骤3：迭代合并k个最小元素，计算WPL
    wpl = 0
    while len(heap) > 1:
        current_sum = 0
        # 提取k个最小元素并求和
        for _ in range(k):
            if heap:
                current_sum += heapq.heappop(heap)
        # 累加WPL（current_sum为本次归并的读次数）
        wpl += current_sum
        # 将合并后的新段加入堆
        heapq.heappush(heap, current_sum)
    
    # 步骤4：计算总IO次数（2×WPL）
    total_io = 2 * wpl
    return (wpl, total_io, m)

# ------------------- 视频示例验证 -------------------
if __name__ == "__main__":
    # 示例1：二路归并（视频2.3节）
    print("=== 示例1：二路归并（k=2）===")
    seg1 = [2, 5, 1, 6, 2]  # r1(2), r2(5), r3(1), r4(6), r5(2)
    wpl1, io1, m1 = compute_best_merge_tree(seg1, k=2)
    print(f"初始归并段：{seg1}")
    print(f"补虚段数量：{m1}（预期0）")
    print(f"WPL：{wpl1}（预期34）")
    print(f"总IO次数：{io1}（预期68）\n")
    
    # 示例2：三路归并（无虚段，视频3.3节）
    print("=== 示例2：三路归并（无虚段，k=3）===")
    seg2 = [2, 3, 6, 9, 12, 17, 18, 24, 30]
    wpl2, io2, m2 = compute_best_merge_tree(seg2, k=3)
    print(f"初始归并段：{seg2}")
    print(f"补虚段数量：{m2}（预期0）")
    print(f"WPL：{wpl2}（预期223）")
    print(f"总IO次数：{io2}（预期446）\n")
    
    # 示例3：三路归并（需补虚段，视频3.4节）
    print("=== 示例3：三路归并（需补虚段，k=3）===")
    seg3 = [2, 3, 6, 9, 12, 17, 18, 24]
    wpl3, io3, m3 = compute_best_merge_tree(seg3, k=3)
    print(f"初始归并段：{seg3}")
    print(f"补虚段数量：{m3}（预期1）")
    print(f"WPL：{wpl3}（预期163）")
    print(f"总IO次数：{io3}（预期326）")
```

### 4.3 代码运行结果

plaintext

```plaintext
=== 示例1：二路归并（k=2）===
初始归并段：[2, 5, 1, 6, 2]
补虚段数量：0（预期0）
WPL：34（预期34）
总IO次数：68（预期68）

=== 示例2：三路归并（无虚段，k=3）===
初始归并段：[2, 3, 6, 9, 12, 17, 18, 24, 30]
补虚段数量：0（预期0）
WPL：223（预期223）
总IO次数：446（预期446）

=== 示例3：三路归并（需补虚段，k=3）===
初始归并段：[2, 3, 6, 9, 12, 17, 18, 24]
补虚段数量：1（预期1）
WPL：163（预期163）
总IO次数：326（预期326）
```

## 5. 视频核心结论

1. 最佳归并树的本质是**k 叉哈夫曼树**，核心目标是最小化 WPL，从而最小化磁盘 IO。
2. 磁盘 IO 与 WPL 的关系：**总 IO = 2×WPL**（读、写次数均等于 WPL）。
3. 多路归并（k≥3）需满足 “严格 k 叉树” 条件：若初始归并段数量 n₀不满足`(n₀-1) % (k-1) == 0`，需补充`m=(k-1)-(n₀-1)%(k-1)`个长度为 0 的虚段。
4. 高效构造工具：**最小堆**（优先队列），可快速提取每次需合并的 k 个最小归并段，降低时间复杂度。
