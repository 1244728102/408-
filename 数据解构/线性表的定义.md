# 线性表的定义和基本操作

## 1. 线性表的定义与核心特性

### 1.1 定义

线性表是**具有相同数据类型的 n 个数据元素的有限序列**，若用`L`表示线性表，可表示为 `L = (a₁, a₂, ..., aᵢ, ..., aₙ)`，其中`aᵢ`是线性表的第`i`个数据元素。

### 1.2 关键特性（定义中的 3 个核心要点）

1. **数据类型一致性**：所有数据元素的数据类型相同（如均为`int`、自定义`struct`等），因此各元素占用的存储空间大小一致，可帮助计算机快速定位元素。
2. **序列性（有序性）**：数据元素之间存在明确的先后次序，每个元素（除首尾外）的位置固定。
3. **有限性**：数据元素的数量`n`（表长）是有限的。例如 “所有整数的递增序列” 因元素数量无限，不属于线性表。

### 1.3 核心术语

| 术语     | 定义与说明                                                   |
| -------- | ------------------------------------------------------------ |
| 表长     | 线性表中数据元素的个数`n`，记为`length(L)`                   |
| 空表     | 表长`n=0`的线性表，即不包含任何数据元素的线性表              |
| 位序     | 数据元素在线性表中的 “第几个” 位置，**从 1 开始计数**（与数组下标从 0 开始形成区别，需特别注意） |
| 表头元素 | 线性表的第一个元素，即`a₁`                                   |
| 表尾元素 | 线性表的最后一个元素，即`aₙ`                                 |
| 直接前驱 | 除表头元素外，每个元素`aᵢ`（`i≥2`）前面的第一个元素`aᵢ₋₁`    |
| 直接后继 | 除表尾元素外，每个元素`aᵢ`（`i≤n-1`）后面的第一个元素`aᵢ₊₁`  |

### 1.4 名称由来

线性表的英文为 “Linear List”：

- “Linear” 对应 “线性”，指元素间逻辑关系是 “一条线” 的结构；
- “List” 对应 “表”，指元素以 “列表” 形式组织（如代办清单`To-Do List`），若元素包含多个数据项（如学生信息含学号、姓名），形式上更接近 “表格”。

## 2. 线性表的基本操作

### 2.1 核心操作及功能（抽象函数接口）

视频中定义的线性表基本操作均为抽象接口（未指定具体数据类型，仅描述功能和参数），参考严蔚敏版《数据结构》命名风格，具体如下：

| 操作名称     | 函数接口（抽象）        | 功能说明                                                     |
| ------------ | ----------------------- | ------------------------------------------------------------ |
| 初始化线性表 | `InitList(&L)`          | 为线性表`L`分配内存空间，初始化表长为 0，实现 “从无到有”     |
| 销毁线性表   | `DestroyList(&L)`       | 释放线性表`L`占用的内存空间，实现 “从有到无”                 |
| 插入元素     | `ListInsert(&L, i, e)`  | 在线性表`L`的第`i`个位置（位序）插入数据元素`e`，插入后表长 + 1 |
| 删除元素     | `ListDelete(&L, i, &e)` | 删除线性表`L`第`i`个位置的元素，将删除的元素值存入`e`，删除后表长 - 1 |
| 按值查找     | `LocateElem(L, e)`      | 在 linear 表`L`中查找与`e`值相等的元素，返回该元素的位序（若不存在返回 0） |
| 按位查找     | `GetElem(L, i, &e)`     | 获取线性表`L`第`i`个位置的元素，将元素值存入`e`              |
| 求表长       | `Length(L)`             | 返回线性表`L`的表长`n`                                       |
| 打印线性表   | `PrintList(L)`          | 依次打印线性表`L`中所有元素的值                              |
| 判空         | `Empty(L)`              | 若线性表`L`为空表（`n=0`）返回`true`，否则返回`false`        |

### 2.2 操作的关键说明

1. **操作的通用性**：所有数据结构的核心操作均可归纳为 “创建、销毁、增删改查”，线性表的操作也不例外：
	- “增” 对应`ListInsert`，“删” 对应`ListDelete`；
	- “查” 对应`LocateElem`（按值查）和`GetElem`（按位查）；
	- “改” 需先通过 “查” 找到目标元素，再修改其值（视频中未单独定义 “改” 操作，可根据需求自定义）。
2. **接口的抽象性**：函数接口中未指定参数的具体数据类型（如`e`可表示`int`、`struct`等），仅在实际编码实现时需明确类型。
3. **操作的可扩展性**：可根据实际需求自定义额外操作（如 “修改元素”`UpdateElem(&L, i, e)`），只要命名具有可读性（如`DestroyList`明确表示 “销毁表”，避免命名为`a`等无意义名称）。

## 3. 参数传递方式（值传递 vs 引用传递）

视频中重点强调：**若需将函数对参数的修改结果 “带回” 主调函数，需使用引用传递（C++ 特性）**，以下为视频中的完整代码示例及说明。

### 3.1 值传递（修改结果不带回）

#### 代码实现（C++）

cpp



```cpp
#include <iostream>
using namespace std;

// 值传递：形参是实参的复制品，修改形参不影响实参
void test(int x) {
    x = 1024;  // 修改形参x的值
    cout << "test函数内x的值：" << x << endl;  // 输出：1024
}

int main() {
    int x = 1;  // 定义实参x，初始值为1
    cout << "调用test前x的值：" << x << endl;  // 输出：1
    test(x);    // 传入实参x（值传递）
    cout << "调用test后x的值：" << x << endl;  // 输出：1（修改未带回）
    return 0;
}
```

#### 运行结果

plaintext

```plaintext
调用test前x的值：1
test函数内x的值：1024
调用test后x的值：1
```

#### 原理

- 主函数中`x`是实参，调用`test(x)`时，`test`的形参`x`是实参`x`的**复制品**（内存中为两份独立数据）；
- 函数内修改的是形参`x`，实参`x`的值不变，因此修改结果无法带回主函数。

### 3.2 引用传递（修改结果带回）

#### 代码实现（C++）

cpp

```cpp
#include <iostream>
using namespace std;

// 引用传递：形参是实参的别名，修改形参即修改实参
void test(int &x) {  // 形参前加&，表示引用类型
    x = 1024;        // 修改形参x（即修改实参x）
    cout << "test函数内x的值：" << x << endl;  // 输出：1024
}

int main() {
    int x = 1;  // 定义实参x，初始值为1
    cout << "调用test前x的值：" << x << endl;  // 输出：1
    test(x);    // 传入实参x（引用传递）
    cout << "调用test后x的值：" << x << endl;  // 输出：1024（修改已带回）
    return 0;
}
```

#### 运行结果

plaintext

```plaintext
调用test前x的值：1
test函数内x的值：1024
调用test后x的值：1024
```

#### 原理

- 形参`int &x`是实参`x`的**别名**，形参与实参指向同一块内存空间；
- 函数内修改形参`x`，本质是修改实参`x`的内存数据，因此修改结果可带回主函数。

### 3.3 引用传递的应用场景（线性表操作）

线性表的**初始化（InitList）、销毁（DestroyList）、插入（ListInsert）、删除（ListDelete）** 操作需修改线性表`L`本身（如改变表长、修改元素），因此函数参数中`L`需用引用类型（如`InitList(&L)`）；
而**按值查找（LocateElem）、按位查找（GetElem）、求表长（Length）、判空（Empty）** 仅读取`L`的数据，不修改`L`，因此`L`无需引用（如`Length(L)`）。



# 顺序表知识点总结

## 1. 顺序表的核心定义

### 1.1 顺序表与顺序存储的关系

- 顺序表：**用顺序存储方式实现的线性表**，是线性表的物理实现（对应线性表的逻辑结构）。
- 顺序存储的本质：**逻辑上相邻的数据元素，在物理内存中也存储在相邻的存储单元中**，通过物理位置的相邻性体现数据元素的逻辑关系。

## 2. 顺序存储的关键原理

### 2.1 地址计算规则

由于顺序表中所有数据元素的**数据类型相同**（即每个元素占用的内存空间大小相等），可通过起始地址计算任意元素的地址：

- 设：顺序表起始地址（第一个元素地址）为 `LOC(a₁)`，单个元素占用字节数为 `sizeof(ElementType)`，则第 `i` 个元素的地址为：
	`LOC(aᵢ) = LOC(a₁) + (i-1) × sizeof(ElementType)`
- 示例：若 `LOC(a₁)=0x100`，`sizeof(int)=4`（视频中默认 int 占 4 字节），则 `LOC(a₃)=0x100 + 2×4=0x108`。

### 2.2 `sizeof` 关键字的作用

- 功能：在 C 语言中用于**计算指定数据类型或变量占用的内存字节数**，无需手动记忆不同类型的字节大小。

- 用法示例：

	- 计算 int 类型大小：`sizeof(int)` → 结果为 4（常见系统）。

	- 计算自定义结构体大小：

		c

		```c
		// 视频中定义的Customer结构体
		typedef struct {
		    int numb;    // 4字节
		    int people;  // 4字节
		} Customer;
		sizeof(Customer); // 结果为8字节（两个int之和）
		```

## 3. 顺序表的两种实现方式

### 3.1 方式一：静态分配（基于静态数组）

#### 3.1.1 核心特点

- 用**静态数组**存储数据元素，数组长度（最大容量）由宏定义固定，**一旦声明无法修改**。
- 需额外记录顺序表的**当前长度（length）**（即已存储的元素个数），区别于数组的最大容量。

#### 3.1.2 完整代码实现

c

```c
#include <stdio.h>
// 1. 宏定义顺序表的最大容量（静态分配固定大小）
#define MAXSIZE 10

// 2. 定义顺序表结构体（Sq=Sequence，表名SqList）
typedef struct {
    int data[MAXSIZE];  // 静态数组：存储数据元素（此处以int为例）
    int length;         // 顺序表当前长度（已存元素个数）
} SqList;

// 3. 顺序表初始化函数（核心：初始化length，可选初始化数组）
void initList(SqList &L) {
    // 可选步骤：将数组元素置0（避免内存"脏数据"，但非必须）
    for (int i = 0; i < MAXSIZE; i++) {
        L.data[i] = 0;  // 给数组赋默认值
    }
    // 必须步骤：初始化当前长度为0（无元素存储）
    L.length = 0;
}

// 4. 主函数测试
int main() {
    // 声明一个顺序表
    SqList L;
    // 调用初始化函数
    initList(L);

    // 【关键说明】正确访问顺序表的方式：按当前长度length遍历，而非数组最大容量
    // 错误方式：for(int i=0; i<MAXSIZE; i++) → 可能访问到未使用的"脏数据"
    // 正确方式：
    for (int i = 0; i < L.length; i++) {
        printf("%d ", L.data[i]);  // 初始length=0，无输出
    }
    return 0;
}
```

#### 3.1.3 关键注意点

- 内存分配：声明`SqList L`时，系统会分配两部分内存：
	1. 数组`data`：`MAXSIZE × sizeof(int)` 字节（如 MAXSIZE=10 时为 40 字节）；
	2. 变量`length`：`sizeof(int)` 字节（4 字节）。
- 脏数据问题：若不初始化数组，数组元素会保留内存中之前的残留数据（脏数据），但按`length`访问时不会读取到（因`length`初始为 0，无元素可访问）。
- 局限性：数组容量固定，若元素存满无法扩容，只能 "放弃治疗"（视频原话）；若初始容量设过大，会浪费内存。

### 3.2 方式二：动态分配（基于指针与`malloc/free`）

#### 3.2.1 核心特点

- 用**指针**指向动态申请的内存空间，容量可通过`malloc`（申请内存）和`free`（释放内存）动态调整。
- 结构体需额外记录**最大容量（maxSize）**（区别于当前长度 length），用于后续扩容判断。

#### 3.2.2 依赖工具：`malloc`与`free`函数

- 头文件：需包含 `<stdlib.h>`（视频强调必须包含）。
- `malloc` 功能：申请**连续的内存空间**，返回指向该空间起始地址的指针（需强制转换为对应数据类型指针）。
	- 语法：`(ElementType*)malloc(申请空间总字节数)`
		示例：`(int*)malloc(10*sizeof(int))` → 申请能存 10 个 int 的连续空间。
- `free` 功能：释放`malloc`申请的内存空间，避免内存泄漏。
	- 语法：`free(指向待释放空间的指针)`
		示例：`free(p)` → 释放指针 p 指向的内存。

#### 3.2.3 完整代码实现（含初始化与扩容）

c

```c
#include <stdio.h>
#include <stdlib.h>  // 必须包含：malloc/free的头文件

// 1. 宏定义顺序表的初始容量
#define INIT_SIZE 10

// 2. 定义动态顺序表结构体
typedef struct {
    int *data;       // 指针：指向动态申请的内存空间（存储数据元素）
    int maxSize;     // 顺序表当前的最大容量
    int length;      // 顺序表当前的长度（已存元素个数）
} SqList;

// 3. 初始化函数：动态申请初始容量的内存
void initList(SqList &L) {
    // 步骤1：申请INIT_SIZE个int的连续空间，强制转换为int*类型
    L.data = (int*)malloc(INIT_SIZE * sizeof(int));
    // 步骤2：设置初始最大容量和当前长度
    L.maxSize = INIT_SIZE;
    L.length = 0;
}

// 4. 扩容函数：增加顺序表的容量（参数len：需增加的容量）
void increaseSize(SqList &L, int len) {
    // 步骤1：保存原内存地址（避免扩容后丢失原数据）
    int *p = L.data;
    // 步骤2：申请新内存空间（原容量+新增容量）
    L.data = (int*)malloc((L.maxSize + len) * sizeof(int));
    // 步骤3：将原数据复制到新内存空间
    for (int i = 0; i < L.length; i++) {
        L.data[i] = p[i];  // 逐个复制原元素
    }
    // 步骤4：更新最大容量
    L.maxSize += len;
    // 步骤5：释放原内存空间（避免内存泄漏）
    free(p);
}

// 5. 主函数测试
int main() {
    // 声明并初始化动态顺序表
    SqList L;
    initList(L);

    // 模拟：填满顺序表（假设存入10个元素，length=10，maxSize=10）
    for (int i = 0; i < L.maxSize; i++) {
        L.data[i] = i + 1;  // 存入1~10
        L.length++;
    }

    // 扩容：增加5个容量（maxSize变为15）
    increaseSize(L, 5);

    // 测试扩容后：新增空间可存入元素（11~15）
    for (int i = 10; i < L.maxSize; i++) {
        L.data[i] = i + 1;  // 存入11~15
        L.length++;
    }

    // 遍历输出所有元素（1~15）
    for (int i = 0; i < L.length; i++) {
        printf("%d ", L.data[i]);
    }

    // （可选）释放动态内存（避免程序结束后内存泄漏）
    free(L.data);
    L.data = NULL;  // 指针置空，避免野指针
    return 0;
}
```

#### 3.2.4 关键注意点

- 扩容逻辑：扩容时需先保存原地址（`p=L.data`），避免新地址覆盖后原数据丢失；复制原数据后必须释放原内存（`free(p)`）。
- `realloc` 说明：视频提到 C 语言有`realloc`函数可直接实现扩容，但存在 "意想不到的坑"（如内存不足时可能返回 NULL 导致数据丢失），建议手动用`malloc+free`实现，更易理解原理。
- 指针安全：`free`后的指针需置空（如`L.data=NULL`），避免成为 "野指针"（指向已释放的内存）。

## 4. 顺序表的核心特性

### 4.1 特性 1：随机访问（核心优势）

- 定义：可在**O (1) 时间复杂度**内访问任意第`i`个元素（通过地址计算公式直接定位）。
- 体现：代码中通过数组下标直接访问（如`L.data[i]`），系统底层自动计算元素地址。

### 4.2 特性 2：存储密度高

- 定义：存储密度 = 数据元素本身占用的内存 / 顺序表总占用内存。
- 优势：顺序表仅存储数据元素，无额外开销（如链式存储需存储指针），因此存储密度接近 1。

### 4.3 特性 3：拓展容量不方便

- 静态分配：完全无法拓展容量。
- 动态分配：虽可拓展，但需申请新空间、复制原数据（时间复杂度 O (n)），时间开销高。

### 4.4 特性 4：插入 / 删除操作不方便

- 核心问题：插入或删除元素时，需移动大量元素以维持物理相邻性（如在第`i`个位置插入，需移动`n-i+1`个元素）。
- 说明：视频提到该特性会在下一节（顺序表的插入删除）通过代码详细演示。



# 顺序表的插入与删除（基于静态分配）

## 一、顺序表的插入操作

### 1.1 插入操作的核心逻辑

- 目标：往顺序表`L`的第`i`个**位序**（从 1 开始计数，视频明确区分 “位序” 与数组下标）插入元素`e`
- 核心特性：顺序表需保证 “逻辑相邻元素物理也相邻”，因此插入前需将第`i`位及之后的所有元素**从后往前依次后移 1 位**，腾出位置后再插入`e`
- 前提：基于**静态分配**的顺序表（预先定义最大存储容量，用数组实现，视频中示例最大容量为 10）

### 1.2 完整代码实现（含健壮性优化）

#### 1.2.1 顺序表结构定义（视频指定 int 类型元素）

cpp



```cpp
#include <iostream>
using namespace std;

// 静态分配的顺序表最大存储容量（视频示例值为10）
#define MAXSIZE 10

// 顺序表结构体定义
typedef struct {
    int data[MAXSIZE];  // 存储数据元素的数组（元素类型为int）
    int length;         // 记录顺序表当前实际元素个数（初始为0，即空表）
} SqList;
```

#### 1.2.2 插入函数实现（返回操作结果，保证健壮性）

cpp



```cpp
/**
 * 向顺序表L的第i个位置（位序）插入元素e
 * @param L 待操作的顺序表（需加引用&，否则修改的是副本）
 * @param i 插入位置（位序，合法范围：1 ≤ i ≤ L.length + 1）
 * @param e 待插入的元素（int类型）
 * @return bool 插入成功返回true，失败返回false
 */
bool ListInsert(SqList& L, int i, int e) {
    // 1. 健壮性判断1：插入位置i是否合法
    if (i < 1 || i > L.length + 1) {
        return false;  // 位置超出范围（如插入第9位但当前表长仅5，合法最大为6）
    }

    // 2. 健壮性判断2：顺序表是否已满（静态分配容量不可扩展）
    if (L.length >= MAXSIZE) {
        return false;  // 表满时无法插入新元素
    }

    // 3. 元素后移：从最后一个元素（下标L.length-1）开始，到第i位（下标i-1）结束
    // 循环条件：j从当前表长开始，大于等于i（位序转下标需-1，j >= i等价于下标j-1 >= i-1）
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];  // 每个元素往后移1位
    }

    // 4. 插入元素e：第i位（位序）对应数组下标为i-1
    L.data[i - 1] = e;

    // 5. 更新顺序表实际长度（元素个数+1）
    L.length++;

    // 6. 插入成功，返回true
    return true;
}
```

#### 1.2.3 函数调用示例（视频中的测试场景）

cpp



```cpp
int main() {
    SqList L;
    // 初始化顺序表（视频中初始状态：元素1、2、4、5、6，长度为5）
    L.length = 0;  // 初始为空表
    // 手动插入初始元素（模拟视频中的初始数据）
    ListInsert(L, 1, 1);  // 第1位插1
    ListInsert(L, 2, 2);  // 第2位插2
    ListInsert(L, 3, 4);  // 第3位插4
    ListInsert(L, 4, 5);  // 第4位插5
    ListInsert(L, 5, 6);  // 第5位插6

    // 测试：向第3个位置（位序）插入元素3
    int insertElem = 3;
    bool insertResult = ListInsert(L, 3, insertElem);
    if (insertResult) {
        cout << "插入成功！" << endl;
        cout << "插入后表长：" << L.length << endl;  // 预期输出6
        cout << "插入后元素序列：";  // 预期输出1 2 3 4 5 6
        for (int k = 0; k < L.length; k++) {
            cout << L.data[k] << " ";
        }
    } else {
        cout << "插入失败！（位置非法或表满）" << endl;
    }

    return 0;
}
```

### 1.3 插入操作的时间复杂度分析

#### 1.3.1 问题规模定义

以顺序表的**实际长度 n**（即`L.length`）作为问题规模。

#### 1.3.2 三种情况详细分析

| 情况     | 触发条件                    | 元素移动次数 | 时间复杂度 | 说明                                                         |
| -------- | --------------------------- | ------------ | ---------- | ------------------------------------------------------------ |
| 最好情况 | 插入到**表尾**（i = n+1）   | 0 次         | O(1)       | 无需移动任何元素，直接在数组末尾插入，仅需修改`length`，操作时间为常数级 |
| 最坏情况 | 插入到**表头**（i = 1）     | n 次         | O(n)       | 需将原有的 n 个元素全部后移 1 位，移动次数与表长成正比       |
| 平均情况 | 插入位置概率均等（1/(n+1)） | n/2 次       | O(n)       | 所有可能插入位置（共 n+1 个）的移动次数加权平均，结果为 n/2  |

- 平均移动次数计算过程：
	所有位置的移动次数总和 = n（插表头） + (n-1)（插第 2 位） + ... + 1（插第 n 位） + 0（插表尾） = `n(n+1)/2`
	平均移动次数 = 总和 × 概率（1/(n+1)） = `[n(n+1)/2] × [1/(n+1)] = n/2`

## 二、顺序表的删除操作

### 2.1 删除操作的核心逻辑

- 目标：删除顺序表`L`的第`i`个**位序**（从 1 开始）的元素，并通过引用参数`e`返回被删除的元素
- 核心特性：删除后需保持剩余元素物理相邻，因此需将第`i+1`位及之后的所有元素**从前往后依次前移 1 位**，覆盖被删除元素的位置
- 关键要求：删除的元素必须存在（即`i`在合法范围内），且需通过引用参数反馈被删除元素

### 2.2 完整代码实现（含引用参数说明）

#### 2.2.1 删除函数实现（含健壮性优化）

cpp



```cpp
/**
 * 删除顺序表L的第i个位置（位序）的元素，并用e返回该元素
 * @param L 待操作的顺序表（加&，确保修改原表）
 * @param i 删除位置（位序，合法范围：1 ≤ i ≤ L.length）
 * @param e 接收被删除元素的变量（加&，确保主函数能获取结果）
 * @return bool 删除成功返回true，失败返回false
 */
bool ListDelete(SqList& L, int i, int& e) {
    // 1. 健壮性判断：删除位置i是否合法（需存在该元素）
    if (i < 1 || i > L.length) {
        return false;  // 位置非法（如删除第6位但当前表长仅5）
    }

    // 2. 保存被删除元素：第i位（位序）对应数组下标i-1
    e = L.data[i - 1];

    // 3. 元素前移：从第i+1位（下标i）开始，到最后一个元素（下标L.length-1）结束
    for (int j = i; j < L.length; j++) {
        L.data[j - 1] = L.data[j];  // 每个元素往前移1位
    }

    // 4. 更新顺序表实际长度（元素个数-1）
    L.length--;

    // 5. 删除成功，返回true
    return true;
}
```

#### 2.2.2 函数调用示例（视频中的测试场景）

cpp



```cpp
int main() {
    SqList L;
    // 初始化顺序表（模拟视频中删除前的状态：元素1、2、3、4、5、6，长度为6）
    L.length = 0;
    ListInsert(L, 1, 1);
    ListInsert(L, 2, 2);
    ListInsert(L, 3, 3);
    ListInsert(L, 4, 4);
    ListInsert(L, 5, 5);
    ListInsert(L, 6, 6);

    // 测试：删除第3个位置（位序）的元素
    int deletedElem;  // 用于接收被删除的元素
    bool deleteResult = ListDelete(L, 3, deletedElem);
    if (deleteResult) {
        cout << "删除成功！" << endl;
        cout << "被删除的元素：" << deletedElem << endl;  // 预期输出3
        cout << "删除后表长：" << L.length << endl;        // 预期输出5
        cout << "删除后元素序列：";  // 预期输出1 2 4 5 6
        for (int k = 0; k < L.length; k++) {
            cout << L.data[k] << " ";
        }
    } else {
        cout << "删除失败！（位置非法，无此元素）" << endl;
    }

    return 0;
}
```

### 2.3 关键知识点：引用参数（&）的必要性

视频重点强调**引用符号 & 不可省略**，否则函数操作的是参数的 “副本”，无法修改原数据：

1. 顺序表参数`SqList& L`：
	若不加`&`，函数内修改的是`L`的副本（如`L.length--`仅作用于副本），主函数中的原顺序表`L`的`data`和`length`不会变化。
2. 元素参数`int& e`：
	若不加`&`，函数内给`e`赋值（`e = L.data[i-1]`）仅作用于副本，主函数中的`deletedElem`仍为初始值（无法获取被删除元素）。

### 2.4 删除操作的时间复杂度分析

#### 2.4.1 问题规模定义

以顺序表的**实际长度 n**（`L.length`）作为问题规模。

#### 2.4.2 三种情况详细分析

| 情况     | 触发条件                  | 元素移动次数 | 时间复杂度 | 说明                                                         |
| -------- | ------------------------- | ------------ | ---------- | ------------------------------------------------------------ |
| 最好情况 | 删除**表尾**元素（i = n） | 0 次         | O(1)       | 无需移动任何元素，仅需修改`length`，操作时间为常数级         |
| 最坏情况 | 删除**表头**元素（i = 1） | n-1 次       | O(n)       | 需将原有的 n-1 个元素全部前移 1 位，移动次数与表长成正比     |
| 平均情况 | 删除位置概率均等（1/n）   | (n-1)/2 次   | O(n)       | 所有可能删除位置（共 n 个）的移动次数加权平均，结果为 (n-1)/2 |

- 平均移动次数计算过程：
	所有位置的移动次数总和 = (n-1)（删表头） + (n-2)（删第 2 位） + ... + 1（删第 n-1 位） + 0（删表尾） = `n(n-1)/2`
	平均移动次数 = 总和 × 概率（1/n） = `[n(n-1)/2] × [1/n] = (n-1)/2`

## 三、重点强调的通用注意事项

1. **位序与数组下标的转换**：
	顺序表的 “第 i 个位置” 是**位序（从 1 开始）**，对应数组的**下标（从 0 开始）**，需始终牢记`下标 = 位序 - 1`，避免因混淆导致越界或插入 / 删除位置错误（如插入第 3 位，实际应操作数组下标 2）。
2. **代码健壮性设计**：
	必须先判断参数合法性（插入 / 删除位置范围）和表状态（表满 / 表空），并通过返回值（`bool`）向调用者反馈操作结果，便于调用者调试（如判断 “插入失败是因为位置错还是表满”）。
3. **元素移动方向**：
	- 插入操作：元素后移需**从后往前**（若从前往后，会覆盖未移动的元素，如插入第 3 位时，先移第 3 位会覆盖第 4 位的原始值）；
	- 删除操作：元素前移需**从前往后**（若从后往前，会遗漏前面的元素，如删除第 3 位时，先移最后一位会导致第 4 位的值丢失）。
4. **团队开发易用性**：
	函数设计需考虑 “让调用者用得爽”，例如通过返回值反馈操作结果、通过引用返回关键数据（如被删除的元素），避免调用者因 “无反馈” 而无法判断操作状态。



# 顺序表的查找

## 一、按位查找

### 1.1 核心原理

按位查找是从顺序表 `L` 中获取**第 `i` 个元素**（位序从 1 开始），核心依赖顺序表的「随机存取特性」：

- 顺序表元素在内存中**连续存储**，且所有元素数据类型相同（占用字节数一致）；
- 已知顺序表起始地址（数组 / 指针首地址）和元素大小，可直接计算第 `i` 个元素的存储地址，无需遍历。
- 关键映射关系：**位序 `i` ↔ 数组下标 `i-1`**（数组下标从 0 开始）。

### 1.2 静态分配方式实现（数组存储）

#### 1.2.1 静态顺序表结构体定义

c

```c
#include <stdio.h>
#include <stdlib.h>  // 用于exit()函数

// 1. 定义数据元素类型（示例为int，可根据需求修改）
typedef int ElemType;
// 2. 定义静态分配的顺序表结构体
#define MaxSize 100  // 静态顺序表的最大容量（宏定义固定）
typedef struct {
    ElemType data[MaxSize];  // 存储数据元素的数组
    int length;              // 顺序表当前实际长度（元素个数）
} SqList;
```

#### 1.2.2 按位查找函数（静态分配）

c

```c
/**
 * 功能：从静态分配的顺序表L中查找第i个元素
 * 参数：L-待查找的顺序表，i-目标元素的位序（1<=i<=L.length）
 * 返回值：找到的第i个元素（ElemType类型）；若i不合法，终止程序
 */
ElemType GetElem_Static(SqList L, int i) {
    // 健壮性判断：检查位序i是否合法
    if (i < 1 || i > L.length) {
        printf("位序i不合法（需满足1<=i<=表长）\n");
        exit(1);  // 终止程序，避免非法访问
    }
    // 位序i对应数组下标i-1，直接返回该位置元素
    return L.data[i - 1];
}
```

### 1.3 动态分配方式实现（指针存储）

#### 1.3.1 动态顺序表结构体定义

动态分配通过`malloc`申请连续内存，`data`为指向内存起始地址的指针，支持容量扩展（视频未提扩展，仅讲查找）：

c

```c
#include <stdio.h>
#include <stdlib.h>  // 用于malloc()、free()、exit()

typedef int ElemType;
// 定义动态分配的顺序表结构体
typedef struct {
    ElemType *data;  // 指针：指向申请的连续内存首地址
    int length;      // 当前实际长度
    int MaxSize;     // 当前最大容量（可扩展）
} SqList_Dynamic;
```

#### 1.3.2 动态顺序表初始化（辅助查找的前提）

c

```c
/**
 * 功能：初始化动态顺序表，分配初始容量
 * 参数：L-待初始化的动态顺序表指针，initSize-初始容量
 */
void InitList_Dynamic(SqList_Dynamic *L, int initSize) {
    // 用malloc申请initSize个ElemType大小的连续内存
    L->data = (ElemType *)malloc(initSize * sizeof(ElemType));
    // 健壮性判断：malloc申请失败（返回NULL）
    if (L->data == NULL) {
        printf("内存申请失败\n");
        exit(1);
    }
    L->length = 0;          // 初始长度为0（无元素）
    L->MaxSize = initSize;  // 初始最大容量为initSize
}
```

#### 1.3.3 按位查找函数（动态分配）

c

```c
/**
 * 功能：从动态分配的顺序表L中查找第i个元素
 * 参数：L-待查找的动态顺序表，i-目标元素的位序（1<=i<=L.length）
 * 返回值：找到的第i个元素（ElemType类型）；若i不合法，终止程序
 */
ElemType GetElem_Dynamic(SqList_Dynamic L, int i) {
    // 健壮性判断：检查位序i是否合法
    if (i < 1 || i > L.length) {
        printf("位序i不合法（需满足1<=i<=表长）\n");
        exit(1);
    }
    // 指针支持数组下标访问：L.data[i-1] 等价于 *(L.data + i-1)
    // 系统会自动根据ElemType字节数计算地址：起始地址 + (i-1)*sizeof(ElemType)
    return L.data[i - 1];
}
```

#### 1.3.4 指针数组下标访问的原理

- 假设`L.data`指向的起始地址为`2000`，`ElemType`为`int`（占 4 字节）：
	- `L.data[0]`：地址`2000 ~ 2003`（第 1 个元素）；
	- `L.data[1]`：地址`2004 ~ 2007`（第 2 个元素）；
	- 通用公式：第`i`个元素地址 = 起始地址 + (i-1)*sizeof (ElemType)。
- 若指针类型定义错误（如`int*`指向`double`数据），会导致地址计算错误，无法正确读取元素 → 因此`malloc`返回值需**强制转换为与 ElemType 匹配的指针类型**。

### 1.4 按位查找的时间复杂度分析

- **时间复杂度：O (1)**（常数阶）；
- 原因：仅需 1 次地址计算和 1 次元素读取，无循环、无递归，操作次数与顺序表长度`n`无关；
- 本质：顺序表「随机存取」特性的体现（直接定位元素地址，无需逐个遍历）。

## 二、按值查找

### 2.1 核心原理

按值查找是在顺序表 `L` 中查找**与目标值 `e` 相等的元素**，返回其位序（若存在），核心逻辑：

- 从第一个元素（下标 0）开始，逐个遍历顺序表；
- 对比当前元素与`e`，若相等则返回当前元素的位序（下标 + 1）；
- 遍历结束仍未找到，返回 0（表示不存在）。

### 2.2 基本数据类型的按值查找（int/char/double 等）

#### 2.2.1 函数实现（适配静态 / 动态顺序表，以静态为例）

c

```c
#include <stdio.h>
// 复用1.2.1中的静态顺序表结构体定义（SqList、ElemType=int、MaxSize）

/**
 * 功能：在静态顺序表L中查找值为e的元素
 * 参数：L-待查找的顺序表，e-目标值
 * 返回值：找到的元素的位序（1~L.length）；未找到返回0
 */
int LocateElem_Basic(SqList L, ElemType e) {
    // 遍历顺序表：i从0到L.length-1（覆盖所有元素）
    for (int i = 0; i < L.length; i++) {
        // 基本数据类型可直接用"=="比较
        if (L.data[i] == e) {
            return i + 1;  // 位序 = 下标 + 1
        }
    }
    // 遍历结束未找到
    return 0;
}
```

#### 2.2.2 示例演示（视频案例）

假设静态顺序表 `L` 已初始化，元素为 `[3, 5, 9, 12, 15, 18]`（`length=6`），查找 `e=9`：

1. `i=0`：`L.data[0]=3 ≠9` → `i++`；
2. `i=1`：`L.data[1]=5 ≠9` → `i++`；
3. `i=2`：`L.data[2]=9 ==9` → 返回 `2+1=3`（位序 3）。

### 2.3 结构体类型的按值查找（复杂数据类型）

#### 2.3.1 核心注意点（视频重点）

- **C 语言中结构体不能直接用 "==" 比较**：编译器会报错，需逐个比较结构体的「成员变量」；
- **C++ 可重载 "==" 运算符**（视频未展开，跨考同学了解即可）；
- **考研初试提示**：
	- 若科目为「数据结构」：可直接用 "=="（考察算法逻辑，不严格要求语法）；
	- 若科目为「C 语言程序设计」：需严格按成员比较（关注语法正确性，建议参考历年真题）。

#### 2.3.2 结构体类型的查找函数实现

c

```c
#include <stdio.h>
#include <stdlib.h>

// 1. 定义结构体类型（示例：客户信息）
typedef struct {
    int id;     // 客户ID
    int score;  // 客户分数
} Customer;
// 2. 定义静态顺序表（数据元素为Customer）
#define MaxSize 100
typedef struct {
    Customer data[MaxSize];  // 存储结构体元素的数组
    int length;              // 当前长度
} SqList_Struct;

/**
 * 功能：在结构体类型的顺序表中查找目标客户e
 * 参数：L-待查找的顺序表，e-目标客户（含id和score）
 * 返回值：找到的客户的位序（1~L.length）；未找到返回0
 */
int LocateElem_Struct(SqList_Struct L, Customer e) {
    for (int i = 0; i < L.length; i++) {
        // 逐个比较结构体成员（id和score均相等才认为是同一客户）
        if (L.data[i].id == e.id && L.data[i].score == e.score) {
            return i + 1;  // 返回位序
        }
    }
    return 0;  // 未找到
}
```

### 2.4 按值查找的时间复杂度分析

时间复杂度需考虑「目标元素的位置概率」，假设目标元素在每个位置的概率均为 `1/n`（`n`为表长）：

#### 2.4.1 最好情况

- 目标元素为**第一个元素**（下标 0）：仅需 1 次比较 → 时间复杂度 `O(1)`。

#### 2.4.2 最坏情况

- 目标元素为**最后一个元素**（下标 n-1）：需 n 次比较；
- 目标元素**不存在**：需遍历所有 n 个元素 → 时间复杂度 `O(n)`。

#### 2.4.3 平均情况

- 平均比较次数 = 所有位置比较次数的加权和：
	`(1*(1/n) + 2*(1/n) + ... + n*(1/n)) = (n(n+1)/2)/n = (n+1)/2`；
- 忽略常数项和低次项 → 时间复杂度 `O(n)`。

## 三、关键总结

1. **位序与下标映射**：顺序表位序从 1 开始，数组下标从 0 开始 → 位序`i`对应下标`i-1`（跨考重点）；
2. **静态 vs 动态分配**：查找逻辑一致，区别仅在数据存储方式（数组 vs 指针），指针可通过数组下标访问；
3. **查找效率差异**：按位查找 O (1)（随机存取），按值查找 O (n)（顺序遍历）；
4. **结构体比较**：C 语言需逐个成员比较，考研根据科目要求决定是否简化。



# 2.3.1 单链表的定义

## 1. 单链表的核心概念

### 1.1 单链表与线性表、顺序表的关系

- 线性表是**逻辑结构**（数据元素呈线性关系），需通过**存储结构**（顺序存储 / 链式存储）实现；
- 顺序表：用 “顺序存储” 实现的线性表（物理地址连续）；
- 链表：用 “链式存储” 实现的线性表（物理地址离散），单链表是链表的分支之一；
- 链表分类：单链表、双链表、循环链表、静态链表（本小节聚焦单链表）。

### 1.2 单链表的节点构成

单链表由若干 “节点” 串联而成，每个节点必须包含两部分：

1. **数据域**：存储数据元素（视频中用`data`表示，类型为`ElemType`，可自定义为`int`/`char`等）；
2. **指针域**：存储下一个节点的内存地址（视频中用`next`表示，类型为`struct Node*`，仅指向后继节点，故称为 “单” 链表）。

### 1.3 单链表与顺序表的核心对比

| 特性     | 顺序表                       | 单链表                   |
| -------- | ---------------------------- | ------------------------ |
| 物理存储 | 连续内存空间                 | 离散内存空间             |
| 存取方式 | 随机存取（下标直接访问）     | 顺序存取（需从表头遍历） |
| 容量扩容 | 不方便（需申请大片连续空间） | 方便（按需申请离散节点） |
| 存储密度 | 高（无额外指针开销）         | 低（含指针域开销）       |

## 2. 单链表的节点结构定义（C 语言）

### 2.1 基础定义（未用`typedef`，需带`struct`关键字）

视频中先演示原始结构体定义，每次使用节点类型需加`struct Node`，代码较繁琐：

c

```c
// 定义单链表节点结构体（未简化）
struct Node {
    ElemType data;          // 数据域：存储数据元素
    struct Node *next;      // 指针域：指向后续节点的地址
};

// 申请新节点的示例（视频提及`malloc`函数）
struct Node *p;  // 定义指向节点的指针p
// 申请1个Node大小的内存空间，强制转换为struct Node*类型，地址赋给p
p = (struct Node *)malloc(sizeof(struct Node));
// 后续可通过`p->data`赋值数据，`p->next`连接其他节点
```

## 3. `typedef`关键字的用法（简化节点定义）

视频强调`typedef`的核心作用是 “重命名数据类型”，简化代码书写，尤其针对`struct`这类长类型名。

### 3.1 `typedef`基本用法（视频示例）

c

```c
// 示例1：将int重命名为“整数”（自定义中文别名，视频演示用）
typedef int 整数;
// 示例2：将int*重命名为“整数指针”
typedef int *整数指针;

// 原定义 vs 简化定义对比
int a;                // 原定义：int类型变量a
整数 a;               // 简化定义：与上等价
int *ptr;             // 原定义：int型指针ptr
整数指针 ptr;         // 简化定义：与上等价
```

### 3.2 单链表节点的`typedef`简化（视频核心代码）

视频提供两种等价简化方式，且强调`LNode`与`LinkList`的 “含义差异”：

#### 方式 1：先定义`struct`，再单独`typedef`

c

```c
// 步骤1：定义原始结构体
struct Node {
    ElemType data;
    struct Node *next;
};
// 步骤2：重命名
typedef struct Node LNode;    // 将struct Node重命名为LNode（表示“单个节点”）
typedef LNode *LinkList;      // 将LNode*重命名为LinkList（表示“链表头指针”）
```

#### 方式 2：定义`struct`时直接`typedef`（教材简洁写法）

c

```c
// 一步完成：定义结构体+重命名，与方式1完全等价
typedef struct Node {
    ElemType data;
    struct Node *next;
} LNode, *LinkList;  // LNode=struct Node，LinkList=LNode*
```

#### 关键含义差异（视频重点强调）

- `LNode *p`：强调`p`是 “指向单个节点” 的指针（如函数返回某一具体节点时用此类型）；
- `LinkList L`：强调`L`是 “指向整个链表” 的头指针（如函数参数表示 “操作某一链表” 时用此类型）。

#### 示例：`GetElem`函数类型用法（视频提及）

c

```c
// 功能：从链表L中获取第i个节点，返回该节点的指针
LNode *GetElem(LinkList L, int i) {  
    // 参数L：表示操作的“链表”（用LinkList）
    // 返回值：表示找到的“单个节点”（用LNode*）
    // 函数体（本小节未展开实现，仅演示类型逻辑）
}
```

## 4. 单链表的两种实现方式（初始化 + 空表判断）

视频明确单链表分为 “不带头节点” 和 “带头节点” 两种实现，核心差异在于是否存在 “空的头节点”（不存数据，仅简化操作）。

### 4.1 方式 1：不带头节点的单链表

#### 4.1.1 初始化函数（视频核心代码）

- 核心逻辑：空表状态下，头指针直接指向`NULL`（无任何节点）；
- 传引用原因：视频强调 “若不传引用（`&`），函数内修改的是头指针的复制品，无法真正初始化链表”。

c

```c
// 初始化不带头节点的单链表（L为引用传递）
void InitList(LinkList &L) {
    L = NULL;  // 头指针L指向NULL，代表空表（无节点）
}
```

#### 4.1.2 空表判断函数（视频核心代码）

- 判断依据：头指针`L`是否等于`NULL`（无任何节点即为空）。

c

```c
// 判断不带头节点的单链表是否为空
bool ListEmpty(LinkList L) {
    return L == NULL;  // 简化写法：条件结果直接返回（true=空，false=非空）
}
```

### 4.2 方式 2：带头节点的单链表

#### 4.2.1 初始化函数（视频核心代码）

- 核心逻辑：先申请一个 “空的头节点”（不存数据），头指针指向头节点，头节点的`next`指向`NULL`；
- 头节点作用：视频提及 “后续插入、删除首节点时无需特殊处理，简化代码逻辑”。

c

```c
// 初始化带头节点的单链表（L为引用传递）
void InitList(LinkList &L) {
    // 1. 申请头节点的内存空间（用malloc）
    L = (LinkList)malloc(sizeof(LNode));  // L指向新申请的头节点
    // 2. 头节点的指针域设为NULL（表示无后续数据节点，空表）
    L->next = NULL;
    // 注意：头节点的数据域（L->data）不存储实际数据（视频明确说明）
}
```

#### 4.2.2 空表判断函数（视频核心代码）

- 判断依据：头节点的`next`是否等于`NULL`（虽有头节点，但无数据节点即为空）。

c

```c
// 判断带头节点的单链表是否为空
bool ListEmpty(LinkList L) {
    return L->next == NULL;  // 头节点的next为NULL，代表空表
}
```

## 5. 两种实现方式的核心区别

| 对比维度       | 不带头节点的单链表                            | 带头节点的单链表                    |
| -------------- | --------------------------------------------- | ----------------------------------- |
| 头指针指向内容 | 非空时指向 “第一个数据节点”；空表时指向`NULL` | 始终指向 “头节点”（非空，不存数据） |
| 空表判断条件   | `L == NULL`                                   | `L->next == NULL`                   |
| 代码复杂度     | 较高（插入 / 删除首节点需特殊处理）           | 较低（所有节点操作逻辑统一）        |
| 实际使用场景   | 较少                                          | 大多数情况（视频推荐优先使用）      |
| 节点构成       | 所有节点均为 “数据节点”                       | 含 1 个 “头节点”+ 若干 “数据节点”   |



# 单链表的插入与删除操作

## 一、单链表按位序插入

按位序插入指 “在第`i`个位置插入元素`e`”，位序从`1`开始（即第一个数据节点为第`1`位），核心逻辑是 “找到第`i-1`个节点，修改指针连接新节点”，分**带头节点**和**不带头节点**两种场景。

### 1.1 带头节点的单链表按位序插入

#### 核心原理

- 头节点视为 “第`0`个节点”，无需特殊处理 “插入到第`1`位” 的场景，操作统一。
- 步骤：
	1. 合法性判断：若`i < 1`，插入位置非法，返回失败。
	2. 找到第`i-1`个节点：用指针`p`指向头节点，变量`j`标记`p`当前指向的节点序号（初始`j=0`），遍历至`j == i-1`。
	3. 申请新节点：用`malloc`分配内存，存入元素`e`。
	4. 修改指针：**先连后，再连前**（避免断链）：
		- 新节点`s`的`next`指向`p`的`next`（`s->next = p->next`）；
		- `p`的`next`指向新节点`s`（`p->next = s`）。

#### 关键场景示例

| 插入位置`i`   | 处理逻辑                                                     |
| ------------- | ------------------------------------------------------------ |
| `i=1`（表头） | `p`初始指向头节点（`j=0`），无需遍历，直接执行指针修改，时间复杂度`O(1)`。 |
| `i=3`（中间） | 遍历 2 次，`p`指向第 2 个节点，执行指针修改，时间复杂度`O(n)`。 |
| `i=5`（表尾） | 遍历至最后一个节点（第 4 个），`s->next`指向`NULL`，时间复杂度`O(n)`（最坏）。 |
| `i=6`（非法） | 遍历后`p`指向`NULL`，插入位置超过表长，返回失败。            |

#### 完整代码

c

```c
#include <stdlib.h>
// 单链表节点定义
typedef struct Node {
    int data;          // 数据域
    struct LNode *next;// 指针域
} LNode, *LinkList;

// 带头节点单链表按位序插入：L为头指针，i为位序，e为待插入元素，成功返回true，失败返回false
bool ListInsert(LinkList L, int i, int e) {
    if (i < 1) {       // 位序非法
        return false;
    }
    LNode *p = L;      // p指向头节点（第0个节点）
    int j = 0;         // j标记p当前指向的节点序号
    // 找到第i-1个节点
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (p == NULL) {   // 第i-1个节点不存在（i超过表长）
        return false;
    }
    // 申请新节点
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if (s == NULL) {   // 内存分配失败（视频提及特殊情况）
        return false;
    }
    s->data = e;       // 存入元素e
    // 修改指针（顺序不可颠倒）
    s->next = p->next;
    p->next = s;
    return true;
}
```

#### 时间复杂度

- 最好情况：`O(1)`（插入到表头，无需遍历）；
- 最坏情况：`O(n)`（插入到表尾，需遍历全部节点）；
- 平均情况：`O(n)`。

### 1.2 不带头节点的单链表按位序插入

#### 核心原理

- 无 “第 0 个节点”，插入到第`1`位时需**修改头指针**，需特殊处理；
- 步骤：
	1. 若`i=1`（表头插入）：
		- 申请新节点`s`，存入`e`；
		- `s->next`指向原头指针`L`；
		- 头指针`L`更新为`s`（需传`LinkList *`，即指针的指针）。
	2. 若`i>1`（中间 / 表尾）：
		- 逻辑与带头节点类似，但`p`初始指向第一个节点（`j=1`），遍历至第`i-1`个节点。

#### 关键问题

- 需修改头指针，因此函数参数中`L`的类型为`LinkList *`（而非`LinkList`）；
- 代码逻辑不统一，比带头节点更繁琐，视频推荐优先使用带头节点。

#### 完整代码

c

```c
// 不带头节点单链表按位序插入：L为头指针的指针（需修改头指针），i为位序，e为待插入元素
bool ListInsert_NoHead(LinkList *L, int i, int e) {
    if (i < 1) {
        return false;
    }
    // 特殊处理：插入到第1位（表头）
    if (i == 1) {
        LNode *s = (LNode *)malloc(sizeof(LNode));
        if (s == NULL) {
            return false;
        }
        s->data = e;
        s->next = *L;   // 新节点指向原头节点
        *L = s;         // 更新头指针
        return true;
    }
    // 处理i>1的情况：找到第i-1个节点
    LNode *p = *L;      // p指向第一个节点（第1个节点）
    int j = 1;          // j标记p当前指向的节点序号
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (p == NULL) {
        return false;
    }
    // 申请新节点并修改指针
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if (s == NULL) {
        return false;
    }
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
```

#### 时间复杂度

与带头节点一致：最好`O(1)`，最坏`O(n)`，平均`O(n)`。

## 二、单链表指定节点插入

给定一个节点`p`，在其**之后**或**之前**插入元素`e`，核心差异在于 “单链表只能向后遍历，无法直接找前驱”。

### 2.1 后插操作（在节点`p`之后插入`e`）

#### 核心原理

- 无需遍历，直接利用`p`的指针修改，时间复杂度`O(1)`；
- 步骤：
	1. 申请新节点`s`，存入`e`；
	2. 指针修改：`s->next = p->next` → `p->next = s`（与按位序插入一致）。

#### 完整代码

c

```c
// 后插操作：在节点p之后插入元素e，成功返回true，失败返回false
bool InsertNextNode(LNode *p, int e) {
    if (p == NULL) {   // p为NULL，无效节点
        return false;
    }
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if (s == NULL) {   // 内存分配失败
        return false;
    }
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
```

#### 时间复杂度

`O(1)`（无遍历，直接修改指针）。

### 2.2 前插操作（在节点`p`之前插入`e`）

#### 核心问题

单链表无法直接找到`p`的前驱节点，视频提供两种方案：

| 方案               | 原理                                                       | 时间复杂度 |
| ------------------ | ---------------------------------------------------------- | ---------- |
| 方案 1（遍历）     | 传头指针`L`，遍历找到`p`的前驱节点，执行后插操作。         | `O(n)`     |
| 方案 2（偷天换日） | 无需找前驱，通过 “数据交换” 实现逻辑前插，视频推荐此方案。 | `O(1)`     |

#### 方案 2（偷天换日）核心原理

1. 先在`p`之后插入新节点`s`（执行后插操作）；
2. 交换`p`和`s`的数据：
	- 临时保存`p`的数据（`temp = p->data`）；
	- `p`的数据更新为`e`（待插入元素）；
	- `s`的数据更新为`temp`（原`p`的数据）；
3. 逻辑上，`s`成为`p`的前驱节点（实际物理位置仍在`p`之后）。

#### 完整代码（方案 2）

c

```c
// 前插操作（偷天换日）：在节点p之前插入元素e，成功返回true，失败返回false
bool InsertPriorNode(LNode *p, int e) {
    if (p == NULL) {
        return false;
    }
    // 1. 申请新节点s，插入到p之后
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if (s == NULL) {
        return false;
    }
    s->next = p->next;
    p->next = s;
    // 2. 交换p和s的数据
    int temp = p->data;
    p->data = e;
    s->data = temp;
    return true;
}

// 王道书版本：直接传入新节点s，而非动态申请
bool InsertPriorNode_Wangdao(LNode *p, LNode *s) {
    if (p == NULL || s == NULL) {
        return false;
    }
    s->next = p->next;
    p->next = s;
    int temp = p->data;
    p->data = s->data;
    s->data = temp;
    return true;
}
```

#### 时间复杂度

`O(1)`（无遍历，仅指针修改和数据交换）。

## 三、单链表的删除操作

删除操作包括 “按位序删除” 和 “指定节点删除”，核心逻辑是 “找到前驱节点，修改指针，释放待删节点内存”。

### 3.1 带头节点的单链表按位序删除

#### 核心原理

- 目标：删除第`i`个节点，返回删除的元素`e`（需用引用`&e`）；
- 步骤：
	1. 合法性判断：`i < 1` → 失败；
	2. 找到第`i-1`个节点`p`（遍历逻辑与按位序插入一致）；
	3. 待删节点`q = p->next`，若`q == NULL` → 第`i`个节点不存在，失败；
	4. 保存删除元素：`e = q->data`；
	5. 修改指针：`p->next = q->next`（跳过`q`）；
	6. 释放内存：`free(q)`。

#### 完整代码

c

```c
// 带头节点单链表按位序删除：L为头指针，i为位序，e保存删除的元素，成功返回true
bool ListDelete(LinkList L, int i, int &e) {
    if (i < 1) {
        return false;
    }
    LNode *p = L;      // p指向头节点（第0个）
    int j = 0;
    // 找到第i-1个节点
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (p == NULL || p->next == NULL) {  // 第i-1个节点不存在，或第i个节点不存在
        return false;
    }
    LNode *q = p->next;  // q为待删节点
    e = q->data;         // 保存删除的元素
    p->next = q->next;   // 跳过待删节点
    free(q);             // 释放内存
    return true;
}
```

#### 时间复杂度

- 最好情况：`O(1)`（删除第 1 个节点，无需遍历）；
- 最坏情况：`O(n)`（删除最后一个节点，需遍历全部节点）；
- 平均情况：`O(n)`。

### 3.2 指定节点删除（删除节点`p`）

#### 核心问题

无法直接找到`p`的前驱节点，视频提供两种方案：

| 方案               | 原理                                                         | 注意事项                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 方案 1（遍历）     | 传头指针`L`，遍历找到`p`的前驱节点`pre`，执行`pre->next = p->next`，`free(p)`。 | 时间复杂度`O(n)`，无 bug，适用于所有场景（包括`p`为尾节点）。 |
| 方案 2（偷天换日） | 无需找前驱，将`p`的后继节点`q`的数据复制到`p`，再删除`q`（逻辑上删除`p`）。 | 时间复杂度`O(1)`，但**bug**：若`p`为尾节点，`q = p->next`为`NULL`，无法复制数据。 |

#### 方案 2（偷天换日）完整代码

c

```c
// 指定节点删除（偷天换日）：删除节点p，成功返回true，失败返回false
bool DeleteNode(LNode *p) {
    if (p == NULL) {
        return false;
    }
    LNode *q = p->next;  // q为p的后继节点
    //  bug场景：p为尾节点时，q == NULL，以下代码会崩溃
    if (q == NULL) {
        free(p);         // 仅释放p，但无法修改前驱指针，链表会残留空指针（需方案1解决）
        return false;
    }
    // 复制q的数据到p
    p->data = q->data;
    // 修改指针，删除q
    p->next = q->next;
    free(q);
    return true;
}

// 方案1（遍历找前驱）：L为头指针，删除节点p，成功返回true
bool DeleteNode_ByTraverse(LinkList L, LNode *p) {
    if (L == NULL || p == NULL) {
        return false;
    }
    LNode *pre = L;  // pre为前驱节点，初始指向头节点
    // 遍历找到p的前驱节点
    while (pre->next != NULL && pre->next != p) {
        pre = pre->next;
    }
    if (pre->next == NULL) {  // p不在链表中
        return false;
    }
    // 修改指针，删除p
    pre->next = p->next;
    free(p);
    return true;
}
```

## 四、核心总结

1. **头节点的作用**：统一插入 / 删除的逻辑（无需特殊处理表头），推荐优先使用带头节点的单链表。
2. **指针修改顺序**：插入 / 删除时，需先处理 “后续节点” 的指针，再处理 “前驱节点” 的指针，避免链表断链（如`s->next = p->next`必须在`p->next = s`之前）。
3. **时间复杂度关键**：涉及 “找第`i-1`个节点” 或 “找前驱节点” 的操作，时间复杂度为`O(n)`；无需遍历的操作（后插、前插偷天换日），时间复杂度为`O(1)`。
4. **边界场景**：需处理 “位序非法”“节点为`NULL`”“尾节点操作” 等场景，避免崩溃或逻辑错误。



# 单链表查找及表长计算知识点总结（基于带头节点单链表）

## 一、前提说明

本总结所有操作均基于**带头节点的单链表**（头节点视为第 0 个节点），视频中明确要求需主动思考 “不带头节点单链表” 的实现差异；所有代码逻辑围绕单链表的核心操作展开，涉及的`ElemType`默认以`int`型为例（若为结构体类型需特殊处理比较逻辑）。

## 二、按位查找（GetElem）

### 1. 定义

从单链表`L`中找到第`i`个节点，并返回该节点的指针；若`i`不合法（`i<0`或`i>表长`），返回`NULL`。

### 2. 核心思路

1. 合法性判断：先检查`i`是否小于 0，若小于 0 直接返回`NULL`（非法索引）。
2. 初始化指针与计数器：`p`指向头节点（`L`），`j`（当前节点序号）初始化为 0。
3. 遍历查找：循环执行 “`p`后移、`j`自增”，直到`j == i`（找到第`i`个节点）或`p == NULL`（`i`超出表长）。
4. 返回结果：循环结束后返回`p`（`p`为`NULL`表示查找失败，否则为第`i`个节点的指针）。

### 3. 完整代码

#### （1）单链表节点结构体定义

c

```c
// 单链表节点结构体
typedef struct LNode {
    ElemType data;       // 数据域（默认int型）
    struct LNode *next;  // 指针域（指向后继节点）
} LNode, *LinkList;      // LNode：节点类型；LinkList：单链表头指针类型
```

#### （2）按位查找函数实现

c

```c
// 按位查找：查找单链表L中第i个节点，返回节点指针
LNode* GetElem(LinkList L, int i) {
    // 1. 合法性判断：i<0为非法索引
    if (i < 0) {
        return NULL;
    }
    // 2. 初始化：p指向头节点（第0个节点），j记录当前节点序号
    LNode *p = L;
    int j = 0;
    // 3. 遍历查找：j < i时继续后移，且p不为空（避免i超出表长）
    while (j < i && p != NULL) {
        p = p->next;  // p后移到下一个节点
        j++;          // 节点序号自增
    }
    // 4. 返回结果：p为第i个节点（j==i）或NULL（i超出表长）
    return p;
}
```

### 4. 边界情况分析

| 边界场景                    | 执行过程                                                     | 结果                   |
| --------------------------- | ------------------------------------------------------------ | ---------------------- |
| `i = 0`（查找头节点）       | `j=0`，循环条件`j<i`（0<0）不满足，直接返回`p`（指向头节点） | 返回头节点指针         |
| `i > 表长`（如表长 5，i=8） | `p`遍历至表尾（`p=NULL`），循环条件`p!=NULL`不满足，返回`p`（`NULL`） | 返回`NULL`（查找失败） |
| `i = 合法值`（如 i=3）      | `p`从头部开始后移 3 次，`j=3`时循环结束，返回`p`（指向第 3 个数据节点） | 返回第 i 个节点指针    |

### 5. 与王道书代码的差异

视频中明确对比了王道书的按位查找实现，核心差异在于 “初始指针位置” 和 “计数器初始值”，具体如下：

#### 王道书代码实现

c

```c
// 王道书按位查找：j初始为1，p初始指向第一个数据节点（L->next）
LNode* GetElem_WangDao(LinkList L, int i) {
    // 若i=0，直接返回头节点（特殊处理）
    if (i == 0) {
        return L;
    }
    // 合法性判断：i<1为非法（王道书逻辑中数据节点从1开始计数）
    if (i < 1) {
        return NULL;
    }
    // 初始化：p指向第一个数据节点，j初始为1
    LNode *p = L->next;
    int j = 1;
    // 遍历查找：j < i且p不为空
    while (j < i && p != NULL) {
        p = p->next;
        j++;
    }
    return p;
}
```

#### 差异总结

| 对比项           | 视频代码（本总结代码） | 王道书代码                     |
| ---------------- | ---------------------- | ------------------------------ |
| 数据节点计数起点 | 头节点 0，数据节点 1~n | 数据节点 1~n（头节点特殊处理） |
| `p`初始指向      | 头节点（`L`）          | 第一个数据节点（`L->next`）    |
| `j`初始值        | 0                      | 1                              |
| `i=0`的处理方式  | 自然满足（`j=0=i`）    | 单独判断返回头节点             |

### 6. 时间复杂度

- **平均时间复杂度**：`O(n)`。假设`i`在合法范围内（0~n）的概率均等，平均需遍历`n/2`个节点。
- **最坏时间复杂度**：`O(n)`。当`i`为表长（如第 n 个数据节点）时，需遍历全部 n 个节点。

### 7. 封装的应用价值

视频强调：按位查找可作为 “基础操作” 封装，供按位插入、按位删除调用，核心好处包括：

1. 避免重复代码：无需在插入 / 删除函数中重复编写 “找第 i-1 个节点” 的逻辑。
2. 易维护：若查找逻辑存在 bug，仅需修改`GetElem`函数，所有调用处均生效。
3. 增强健壮性：`GetElem`返回`NULL`时，调用者可直接判断 “节点不存在”，避免非法访问。

## 三、按值查找（LocateElem）

### 1. 定义

给定数据元素`e`，在单链表`L`中查找 “数据域等于`e`” 的第一个节点，并返回该节点的指针；若未找到，返回`NULL`。

### 2. 核心思路

1. 初始化指针：`p`指向第一个数据节点（`L->next`，跳过头节点）。
2. 遍历匹配：循环执行 “判断`p`的数据域是否等于`e`”，若不等于则`p`后移，直到`p == NULL`（遍历结束）或找到匹配节点。
3. 返回结果：找到则返回`p`，未找到返回`NULL`。

### 3. 完整代码

c

```c
// 按值查找：查找单链表L中数据域等于e的第一个节点，返回节点指针
LNode* LocateElem(LinkList L, ElemType e) {
    // 1. 初始化：p指向第一个数据节点（跳过头节点）
    LNode *p = L->next;
    // 2. 遍历匹配：p不为空且数据域不等于e时，继续后移
    while (p != NULL && p->data != e) {
        p = p->next;
    }
    // 3. 返回结果：p为匹配节点（找到）或NULL（未找到）
    return p;
}
```

### 4. 特殊情况处理

- **`ElemType`为结构体类型**：视频强调 “不能直接用`==`比较”，需自定义比较逻辑（如写一个`Compare`函数，逐一比较结构体的每个成员）。示例如下：

	c

	```c
	// 假设ElemType为学生结构体
	typedef struct {
	    int id;
	    char name[20];
	} Student;
	typedef struct LNode {
	    Student data;
	    struct LNode *next;
	} LNode, *LinkList;
	
	// 自定义比较函数：比较两个学生是否相等（按学号）
	int Compare(Student s1, Student s2) {
	    return s1.id == s2.id;  // 学号相等则认为两个学生相等
	}
	
	// 结构体类型的按值查找
	LNode* LocateElem_Struct(LinkList L, Student e) {
	    LNode *p = L->next;
	    while (p != NULL && !Compare(p->data, e)) {  // 调用自定义比较函数
	        p = p->next;
	    }
	    return p;
	}
	```

### 5. 边界情况分析

| 边界场景             | 执行过程                                               | 结果                   |
| -------------------- | ------------------------------------------------------ | ---------------------- |
| 链表中存在`e`        | `p`遍历到数据域等于`e`的节点，循环结束，返回该节点指针 | 返回匹配节点指针       |
| 链表中不存在`e`      | `p`遍历至表尾（`p=NULL`），循环结束，返回`NULL`        | 返回`NULL`（查找失败） |
| 链表为空（仅头节点） | `p`初始为`NULL`（`L->next=NULL`），直接返回`NULL`      | 返回`NULL`（查找失败） |

### 6. 时间复杂度

- **平均时间复杂度**：`O(n)`。假设元素`e`在链表中的概率均等，平均需遍历`n/2`个节点。
- **最坏时间复杂度**：`O(n)`。当`e`不存在或在表尾时，需遍历全部`n`个节点。

## 四、单链表求表长（ListLength）

### 1. 定义

统计单链表`L`中**数据节点的个数**（不包含头节点），返回节点总数。

### 2. 核心思路

1. 初始化指针与计数器：`p`指向第一个数据节点（`L->next`），`count`（节点总数）初始化为 0。
2. 遍历计数：循环执行 “`count`自增、`p`后移”，直到`p == NULL`（遍历结束）。
3. 返回结果：返回`count`（数据节点总数）。

### 3. 完整代码

c

```c
// 求单链表长度：返回数据节点的个数（不包含头节点）
int ListLength(LinkList L) {
    // 1. 初始化：p指向第一个数据节点，count初始为0
    LNode *p = L->next;
    int count = 0;
    // 2. 遍历计数：p不为空则计数+1，p后移
    while (p != NULL) {
        count++;
        p = p->next;
    }
    // 3. 返回数据节点总数
    return count;
}
```

### 4. 不带头节点的差异思考

视频要求主动思考 “不带头节点的表长计算”，核心差异在于 “`p`的初始指向”：

- 不带头节点的单链表：`p`初始指向头指针`L`（直接指向第一个数据节点），其他逻辑不变。代码如下：

	c

	```c
	// 不带头节点的单链表求表长
	int ListLength_NoHead(LinkList L) {
	    LNode *p = L;  // p初始指向第一个数据节点（无表头）
	    int count = 0;
	    while (p != NULL) {
	        count++;
	        p = p->next;
	    }
	    return count;
	}
	```

### 5. 时间复杂度

- **时间复杂度**：`O(n)`。无论是否带头节点，均需遍历全部数据节点，遍历次数等于数据节点个数`n`。

## 五、关键思想总结

1. **健壮性设计**：所有操作均需判断指针是否为`NULL`（如`i>表长`时`p=NULL`、链表为空时`p=NULL`），避免非法访问内存。
2. **封装思想**：将按位查找、按值查找等基础操作封装为独立函数，降低代码冗余，提升可维护性。
3. **单链表的局限性**：由于单链表不支持随机访问，所有查找（按位、按值）和表长计算均需遍历，时间复杂度均为`O(n)`（与顺序表的`O(1)`按位查找形成对比）。

# 链表的建立（带头结点）

## 一、核心前提

1. **目标**：将多个数据元素（视频中为整型）存入单链表，核心是 “从无到有创建链表 + 逐个插入元素”
2. **依赖基础操作**：
	- 单链表初始化：创建头节点（简化空表与非空表的操作逻辑）
	- 指定节点后插操作：将新节点插入到某一节点的后继位置
3. **链表类型**：**带头结点的单链表**（视频明确说明，区别于不带头结点的链表，避免空表判断冗余）

## 二、尾插法建立单链表

### 2.1 原理

1. **核心逻辑**：每次取一个数据元素，插入到单链表的**表尾**
2. **两种实现方式对比**：
	- 原始方式：依赖 “按位序插入” 操作，每次插入需从表头遍历到表尾，时间复杂度`O(n²)`（效率低，视频仅提及不推荐）
	- 优化方式：设置**表尾指针 r**（始终指向最后一个数据节点），直接对 r 执行后插，无需遍历，时间复杂度`O(n)`（视频重点讲解）

### 2.2 优化实现步骤

1. **初始化**：创建头节点，头节点的`next`指针需初始化为`NULL`（视频强调 “养成好习惯，避免脏数据”）
2. **指针定义**：
	- `L`：头指针（指向头节点，作为链表的入口）
	- `r`：表尾指针（初始指向头节点，后续始终指向最后一个数据节点）
	- `s`：临时指针（指向新创建的节点）
3. **数据输入**：循环读取输入数据（视频用`9999`作为终止符，输入`9999`表示停止插入）
4. **插入流程**：
	- 为新数据创建节点`s`，赋值`s->data`并将`s->next`设为`NULL`
	- 后插操作：`r->next = s`（将新节点连到表尾）
	- 更新表尾指针：`r = s`（让`r`指向新的表尾节点）
5. **终止处理**：循环结束后，设置`r->next = NULL`（确保链表尾节点指向空，形成合法链表）
6. **返回结果**：返回头指针`L`，即完成链表建立

### 2.3 完整代码（C 语言，视频对应实现）

c

```c
#include <stdio.h>
#include <stdlib.h>

// 定义单链表节点结构（视频隐含的基础结构）
typedef int ElemType;  // 视频中数据元素类型为整型
typedef struct LNode {
    ElemType data;      // 数据域：存储元素值
    struct LNode *next; // 指针域：指向后继节点
} LNode, *LinkList;     // LNode* 等价于 LinkList（头指针类型）

// 尾插法建立单链表：返回头指针，参数用指针的指针接收头节点地址
LinkList List_TailInsert(LinkList *L) {
    // 1. 初始化头节点（必须申请内存，避免野指针）
    *L = (LinkList)malloc(sizeof(LNode));
    if (*L == NULL) { // 检查内存分配是否成功
        printf("内存分配失败，无法创建头节点\n");
        exit(1); // 分配失败则退出程序
    }
    (*L)->next = NULL; // 头节点next初始化为NULL（关键：避免脏数据）
    LNode *r = *L;     // 表尾指针r初始指向头节点
    ElemType x;        // 存储输入的单个数据元素
    scanf("%d", &x);   // 读取第一个数据

    // 2. 循环插入数据（终止条件：输入9999）
    while (x != 9999) {
        // 2.1 创建新节点s
        LNode *s = (LNode *)malloc(sizeof(LNode));
        if (s == NULL) {
            printf("内存分配失败，无法创建新节点\n");
            exit(1);
        }
        s->data = x;    // 新节点数据域赋值
        s->next = NULL; // 新节点next初始化为NULL（确保链表尾部合法）

        // 2.2 后插操作：将s插入到表尾（r指向的节点后）
        r->next = s;
        // 2.3 更新表尾指针：r指向新的表尾节点s
        r = s;

        // 2.4 读取下一个数据
        scanf("%d", &x);
    }

    // 3. 确保链表最后一个节点的next为NULL（冗余但安全）
    r->next = NULL;

    // 4. 返回头指针（指向头节点，代表整个链表）
    return *L;
}
```

### 2.4 关键特性

- **时间复杂度**：`O(n)`（n 为数据元素个数，仅需遍历一次输入数据，无额外链表遍历）
- **元素顺序**：链表中元素顺序与**输入顺序完全一致**（例：输入 10→16→27→9999，链表为 [头节点]→10→16→27→NULL）
- **核心优化**：表尾指针`r`的引入，避免了每次插入时从表头到表尾的遍历，大幅提升效率

## 三、头插法建立单链表

### 3.1 原理

1. **核心逻辑**：每次取一个数据元素，插入到**头节点之后**（即链表的 “表头位置”，非头节点本身）
2. **本质**：对 “头节点” 执行**后插操作**（视频强调与尾插法的核心共性，均基于后插逻辑）
3. **关键特性**：链表中元素顺序与**输入顺序相反**（视频重点强调，可用于链表逆置）

### 3.2 实现步骤

1. **初始化**：创建头节点，**必须将头节点的`next`设为`NULL`**（视频警告：不初始化会导致`next`指向未知 “脏数据” 区域，引发错误）
2. **指针定义**：
	- `L`：头指针（指向头节点）
	- `s`：临时指针（指向新创建的节点）
3. **数据输入**：循环读取输入数据（终止符仍为`9999`）
4. **插入流程（核心）**：
	- 为新数据创建节点`s`，赋值`s->data`
	- 关键步骤 1：`s->next = L->next`（新节点先连接头节点原本的后继节点，避免链表断裂）
	- 关键步骤 2：`L->next = s`（头节点再连接新节点，完成插入）
5. **终止处理**：无需额外操作（插入逻辑已确保链表合法）
6. **返回结果**：返回头指针`L`

### 3.3 完整代码（C 语言，视频对应实现）

c

```c
#include <stdio.h>
#include <stdlib.h>

// 同尾插法，定义单链表节点结构
typedef int ElemType;
typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 头插法建立单链表：返回头指针
LinkList List_HeadInsert(LinkList *L) {
    // 1. 初始化头节点（必须设置next为NULL，避免野指针）
    *L = (LinkList)malloc(sizeof(LNode));
    if (*L == NULL) {
        printf("内存分配失败，无法创建头节点\n");
        exit(1);
    }
    (*L)->next = NULL; // 视频强调的关键步骤：避免脏数据
    ElemType x;        // 存储输入的单个数据元素
    scanf("%d", &x);   // 读取第一个数据

    // 2. 循环插入数据（终止条件：输入9999）
    while (x != 9999) {
        // 2.1 创建新节点s
        LNode *s = (LNode *)malloc(sizeof(LNode));
        if (s == NULL) {
            printf("内存分配失败，无法创建新节点\n");
            exit(1);
        }
        s->data = x; // 新节点数据域赋值

        // 2.2 核心插入逻辑：先连后、再连前（避免链表断裂）
        s->next = (*L)->next; // 新节点连接头节点的原后继
        (*L)->next = s;        // 头节点连接新节点，完成插入

        // 2.3 读取下一个数据
        scanf("%d", &x);
    }

    // 3. 返回头指针（代表整个链表）
    return *L;
}
```

### 3.4 关键特性与应用

- **时间复杂度**：`O(n)`（n 为数据元素个数，无需遍历链表，仅处理输入和指针操作）
- **元素顺序**：逆序特性（例：输入 10→16→27→9999，链表为 [头节点]→27→16→10→NULL）
- **典型应用**：**链表逆置**（视频重点提及）
	- 场景：若已有一个单链表`L`，可通过头插法将`L`中元素依次取出，插入到新链表中，新链表即为`L`的逆置结果
	- 原地逆置思路：取下原链表的每个数据节点，用头插法重新插入到原头节点之后，无需额外创建新链表

## 四、两种建立方法的核心对比

| 对比维度         | 尾插法             | 头插法                         |
| ---------------- | ------------------ | ------------------------------ |
| 插入位置         | 链表表尾           | 头节点之后（表头）             |
| 元素顺序         | 与输入顺序一致     | 与输入顺序相反                 |
| 关键指针         | 需维护表尾指针`r`  | 无需额外指针（仅用`s`）        |
| 时间复杂度       | `O(n)`             | `O(n)`                         |
| 头节点`next`要求 | 建议初始化为`NULL` | 必须初始化为`NULL`（否则出错） |
| 核心应用场景     | 正常顺序存储数据   | 链表逆置、数据逆序处理         |

## 五、强调的关键注意事项

1. **头节点的必要性**：带头结点的链表可统一空表与非空表的插入逻辑，无需额外判断 “是否为第一个元素”
2. **内存分配检查**：使用`malloc`申请节点后，必须检查返回值是否为`NULL`（避免野指针操作导致崩溃）
3. **指针初始化**：所有指针（头节点`next`、表尾指针`r`）必须初始化，严禁 “野指针”（视频反复警告）
4. **终止符选择**：视频用`9999`作为终止符，实际可根据数据范围修改（本质是 “哨兵值”，需避免与正常数据冲突）
5. **基本操作迁移**：两种建立方法均基于 “初始化” 和 “后插操作”，掌握基本操作可推导复杂功能（视频核心学习思想）



#  双链表的定义

## 1. 双链表的定义（与单链表的区别）

### 核心区别

单链表的节点仅含**指向后继节点的指针（next）**，无法直接获取前驱节点；双链表在单链表基础上新增**指向前驱节点的指针（prior）**，解决了前驱节点查找困难的问题。

### 节点结构定义

视频中定义双链表节点名为`DNode`（`D`即`double`，表示双链表），同时通过类型重命名区分 “链表” 和 “节点指针”：

- `DLinkList`：强调该变量是**双链表的头指针**（代表整个链表）；
- `DNode*`：强调该变量是**双链表的单个节点指针**（代表单个节点）。

c

```c
// 假设数据元素类型为ElemType（需根据实际场景定义，如int、char等）
typedef struct dnode {
    ElemType data;          // 数据域：存储节点数据
    struct dnode *prior;    // 前驱指针域：指向当前节点的前驱节点
    struct dnode *next;     // 后继指针域：指向当前节点的后继节点
} DNode, *DLinkList;
```

## 2. 带头节点双链表的初始化

视频中明确双链表默认讨论**带头节点**的场景（头节点不存储实际数据，仅用于简化操作），初始化步骤如下：

1. 声明双链表头指针`L`；
2. 为头节点申请内存空间；
3. 将头节点的`prior`和`next`均设为`NULL`（头节点无前驱，初始无后继）。

### 完整初始化代码

c

```c
// 初始化带头节点的双链表
void InitDLinkList(DLinkList *L) {
    // 1. 为头节点分配内存空间（若分配失败，需根据实际场景处理，此处简化）
    *L = (DLinkList)malloc(sizeof(DNode));
    if (*L == NULL) {
        printf("内存分配失败！\n");
        return;
    }
    // 2. 头节点的前驱指针永远为NULL（无前置节点）
    (*L)->prior = NULL;
    // 3. 初始时链表无数据节点，头节点的后继指针设为NULL
    (*L)->next = NULL;
}
```

## 3. 带头节点双链表的判空

### 判空逻辑

带头节点的双链表 “为空” 的本质是：**头节点之后无任何数据节点**，因此判空条件为「头节点的`next`指针是否为`NULL`」。

### 判空代码

cs

```c
// 判断带头节点的双链表是否为空
bool IsEmpty(DLinkList L) {
    // 若头节点的next为NULL，说明无数据节点，链表为空
    return (L->next == NULL);
}
```

## 4. 双链表的插入操作（p 节点后插 s 节点）

视频中重点讲解 “在指定节点`p`之后插入新节点`s`”，需注意**边界处理**（若`p`是尾节点，`p->next`为`NULL`，直接修改`p->next->prior`会触发空指针错误）。

### 插入步骤（顺序不可乱）

1. 新节点`s`的`next`指向`p`的原后继节点（`p->next`）；
2. 若`p`不是尾节点（`p->next != NULL`），则`p`原后继节点的`prior`指向`s`；
3. 新节点`s`的`prior`指向`p`；
4. `p`的`next`指向`s`（完成插入）。

### 完整插入代码

c

```c
// 在节点p之后插入新节点s（p为双链表中已存在的节点，s为已初始化的新节点）
bool InsertAfterP(DLinkList L, DNode *p, DNode *s) {
    // 健壮性判断：p或s为NULL时插入失败（p需是链表中有效节点）
    if (p == NULL || s == NULL) {
        printf("插入节点无效！\n");
        return false;
    }
    // 步骤1：s的next指向p的原后继
    s->next = p->next;
    // 步骤2：若p不是尾节点，修改p原后继的prior为s（避免空指针）
    if (p->next != NULL) {
        p->next->prior = s;
    }
    // 步骤3：s的prior指向p
    s->prior = p;
    // 步骤4：p的next指向s（最终完成链接）
    p->next = s;
    return true;
}
```

### 插入关键注意事项

- 步骤顺序不可颠倒：若先执行`p->next = s`（步骤 4），再执行`s->next = p->next`（步骤 1），会导致`s->next`指向`s`自身（丢失`p`的原后继节点地址），插入错误。
- 边界处理必须存在：当`p`是尾节点（`p->next = NULL`）时，跳过步骤 2，避免空指针访问。

## 5. 双链表的删除操作（删除 p 的后继节点 q）

视频中讲解 “删除指定节点`p`的后继节点`q`”，同样需处理**边界问题**（若`q`是尾节点，`q->next`为`NULL`，修改`q->next->prior`会触发空指针错误）。

### 删除步骤

1. 先获取`p`的后继节点`q`（`q = p->next`）；
2. 若`q`为`NULL`（`p`无后继节点），删除失败；
3. `p`的`next`指向`q`的后继节点（跳过`q`）；
4. 若`q`不是尾节点（`q->next != NULL`），则`q`后继节点的`prior`指向`p`；
5. 释放`q`的内存空间（避免内存泄漏）。

### 完整删除代码

c

```c
// 删除节点p的后继节点q（p为双链表中已存在的节点）
bool DeleteNextNode(DLinkList L, DNode *p) {
    // 健壮性判断：p为NULL时删除失败
    if (p == NULL) {
        printf("指定节点无效！\n");
        return false;
    }
    // 步骤1：获取p的后继节点q
    DNode *q = p->next;
    // 步骤2：若q为NULL，p无后继节点，删除失败
    if (q == NULL) {
        printf("无后继节点可删除！\n");
        return false;
    }
    // 步骤3：p的next指向q的后继（跳过q）
    p->next = q->next;
    // 步骤4：若q不是尾节点，修改q后继的prior为p（避免空指针）
    if (q->next != NULL) {
        q->next->prior = p;
    }
    // 步骤5：释放q的内存（防止内存泄漏）
    free(q);
    return true;
}
```

## 6. 双链表的销毁

销毁双链表的核心是**释放所有节点的内存**（包括头节点），步骤如下：

1. 用临时指针`temp`存储当前要释放的节点（初始为头节点的后继）；
2. 循环：每次让头节点的`next`指向`temp`的后继，释放`temp`，再更新`temp`为新的头节点后继；
3. 当`temp`为`NULL`（所有数据节点已释放），最后释放头节点，将头指针设为`NULL`。

### 完整销毁代码

c

```c
// 销毁带头节点的双链表（释放所有节点内存）
void DestroyDLinkList(DLinkList *L) {
    // 临时指针：存储当前要释放的节点
    DNode *temp;
    // 循环：从数据节点开始释放（头节点的后继）
    while ((*L)->next != NULL) {
        // 1. temp指向当前要释放的数据节点
        temp = (*L)->next;
        // 2. 头节点的next指向temp的后继（跳过temp，避免断链）
        (*L)->next = temp->next;
        // 3. 释放temp节点的内存
        free(temp);
    }
    // 4. 所有数据节点释放后，释放头节点
    free(*L);
    // 5. 头指针设为NULL（避免野指针）
    *L = NULL;
}
```

## 7. 双链表的遍历（正向 + 反向）

双链表支持**正向遍历**（从首元节点到尾节点）和**反向遍历**（从尾节点到首元节点），核心是通过`next`或`prior`指针移动，遍历时间复杂度均为`O(n)`（无随机存取特性）。

### 7.1 正向遍历（处理数据节点，跳过头节点）

遍历逻辑：从**头节点的后继（首元节点）** 开始，通过`next`指针移动，直到指针为`NULL`（尾节点之后）。

c

```c
// 正向遍历双链表（打印数据节点的data，跳过头节点）
void TraverseForward(DLinkList L) {
    if (L == NULL) {
        printf("链表未初始化！\n");
        return;
    }
    // p从首元节点开始（头节点的后继）
    DNode *p = L->next;
    printf("正向遍历结果：");
    while (p != NULL) {
        // 处理数据（此处为打印，可根据需求修改）
        printf("%d ", p->data);
        // 移动到下一个节点
        p = p->next;
    }
    printf("\n");
}
```

### 7.2 反向遍历（处理数据节点，跳过头节点）

遍历逻辑：先通过正向遍历找到**尾节点**（`p->next == NULL`），再通过`prior`指针移动，直到`p->prior == NULL`（头节点之前，停止，避免处理头节点）。

c

```c
// 反向遍历双链表（打印数据节点的data，跳过头节点）
void TraverseBackward(DLinkList L) {
    if (L == NULL) {
        printf("链表未初始化！\n");
        return;
    }
    // 步骤1：找到尾节点（从首元节点开始，直到p->next为NULL）
    DNode *p = L->next;
    if (p == NULL) {
        printf("链表为空，无数据可遍历！\n");
        return;
    }
    while (p->next != NULL) {
        p = p->next;
    }
    // 步骤2：从尾节点开始反向遍历，直到p->prior为NULL（头节点之前）
    printf("反向遍历结果：");
    while (p->prior != NULL) {
        // 处理数据（此处为打印，可根据需求修改）
        printf("%d ", p->data);
        // 移动到前一个节点
        p = p->prior;
    }
    printf("\n");
}
```

### 遍历的延伸应用

- 按位查找：遍历过程中增加计数器，计数达到目标位序时返回对应节点；
- 按值查找：遍历过程中对比节点`data`与目标值，匹配时返回对应节点；
- 核心限制：因双链表无随机存取特性，查找操作时间复杂度均为`O(n)`。

## 8. 关键总结（视频强调的核心要点）

1. 双链表的核心优势：通过`prior`指针直接获取前驱节点，解决单链表前驱查找困难的问题；
2. 头节点作用：简化初始化、判空、插入、删除操作（无需特殊处理首元节点）；
3. 指针修改顺序：插入 / 删除时需先处理 “新链接”，再断开 “旧链接”，避免丢失节点地址；
4. 边界处理：必须判断节点是否为尾节点（`next == NULL`），避免空指针错误；
5. 内存管理：删除 / 销毁节点时必须`free`释放内存，防止内存泄漏。



# 循环链表知识点总结

## 一、循环单链表

循环单链表是在**普通单链表**基础上改进的线性结构，核心特征是**最后一个节点的`next`指针指向头节点**，形成闭环。

### 1. 定义与核心特性

#### （1）结构定义

通过结构体实现，包含数据域和指向后继节点的指针域，需额外引入头节点（哨兵节点）简化操作：

c

```c
// 循环单链表节点结构体定义
typedef struct Node {
    int data;               // 数据域（视频中未指定类型，以int为例）
    struct Node *next;      // 指针域，指向后继节点
} Node, *CircularLinkedList;
```

#### （2）核心特性

- 闭环结构：表尾节点的`next` ≠ `NULL`，而是指向头节点，解决普通单链表 “表尾无法回溯” 的问题。
- 全局访问性：给定任意一个节点`p`，可通过循环遍历（`p = p->next`）找到链表中所有节点（无需依赖头节点）。
- 操作效率优化：若将链表指针指向**表尾节点**（而非头节点），则表头（表尾`next`即头节点）和表尾操作的时间复杂度可从普通单链表的`O(n)`降至`O(1)`。

### 2. 关键操作（含完整代码）

#### （1）初始化（空表）

- 视频核心规则：空循环单链表的**头节点`next`指针指向自身**（区别于普通单链表的`next = NULL`）。

c

```c
// 初始化循环单链表（创建空表，返回头节点指针）
CircularLinkedList InitCircularList() {
    // 1. 分配头节点内存
    CircularLinkedList head = (CircularLinkedList)malloc(sizeof(Node));
    if (head == NULL) {
        printf("内存分配失败\n");
        return NULL;
    }
    // 2. 空表时，头节点next指向自身
    head->next = head;
    return head;
}
```

#### （2）判空

- 视频判空条件：判断**头节点的`next`是否指向自身**。

c

```c
// 判断循环单链表是否为空（空表返回1，非空返回0）
int IsEmpty(CircularLinkedList head) {
    // 空表特征：head->next == head
    return head->next == head ? 1 : 0;
}
```

#### （3）表尾节点判断

- 视频判断规则：若节点`p`的`next`指向头节点，则`p`是表尾节点。

c

```c
// 判断节点p是否为循环单链表的表尾节点（是返回1，否返回0）
int IsTail(CircularLinkedList head, Node *p) {
    // 表尾特征：p->next == head
    return p->next == head ? 1 : 0;
}
```

#### （4）在节点`p`后插入节点`s`

- 操作逻辑与普通单链表一致，但无需考虑`p`是表尾（因`p->next`是头节点，非`NULL`，无空指针风险）。

c

```c
// 在循环单链表的节点p后插入新节点s
void InsertAfter(Node *p, Node *s) {
    if (p == NULL || s == NULL) {
        printf("节点p或s为空，插入失败\n");
        return;
    }
    // 1. s的next指向p的原后继
    s->next = p->next;
    // 2. p的next指向s
    p->next = s;
}
```

#### （5）删除节点`p`

- 视频核心逻辑：普通单链表仅知`p`无法找前驱，循环单链表可通过遍历找`p`的前驱`pre`，再修改`pre->next`。

c

```c
// 删除循环单链表中的节点p（需保证p在链表中）
void DeleteNode(CircularLinkedList head, Node *p) {
    if (IsEmpty(head) || p == NULL) {
        printf("链表为空或节点p无效，删除失败\n");
        return;
    }
    // 1. 遍历找到p的前驱节点pre
    Node *pre = head;
    while (pre->next != p) {  // 终止条件：pre的后继是p
        pre = pre->next;
        // 防止p不在链表中导致死循环（可选校验）
        if (pre == head) {
            printf("节点p不在链表中\n");
            return;
        }
    }
    // 2. 前驱pre的next指向p的后继，跳过p
    pre->next = p->next;
    // 3. 释放p的内存
    free(p);
}
```

#### （6）遍历

- 遍历终止条件：扫描指针`p`回到头节点（区别于普通单链表的`p == NULL`）。

c

```c
// 遍历循环单链表（从表头开始打印所有数据）
void TraverseList(CircularLinkedList head) {
    if (IsEmpty(head)) {
        printf("链表为空\n");
        return;
    }
    Node *p = head->next;  // p从第一个数据节点开始
    printf("循环单链表内容：");
    while (p != head) {    // 终止条件：p回到头节点
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}
```

## 二、循环双链表

循环双链表是在**普通双链表**基础上改进的线性结构，核心特征是：**表尾节点`next`指向头节点，头节点`prior`指向表尾节点**，形成双向闭环。

### 1. 定义与核心特性

#### （1）结构定义

结构体包含数据域、指向后继的`next`指针、指向前驱的`prior`指针，同样引入头节点：

c

```c
// 循环双链表节点结构体定义
typedef struct DNode {
    int data;               // 数据域（视频中未指定类型，以int为例）
    struct DNode *prior;    // 指针域，指向前驱节点
    struct DNode *next;     // 指针域，指向后继节点
} DNode, *CircularDLinkedList;
```

#### （2）核心特性

- 双向闭环：`next`指针形成 “表尾→头” 的闭环，`prior`指针形成 “头→表尾” 的闭环，支持双向遍历。
- 无空指针：所有节点的`next`和`prior`均非`NULL`（表尾`next`= 头，头`prior`= 表尾），解决普通双链表表尾`next`=NULL、表头`prior`=NULL 导致的操作风险（如插入 / 删除表尾时空指针错误）。
- 判空简化：空表判断逻辑与循环单链表一致（头节点`next`指向自身）。

### 2. 关键操作（含完整代码）

#### （1）初始化（空表）

- 视频核心规则：空循环双链表的**头节点`next`和`prior`均指向自身**（区别于普通双链表的`next = NULL`、`prior = NULL`）。

c

```c
// 初始化循环双链表（创建空表，返回头节点指针）
CircularDLinkedList InitCircularDList() {
    // 1. 分配头节点内存
    CircularDLinkedList head = (CircularDLinkedList)malloc(sizeof(DNode));
    if (head == NULL) {
        printf("内存分配失败\n");
        return NULL;
    }
    // 2. 空表时，头节点prior和next均指向自身
    head->prior = head;
    head->next = head;
    return head;
}
```

#### （2）判空

- 视频判空条件：与循环单链表一致，判断**头节点的`next`是否指向自身**（因双向闭环，`prior`指向自身也成立，取其一即可）。

c

```c
// 判断循环双链表是否为空（空表返回1，非空返回0）
int IsDEmpty(CircularDLinkedList head) {
    // 空表特征：head->next == head（或head->prior == head）
    return head->next == head ? 1 : 0;
}
```

#### （3）表尾节点判断

- 视频判断规则：与循环单链表一致，若节点`p`的`next`指向头节点，则`p`是表尾节点。

c

```c
// 判断节点p是否为循环双链表的表尾节点（是返回1，否返回0）
int IsDTail(CircularDLinkedList head, DNode *p) {
    // 表尾特征：p->next == head
    return p->next == head ? 1 : 0;
}
```

#### （4）在节点`p`后插入节点`s`

- 视频核心优势：普通双链表若`p`是表尾，`p->next`=NULL，修改`p->next->prior`会报错；循环双链表`p->next`= 头节点，可安全修改头节点的`prior`，无需特殊处理。

c

```c
// 在循环双链表的节点p后插入新节点s
void DInsertAfter(DNode *p, DNode *s) {
    if (p == NULL || s == NULL) {
        printf("节点p或s为空，插入失败\n");
        return;
    }
    // 步骤1：s的next指向p的原后继，s的prior指向p
    s->next = p->next;
    s->prior = p;
    // 步骤2：p的原后继的prior指向s（关键：即使原后继是头节点，也无空指针风险）
    p->next->prior = s;
    // 步骤3：p的next指向s
    p->next = s;
}
```

#### （5）删除节点`q`

- 视频核心优势：普通双链表若`q`是表尾，`q->next`=NULL，修改`q->next->prior`会报错；循环双链表`q->next`= 头节点，可安全修改头节点的`prior`。

c

```c
// 删除循环双链表中的节点q（需保证q在链表中）
void DeleteDNode(CircularDLinkedList head, DNode *q) {
    if (IsDEmpty(head) || q == NULL) {
        printf("链表为空或节点q无效，删除失败\n");
        return;
    }
    // 步骤1：q的前驱的next指向q的后继
    q->prior->next = q->next;
    // 步骤2：q的后继的prior指向q的前驱（关键：即使后继是头节点，也无空指针风险）
    q->next->prior = q->prior;
    // 步骤3：释放q的内存
    free(q);
}
```

#### （6）双向遍历

- 正向遍历：从表头开始，`p = p->next`，终止于`p == head`；
- 反向遍历：从表尾开始（`p = head->prior`），`p = p->prior`，终止于`p == head`。

c

```c
// 正向遍历循环双链表（从表头到表尾打印）
void TraverseDListForward(CircularDLinkedList head) {
    if (IsDEmpty(head)) {
        printf("循环双链表为空\n");
        return;
    }
    DNode *p = head->next;  // p从第一个数据节点开始
    printf("正向遍历内容：");
    while (p != head) {     // 终止条件：p回到头节点
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

// 反向遍历循环双链表（从表尾到表头打印）
void TraverseDListBackward(CircularDLinkedList head) {
    if (IsDEmpty(head)) {
        printf("循环双链表为空\n");
        return;
    }
    DNode *p = head->prior;  // p从表尾节点开始（head->prior是表尾）
    printf("反向遍历内容：");
    while (p != head) {      // 终止条件：p回到头节点
        printf("%d ", p->data);
        p = p->prior;
    }
    printf("\n");
}
```

## 三、循环链表与普通链表的核心区别

| 对比维度                | 普通单链表                              | 循环单链表                              | 普通双链表                          | 循环双链表                              |
| ----------------------- | --------------------------------------- | --------------------------------------- | ----------------------------------- | --------------------------------------- |
| 表尾指针指向            | `NULL`                                  | 头节点                                  | `NULL`（`next`）、`NULL`（`prior`） | 头节点（`next`）、表尾（`prior`）       |
| 空表初始化              | 头节点`next = NULL`                     | 头节点`next = 头节点`                   | 头节点`next = NULL`、`prior = NULL` | 头节点`next = 头节点`、`prior = 头节点` |
| 判空条件                | `head->next == NULL`                    | `head->next == head`                    | `head->next == NULL`                | `head->next == head`                    |
| 表尾节点判断            | `p->next == NULL`                       | `p->next == head`                       | `p->next == NULL`                   | `p->next == head`                       |
| 前驱节点查找（已知`p`） | 需从头遍历（`O(n)`），无法仅通过`p`查找 | 可通过`p`循环遍历（`O(n)`），无需头节点 | 直接`p->prior`（`O(1)`）            | 直接`p->prior`（`O(1)`）                |
| 表尾插入 / 删除风险     | 无，但需遍历找表尾（`O(n)`）            | 无，若指针指向表尾则操作`O(1)`          | 表尾操作可能空指针错误              | 无空指针错误，操作更安全                |



# 静态链表知识点总结

## 1. 静态链表的基本概念

### 1.1 定义与核心本质

静态链表是**用数组实现的链表结构**，其核心特征是：

- 分配**一整片连续的内存空间**，所有节点存放在该连续空间中；
- 节点间的逻辑顺序通过**游标（数组下标）** 维系，而非物理地址；
- 解决了早期低级语言（无指针）无法实现动态链表的问题。

### 1.2 与单链表的核心差异

| 对比维度     | 单链表               | 静态链表                 |
| ------------ | -------------------- | ------------------------ |
| 内存分布     | 离散内存             | 连续内存                 |
| 节点关联方式 | 指针（内存地址）     | 游标（数组下标）         |
| 表尾标识     | `next = NULL`        | `next = -1`              |
| 容量灵活性   | 动态扩容（按需分配） | 容量固定（初始化时定死） |

### 1.3 节点的组成

静态链表的每个节点包含两个核心字段：

1. **数据域（data）**：存储实际的数据元素；
2. **游标域（next）**：存储下一个节点的**数组下标**（替代单链表的指针）。

**特殊节点说明**：

- 数组下标为`0`的节点：充当**头节点**，不存储实际数据，仅通过`next`指向第一个数据节点（逻辑上的 “首元节点”）；
- 空闲节点：未存储数据的节点，通过`next = -2`标记（便于计算机识别空闲空间）；
- 表尾节点：`next = -1`（表示后续无节点）。

### 1.4 静态链表的内存地址计算

若已知：

- 节点大小 = 数据域大小 + 游标域大小（例：`int data`4 字节 + `int next`4 字节 = 8 字节）；
- 静态链表起始地址 = `addr_start`；
- 目标节点的数组下标 = `index`；

则目标节点的实际内存地址为：
`addr_target = addr_start + 节点大小 × index`

## 2. 静态链表的代码定义（C 语言）

视频中提到两种定义方式，核心功能等价，但语法形式不同。

### 2.1 基础定义方式（易理解）

先定义节点结构体，再声明结构体数组（静态链表的载体）：

c

```c
#include <stdio.h>
#include <stdlib.h>

// 1. 定义静态链表的最大容量（视频中取10）
#define MAXSIZE 10

// 2. 定义节点结构体
struct Node {
    int data;   // 数据域（视频中用int举例）
    int next;   // 游标域（存储下一个节点的数组下标）
};

// 3. 声明静态链表（数组形式，元素类型为struct Node）
struct Node a[MAXSIZE];
```

### 2.2 课本特殊定义方式（typedef 简化）

视频中提到课本使用`typedef`将 “结构体 + 数组” 合并定义，目的是直接体现 “变量是静态链表” 的语义：

c

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 10

// 关键：typedef将“struct Node数组”重命名为SLinkList
typedef struct Node {
    int data;
    int next;
} SLinkList[MAXSIZE];  // SLinkList本质是“struct Node [MAXSIZE]”的别名

// 声明静态链表（直接用SLinkList定义，语义更清晰）
SLinkList b;
```

### 2.3 两种定义方式的等价性验证（视频代码）

视频通过`sizeof`验证两种定义的内存占用一致，代码如下：

c

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 10

// 基础定义方式的结构体
struct Node {
    int data;
    int next;
};

// 课本定义方式（typedef）
typedef struct Node SLinkList[MAXSIZE];

int main() {
    // 1. 验证单个节点的大小（int占4字节，2个int共8字节）
    struct Node x;
    printf("单个节点大小：%lu 字节\n", sizeof(x));  // 输出：8
    
    // 2. 验证基础方式定义的静态链表大小（10个节点 × 8字节 = 80字节）
    struct Node a[MAXSIZE];
    printf("基础方式链表大小：%lu 字节\n", sizeof(a));  // 输出：80
    
    // 3. 验证课本方式定义的静态链表大小（与a等价，同样80字节）
    SLinkList b;
    printf("课本方式链表大小：%lu 字节\n", sizeof(b));  // 输出：80
    
    return 0;
}
```

**运行结果**（视频中展示）：

plaintext

```plaintext
单个节点大小：8 字节
基础方式链表大小：80 字节
课本方式链表大小：80 字节
```

## 3. 静态链表的基本操作

视频中重点讲解操作逻辑，以下为对应代码实现（基于课本定义方式`SLinkList`）。

### 3.1 初始化操作

**核心目标**：

1. 头节点（下标 0）的`next`设为`-1`（初始无数据节点）；
2. 所有空闲节点（下标 1~MAXSIZE-1）的`next`设为`-2`（标记空闲）。

c

```c
// 初始化静态链表L
void InitSLinkList(SLinkList L) {
    // 1. 初始化头节点：无后续节点
    L[0].next = -1;
    
    // 2. 初始化所有空闲节点：标记为-2
    for (int i = 1; i < MAXSIZE; i++) {
        L[i].next = -2;
    }
}
```

### 3.2 查找操作（按位序查找）

**需求**：查找逻辑位序为`i`的节点（位序 1 对应第一个数据节点），返回该节点的数组下标；若不存在，返回`-1`。

**逻辑**：从头节点出发，通过游标遍历，直到找到第`i`个节点或表尾。

c

```c
// 查找位序为i的节点，返回其数组下标
int LocateElem(SLinkList L, int i) {
    // 边界判断：位序i无效（i<1）
    if (i < 1) {
        return -1;
    }
    
    int j = 1;                  // 计数器：当前遍历到第j个数据节点
    int p = L[0].next;          // 起始指针：从第一个数据节点开始（头节点的next）
    
    // 遍历条件：未到表尾（p!=-1）且未找到第i个节点（j<i）
    while (p != -1 && j < i) {
        p = L[p].next;          // 移动到下一个节点
        j++;                    // 计数器加1
    }
    
    // 若p=-1，说明i超过链表长度（无该节点）；否则返回p（节点下标）
    return p;
}
```

**时间复杂度**：`O(n)`（需从头遍历，无法随机存取）。

### 3.3 插入操作（在位序 i 处插入节点）

**核心步骤**（视频重点强调）：

1. 找到**空闲节点**（`next=-2`的节点），作为新节点；
2. 找到**位序 i-1 的前驱节点**（确保插入位置合法）；
3. 赋值新节点的数据，并修改游标（维系逻辑顺序）；
4. 标记原空闲节点为 “已使用”（无需单独标记，游标已指向有效节点）。

c

```c
// 在位序i处插入数据e，成功返回1，失败返回0
int ListInsert(SLinkList L, int i, int e) {
    // 步骤1：查找空闲节点（遍历找next=-2的下标）
    int newNode = -1;
    for (int k = 1; k < MAXSIZE; k++) {
        if (L[k].next == -2) {
            newNode = k;
            break;
        }
    }
    if (newNode == -1) {
        printf("链表已满，无法插入\n");
        return 0;  // 无空闲节点，插入失败
    }
    
    // 步骤2：查找前驱节点（位序i-1的节点下标）
    int pre = L[0].next;  // 前驱节点的初始值（若i=1，前驱是头节点，需特殊处理）
    int j = 1;
    if (i == 1) {
        pre = 0;  // 插入到第一个位置，前驱是头节点（下标0）
    } else {
        pre = LocateElem(L, i-1);  // 查找i-1的节点下标
        if (pre == -1) {
            printf("插入位置无效（i超过链表长度+1）\n");
            return 0;
        }
    }
    
    // 步骤3：插入节点（修改游标）
    L[newNode].data = e;          // 新节点赋值
    L[newNode].next = L[pre].next;// 新节点的next = 前驱的原next
    L[pre].next = newNode;        // 前驱的next = 新节点下标
    
    return 1;
}
```

### 3.4 删除操作（删除位序 i 的节点）

**核心步骤**（视频重点强调）：

1. 找到**位序 i-1 的前驱节点**；
2. 找到**待删除节点**（前驱节点的`next`）；
3. 修改前驱节点的游标（跳过待删除节点）；
4. 标记待删除节点为 “空闲”（`next=-2`）。

c

```c
// 删除位序i的节点，成功返回1，失败返回0
int ListDelete(SLinkList L, int i) {
    // 步骤1：查找前驱节点（位序i-1）
    int pre = -1;
    if (i == 1) {
        pre = 0;  // 删除第一个节点，前驱是头节点
    } else {
        pre = LocateElem(L, i-1);
        if (pre == -1) {
            printf("删除位置无效（i超过链表长度）\n");
            return 0;
        }
    }
    
    // 步骤2：确认待删除节点存在
    int delNode = L[pre].next;
    if (delNode == -1) {
        printf("待删除节点不存在\n");
        return 0;
    }
    
    // 步骤3：删除节点（修改游标）
    L[pre].next = L[delNode].next;  // 前驱的next = 待删除节点的next
    L[delNode].next = -2;           // 标记待删除节点为空闲
    
    return 1;
}
```

## 4. 静态链表的特性总结

### 4.1 优点

1. **无需移动元素**：插入 / 删除仅需修改游标（类似单链表），避免了顺序表 “移动大量元素” 的开销；
2. **适配无指针语言**：早期无指针的低级语言（如早期 BASIC）可通过静态链表实现链表功能。

### 4.2 缺点

1. **无法随机存取**：查找需从头遍历，时间复杂度`O(n)`（与单链表一致）；
2. **容量固定**：初始化时`MAXSIZE`定死，无法动态扩容，可能导致内存浪费或溢出；
3. **需标记空闲节点**：需额外通过`next=-2`管理空闲空间，增加实现复杂度。

## 5. 静态链表的应用场景

1. **早期无指针语言**：作为动态链表的替代方案；
2. **数据量固定的场景**：当数据元素数量已知且基本不变时（如操作系统中的**文件分配表 FAT**，视频中重点提及，本质是静态链表）。



# 顺序表与链表的比较

## 1. 数据结构三要素核心对比

视频明确数据结构的核心三要素为「逻辑结构」「物理结构（存储结构）」「数据运算」，顺序表与链表的差异围绕这三要素展开。

### 1.1 逻辑结构

- **共性**：两者均为「线性结构」，数据元素间呈**一对一**的逻辑关系，均属于线性表的实现。
- **差异**：无（逻辑层面完全一致，仅在物理存储和运算上体现差异）。

### 1.2 物理结构（存储结构）

| 对比维度     | 顺序表（顺序存储）                                           | 链表（链式存储）                                             |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 空间分配方式 | 要求**连续的整片存储空间**                                   | 允许**离散的存储空间**，节点可分散存储                       |
| 存取特性     | **随机存取**：已知起始地址，可通过公式直接定位任意元素（`地址 = 起始地址 + 元素下标 × 元素大小`） | **不可随机存取**：需从表头开始依次遍历，无法直接定位         |
| 存储密度     | 高：仅存储数据元素，无冗余信息                               | 低：每个节点需额外存储「指针（next）」，占用额外空间         |
| 容量灵活性   | 差： - 静态分配：容量固定，无法扩展； - 动态分配：扩展需移动大量元素，时间代价高 | 好：扩展时仅需用`malloc`动态申请单个节点空间，通过指针连接即可 |
| 空间分配难度 | 高：需一次性申请大片连续空间，若内存碎片化严重则可能分配失败 | 低：每次仅申请单个节点的小空间，易成功                       |

## 2. 基本运算（核心操作）实现

视频重点讲解「初始化、销毁、插入、删除、查找」五大核心运算，以下为基于 C 语言的完整实现（视频隐含的标准实现逻辑，结合存储特性推导）。

### 2.0 基础结构体定义（视频隐含的底层结构）

#### 2.0.1 顺序表结构体

- 分「静态分配」和「动态分配」两种，视频明确两者的差异在于空间是否可手动扩展：

c

```c
#include <stdio.h>
#include <stdlib.h>
// 假设数据元素类型为int（可根据需求替换）
typedef int ElemType;
#define InitMaxSize 10  // 静态分配的初始容量

// 1. 静态分配顺序表
typedef struct {
    ElemType data[InitMaxSize];  // 连续数组存储数据
    int length;                  // 当前有效元素个数（初始为0）
} SqList_Static;

// 2. 动态分配顺序表
typedef struct {
    ElemType *data;  // 指向动态申请的连续空间
    int length;      // 当前有效元素个数（初始为0）
    int MaxSize;     // 当前最大容量（可扩展）
} SqList_Dynamic;
```

#### 2.0.2 链表结构体

- 视频默认「单链表」，支持「带头节点」和「不带头节点」，以下为常用的「带头节点」实现（简化操作逻辑）：

c

```c
// 单链表节点结构体
typedef struct LNode {
    ElemType data;          // 数据域：存储元素
    struct LNode *next;     // 指针域：指向后继节点
} LNode, *LinkList;  // LNode：节点类型；LinkList：指向节点的指针类型
```

### 2.1 初始化操作

#### 2.1.1 顺序表初始化

- 静态分配：仅需初始化`length`为 0；
- 动态分配：需用`malloc`申请初始空间，并初始化`length`和`MaxSize`。

c

```c
// 1. 静态顺序表初始化
void InitSqList_Static(SqList_Static *L) {
    L->length = 0;  // 初始无有效元素
}

// 2. 动态顺序表初始化（初始容量设为InitMaxSize）
bool InitSqList_Dynamic(SqList_Dynamic *L) {
    // 申请InitMaxSize个ElemType大小的连续空间
    L->data = (ElemType *)malloc(InitMaxSize * sizeof(ElemType));
    if (L->data == NULL) return false;  // 内存分配失败
    L->length = 0;          // 初始无有效元素
    L->MaxSize = InitMaxSize;  // 初始最大容量
    return true;
}
```

#### 2.1.2 链表初始化（带头节点）

- 视频说明：初始化仅需「创建头节点」，头节点不存储实际数据，仅用于简化插入 / 删除操作。

c

```c
bool InitLinkList(LinkList *L) {
    // 申请头节点空间
    *L = (LinkList)malloc(sizeof(LNode));
    if (*L == NULL) return false;  // 内存分配失败
    (*L)->next = NULL;  // 头节点的后继指针置空（初始链表为空）
    return true;
}
```

### 2.2 销毁操作

视频强调：销毁的核心是「回收占用的内存空间」，避免内存泄漏，需区分静态 / 动态分配的差异。

#### 2.2.1 顺序表销毁

- 静态分配：空间由系统自动回收（数组生命周期结束后），仅需将`length`置 0；
- 动态分配：需手动用`free`回收`data`指向的空间，避免堆区内存泄漏。

c

```c
// 1. 静态顺序表销毁（仅逻辑置空，空间系统回收）
void DestroySqList_Static(SqList_Static *L) {
    L->length = 0;  // 逻辑上标记为空表
}

// 2. 动态顺序表销毁（手动回收堆区空间）
void DestroySqList_Dynamic(SqList_Dynamic *L) {
    free(L->data);   // 回收动态申请的连续空间
    L->data = NULL;  // 避免野指针
    L->length = 0;   // 逻辑置空
    L->MaxSize = 0;  // 容量置0
}
```

#### 2.2.2 链表销毁

- 视频逻辑：需「循环遍历所有节点」，依次用`free`回收，避免遗漏节点导致内存泄漏。

c

```c
void DestroyLinkList(LinkList *L) {
    LNode *p = *L;    // p指向当前要销毁的节点（先指向头节点）
    LNode *q = NULL;  // q暂存p的后继节点
    while (p != NULL) {
        q = p->next;  // 先保存后继节点，避免销毁p后找不到
        free(p);      // 销毁当前节点
        p = q;        // 移动到下一个节点
    }
    *L = NULL;  // 链表头指针置空，避免野指针
}
```

### 2.3 插入操作（在第 i 个位置插入元素 e）

#### 2.3.1 顺序表插入

- 视频核心逻辑：因空间连续，插入需「移动第 i 个位置及之后的所有元素」（后移 1 位），时间复杂度 O (n)。

c

```c
// 动态顺序表插入（静态类似，仅无需判断容量）
bool ListInsert_Sq(SqList_Dynamic *L, int i, ElemType e) {
    // 1. 合法性检查：i需在[1, length+1]（1-based）
    if (i < 1 || i > L->length + 1) return false;
    // 2. 若容量不足，先扩展（视频提到动态扩展需移动元素，此处简化扩展逻辑）
    if (L->length >= L->MaxSize) {
        ElemType *newData = (ElemType *)realloc(L->data, 2 * L->MaxSize * sizeof(ElemType));
        if (newData == NULL) return false;  // 扩展失败
        L->data = newData;
        L->MaxSize *= 2;  // 容量翻倍
    }
    // 3. 移动元素：从最后一个元素开始，到第i个元素，依次后移
    for (int j = L->length; j >= i; j--) {
        L->data[j] = L->data[j-1];
    }
    // 4. 插入元素e到第i个位置（数组下标为i-1）
    L->data[i-1] = e;
    L->length++;  // 有效元素个数+1
    return true;
}
```

#### 2.3.2 链表插入（带头节点，第 i 个位置）

- 视频核心逻辑：无需移动元素，仅需「找到第 i-1 个前驱节点」，修改指针指向，时间复杂度 O (n)（主要耗时在找前驱）。

c

```c
bool ListInsert_L(LinkList L, int i, ElemType e) {
    // 1. 合法性检查：i至少为1
    if (i < 1) return false;
    LNode *p = L;    // p指向头节点（初始前驱节点）
    int j = 0;       // j记录当前p的位置（头节点为第0个）
    // 2. 找到第i-1个前驱节点（循环i-1次）
    while (p != NULL && j < i-1) {
        p = p->next;
        j++;
    }
    // 3. 若p为空（i超过链表长度+1），插入失败
    if (p == NULL) return false;
    // 4. 申请新节点并赋值
    LNode *newNode = (LNode *)malloc(sizeof(LNode));
    if (newNode == NULL) return false;  // 内存分配失败
    newNode->data = e;
    // 5. 修改指针：新节点指向p的后继，p指向新节点
    newNode->next = p->next;
    p->next = newNode;
    return true;
}
```

### 2.4 删除操作（删除第 i 个位置的元素，用 e 返回删除值）

#### 2.4.1 顺序表删除

- 视频核心逻辑：需「移动第 i+1 个位置及之后的所有元素」（前移 1 位），覆盖被删除元素，时间复杂度 O (n)。

c

```c
bool ListDelete_Sq(SqList_Dynamic *L, int i, ElemType *e) {
    // 1. 合法性检查：i需在[1, length]，且e不为空
    if (i < 1 || i > L->length || e == NULL) return false;
    // 2. 保存被删除元素的值
    *e = L->data[i-1];
    // 3. 移动元素：从第i个元素开始，到最后一个元素，依次前移
    for (int j = i; j < L->length; j++) {
        L->data[j-1] = L->data[j];
    }
    L->length--;  // 有效元素个数-1
    return true;
}
```

#### 2.4.2 链表删除（带头节点，第 i 个位置）

- 视频核心逻辑：无需移动元素，仅需「找到第 i-1 个前驱节点」，修改指针跳过被删除节点，再用`free`回收，时间复杂度 O (n)。

c

```c
bool ListDelete_L(LinkList L, int i, ElemType *e) {
    // 1. 合法性检查：i至少为1，e不为空
    if (i < 1 || e == NULL) return false;
    LNode *p = L;    // p指向头节点（前驱）
    int j = 0;       // j记录p的位置（头节点为第0个）
    // 2. 找到第i-1个前驱节点
    while (p != NULL && j < i-1) {
        p = p->next;
        j++;
    }
    // 3. 若p为空或p的后继为空（i超过链表长度），删除失败
    if (p == NULL || p->next == NULL) return false;
    // 4. 暂存被删除节点
    LNode *q = p->next;
    // 5. 保存被删除元素的值
    *e = q->data;
    // 6. 修改指针：p的后继指向q的后继，跳过q
    p->next = q->next;
    // 7. 回收被删除节点的空间
    free(q);
    return true;
}
```

### 2.5 查找操作（按位查找、按值查找）

#### 2.5.1 顺序表查找

| 查找类型                    | 实现逻辑                                                     | 时间复杂度                   |
| --------------------------- | ------------------------------------------------------------ | ---------------------------- |
| 按位查找（找第 i 个元素）   | 直接通过数组下标定位（`data[i-1]`），支持随机存取            | O(1)                         |
| 按值查找（找值为 e 的元素） | 1. 若元素无序：从表头遍历，逐一对比； 2. 若元素有序：可使用「折半查找」，效率更高 | 无序：O (n)； 有序：O (logn) |

c

```c
// 1. 顺序表按位查找
ElemType GetElem_Sq(SqList_Dynamic L, int i) {
    // 合法性检查：i需在[1, length]
    if (i < 1 || i > L.length) {
        printf("查找位置非法！\n");
        exit(1);  // 实际应用中可返回特殊值或用bool标记失败
    }
    return L.data[i-1];  // 直接定位
}

// 2. 顺序表按值查找（无序表，返回第一个匹配元素的位置，无则返回0）
int LocateElem_Sq(SqList_Dynamic L, ElemType e) {
    for (int i = 0; i < L.length; i++) {
        if (L.data[i] == e) {
            return i+1;  // 返回1-based位置
        }
    }
    return 0;  // 未找到
}

// 3. 顺序表按值查找（有序表，折半查找，返回位置，无则返回0）
int BinarySearch_Sq(SqList_Dynamic L, ElemType e) {
    int low = 0, high = L.length - 1;  // 初始化左右边界（0-based）
    while (low <= high) {
        int mid = (low + high) / 2;  // 中间位置
        if (L.data[mid] == e) {
            return mid + 1;  // 找到，返回1-based位置
        } else if (L.data[mid] > e) {
            high = mid - 1;  // 目标在左半区
        } else {
            low = mid + 1;   // 目标在右半区
        }
    }
    return 0;  // 未找到
}
```

#### 2.5.2 链表查找

- 视频明确：无论元素是否有序，链表均不支持随机存取，需从表头遍历，时间复杂度均为 O (n)。

c

```c
// 1. 链表按位查找（返回第i个元素的节点指针，无则返回NULL）
LNode *GetElem_L(LinkList L, int i) {
    if (i < 1) return NULL;  // 位置非法
    LNode *p = L->next;  // p指向第一个有效节点（1-based）
    int j = 1;           // j记录当前p的位置
    while (p != NULL && j < i) {
        p = p->next;
        j++;
    }
    return p;  // 若p为空，说明i超过链表长度
}

// 2. 链表按值查找（返回第一个值为e的节点指针，无则返回NULL）
LNode *LocateElem_L(LinkList L, ElemType e) {
    LNode *p = L->next;  // p指向第一个有效节点
    while (p != NULL) {
        if (p->data == e) {
            return p;  // 找到，返回节点指针
        }
        p = p->next;
    }
    return NULL;  // 未找到
}
```

## 3. 应用场景选择

视频通过具体场景说明两者的适用范围，核心依据「表长灵活性」和「核心操作类型」：

| 适用场景                 | 推荐数据结构 | 理由                                                         |
| ------------------------ | ------------ | ------------------------------------------------------------ |
| 奶茶店排队取号 / 叫号    | 链表         | 1. 表长不可预估（顾客数量波动大）； 2. 核心操作是「插入（新顾客取号）」和「删除（顾客取餐）」，链表效率更高。 |
| 课堂学生点名             | 顺序表       | 1. 表长固定（班级人数稳定，可预估）； 2. 核心操作是「按名查找（点名）」或「按位查找（按学号点名）」，顺序表支持随机存取，效率更高。 |
| 静态数据存储（如配置表） | 顺序表       | 表长固定，无需频繁插入 / 删除，顺序表存储密度高，节省空间。  |
| 动态数据集合（如日志）   | 链表         | 表长动态增长，需频繁追加元素，链表扩展灵活，无需移动数据。   |

## 4. 关键结论

1. **逻辑一致，存储不同**：顺序表与链表逻辑结构均为线性表，但物理存储方式决定了存取特性和灵活性的差异；
2. **操作效率 trade-off**：
    \- 顺序表：查找快（O (1) 按位），插入 / 删除慢（O (n) 移动元素）；
    \- 链表：插入 / 删除快（O (1) 改指针，不含查找前驱时间），查找慢（O (n) 遍历）；
3. **场景优先选择**：表长固定、查找多 → 顺序表；表长动态、插入删除多 → 链表；
4. **内存管理注意**：动态分配的顺序表和链表，必须手动`free`回收空间，避免内存泄漏；静态顺序表由系统自动回收。



# 链表核心知识点总结（基于视频内容）

## 基础前提

所有链表均为**带有表头节点的单链表**，节点核心结构为`data`（数据域）和`next`（指针域，指向后继节点），C++ 实现中使用`struct`定义节点，并通过构造函数简化初始化。

### 1. 查找单链表中倒数第 K 个节点（1919 年真题）

#### 基本思想

采用**快慢指针（双指针）** 策略，利用指针间距实现 “一次遍历定位”：

- 让快指针（`fast`）先向前移动`K`步，形成与慢指针（`slow`）的`K`步间距；
- 随后快慢指针同步向前移动，直到快指针指向`NULL`（链表尾）；
- 此时慢指针指向的节点即为**倒数第 K 个节点**（间距保持`K`，快指针到尾时，慢指针恰好到倒数第 K 个）。

#### 实现步骤

1. 初始化快慢指针，均指向**首节点**（表头节点的`next`）；
2. 快指针先移动`K`步：若移动过程中快指针提前指向`NULL`，说明`K`大于链表长度，查找失败；
3. 快慢指针同步移动，直到`fast == NULL`；
4. 查找成功：输出慢指针的`data`，返回 1；失败：返回 0。

#### C++ 代码

cpp







```cpp
#include <iostream>
using namespace std;

// 节点定义（数据域为int）
struct Node {
    int data;
    Node* next;
    // 构造函数：默认数据为0，指针为NULL
    Node(int d = 0, Node* n = NULL) : data(d), next(n) {}
};

// 查找倒数第K个节点：list为表头指针，K为目标位置
int findKthFromTail(Node* list, int K) {
    if (list == NULL || list->next == NULL || K <= 0) {
        return 0; // 表头为空、链表无有效节点、K非法，失败
    }

    Node* fast = list->next; // 快指针：指向首节点
    Node* slow = list->next; // 慢指针：指向首节点

    // 步骤1：快指针先移动K步
    for (int i = 0; i < K; i++) {
        if (fast == NULL) {
            return 0; // K超过链表长度，失败
        }
        fast = fast->next;
    }

    // 步骤2：快慢指针同步移动，直到快指针到尾
    while (fast != NULL) {
        fast = fast->next;
        slow = slow->next;
    }

    // 查找成功：输出data，返回1
    cout << "倒数第" << K << "个节点的data：" << slow->data << endl;
    return 1;
}

// 测试：构造链表（头→10→20→30→40→50→60→70）
int main() {
    // 构造表头节点
    Node* head = new Node();
    // 尾插法构造链表
    Node* tail = head;
    int arr[] = {10, 20, 30, 40, 50, 60, 70};
    for (int num : arr) {
        tail->next = new Node(num);
        tail = tail->next;
    }

    // 查找倒数第3个节点（预期结果：50）
    int K = 3;
    int result = findKthFromTail(head, K);
    if (result == 0) {
        cout << "查找失败：K非法或链表长度不足" << endl;
    }

    // 释放链表内存（避免内存泄漏）
    Node* temp = NULL;
    while (head != NULL) {
        temp = head;
        head = head->next;
        delete temp;
    }
    return 0;
}
```

#### 示例

- 构造链表：`头节点 → 10 → 20 → 30 → 40 → 50 → 60 → 70`
- 查找`K=3`（倒数第 3 个节点）：
	快指针先移动 3 步（10→20→30→40），随后同步移动：
	- 快指针：40→50→60→70→NULL
	- 慢指针：10→20→30→40→50
	- 最终输出`50`，返回 1。

### 2. 查找两个单链表的共同后缀起始节点（2012 年真题）

#### 基本思想

共同后缀指两个链表从某一节点开始，后续节点完全共享（地址相同）。利用**长度差 + 快慢指针**：

- 先计算两个链表的长度`len1`和`len2`，求长度差`diff = abs(len1 - len2)`；
- 让指向**较长链表**的快指针先移动`diff`步，消除长度差；
- 快慢指针同步移动，直到两指针指向同一节点（地址相同），该节点即为共同后缀起始节点。

#### 实现步骤

1. 定义节点（数据域为`char`，存储单词字符）；
2. 编写函数计算链表长度；
3. 确定较长链表的指针，先移动`diff`步；
4. 同步移动两指针，直到指针相等，返回该节点；
5. 若遍历结束未相遇，返回`NULL`（无共同后缀）。

#### C++ 代码

cpp







```cpp
#include <iostream>
#include <cstdlib> // for abs()
using namespace std;

// 节点定义（数据域为char，存储单词字符）
struct Node {
    char data;
    Node* next;
    Node(char d = '\0', Node* n = NULL) : data(d), next(n) {}
};

// 计算链表长度（表头节点不计入有效长度）
int getListLength(Node* head) {
    int len = 0;
    Node* p = head->next;
    while (p != NULL) {
        len++;
        p = p->next;
    }
    return len;
}

// 查找共同后缀起始节点：head1、head2为两个链表的表头
Node* findCommonSuffix(Node* head1, Node* head2) {
    if (head1 == NULL || head2 == NULL || head1->next == NULL || head2->next == NULL) {
        return NULL; // 空链表无共同后缀
    }

    // 步骤1：计算两个链表的长度
    int len1 = getListLength(head1);
    int len2 = getListLength(head2);
    int diff = abs(len1 - len2);

    // 步骤2：确定较长链表的指针，先移动diff步
    Node* fast = (len1 > len2) ? head1->next : head2->next; // 较长链表的指针
    Node* slow = (len1 > len2) ? head2->next : head1->next; // 较短链表的指针

    for (int i = 0; i < diff; i++) {
        if (fast == NULL) {
            return NULL; // 异常情况：较长链表长度不足diff
        }
        fast = fast->next;
    }

    // 步骤3：同步移动，直到指针相等
    while (fast != NULL && slow != NULL) {
        if (fast == slow) { // 地址相同，找到共同后缀
            return fast;
        }
        fast = fast->next;
        slow = slow->next;
    }

    return NULL; // 无共同后缀
}

// 测试：构造两个有共同后缀的链表（loading和being，共同后缀为'ing'）
int main() {
    // 构造共同后缀节点：i → n → g
    Node* common_i = new Node('i');
    Node* common_n = new Node('n', common_i);
    Node* common_g = new Node('g', common_n);

    // 构造链表1：loading（头→l→o→a→d→i→n→g）
    Node* head1 = new Node();
    Node* tail1 = head1;
    tail1->next = new Node('l'); tail1 = tail1->next;
    tail1->next = new Node('o'); tail1 = tail1->next;
    tail1->next = new Node('a'); tail1 = tail1->next;
    tail1->next = new Node('d'); tail1 = tail1->next;
    tail1->next = common_g; // 接入共同后缀（d→g→n→i）

    // 构造链表2：being（头→b→e→i→n→g）
    Node* head2 = new Node();
    Node* tail2 = head2;
    tail2->next = new Node('b'); tail2 = tail2->next;
    tail2->next = new Node('e'); tail2 = tail2->next;
    tail2->next = common_g; // 接入共同后缀（e→g→n→i）

    // 查找共同后缀起始节点
    Node* commonNode = findCommonSuffix(head1, head2);
    if (commonNode != NULL) {
        cout << "共同后缀起始节点的data：" << commonNode->data << endl; // 预期输出'g'
    } else {
        cout << "无共同后缀" << endl;
    }

    // 释放内存（注意：共同节点只释放一次）
    Node* temp = NULL;
    // 释放链表1
    while (head1 != NULL) {
        temp = head1;
        head1 = head1->next;
        if (temp != common_i && temp != common_n && temp != common_g) {
            delete temp;
        }
    }
    // 释放链表2
    while (head2 != NULL) {
        temp = head2;
        head2 = head2->next;
        delete temp;
    }
    // 释放共同节点
    delete common_i;
    delete common_n;
    delete common_g;

    return 0;
}
```

#### 示例

- 链表 1（loading）：`头 → l → o → a → d → g → n → i`
- 链表 2（being）：`头 → b → e → g → n → i`
- 共同后缀起始节点为`g`：
	1. 长度计算：链表 1 长度 6（l,o,a,d,g,n,i），链表 2 长度 4（b,e,g,n,i），`diff=2`；
	2. 链表 1 的快指针先移动 2 步（l→o→a）；
	3. 同步移动：快指针（a→d→g），慢指针（b→e→g），相遇于`g`，输出`g`。

### 3. 删除单链表中绝对值相等的重复节点（2015 年真题）

#### 基本思想

题目要求：仅保留绝对值相等节点的**第一次出现**，删除后续重复节点。利用**空间换时间**策略：

- 已知节点`data`的绝对值≤`N`（`N`为链表长度），因此可创建大小为`N+1`的数组（下标 0~N），记录节点是否已出现（数组值 0 = 未出现，1 = 已出现）；
- 遍历链表，对每个节点取`data`的绝对值作为数组下标：
	- 若数组值为 0：标记为 1，指针后移；
	- 若数组值为 1：删除该节点，释放内存，调整指针指向。

#### 实现步骤

1. 计算链表长度`N`；
2. 动态创建数组`flag`（大小`N+1`），初始化为 0；
3. 遍历链表，用前驱指针`prev`和当前指针`curr`跟踪节点：
	- `curr = prev->next`，取`abs(curr->data)`作为下标`idx`；
	- 若`flag[idx] == 0`：标记`flag[idx] = 1`，`prev`和`curr`后移；
	- 若`flag[idx] == 1`：删除`curr`，`prev->next = curr->next`，释放`curr`，`curr = prev->next`；
4. 遍历结束后，释放数组内存。

#### C++ 代码

cpp







```cpp
#include <iostream>
#include <cstdlib> // for abs()
using namespace std;

// 节点定义（数据域为int）
struct Node {
    int data;
    Node* next;
    Node(int d = 0, Node* n = NULL) : data(d), next(n) {}
};

// 计算链表长度
int getListLength(Node* head) {
    int len = 0;
    Node* p = head->next;
    while (p != NULL) {
        len++;
        p = p->next;
    }
    return len;
}

// 删除绝对值相等的重复节点：head为表头，N为链表长度
void removeAbsDuplicate(Node* head, int N) {
    if (head == NULL || head->next == NULL || N <= 1) {
        return; // 空链表或只有一个节点，无需删除
    }

    // 步骤1：创建标记数组，初始化为0（0=未出现，1=已出现）
    int* flag = new int[N + 1](); // ()表示默认初始化0
    Node* prev = head; // 前驱指针
    Node* curr = head->next; // 当前指针
    int idx = 0; // 数组下标（绝对值）

    // 步骤2：遍历链表，删除重复节点
    while (curr != NULL) {
        idx = abs(curr->data);
        if (flag[idx] == 0) {
            // 第一次出现：标记，指针后移
            flag[idx] = 1;
            prev = curr;
            curr = curr->next;
        } else {
            // 重复出现：删除curr节点
            prev->next = curr->next;
            delete curr; // 释放内存
            curr = prev->next; // 重新指向新的当前节点
        }
    }

    // 步骤3：释放数组内存
    delete[] flag;
}

// 测试：构造链表（头→21→-15→-15→7→-7→15）
void printList(Node* head) {
    Node* p = head->next;
    while (p != NULL) {
        cout << p->data << " ";
        p = p->next;
    }
    cout << endl;
}

int main() {
    // 构造表头节点
    Node* head = new Node();
    // 尾插法构造链表
    Node* tail = head;
    int arr[] = {21, -15, -15, 7, -7, 15};
    for (int num : arr) {
        tail->next = new Node(num);
        tail = tail->next;
    }

    // 输出原链表
    cout << "原链表：";
    printList(head);

    // 计算链表长度N=6
    int N = getListLength(head);
    // 删除绝对值相等的重复节点
    removeAbsDuplicate(head, N);

    // 输出删除后的链表（预期：21 -15 7）
    cout << "删除后链表：";
    printList(head);

    // 释放链表内存
    Node* temp = NULL;
    while (head != NULL) {
        temp = head;
        head = head->next;
        delete temp;
    }

    return 0;
}
```

#### 示例

- 原链表：`头 → 21 → -15 → -15 → 7 → -7 → 15`
- 处理过程：
	1. 数组`flag`大小 7（0~6？不，N=6，数组大小 7（0~6）？不对，`data`绝对值最大为 21，哦视频中说 “data 绝对值≤N”，N 是链表长度，这里示例可能调整为`data`绝对值≤6，实际按题目条件）；
	2. 遍历：
		- 21（绝对值 21，若 N≥21，`flag[21]=1`）；
		- -15（绝对值 15，`flag[15]=1`）；
		- 下一个 - 15（`flag[15]=1`，删除）；
		- 7（`flag[7]=1`）；
		- -7（`flag[7]=1`，删除）；
		- 15（`flag[15]=1`，删除）；
	3. 最终链表：`21 → -15 → 7`。

### 4. 反转单链表

#### 基本思想

采用**三指针法**，避免链表断裂（单链表无法回溯，需提前保存后继节点）：

- 定义三个指针：`prev`（前驱节点，初始`NULL`）、`curr`（当前节点，初始首节点）、`nextNode`（后继节点，保存`curr`的下一个节点）；
- 遍历链表，每次将`curr`的`next`指向`prev`（反转指针方向），然后三个指针依次后移；
- 遍历结束后，`prev`指向原链表尾节点，成为新链表的首节点，表头节点的`next`指向`prev`。

#### 实现步骤

1. 初始化三指针：`prev = NULL`，`curr = head->next`，`nextNode = NULL`；
2. 循环：若`curr != NULL`：
	- 保存`curr`的后继：`nextNode = curr->next`；
	- 反转`curr`的指针：`curr->next = prev`；
	- 指针后移：`prev = curr`，`curr = nextNode`；
3. 调整表头：`head->next = prev`（`prev`为新首节点）。

#### C++ 代码

cpp







```cpp
#include <iostream>
using namespace std;

// 节点定义（数据域为int）
struct Node {
    int data;
    Node* next;
    Node(int d = 0, Node* n = NULL) : data(d), next(n) {}
};

// 反转单链表：head为表头
void reverseList(Node* head) {
    if (head == NULL || head->next == NULL) {
        return; // 空链表或只有一个节点，无需反转
    }

    // 步骤1：初始化三指针
    Node* prev = NULL;       // 前驱节点
    Node* curr = head->next; // 当前节点（首节点）
    Node* nextNode = NULL;   // 后继节点（保存curr->next）

    // 步骤2：遍历链表，反转指针
    while (curr != NULL) {
        nextNode = curr->next; // 保存后继，避免断裂
        curr->next = prev;     // 反转当前节点的指针
        // 指针后移
        prev = curr;
        curr = nextNode;
    }

    // 步骤3：表头指向新首节点（原尾节点prev）
    head->next = prev;
}

// 打印链表
void printList(Node* head) {
    Node* p = head->next;
    while (p != NULL) {
        cout << p->data << " ";
        p = p->next;
    }
    cout << endl;
}

// 测试：构造链表（头→1→2→3→4→5→6）
int main() {
    // 构造表头节点
    Node* head = new Node();
    // 尾插法构造链表
    Node* tail = head;
    for (int i = 1; i <= 6; i++) {
        tail->next = new Node(i);
        tail = tail->next;
    }

    // 输出原链表
    cout << "原链表：";
    printList(head);

    // 反转链表
    reverseList(head);

    // 输出反转后链表（预期：6 5 4 3 2 1）
    cout << "反转后链表：";
    printList(head);

    // 释放内存
    Node* temp = NULL;
    while (head != NULL) {
        temp = head;
        head = head->next;
        delete temp;
    }

    return 0;
}
```

#### 示例

- 原链表：`头 → 1 → 2 → 3 → 4 → 5 → 6`
- 反转过程：
	1. 初始：`prev=NULL`，`curr=1`，`nextNode=2`；
	2. 第一次循环：`1->next=NULL`，`prev=1`，`curr=2`；
	3. 第二次循环：`2->next=1`，`prev=2`，`curr=3`；
		...
	4. 最终：`prev=6`，表头`next=6`，链表变为`头 → 6 → 5 → 4 → 3 → 2 → 1`。

### 5. 删除单链表的中间节点

#### 基本思想

采用**快慢指针（步长差 2:1）** 定位中间节点：

- 快指针（`fast`）每次移动 2 步，慢指针（`slow`）每次移动 1 步；
- 当快指针指向`NULL`（奇数节点）或快指针的`next`指向`NULL`（偶数节点）时，慢指针的`next`即为**中间节点**（偶数节点取偏后的中间节点）；
- 删除中间节点：调整慢指针的`next`，释放中间节点内存。

#### 实现步骤

1. 初始化快慢指针：`fast = head->next`（首节点），`slow = head`（表头）；
2. 循环：若`fast != NULL && fast->next != NULL`：
	- 快指针移动 2 步：`fast = fast->next->next`；
	- 慢指针移动 1 步：`slow = slow->next`；
3. 定位中间节点：`midNode = slow->next`；
4. 删除中间节点：`slow->next = midNode->next`，释放`midNode`。

#### C++ 代码

cpp







```cpp
#include <iostream>
using namespace std;

// 节点定义（数据域为int）
struct Node {
    int data;
    Node* next;
    Node(int d = 0, Node* n = NULL) : data(d), next(n) {}
};

// 删除中间节点：head为表头
void deleteMiddleNode(Node* head) {
    if (head == NULL || head->next == NULL) {
        return; // 空链表或只有一个节点，无中间节点
    }

    // 步骤1：初始化快慢指针
    Node* fast = head->next; // 快指针：首节点，每次走2步
    Node* slow = head;       // 慢指针：表头，每次走1步
    Node* midNode = NULL;    // 中间节点

    // 步骤2：移动指针，定位中间节点的前驱（slow）
    while (fast != NULL && fast->next != NULL) {
        fast = fast->next->next; // 快指针走2步
        slow = slow->next;       // 慢指针走1步
    }

    // 步骤3：删除中间节点（slow->next即为中间节点）
    midNode = slow->next;
    slow->next = midNode->next;
    delete midNode; // 释放内存
}

// 打印链表
void printList(Node* head) {
    Node* p = head->next;
    while (p != NULL) {
        cout << p->data << " ";
        p = p->next;
    }
    cout << endl;
}

// 测试：构造链表（头→1→2→3→4→5→6→7）（奇数节点，中间为4；偶数节点如1-6，中间为4）
int main() {
    // 构造表头节点
    Node* head = new Node();
    // 尾插法构造链表（1-7，奇数节点）
    Node* tail = head;
    for (int i = 1; i <= 7; i++) {
        tail->next = new Node(i);
        tail = tail->next;
    }

    // 输出原链表
    cout << "原链表（1-7）：";
    printList(head);

    // 删除中间节点（预期删除4，链表变为1 2 3 5 6 7）
    deleteMiddleNode(head);
    cout << "删除中间节点后：";
    printList(head);

    // 释放内存
    Node* temp = NULL;
    while (head != NULL) {
        temp = head;
        head = head->next;
        delete temp;
    }

    return 0;
}
```

#### 示例

- 原链表（奇数节点）：`头 → 1 → 2 → 3 → 4 → 5 → 6 → 7`
- 定位过程：
	1. 初始：`fast=1`，`slow=head`；
	2. 第一次循环：`fast=3`，`slow=1`；
	3. 第二次循环：`fast=5`，`slow=2`；
	4. 第三次循环：`fast=7`，`slow=3`；
	5. 第四次循环：`fast=NULL`（7->next=6->next=NULL），退出循环；
	6. 中间节点为`slow->next=4`，删除后链表：`1 → 2 → 3 → 5 → 6 → 7`。

### 6. 单链表重新排列（A₁→Aₙ→A₂→Aₙ₋₁→A₃→Aₙ₋₂→…）

#### 基本思想

结合 “找中间节点” 和 “反转链表”，分三步实现：

1. **找中间节点**：用快慢指针将链表分为前半段（A₁~Aₘ）和后半段（Aₘ₊₁~Aₙ）；
2. **反转后半段**：将后半段反转（Aₙ~Aₘ₊₁）；
3. **穿插合并**：将反转后的后半段节点依次插入前半段的间隙（A₁后插 Aₙ，A₂后插 Aₙ₋₁，…）。

#### 实现步骤

1. 找中间节点：快慢指针定位中间节点的前驱，断开链表（前半段尾节点`next=NULL`）；
2. 反转后半段：用三指针法反转后半段；
3. 穿插合并：定义`p1`（前半段指针）、`p2`（后半段指针），保存`p1`的后继，将`p2`插入`p1`后，依次后移指针。

#### C++ 代码

cpp







```cpp
#include <iostream>
using namespace std;

// 节点定义（数据域为int）
struct Node {
    int data;
    Node* next;
    Node(int d = 0, Node* n = NULL) : data(d), next(n) {}
};

// 步骤1：找中间节点，断开链表为前半段和后半段
Node* findMiddleAndSplit(Node* head) {
    if (head == NULL || head->next == NULL) {
        return NULL; // 空链表或只有一个节点，无后半段
    }

    Node* fast = head->next;
    Node* slow = head;
    // 找中间节点的前驱（slow）
    while (fast != NULL && fast->next != NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }

    Node* secondHalf = slow->next; // 后半段首节点
    slow->next = NULL;             // 断开前半段和后半段
    return secondHalf;
}

// 步骤2：反转链表（用于反转后半段）
Node* reverseList(Node* head) {
    if (head == NULL) {
        return NULL;
    }

    Node* prev = NULL;
    Node* curr = head;
    Node* nextNode = NULL;
    while (curr != NULL) {
        nextNode = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextNode;
    }
    return prev; // 反转后的首节点
}

// 步骤3：穿插合并前半段和反转后的后半段
void mergeLists(Node* firstHalf, Node* reversedSecondHalf) {
    Node* p1 = firstHalf->next; // 前半段指针（首节点）
    Node* p2 = reversedSecondHalf; // 后半段指针（反转后的首节点）
    Node* temp1 = NULL; // 保存p1的后继
    Node* temp2 = NULL; // 保存p2的后继

    while (p1 != NULL && p2 != NULL) {
        // 保存后继
        temp1 = p1->next;
        temp2 = p2->next;

        // 将p2插入p1后
        p1->next = p2;
        p2->next = temp1;

        // 指针后移
        p1 = temp1;
        p2 = temp2;
    }
}

// 整体重新排列函数
void reorderList(Node* head) {
    if (head == NULL || head->next == NULL) {
        return;
    }

    // 步骤1：找中间节点，断开为前半段和后半段
    Node* secondHalf = findMiddleAndSplit(head);
    // 步骤2：反转后半段
    Node* reversedSecondHalf = reverseList(secondHalf);
    // 步骤3：穿插合并
    mergeLists(head, reversedSecondHalf);
}

// 打印链表
void printList(Node* head) {
    Node* p = head->next;
    while (p != NULL) {
        cout << p->data << " ";
        p = p->next;
    }
    cout << endl;
}

// 测试：构造链表（头→1→2→3→4→5→6）（预期排列：1→6→2→5→3→4）
int main() {
    // 构造表头节点
    Node* head = new Node();
    // 尾插法构造链表（1-6）
    Node* tail = head;
    for (int i = 1; i <= 6; i++) {
        tail->next = new Node(i);
        tail = tail->next;
    }

    // 输出原链表
    cout << "原链表（1-6）：";
    printList(head);

    // 重新排列链表
    reorderList(head);

    // 输出排列后链表（预期：1 6 2 5 3 4）
    cout << "重新排列后：";
    printList(head);

    // 释放内存
    Node* temp = NULL;
    while (head != NULL) {
        temp = head;
        head = head->next;
        delete temp;
    }

    return 0;
}
```

#### 示例

- 原链表：`头 → 1 → 2 → 3 → 4 → 5 → 6`

- 步骤 1：找中间节点，断开为前半段（1→2→3）和后半段（4→5→6）；

- 步骤 2：反转后半段为（6→5→4）；

- 步骤 3：穿插合并：

	1. 1 后插 6 → 1→6→2→3；
	2. 2 后插 5 → 1→6→2→5→3；
	3. 3 后插 4 → 1→6→2→5→3→4；

- 最终链表：`1 → 6 → 2 → 5 → 3 → 4`。

- ### 7. 判断单链表是否有环（2018 年真题）

	#### 基本思想

	利用**快慢指针（追击问题）** 特性：若链表无环，快指针会率先到达链表尾（指向`NULL`）；若链表有环，快指针会在环内循环，并最终与慢指针相遇（快指针速度是慢指针 2 倍，必然会追上）。

	- 快指针（`fast`）：每次移动 2 步；
	- 慢指针（`slow`）：每次移动 1 步；
	- 核心结论：若两指针在遍历过程中相遇（地址相同），则链表有环；若快指针指向`NULL`或`fast->next == NULL`，则链表无环。

	#### 实现步骤

	1. 初始化快慢指针，均指向**首节点**（表头节点的`next`）；
	2. 循环遍历：若`fast != NULL`且`fast->next != NULL`（避免快指针越界）：
		- 快指针移动 2 步：`fast = fast->next->next`；
		- 慢指针移动 1 步：`slow = slow->next`；
		- 若`fast == slow`，立即返回`true`（有环）；
	3. 循环结束（快指针到达链表尾），返回`false`（无环）。

	#### C++ 代码

	cpp

	

	

	

	```cpp
	#include <iostream>
	using namespace std;
	
	// 节点定义（数据域为int）
	struct Node {
	    int data;
	    Node* next;
	    Node(int d = 0, Node* n = NULL) : data(d), next(n) {}
	};
	
	// 判断链表是否有环：head为表头，返回true=有环，false=无环
	bool hasCycle(Node* head) {
	    if (head == NULL || head->next == NULL) {
	        return false; // 空链表或仅1个节点，无环
	    }
	
	    Node* fast = head->next; // 快指针：首节点，每次2步
	    Node* slow = head->next; // 慢指针：首节点，每次1步
	
	    while (fast != NULL && fast->next != NULL) {
	        fast = fast->next->next; // 快指针移动2步
	        slow = slow->next;       // 慢指针移动1步
	
	        if (fast == slow) {      // 两指针相遇，有环
	            return true;
	        }
	    }
	
	    return false; // 快指针到尾，无环
	}
	
	// 测试：构造有环和无环链表
	int main() {
	    // --------------- 测试1：无环链表（1→2→3→4→5）---------------
	    Node* head1 = new Node();
	    Node* tail1 = head1;
	    for (int i = 1; i <= 5; i++) {
	        tail1->next = new Node(i);
	        tail1 = tail1->next;
	    }
	    cout << "无环链表（1→2→3→4→5）：" << (hasCycle(head1) ? "有环" : "无环") << endl; // 预期：无环
	
	    // --------------- 测试2：有环链表（1→2→3→4→2，环入口为2）---------------
	    Node* head2 = new Node();
	    Node* node2 = new Node(2);
	    Node* node3 = new Node(3);
	    Node* node4 = new Node(4);
	    // 构建链表：头→1→2→3→4→2（形成环）
	    head2->next = new Node(1);
	    head2->next->next = node2;
	    node2->next = node3;
	    node3->next = node4;
	    node4->next = node2; // 关键：4的next指向2，形成环
	    cout << "有环链表（1→2→3→4→2）：" << (hasCycle(head2) ? "有环" : "无环") << endl; // 预期：有环
	
	    // 释放内存（无环链表正常释放，有环链表需手动断开环再释放）
	    // 释放无环链表head1
	    Node* temp = NULL;
	    while (head1 != NULL) {
	        temp = head1;
	        head1 = head1->next;
	        delete temp;
	    }
	    // 释放有环链表head2（先断开环）
	    node4->next = NULL; // 断开4→2的环
	    delete head2->next; // 释放节点1
	    delete node2;       // 释放节点2
	    delete node3;       // 释放节点3
	    delete node4;       // 释放节点4
	    delete head2;       // 释放表头
	
	    return 0;
	}
	```

	#### 示例

	- 无环链表：`头 → 1 → 2 → 3 → 4 → 5`
		遍历过程：快指针依次经过 1→3→5→NULL，循环结束，返回 “无环”。
	- 有环链表：`头 → 1 → 2 → 3 → 4 → 2（环）`
		遍历过程：
		1. 初始：`fast=1`，`slow=1`；
		2. 1 次循环：`fast=3`，`slow=2`；
		3. 2 次循环：`fast=2`，`slow=3`；
		4. 3 次循环：`fast=4`，`slow=4`（相遇），返回 “有环”。

	### 8. 查找环形单链表的入口节点（2019 年真题）

	#### 基本思想

	基于 “判断链表是否有环” 的基础，结合**数学推导**定位环入口：

	1. 设链表头到环入口的距离为`L`，环入口到快慢指针相遇点的距离为`X`，环的长度为`C`；
	2. 相遇时：慢指针走了`L + X`，快指针走了`L + X + n*C`（`n`为快指针在环内循环的次数）；
	3. 因快指针速度是慢指针 2 倍，故`2*(L + X) = L + X + n*C`，化简得`L = n*C - X`；
	4. 结论：相遇后，让慢指针回表头，快慢指针均改为每次移动 1 步，再次相遇的节点即为**环入口**。

	#### 实现步骤

	1. 先通过快慢指针判断链表是否有环，若无环返回`NULL`；若有环，记录两指针相遇点；
	2. 慢指针重新指向**表头节点的 next**（首节点），快指针保持在相遇点；
	3. 快慢指针同步移动（每次 1 步），直到两指针相遇；
	4. 相遇节点即为环入口，返回该节点。

	#### C++ 代码

	cpp

	

	

	

	```cpp
	#include <iostream>
	using namespace std;
	
	// 节点定义（数据域为int）
	struct Node {
	    int data;
	    Node* next;
	    Node(int d = 0, Node* n = NULL) : data(d), next(n) {}
	};
	
	// 辅助函数：判断环并返回相遇点（无环返回NULL）
	Node* findMeetPoint(Node* head) {
	    if (head == NULL || head->next == NULL) {
	        return NULL;
	    }
	    Node* fast = head->next;
	    Node* slow = head->next;
	    while (fast != NULL && fast->next != NULL) {
	        fast = fast->next->next;
	        slow = slow->next;
	        if (fast == slow) {
	            return fast; // 返回相遇点
	        }
	    }
	    return NULL; // 无环
	}
	
	// 查找环入口节点：head为表头，返回入口节点（无环返回NULL）
	Node* findCycleEntry(Node* head) {
	    Node* meetPoint = findMeetPoint(head);
	    if (meetPoint == NULL) {
	        return NULL; // 无环，无入口
	    }
	
	    // 慢指针回表头首节点，快指针在相遇点
	    Node* slow = head->next;
	    Node* fast = meetPoint;
	
	    // 同步移动1步，相遇即为入口
	    while (slow != fast) {
	        slow = slow->next;
	        fast = fast->next;
	    }
	
	    return slow; // 返回入口节点
	}
	
	// 测试：构造有环链表（1→2→3→4→5→2，环入口为2）
	int main() {
	    // 构建有环链表：头→1→2→3→4→5→2
	    Node* head = new Node();
	    Node* entryNode = new Node(2); // 环入口节点
	    // 依次创建节点并连接
	    head->next = new Node(1);
	    head->next->next = entryNode;
	    entryNode->next = new Node(3);
	    entryNode->next->next = new Node(4);
	    entryNode->next->next->next = new Node(5);
	    entryNode->next->next->next->next = entryNode; // 5→2，形成环
	
	    // 查找环入口
	    Node* cycleEntry = findCycleEntry(head);
	    if (cycleEntry != NULL) {
	        cout << "环入口节点的data：" << cycleEntry->data << endl; // 预期：2
	    } else {
	        cout << "链表无环，无入口节点" << endl;
	    }
	
	    // 释放内存（先断开环）
	    entryNode->next->next->next->next = NULL; // 断开5→2的环
	    Node* temp = NULL;
	    while (head != NULL) {
	        temp = head;
	        head = head->next;
	        delete temp;
	    }
	
	    return 0;
	}
	```

	#### 示例

	- 有环链表：`头 → 1 → 2（入口）→ 3 → 4 → 5 → 2（环）`
		步骤 1：判断环并找相遇点：
		- 快慢指针相遇于节点 4（假设`n=1`，`L=1`，`X=2`，`C=4`，满足`L = C - X`）；
			步骤 2：慢指针回 1，快指针在 4；
			步骤 3：同步移动：
		- 慢指针：1→2，快指针：4→5→2；
		- 两指针在 2 相遇，返回节点 2（环入口）。

	### 9. 合并两个有序单链表（升序，2016 年真题）

	#### 基本思想

	采用**双指针遍历 + 尾插法**，合并后保持链表升序：

	- 定义两个指针`p1`、`p2`，分别指向两个有序链表的首节点；
	- 定义新链表的表头`newHead`和尾指针`newTail`，用于构建合并后的链表；
	- 比较`p1->data`和`p2->data`，将值较小的节点接入新链表尾部，对应指针后移；
	- 当其中一个链表遍历结束后，将另一个链表的剩余节点直接接入新链表尾部。

	#### 实现步骤

	1. 初始化新链表表头`newHead`（空表头）和尾指针`newTail`（指向`newHead`）；
	2. 初始化`p1`（链表 1 首节点）、`p2`（链表 2 首节点）；
	3. 循环遍历：若`p1 != NULL`且`p2 != NULL`：
		- 若`p1->data <= p2->data`：将`p1`接入新链表，`p1`后移；
		- 否则：将`p2`接入新链表，`p2`后移；
		- `newTail`始终指向新链表尾部；
	4. 处理剩余节点：若`p1 != NULL`，将`p1`及后续节点接入新链表；若`p2 != NULL`，同理；
	5. 返回新链表表头`newHead`。

	#### C++ 代码

	cpp

	

	

	

	```cpp
	#include <iostream>
	using namespace std;
	
	// 节点定义（数据域为int）
	struct Node {
	    int data;
	    Node* next;
	    Node(int d = 0, Node* n = NULL) : data(d), next(n) {}
	};
	
	// 合并两个升序有序链表：head1、head2为表头，返回合并后链表的表头
	Node* mergeTwoSortedLists(Node* head1, Node* head2) {
	    // 初始化新链表表头（空表头）
	    Node* newHead = new Node();
	    Node* newTail = newHead; // 新链表尾指针，初始指向表头
	
	    Node* p1 = head1->next; // 链表1的首节点
	    Node* p2 = head2->next; // 链表2的首节点
	
	    // 步骤1：遍历两个链表，合并较小节点
	    while (p1 != NULL && p2 != NULL) {
	        if (p1->data <= p2->data) {
	            newTail->next = p1; // 接入p1
	            p1 = p1->next;      // p1后移
	        } else {
	            newTail->next = p2; // 接入p2
	            p2 = p2->next;      // p2后移
	        }
	        newTail = newTail->next; // 尾指针后移
	    }
	
	    // 步骤2：处理剩余节点（若有）
	    if (p1 != NULL) {
	        newTail->next = p1;
	    }
	    if (p2 != NULL) {
	        newTail->next = p2;
	    }
	
	    // 释放原链表的空表头（避免内存泄漏）
	    delete head1;
	    delete head2;
	
	    return newHead;
	}
	
	// 打印链表
	void printList(Node* head) {
	    Node* p = head->next;
	    while (p != NULL) {
	        cout << p->data << " ";
	        p = p->next;
	    }
	    cout << endl;
	}
	
	// 测试：合并两个升序链表（1→3→5和2→4→6）
	int main() {
	    // 构建链表1：头→1→3→5
	    Node* head1 = new Node();
	    Node* tail1 = head1;
	    tail1->next = new Node(1); tail1 = tail1->next;
	    tail1->next = new Node(3); tail1 = tail1->next;
	    tail1->next = new Node(5); tail1 = tail1->next;
	    cout << "链表1（升序）：";
	    printList(head1);
	
	    // 构建链表2：头→2→4→6
	    Node* head2 = new Node();
	    Node* tail2 = head2;
	    tail2->next = new Node(2); tail2 = tail2->next;
	    tail2->next = new Node(4); tail2 = tail2->next;
	    tail2->next = new Node(6); tail2 = tail2->next;
	    cout << "链表2（升序）：";
	    printList(head2);
	
	    // 合并链表
	    Node* mergedHead = mergeTwoSortedLists(head1, head2);
	    cout << "合并后链表（升序）：";
	    printList(mergedHead);
	
	    // 释放合并后链表内存
	    Node* temp = NULL;
	    while (mergedHead != NULL) {
	        temp = mergedHead;
	        mergedHead = mergedHead->next;
	        delete temp;
	    }
	
	    return 0;
	}
	```

	#### 示例

	- 链表 1：`头 → 1 → 3 → 5`
	- 链表 2：`头 → 2 → 4 → 6`
	- 合并过程：
		1. `p1=1`，`p2=2`：1≤2，接入 1→新链表：1；
		2. `p1=3`，`p2=2`：3>2，接入 2→新链表：1→2；
		3. `p1=3`，`p2=4`：3≤4，接入 3→新链表：1→2→3；
		4. `p1=5`，`p2=4`：5>4，接入 4→新链表：1→2→3→4；
		5. `p1=5`，`p2=6`：5≤6，接入 5→新链表：1→2→3→4→5；
		6. `p1=NULL`，接入剩余 p2=6→最终链表：1→2→3→4→5→6。

	### 10. 删除链表中所有值为 val 的节点（2020 年真题）

	#### 基本思想

	采用**前驱指针 + 当前指针**组合，避免删除节点后丢失后续节点：

	- 前驱指针`prev`：始终指向当前节点的前一个节点，初始指向表头；
	- 当前指针`curr`：指向当前遍历的节点，初始指向首节点；
	- 遍历链表：若`curr->data == val`，则删除`curr`（`prev->next = curr->next`），释放内存并更新`curr`；若不相等，则`prev`和`curr`同步后移。

	#### 实现步骤

	1. 初始化`prev`（表头节点）、`curr`（首节点）；
	2. 循环遍历：若`curr != NULL`：
		- 若`curr->data == val`：
			- 保存`curr`的后继节点：`temp = curr->next`；
			- 删除`curr`：`prev->next = temp`，`delete curr`；
			- 更新`curr`为后继节点：`curr = temp`；
		- 否则：
			- `prev`后移：`prev = curr`；
			- `curr`后移：`curr = curr->next`；
	3. 遍历结束，链表中所有值为`val`的节点已删除。

	#### C++ 代码

	cpp

	

	

	```cpp
	#include <iostream>
	using namespace std;
	
	// 节点定义（数据域为int）
	struct Node {
	    int data;
	    Node* next;
	    Node(int d = 0, Node* n = NULL) : data(d), next(n) {}
	};
	
	// 删除链表中所有值为val的节点：head为表头，val为目标值
	void removeAllVal(Node* head, int val) {
	    if (head == NULL || head->next == NULL) {
	        return; // 空链表或无有效节点，无需删除
	    }
	
	    Node* prev = head;       // 前驱指针（初始指向表头）
	    Node* curr = head->next; // 当前指针（初始指向首节点）
	    Node* temp = NULL;       // 临时指针，保存curr的后继
	
	    while (curr != NULL) {
	        if (curr->data == val) {
	            // 步骤1：删除当前节点
	            temp = curr->next; // 保存后继
	            prev->next = temp; // 前驱指向后继，跳过curr
	            delete curr;       // 释放curr内存
	            curr = temp;       // 更新curr为后继
	        } else {
	            // 步骤2：指针后移
	            prev = curr;
	            curr = curr->next;
	        }
	    }
	}
	
	// 打印链表
	void printList(Node* head) {
	    Node* p = head->next;
	    while (p != NULL) {
	        cout << p->data << " ";
	        p = p->next;
	    }
	    cout << endl;
	}
	
	// 测试：删除链表中所有值为6的节点（原链表：1→2→6→3→4→5→6）
	int main() {
	    // 构建原链表：头→1→2→6→3→4→5→6
	    Node* head = new Node();
	    Node* tail = head;
	    int arr[] = {1, 2, 6, 3, 4, 5, 6};
	    for (int num : arr) {
	        tail->next = new Node(num);
	        tail = tail->next;
	    }
	
	    cout << "原链表：";
	    printList(head);
	
	    // 删除所有值为6的节点
	    int val = 6;
	    removeAllVal(head, val);
	
	    cout << "删除所有值为" << val << "后的链表：";
	    printList(head);
	
	    // 释放链表内存
	    Node* temp = NULL;
	    while (head != NULL) {
	        temp = head;
	        head = head->next;
	        delete temp;
	    }
	
	    return 0;
	}
	```

	#### 示例

	- 原链表：`头 → 1 → 2 → 6 → 3 → 4 → 5 → 6`

	- 删除`val=6`的过程：

		1. `curr=1`≠6：`prev=1`，`curr=2`；
		2. `curr=2`≠6：`prev=2`，`curr=6`；
		3. `curr=6`==6：删除 6，`prev=2`→`curr=3`；
		4. `curr=3`≠6：`prev=3`，`curr=4`；
		5. `curr=4`≠6：`prev=4`，`curr=5`；
		6. `curr=5`≠6：`prev=5`，`curr=6`；
		7. `curr=6`==6：删除 6，`prev=5`→`curr=NULL`；

	- 最终链表：`1 → 2 → 3 → 4 → 5`。

	- ### 11. 重新排列单链表（2019 年真题）

		#### 基本思想

		基于视频讲解的 “分步拆解 + 组合” 思路，核心是利用**找中间节点**和**反转链表**两个前置知识点，实现空间复杂度 O (1)、时间复杂度 O (n) 的高效解法，具体分为 4 步：

		1. **找中间节点**：用快慢指针定位链表中间位置（慢指针最终指向 “前半段尾节点”，确保前半段长度≥后半段）；
		2. **断链**：将链表从中间拆分为前后两段（前半段尾节点的`next`设为`NULL`，避免合并时循环）；
		3. **反转后半段**：用三指针法反转后半段链表（与 “反转链表” 知识点完全一致）；
		4. **合并两段**：用双指针 “见缝插针” 合并前后两段 —— 前半段节点后接后半段节点，后半段节点后接前半段下一个节点，交替进行直到其中一段遍历结束。

		#### 实现步骤

		1. **找中间节点（快慢指针）**：
			- 初始化`fast`（快指针，指向首节点）、`slow`（慢指针，指向表头节点）；
			- 循环条件：`fast != NULL && fast->next != NULL`；
			- 每次`fast`移动 2 步、`slow`移动 1 步，最终`slow`指向**前半段尾节点**（例：链表 1→2→3→4→5→6，`slow`指向 3）。
		2. **断链**：
			- 保存后半段首节点：`secondHalf = slow->next`；
			- 前半段尾节点断链：`slow->next = NULL`（前半段变为 1→2→3，后半段变为 4→5→6）。
		3. **反转后半段**：
			- 用`first`（前驱，初始`NULL`）、`second`（当前，初始`secondHalf`）、`third`（后继，临时保存）三指针反转，得到反转后的后半段（例：6→5→4）。
		4. **合并两段**：
			- 初始化双指针`p1`（前半段首节点，1）、`p2`（反转后后半段首节点，6）；
			- 循环条件：`p1 != NULL && p2 != NULL`；
			- 保存`p1`的后继（`temp1 = p1->next`）和`p2`的后继（`temp2 = p2->next`）；
			- 连接逻辑：`p1->next = p2`（1→6）→ `p2->next = temp1`（6→2）→ 更新`p1 = temp1`、`p2 = temp2`；
			- 循环结束后，若前半段有剩余节点（如链表长度为奇数），无需额外处理（已自然连接）。

		#### C++ 代码

		cpp

		

		

		

		```cpp
		#include <iostream>
		using namespace std;
		
		// 节点定义（数据域为int，带头节点）
		struct Node {
		    int data;
		    Node* next;
		    Node(int d = 0, Node* n = NULL) : data(d), next(n) {}
		};
		
		// 辅助函数1：反转链表（返回反转后链表的表头）
		Node* reverseList(Node* head) {
		    if (head == NULL || head->next == NULL) {
		        return head; // 空链表或仅表头，无需反转
		    }
		    Node* first = NULL;    // 前驱指针（初始空）
		    Node* second = head->next; // 当前指针（后半段首节点）
		    Node* third = NULL;    // 后继指针（临时保存）
		
		    while (second != NULL) {
		        third = second->next; // 保存当前节点的后继
		        second->next = first; // 反转当前节点的指针
		        // 指针后移
		        first = second;
		        second = third;
		    }
		    // 重建反转后链表的表头（原表头仍保留，仅更新next）
		    head->next = first;
		    return head;
		}
		
		// 核心函数：重新排列链表（A1→An→A2→An-1→...）
		void reorderList(Node* head) {
		    if (head == NULL || head->next == NULL || head->next->next == NULL) {
		        return; // 空链表、仅1个节点或2个节点，无需重排
		    }
		
		    // 步骤1：找中间节点（slow最终指向前半段尾节点）
		    Node* fast = head->next; // 快指针：首节点，每次2步
		    Node* slow = head;       // 慢指针：表头，每次1步
		    while (fast != NULL && fast->next != NULL) {
		        fast = fast->next->next;
		        slow = slow->next;
		    }
		
		    // 步骤2：断链（拆分为前半段和后半段）
		    Node* secondHalfHead = new Node(); // 后半段的表头
		    secondHalfHead->next = slow->next; // 后半段首节点：slow的next
		    slow->next = NULL;                 // 前半段尾节点断链
		
		    // 步骤3：反转后半段
		    secondHalfHead = reverseList(secondHalfHead);
		
		    // 步骤4：合并两段（见缝插针）
		    Node* p1 = head->next;        // 前半段指针（1→2→3）
		    Node* p2 = secondHalfHead->next; // 反转后后半段指针（6→5→4）
		    Node* temp1 = NULL;           // 保存p1的后继
		    Node* temp2 = NULL;           // 保存p2的后继
		
		    while (p1 != NULL && p2 != NULL) {
		        // 保存后继节点
		        temp1 = p1->next;
		        temp2 = p2->next;
		
		        // 连接：p1 → p2 → temp1（前半段下一个节点）
		        p1->next = p2;
		        p2->next = temp1;
		
		        // 指针后移
		        p1 = temp1;
		        p2 = temp2;
		    }
		
		    // 释放后半段的空表头（避免内存泄漏）
		    delete secondHalfHead;
		}
		
		// 辅助函数：打印链表
		void printList(Node* head) {
		    Node* p = head->next;
		    while (p != NULL) {
		        cout << p->data << " ";
		        p = p->next;
		    }
		    cout << endl;
		}
		
		// 测试：原链表1→2→3→4→5→6，重排后为1→6→2→5→3→4
		int main() {
		    // 构建原链表：头→1→2→3→4→5→6
		    Node* head = new Node();
		    Node* tail = head;
		    for (int i = 1; i <= 6; i++) {
		        tail->next = new Node(i);
		        tail = tail->next;
		    }
		
		    cout << "原链表：";
		    printList(head);
		
		    // 重新排列链表
		    reorderList(head);
		
		    cout << "重排后链表（A1→An→A2→An-1）：";
		    printList(head);
		
		    // 释放链表内存
		    Node* temp = NULL;
		    while (head != NULL) {
		        temp = head;
		        head = head->next;
		        delete temp;
		    }
		
		    return 0;
		}
		```

		#### 示例

		以链表`头 → 1 → 2 → 3 → 4 → 5 → 6`为例，完整流程如下：

		1. **找中间节点**：`fast`遍历到`NULL`时，`slow`指向 3（前半段尾节点）；
		2. **断链**：前半段`1→2→3`（尾节点 3 的`next=NULL`），后半段`4→5→6`；
		3. **反转后半段**：后半段变为`6→5→4`；
		4. **合并**：
			- 第 1 轮：`1→6`，`6→2`（当前链表：1→6→2→3）；
			- 第 2 轮：`2→5`，`5→3`（当前链表：1→6→2→5→3）；
			- 第 3 轮：`3→4`（当前链表：1→6→2→5→3→4）；
			- 最终结果：`1 → 6 → 2 → 5 → 3 → 4`，完全符合`A1→An→A2→An-1→A3→An-2`的要求。

		### 视频核心套路总结（单链表高频考点）

		结合视频中讲解的 11 类问题，单链表解题的核心套路可归纳为 3 类，覆盖 90% 以上真题场景：

		| 套路类型       | 核心思想                                       | 典型应用场景                                                 | 时间复杂度 | 空间复杂度 |
		| -------------- | ---------------------------------------------- | ------------------------------------------------------------ | ---------- | ---------- |
		| **双指针法**   | 用两个指针控制遍历节奏（快慢、前后、分段）     | 1. 找倒数第 K 个节点 2. 判断链表有环 3. 找环入口 4. 找中间节点 5. 找共同后缀 | O(n)       | O(1)       |
		| **三指针反转** | 用 “前驱 - 当前 - 后继” 三指针原地反转指针方向 | 1. 反转整个链表 2. 反转链表后半段（重排链表用）              | O(n)       | O(1)       |
		| **空间换时间** | 用额外数组 / 哈希表记录状态，避免嵌套循环      | 1. 删除绝对值相同的节点（数组记录出现状态） 2. 快速查找重复节点 | O(n)       | O(n)       |

		**关键提醒**：

		- 所有问题均基于 “带头节点的单链表” 设计（视频反复强调，真题默认条件），需注意表头节点不存储数据，遍历从`head->next`开始；

		- 操作后需释放无用节点（避免内存泄漏），尤其是删除、断链场景；

		- 复杂问题（如重排链表）可拆解为多个基础知识点（找中间 + 反转 + 合并），逐个突破后组合即可。

		- ## 一、循环链表：找环的入口

			视频中先回顾**快慢指针判断链表是否有环**，再通过「计数环长度 + 双指针同步移动」找到环的入口，核心逻辑与代码如下：

			### 1. 核心原理

			1. **判断是否有环**：用`fast`（快指针，每次走 2 步）和`slow`（慢指针，每次走 1 步）遍历链表。若两指针相遇，则链表有环；若`fast`走到`NULL`，则无环。
			2. **计算环的节点数**：两指针相遇后，固定`slow`，让`fast`继续遍历（每次 1 步），同时用`count`计数，直到`fast`再次与`slow`相遇，此时`count`即为环的节点数。
			3. **找到环的入口**：将`fast`和`slow`重新指向头节点，让`fast`先走`count`步，再让两指针同步遍历（每次 1 步），相遇的节点即为环的入口。

			### 2. 完整 C++ 代码

			cpp

			

			

			

			```cpp
			#include <iostream>
			using namespace std;
			
			// 链表节点结构体（视频中默认单链表结构）
			struct ListNode {
			    int data;
			    ListNode* next;
			    ListNode(int val) : data(val), next(NULL) {}
			};
			
			// 1. 判断链表是否有环，并返回快慢指针相遇的节点（无环返回NULL）
			ListNode* hasCycle(ListNode* head) {
			    if (head == NULL || head->next == NULL) {
			        return NULL; // 空链表或只有一个节点，无环
			    }
			    ListNode* fast = head;
			    ListNode* slow = head;
			    while (fast != NULL && fast->next != NULL) {
			        fast = fast->next->next; // 快指针走2步
			        slow = slow->next;       // 慢指针走1步
			        if (fast == slow) {
			            return fast; // 相遇，有环，返回相遇节点
			        }
			    }
			    return NULL; // 无环
			}
			
			// 2. 找到环的入口节点（视频中函数名：findBegin）
			ListNode* findCycleEntry(ListNode* head) {
			    ListNode* meetNode = hasCycle(head);
			    if (meetNode == NULL) {
			        return NULL; // 无环，返回NULL
			    }
			
			    // 步骤1：计算环的节点数count
			    int count = 1;
			    ListNode* p = meetNode; // 从相遇节点开始遍历
			    while (p->next != meetNode) {
			        p = p->next;
			        count++;
			    }
			
			    // 步骤2：快指针先走count步
			    ListNode* fast = head;
			    ListNode* slow = head;
			    for (int i = 0; i < count; i++) {
			        fast = fast->next;
			    }
			
			    // 步骤3：快慢指针同步走，相遇即为入口
			    while (fast != slow) {
			        fast = fast->next;
			        slow = slow->next;
			    }
			    return fast; // 或返回slow，两者相同
			}
			
			// 测试：创建带环链表（1->2->3->4->5->6->3，环入口为3）
			int main() {
			    // 创建节点
			    ListNode* head = new ListNode(1);
			    head->next = new ListNode(2);
			    ListNode* entry = new ListNode(3); // 环入口
			    head->next->next = entry;
			    head->next->next->next = new ListNode(4);
			    head->next->next->next->next = new ListNode(5);
			    head->next->next->next->next->next = new ListNode(6);
			    head->next->next->next->next->next->next = entry; // 造环：6->3
			
			    // 查找环入口
			    ListNode* cycleEntry = findCycleEntry(head);
			    if (cycleEntry != NULL) {
			        cout << "环的入口节点值为：" << cycleEntry->data << endl; // 输出3
			    } else {
			        cout << "链表无环" << endl;
			    }
			
			    // （注：带环链表无法常规释放，此处省略内存释放，避免死循环）
			    return 0;
			}
			```

			## 二、双向链表

			视频中定义双向链表为「含前驱指针（`prior`）和后继指针（`next`）的链表」，解决单链表无法反向查找的问题，核心操作包括**头插法、尾插法、指定位置插入、删除节点**。

			### 1. 双向链表节点结构

			cpp

			

			

			

			```cpp
			#include <iostream>
			using namespace std;
			
			// 双向链表节点结构体（视频中prior为前驱指针，next为后继指针）
			struct DListNode {
			    int data;
			    DListNode* prior; // 指向直接前驱
			    DListNode* next;  // 指向直接后继
			    DListNode(int val) : data(val), prior(NULL), next(NULL) {}
			};
			```

			### 2. 核心操作实现（与视频代码一致）

			#### （1）头插法：在表头插入节点

			**逻辑**：新节点的`prior`指向头节点，`next`指向头节点的原后继；原后继的`prior`指向新节点；头节点的`next`指向新节点。

			cpp

			

			

			

			```cpp
			// 头插法（L为头节点，e为插入的值）
			void dListHeadInsert(DListNode* L, int e) {
			    // 1. 创建新节点
			    DListNode* p = new DListNode(e);
			    // 2. 新节点的prior指向头节点
			    p->prior = L;
			    // 3. 新节点的next指向头节点的原后继
			    p->next = L->next;
			    // 4. 若头节点有后继（链表非空），则原后继的prior指向新节点
			    if (L->next != NULL) {
			        L->next->prior = p;
			    }
			    // 5. 头节点的next指向新节点
			    L->next = p;
			}
			
			// 测试头插法：插入10、20、30，遍历结果应为30、20、10
			void testHeadInsert() {
			    DListNode* head = new DListNode(0); // 头节点（数据无意义）
			    dListHeadInsert(head, 10);
			    dListHeadInsert(head, 20);
			    dListHeadInsert(head, 30);
			
			    // 遍历双向链表（从表头往后）
			    DListNode* p = head->next;
			    cout << "头插法遍历结果：";
			    while (p != NULL) {
			        cout << p->data << " "; // 输出30 20 10
			        p = p->next;
			    }
			    cout << endl;
			
			    // （注：此处省略内存释放，实际需反向遍历释放）
			}
			```

			#### （2）尾插法：在表尾插入节点

			**逻辑**：新节点的`prior`指向原尾节点；原尾节点的`next`指向新节点；新节点的`next`设为`NULL`（新尾节点）。

			cpp

			

			

			

			```cpp
			// 尾插法（L为头节点，e为插入的值，tail为原尾节点的引用）
			void dListTailInsert(DListNode* L, int e, DListNode*& tail) {
			    // 1. 创建新节点
			    DListNode* p = new DListNode(e);
			    // 2. 新节点的prior指向原尾节点
			    p->prior = tail;
			    // 3. 原尾节点的next指向新节点
			    tail->next = p;
			    // 4. 新节点的next设为NULL（新尾节点）
			    p->next = NULL;
			    // 5. 更新尾节点为新节点
			    tail = p;
			}
			
			// 测试尾插法：插入10、20、30，遍历结果应为10、20、30
			void testTailInsert() {
			    DListNode* head = new DListNode(0); // 头节点
			    DListNode* tail = head; // 初始尾节点为头节点（链表空）
			    dListTailInsert(head, 10, tail);
			    dListTailInsert(head, 20, tail);
			    dListTailInsert(head, 30, tail);
			
			    // 遍历双向链表
			    DListNode* p = head->next;
			    cout << "尾插法遍历结果：";
			    while (p != NULL) {
			        cout << p->data << " "; // 输出10 20 30
			        p = p->next;
			    }
			    cout << endl;
			
			    // （注：此处省略内存释放）
			}
			```

			#### （3）指定位置插入：在指定前驱节点后插入

			**逻辑**：找到插入位置的前驱节点`p`；新节点的`prior`指向`p`，`next`指向`p`的后继；`p`后继的`prior`指向新节点；`p`的`next`指向新节点。

			cpp

			

			

			

			```cpp
			// 指定位置插入：在值为preVal的节点后插入e（假设preVal唯一）
			bool dListInsertAfter(DListNode* L, int preVal, int e) {
			    // 1. 找到前驱节点p（值为preVal）
			    DListNode* p = L->next;
			    while (p != NULL && p->data != preVal) {
			        p = p->next;
			    }
			    if (p == NULL) {
			        cout << "未找到前驱节点" << endl;
			        return false; // 未找到前驱，插入失败
			    }
			
			    // 2. 创建新节点
			    DListNode* q = new DListNode(e);
			    // 3. 新节点的prior指向p
			    q->prior = p;
			    // 4. 新节点的next指向p的后继
			    q->next = p->next;
			    // 5. 若p有后继，則p后继的prior指向q
			    if (p->next != NULL) {
			        p->next->prior = q;
			    }
			    // 6. p的next指向q
			    p->next = q;
			    return true;
			}
			
			// 测试指定位置插入：在70后插入80（原链表70->90）
			void testInsertAfter() {
			    DListNode* head = new DListNode(0);
			    dListHeadInsert(head, 90);
			    dListHeadInsert(head, 70); // 原链表：70->90
			
			    bool res = dListInsertAfter(head, 70, 80);
			    if (res) {
			        // 遍历验证
			        DListNode* p = head->next;
			        cout << "指定位置插入后遍历：";
			        while (p != NULL) {
			            cout << p->data << " "; // 输出70 80 90
			            p = p->next;
			        }
			        cout << endl;
			    }
			
			    // （注：此处省略内存释放）
			}
			```

			#### （4）删除节点：删除指定值的节点

			**逻辑**：找到待删除节点`q`；`q`前驱的`next`指向`q`的后继；`q`后继的`prior`指向`q`的前驱；释放`q`。

			cpp

			

			

			

			```cpp
			// 删除节点：删除值为val的节点（假设val唯一）
			bool dListDelete(DListNode* L, int val) {
			    // 1. 找到待删除节点q
			    DListNode* q = L->next;
			    while (q != NULL && q->data != val) {
			        q = q->next;
			    }
			    if (q == NULL) {
			        cout << "未找到待删除节点" << endl;
			        return false; // 未找到，删除失败
			    }
			
			    // 2. q的前驱的next指向q的后继
			    q->prior->next = q->next;
			    // 3. 若q有后继，則q后继的prior指向q的前驱
			    if (q->next != NULL) {
			        q->next->prior = q->prior;
			    }
			    // 4. 释放q
			    delete q;
			    q = NULL;
			    return true;
			}
			
			// 测试删除节点：删除80（原链表70->80->90）
			void testDelete() {
			    DListNode* head = new DListNode(0);
			    dListHeadInsert(head, 90);
			    dListHeadInsert(head, 80);
			    dListHeadInsert(head, 70); // 原链表：70->80->90
			
			    bool res = dListDelete(head, 80);
			    if (res) {
			        // 遍历验证
			        DListNode* p = head->next;
			        cout << "删除节点后遍历：";
			        while (p != NULL) {
			            cout << p->data << " "; // 输出70 90
			            p = p->next;
			        }
			        cout << endl;
			    }
			
			    // （注：此处省略内存释放）
			}
			```

			## 三、顺序表与链表的对比

			视频中从**空间、时间、适用场景**三个维度对比顺序表（数组实现）和链表，具体如下：

			| 对比维度     | 顺序表（Sequential List）                                    | 链表（Linked List）                                          |
			| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
			| **存储空间** | 1. 预先分配固定大小空间，可能出现闲置（空间未用完）或溢出（空间不足）； 2. 无需额外存储逻辑关系，存储密度 = 1（存储密度 = 数据占比 / 总空间）。 | 1. 动态分配空间，按需申请 / 释放，无闲置或溢出； 2. 需额外存储指针（`next`/`prior`），存储密度 < 1。 |
			| **时间效率** | 1. **存取**：随机存取（按索引访问），时间复杂度 O (1)； 2. **插入 / 删除**：需移动一半元素，时间复杂度 O (n)。 | 1. **存取**：顺序存取（需从表头遍历），时间复杂度 O (n)； 2. **插入 / 删除**：找到位置后仅改指针，时间复杂度 O (1)。 |
			| **适用场景** | 1. 表长变化不大，能预先确定空间大小； 2. 很少插入 / 删除，频繁按位置访问 | 1. 表长变化大，频繁插入 / 删除；2. 无需     频繁按位置访问数据。 |

	



# 顺序表知识点总结（逊哥带你学计算机）

## 1. 前置基础：线性表定义

视频中明确线性表是**顺序表的父类概念**，需先理解线性表的核心特性：

- **定义**：由 `N` 个数据特性（数据类型）相同的元素构成的**有限序列**（`N≥0`，`N=0` 时称为 “空表”）。
- **核心特点**：
	1. 存在唯一的 “第一个元素”（头元素）和 “最后一个元素”（尾元素）；
	2. 除头元素外，每个元素有且仅有一个 “前驱”（前一个元素）；
	3. 除尾元素外，每个元素有且仅有一个 “后继”（后一个元素）；
- **元素类型**：可是基本类型（int、double 等），也可是自定义结构体（如 “图书”“游戏英雄” 等复杂数据）。

## 2. 顺序表的定义与本质

### 2.1 定义

顺序表是**线性表的两种存储结构之一**，其本质是：

- 用**一组连续的内存单元**依次存储线性表的所有元素；
- 逻辑上相邻的元素（如第 1 个和第 2 个元素），在物理内存中也必然相邻。

### 2.2 与数组的关系

- 顺序表**基于数组实现**（数组是顺序表的 “存储容器”），但比数组多了 “元素个数管理”（通过 `length` 变量记录当前有效元素数）；
- 数组的长度是固定的（如 `MAX_SIZE=100`），而顺序表的 “有效长度”（`length`）是动态变化的（可增可减，最大不超过数组长度）。

## 3. 顺序表的结构定义

视频中强调用 `typedef` 定义结构体和数据类型，目的是**提高代码通用性**（修改数据类型时只需改一处）。

### 3.1 基础结构（元素为 int 类型）

cpp





```cpp
#include <iostream>
using namespace std;

// 1. 定义顺序表的最大容量（视频中设为100）
#define MAX_SIZE 100

// 2. 定义元素类型（方便后续修改，如改为double、结构体等）
typedef int Element;

// 3. 定义顺序表结构体（视频中命名为 SeqList）
typedef struct SeqList {
    Element data[MAX_SIZE];  // 存储元素的数组（连续内存）
    int length;              // 记录当前顺序表的有效元素个数（初始为0）
} SeqList;
```

### 3.2 扩展：元素为结构体类型（视频中 “图书” 示例）

视频中举了 “图书管理系统” 的例子，演示顺序表元素为复杂结构体的场景：

cpp







```cpp
// 1. 定义“图书”结构体
typedef struct Book {
    int ISBN;          // 书号（视频中简化为int，实际应为字符串）
    char bookName[20]; // 书名（长度设为20，满足一般需求）
    double price;      // 定价
} Book;

// 2. 重新定义元素类型为 Book
typedef Book Element;

// 3. 顺序表结构体（结构不变，仅元素类型变为Book）
typedef struct SeqList {
    Element data[MAX_SIZE];  // 存储图书的数组
    int length;              // 记录当前图书数量
} SeqList;
```

## 4. 顺序表的核心操作（代码与视频完全一致）

视频中依次讲解了 “初始化”“尾部添加”“遍历”“指定位置插入” 四大核心操作，均需通过函数实现，且函数参数需传**结构体指针**（确保修改的是原顺序表，而非副本）。

### 4.1 操作 1：初始化顺序表

#### 功能

- 将顺序表初始化为 “空表”，即 `length=0`（数组无需额外初始化，声明时已开辟连续内存）。

#### 代码

cpp





```cpp
// 函数名：InitList（视频中命名），参数：顺序表指针（修改原表）
void InitList(SeqList *L) {
    L->length = 0;  // 核心：有效元素数设为0，代表空表
    cout << "顺序表初始化成功！当前长度为：" << L->length << endl;
    // 视频中补充：数组占用内存 = MAX_SIZE * 元素字节数（int为4字节，故400字节）
    cout << "顺序表占用内存：" << MAX_SIZE * sizeof(Element) << " 字节" << endl;
}
```

#### 调用示例

cpp





```cpp
int main() {
    SeqList list;  // 定义一个顺序表变量
    InitList(&list);  // 传地址，初始化
    return 0;
}
```

#### 输出结果

plaintext

```plaintext
顺序表初始化成功！当前长度为：0
顺序表占用内存：400 字节
```

### 4.2 操作 2：尾部添加元素

#### 功能

- 在顺序表的**末尾**（即 `data[length]` 位置）添加一个新元素；
- 需先判断顺序表是否已满（`length >= MAX_SIZE`），满则无法添加。

#### 代码

cpp

```cpp
// 函数名：AppendElement（视频中命名），参数：顺序表指针、待添加元素
int AppendElement(SeqList *L, Element e) {
    // 1. 判断顺序表是否已满
    if (L->length >= MAX_SIZE) {
        cout << "顺序表已满，无法添加元素！" << endl;
        return 0;  // 返回0表示添加失败
    }
    // 2. 尾部添加元素（length 是当前最后一个元素的下一个位置）
    L->data[L->length] = e;
    // 3. 有效元素数+1
    L->length++;
    return 1;  // 返回1表示添加成功
}
```

#### 调用示例（基于 int 类型元素）

cpp





```cpp
int main() {
    SeqList list;
    InitList(&list);
    
    // 尾部添加4个元素：88、99、100、12
    AppendElement(&list, 88);
    AppendElement(&list, 99);
    AppendElement(&list, 100);
    AppendElement(&list, 12);
    
    cout << "尾部添加元素后，当前长度为：" << list.length << endl;
    return 0;
}
```

#### 输出结果

plaintext

```plaintext
顺序表初始化成功！当前长度为：0
顺序表占用内存：400 字节
尾部添加元素后，当前长度为：4
```

### 4.3 操作 3：遍历顺序表

#### 功能

- 依次输出顺序表中的所有有效元素（仅输出 `length` 个元素，而非整个数组）。

#### 代码

cpp





```cpp
// 函数名：ListElement（视频中命名），参数：顺序表指针
void ListElement(SeqList *L) {
    // 1. 判断是否为空表
    if (L->length == 0) {
        cout << "顺序表为空，无元素可遍历！" << endl;
        return;
    }
    // 2. 循环遍历有效元素（i从0到length-1）
    cout << "顺序表元素：";
    for (int i = 0; i < L->length; i++) {
        cout << L->data[i] << " ";  // 若为Book类型，需单独输出每个字段
    }
    cout << endl;
}
```

#### 调用示例（衔接尾部添加操作）

cpp

```cpp
int main() {
    SeqList list;
    InitList(&list);
    
    AppendElement(&list, 88);
    AppendElement(&list, 99);
    AppendElement(&list, 100);
    AppendElement(&list, 12);
    
    ListElement(&list);  // 遍历元素
    return 0;
}
```

#### 输出结果

plaintext

```plaintext
顺序表初始化成功！当前长度为：0
顺序表占用内存：400 字节
顺序表元素：88 99 100 12 
```

### 4.4 操作 4：指定位置插入元素（视频重点）

#### 核心逻辑

- 插入位置 `pos` 是 “从 1 开始计数”（如 “插入到第 2 个位置”，对应数组下标 `1`）；
- 步骤：
	1. 判断 `pos` 是否合法（`1 ≤ pos ≤ length+1`，`length+1` 表示插在末尾）；
	2. 判断顺序表是否已满；
	3. 从**最后一个元素**开始，到 `pos-1` 位置，将所有元素**向后移 1 位**（避免覆盖元素）；
	4. 在 `pos-1` 位置插入新元素；
	5. 有效元素数 `length+1`。

#### 代码

cpp





```cpp
// 函数名：InsertElement（视频中逻辑），参数：顺序表指针、插入位置、待插入元素
int InsertElement(SeqList *L, int pos, Element e) {
    // 1. 判断pos合法性（视频中强调：pos从1开始，且不能超过当前长度+1）
    if (pos < 1 || pos > L->length + 1) {
        cout << "插入位置非法！" << endl;
        return 0;
    }
    // 2. 判断顺序表是否已满
    if (L->length >= MAX_SIZE) {
        cout << "顺序表已满，无法插入元素！" << endl;
        return 0;
    }
    // 3. 从后往前移元素（避免覆盖，i从最后一个元素下标开始）
    for (int i = L->length - 1; i >= pos - 1; i--) {
        L->data[i + 1] = L->data[i];  // 每个元素后移1位
    }
    // 4. 在pos-1位置插入新元素
    L->data[pos - 1] = e;
    // 5. 有效元素数+1
    L->length++;
    return 1;  // 插入成功
}
```

#### 调用示例（在 “88、99、100、12” 中插入 66 到第 2 个位置）

cpp

```cpp
int main() {
    SeqList list;
    InitList(&list);
    
    // 先尾部添加4个元素
    AppendElement(&list, 88);
    AppendElement(&list, 99);
    AppendElement(&list, 100);
    AppendElement(&list, 12);
    cout << "插入前：";
    ListElement(&list);
    
    // 插入66到第2个位置
    InsertElement(&list, 2, 66);
    cout << "插入后：";
    ListElement(&list);
    
    return 0;
}
```

#### 输出结果

plaintext

```plaintext
顺序表初始化成功！当前长度为：0
顺序表占用内存：400 字节
插入前：顺序表元素：88 99 100 12 
插入后：顺序表元素：88 66 99 100 12 
```

## 5. 顺序表的特点

### 5.1 优点

1. **随机访问效率高**：通过数组下标可直接访问任意元素（时间复杂度 `O(1)`）；
2. 存储密度高：无需额外存储元素间的逻辑关系（仅用数组存储元素本身）。

### 5.2 缺点

1. **插入 / 删除效率低**：若插入 / 删除位置靠前，需移动大量元素（最坏时间复杂度 `O(n)`）；
2. **容量固定**：数组长度 `MAX_SIZE` 初始化后无法动态扩展（满了就不能添加元素）；
3. **内存浪费**：若实际元素数远小于 `MAX_SIZE`，会浪费大量连续内存。

## 6. 视频中强调的注意事项

1. **`length` 与 `MAX_SIZE` 的区别**：
	- `MAX_SIZE` 是数组的固定长度（顺序表的最大容量）；
	- `length` 是当前有效元素个数（动态变化，范围 `0 ≤ length ≤ MAX_SIZE`）；
2. **指针的作用**：所有操作函数需传结构体指针（`SeqList *L`），否则修改的是函数内的局部副本，无法影响原顺序表；
3. **代码通用性**：通过 `typedef` 定义 `Element` 类型，后续若需将元素改为 `double` 或 `Book`，只需修改 `typedef int Element` 为 `typedef double Element` 或 `typedef Book Element`，其余代码无需改动。



# 链表知识点总结（逊哥带你学计算机）

## 1. 链表的定义与本质

### 1.1 核心定义

链表是**线性表的另一种存储结构**，与顺序表的 “连续内存” 不同，其本质特点是：

- 用**不连续的内存单元**存储线性表的元素（每个元素称为 “节点”）；
- 节点之间通过 “指针” 连接，实现逻辑上的连续（即第 1 个节点的指针指向第 2 个节点，以此类推）；
- 逻辑上相邻的元素，物理内存中不一定相邻。

### 1.2 与顺序表的核心区别

| 对比维度     | 顺序表                          | 链表                     |
| ------------ | ------------------------------- | ------------------------ |
| 内存存储     | 连续内存单元                    | 不连续内存单元           |
| 元素连接方式 | 数组下标（隐含逻辑关系）        | 指针（显式存储逻辑关系） |
| 访问方式     | 随机访问（通过下标）            | 顺序访问（从头指针遍历） |
| 容量扩展     | 固定容量（需提前定义 MAX_SIZE） | 动态扩容（按需创建节点） |

## 2. 链表的基本结构（单链表，视频重点）

视频中明确以 “单链表” 为核心讲解对象，且推荐使用 “带头节点” 的设计（简化空表与非空表的操作逻辑）。

### 2.1 节点结构体定义（C++ 实现，与视频一致）

每个节点包含两部分：**数据域**（存储元素值）和**指针域**（存储下一个节点的地址）。

cpp





```cpp
#include <iostream>
using namespace std;

// 1. 定义元素类型（与顺序表一致，方便复用，示例为int）
typedef int Element;

// 2. 定义链表节点结构体（视频中命名为LinkNode）
typedef struct LinkNode {
    Element data;          // 数据域：存储当前节点的元素值
    struct LinkNode* next; // 指针域：存储下一个节点的地址（指向LinkNode类型）
} LinkNode;

// 3. 定义链表（用头指针表示，视频中推荐带头节点，头节点不存有效数据）
typedef struct {
    LinkNode* head; // 头指针：指向头节点（链表的入口）
    int length;     // 记录链表的有效元素个数（不含头节点）
} LinkList;
```

### 2.2 带头节点的优势（视频强调）

- 无需区分 “空表” 和 “非空表”：空表时头节点的`next`为`NULL`，非空表时头节点的`next`指向第一个有效节点；
- 简化 “表头插入 / 删除” 操作：无需修改头指针，只需操作头节点的`next`，逻辑统一。

## 3. 链表的核心操作（代码与视频完全一致）

视频中依次讲解 “初始化、头插法、尾插法、遍历、指定位置插入、指定元素删除、销毁链表” 七大操作，所有操作均基于 “带头节点的单链表” 实现，且需处理动态内存（`new`创建节点，`delete`释放内存）。

### 3.1 操作 1：初始化链表

#### 功能

- 创建头节点（不存有效数据），初始化头指针指向头节点，链表长度设为 0（空表）。

#### 代码

cpp







```cpp
// 函数名：InitLinkList（视频中命名），参数：链表指针（修改原链表）
bool InitLinkList(LinkList* L) {
    // 1. 动态创建头节点（C++用new，对应C的malloc）
    L->head = new LinkNode;
    if (L->head == NULL) { // 内存分配失败（极端情况）
        cout << "内存分配失败，链表初始化失败！" << endl;
        return false;
    }
    // 2. 头节点的指针域设为NULL（空表状态）
    L->head->next = NULL;
    // 3. 有效元素个数初始化为0
    L->length = 0;
    cout << "链表初始化成功！当前长度为：" << L->length << endl;
    return true;
}
```

#### 调用示例

cpp







```cpp
int main() {
    LinkList list;  // 定义链表变量
    InitLinkList(&list); // 传地址初始化
    return 0;
}
```

#### 输出结果

plaintext







```plaintext
链表初始化成功！当前长度为：0
```

### 3.2 操作 2：头插法（表头插入元素）

#### 核心逻辑

- 新节点插入到 “头节点之后、第一个有效节点之前”；
- 步骤：1. 创建新节点 → 2. 新节点的`next`指向头节点的`next` → 3. 头节点的`next`指向新节点 → 4. 长度 + 1。

#### 代码

cpp







```cpp
// 函数名：HeadInsert（视频中命名），参数：链表指针、待插入元素
bool HeadInsert(LinkList* L, Element e) {
    // 1. 创建新节点
    LinkNode* newNode = new LinkNode;
    if (newNode == NULL) {
        cout << "内存分配失败，插入失败！" << endl;
        return false;
    }
    // 2. 给新节点赋值（数据域存e，指针域暂未确定）
    newNode->data = e;
    // 3. 新节点连接到链表：先连后，再连前（避免断链）
    newNode->next = L->head->next; // 新节点指向原第一个有效节点
    L->head->next = newNode;       // 头节点指向新节点
    // 4. 有效长度+1
    L->length++;
    return true;
}
```

#### 调用示例（插入 10、20、30，头插法结果为 30→20→10）

cpp







```cpp
int main() {
    LinkList list;
    InitLinkList(&list);
    
    // 头插3个元素：10、20、30
    HeadInsert(&list, 10);
    HeadInsert(&list, 20);
    HeadInsert(&list, 30);
    
    cout << "头插后链表长度：" << list.length << endl;
    return 0;
}
```

#### 输出结果

plaintext







```plaintext
链表初始化成功！当前长度为：0
头插后链表长度：3
```

### 3.3 操作 3：尾插法（表尾插入元素）

#### 核心逻辑

- 新节点插入到 “最后一个有效节点之后”；
- 步骤：1. 创建新节点 → 2. 遍历找到尾节点（`next`为`NULL`的节点） → 3. 尾节点的`next`指向新节点 → 4. 新节点的`next`设为`NULL` → 5. 长度 + 1。

#### 代码

cpp







```cpp
// 函数名：TailInsert（视频中命名），参数：链表指针、待插入元素
bool TailInsert(LinkList* L, Element e) {
    // 1. 创建新节点
    LinkNode* newNode = new LinkNode;
    if (newNode == NULL) {
        cout << "内存分配失败，插入失败！" << endl;
        return false;
    }
    newNode->data = e;
    newNode->next = NULL; // 新节点是尾节点，next设为NULL
    
    // 2. 找尾节点：从头节点开始遍历，直到next为NULL
    LinkNode* p = L->head; // 辅助指针p，初始指向头节点
    while (p->next != NULL) {
        p = p->next; // 移动p，直到p是尾节点（p->next=NULL）
    }
    
    // 3. 尾节点连接新节点
    p->next = newNode;
    // 4. 长度+1
    L->length++;
    return true;
}
```

#### 调用示例（尾插 40、50，结合头插结果为 30→20→10→40→50）

cpp







```cpp
int main() {
    LinkList list;
    InitLinkList(&list);
    
    // 先头插30、20、10
    HeadInsert(&list, 10);
    HeadInsert(&list, 20);
    HeadInsert(&list, 30);
    
    // 再尾插40、50
    TailInsert(&list, 40);
    TailInsert(&list, 50);
    
    cout << "尾插后链表长度：" << list.length << endl;
    return 0;
}
```

#### 输出结果

plaintext







```plaintext
链表初始化成功！当前长度为：0
尾插后链表长度：5
```

### 3.4 操作 4：遍历链表（输出所有有效元素）

#### 核心逻辑

- 从头节点的`next`（第一个有效节点）开始，遍历所有节点，直到指针为`NULL`；
- 避免从头节点开始（头节点无有效数据）。

#### 代码

cpp







```cpp
// 函数名：TraverseList（视频中命名），参数：链表指针
void TraverseList(LinkList* L) {
    // 1. 判断链表是否为空（头节点next为NULL）
    if (L->head->next == NULL) {
        cout << "链表为空，无元素可遍历！" << endl;
        return;
    }
    // 2. 辅助指针p，指向第一个有效节点
    LinkNode* p = L->head->next;
    cout << "链表元素：";
    while (p != NULL) {
        cout << p->data << " "; // 输出当前节点数据
        p = p->next;            // 移动到下一个节点
    }
    cout << endl;
}
```

#### 调用示例（遍历上述头插 + 尾插的结果）

cpp







```cpp
int main() {
    LinkList list;
    InitLinkList(&list);
    
    HeadInsert(&list, 10);
    HeadInsert(&list, 20);
    HeadInsert(&list, 30);
    TailInsert(&list, 40);
    TailInsert(&list, 50);
    
    TraverseList(&list); // 遍历输出
    return 0;
}
```

#### 输出结果

plaintext







```plaintext
链表初始化成功！当前长度为：0
链表元素：30 20 10 40 50 
```

### 3.5 操作 5：指定位置插入元素

#### 核心逻辑

- 插入位置`pos`从 1 开始计数（1 表示第一个有效节点）；
- 步骤：1. 检查`pos`合法性（1≤pos≤length+1） → 2. 创建新节点 → 3. 找`pos`的前驱节点（第 pos-1 个有效节点，用辅助指针 p 定位） → 4. 新节点`next`指向 p 的`next` → 5. p 的`next`指向新节点 → 6. 长度 + 1。

#### 代码

cpp







```cpp
// 函数名：InsertByPos（视频中命名），参数：链表指针、插入位置、待插入元素
bool InsertByPos(LinkList* L, int pos, Element e) {
    // 1. 检查pos合法性
    if (pos < 1 || pos > L->length + 1) {
        cout << "插入位置非法！" << endl;
        return false;
    }
    // 2. 创建新节点
    LinkNode* newNode = new LinkNode;
    if (newNode == NULL) {
        cout << "内存分配失败，插入失败！" << endl;
        return false;
    }
    newNode->data = e;
    
    // 3. 找pos的前驱节点：p移动pos-1次（从年头节点开始）
    LinkNode* p = L->head;
    int count = 0;
    while (count < pos - 1) { // 移动到第pos-1个节点（前驱）
        p = p->next;
        count++;
    }
    
    // 4. 插入新节点
    newNode->next = p->next;
    p->next = newNode;
    // 5. 长度+1
    L->length++;
    return true;
}
```

#### 调用示例（在第 3 个位置插入 35，原链表 30→20→10→40→50）

cpp







```cpp
int main() {
    LinkList list;
    InitLinkList(&list);
    
    // 初始化链表：30→20→10→40→50
    HeadInsert(&list, 10);
    HeadInsert(&list, 20);
    HeadInsert(&list, 30);
    TailInsert(&list, 40);
    TailInsert(&list, 50);
    cout << "插入前：";
    TraverseList(&list);
    
    // 在第3个位置插入35
    InsertByPos(&list, 3, 35);
    cout << "插入后：";
    TraverseList(&list);
    
    return 0;
}
```

#### 输出结果

plaintext







```plaintext
链表初始化成功！当前长度为：0
插入前：链表元素：30 20 10 40 50 
插入后：链表元素：30 20 35 10 40 50 
```

### 3.6 操作 6：删除指定位置的元素

#### 核心逻辑

- 步骤：1. 检查`pos`合法性（1≤pos≤length） → 2. 找`pos`的前驱节点 p → 3. 用辅助指针 q 指向待删除节点（p->next） → 4. p->next 指向 q->next（断链，跳过待删除节点） → 5. 删除 q 节点（释放内存） → 6. 长度 - 1。

#### 代码

cpp







```cpp
// 函数名：DeleteByPos（视频中命名），参数：链表指针、删除位置、存储删除元素的变量（可选）
bool DeleteByPos(LinkList* L, int pos, Element* e) {
    // 1. 检查pos合法性
    if (pos < 1 || pos > L->length) {
        cout << "删除位置非法！" << endl;
        return false;
    }
    // 2. 找pos的前驱节点p
    LinkNode* p = L->head;
    int count = 0;
    while (count < pos - 1) {
        p = p->next;
        count++;
    }
    
    // 3. 定位待删除节点q
    LinkNode* q = p->next;
    *e = q->data; // 存储删除的元素值（供外部查看）
    
    // 4. 断链：跳过q节点
    p->next = q->next;
    // 5. 释放q的内存（避免内存泄漏）
    delete q;
    q = NULL; // 避免野指针
    // 6. 长度-1
    L->length--;
    return true;
}
```

#### 调用示例（删除第 3 个位置的元素 35）

cpp







```cpp
int main() {
    LinkList list;
    InitLinkList(&list);
    
    // 初始化链表：30→20→35→10→40→50
    HeadInsert(&list, 10);
    HeadInsert(&list, 20);
    HeadInsert(&list, 30);
    InsertByPos(&list, 3, 35);
    TailInsert(&list, 40);
    TailInsert(&list, 50);
    cout << "删除前：";
    TraverseList(&list);
    
    // 删除第3个位置的元素
    Element delVal;
    DeleteByPos(&list, 3, &delVal);
    cout << "删除的元素：" << delVal << endl;
    cout << "删除后：";
    TraverseList(&list);
    
    return 0;
}
```

#### 输出结果

plaintext







```plaintext
链表初始化成功！当前长度为：0
删除前：链表元素：30 20 35 10 40 50 
删除的元素：35
删除后：链表元素：30 20 10 40 50 
```

### 3.7 操作 7：销毁链表（释放所有内存）

#### 核心逻辑

- 链表节点是动态分配的（`new`），需手动释放，避免内存泄漏；
- 步骤：1. 辅助指针 p 指向头节点的`next` → 2. 循环：用 q 存 p 的下一个节点 → 3. 删除 p → 4. p=q → 5. 最后删除头节点 → 6. 头指针设为 NULL，长度设为 0。

#### 代码

cpp







```cpp
// 函数名：DestroyList（视频中命名），参数：链表指针
void DestroyList(LinkList* L) {
    LinkNode* p = L->head->next; // p指向第一个有效节点
    LinkNode* q;                 // 暂存p的下一个节点
    
    // 1. 释放所有有效节点
    while (p != NULL) {
        q = p->next; // 存下一个节点地址
        delete p;    // 释放当前节点
        p = q;       // 移动到下一个节点
    }
    
    // 2. 释放头节点
    delete L->head;
    L->head = NULL; // 头指针设为NULL，避免野指针
    L->length = 0;  // 长度重置为0
    cout << "链表销毁成功！" << endl;
}
```

#### 调用示例（销毁上述链表）

cpp







```cpp
int main() {
    LinkList list;
    InitLinkList(&list);
    
    // 初始化并操作链表...
    HeadInsert(&list, 10);
    HeadInsert(&list, 20);
    TailInsert(&list, 40);
    
    TraverseList(&list);
    DestroyList(&list); // 销毁链表
    
    // 销毁后遍历（验证为空）
    TraverseList(&list);
    return 0;
}
```

#### 输出结果

plaintext







```plaintext
链表初始化成功！当前长度为：0
链表元素：20 10 40 
链表销毁成功！
链表为空，无元素可遍历！
```

## 4. 链表的特点（视频总结）

### 4.1 优点

1. **动态扩容**：无需提前定义容量，按需创建节点，内存利用率高；
2. **插入 / 删除效率高**：仅需修改指针指向，无需移动元素（除遍历找位置外，核心操作时间复杂度`O(1)`）；
3. **内存灵活**：无需连续内存，适合元素个数频繁变化的场景。

### 4.2 缺点

1. **无法随机访问**：需从头节点遍历才能找到目标元素，访问时间复杂度`O(n)`；
2. **内存开销大**：每个节点需额外存储指针域（约占节点内存的 1/3~1/2）；
3. **存在指针风险**：易出现野指针、断链等问题，需谨慎处理指针操作。

## 5. 视频中强调的注意事项

1. **头节点的作用**：务必使用带头节点的设计，避免空表与非空表的逻辑分支（如头插 / 尾插无需判断链表是否为空）；
2. **指针操作规范**：
	- 插入节点时 “先连后、再连前”（避免断链，如头插时先让新节点指向原首节点）；
	- 删除节点后需`delete`释放内存，并将指针设为`NULL`（避免野指针）；
3. **遍历边界**：遍历终止条件是 “指针 ==NULL”，而非 “指针 ->next==NULL”（后者会漏掉最后一个节点）；
4. **动态内存管理**：C++ 中用`new`创建节点，必须用`delete`销毁，否则会导致内存泄漏；
5. **位置合法性检查**：插入 / 删除时必须验证`pos`范围（插入为 1≤pos≤length+1，删除为 1≤pos≤length）。

