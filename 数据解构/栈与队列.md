# 栈的基本概念

## 1. 栈的定义与本质

栈是**特殊的线性表**，其核心约束是：**插入（进栈）和删除（出栈）操作仅允许在表的一端进行**，该端称为 “栈顶”；另一端不允许任何插入 / 删除操作，称为 “栈底”。

### 1.1 与普通线性表的区别

| 特性         | 普通线性表           | 栈（特殊线性表）           |
| ------------ | -------------------- | -------------------------- |
| 插入操作位置 | 任意位置             | 仅栈顶                     |
| 删除操作位置 | 任意位置             | 仅栈顶                     |
| 操作灵活性   | 高（无约束）         | 低（操作受限）             |
| 逻辑结构基础 | 一对一的线性逻辑关系 | 继承线性表的一对一逻辑关系 |

### 1.2 生活实例

- **石头堆**：新石头只能放在堆顶，取石头也只能从堆顶拿，无法直接抽走中间石头（否则堆散）。
- **摞放的洗碗碟**：洗好的碟子只能摞在最顶层（进栈），使用时只能从顶层取走（出栈）。
- **烤串**：穿肉时从串的顶端依次穿入（进栈），吃串时从顶端依次取下（出栈）。

## 2. 栈的核心特性 —— 后进先出（LIFO）

栈的最核心属性是**后进先出**，英文表述为 “Last In First Out”，缩写为**LIFO**。

### 2.1 进出栈顺序实例（视频示例）

若元素 `a₁、a₂、a₃、a₄、a₅` 按顺序依次进栈：

- 情况 1：全部元素进栈后再出栈
	进栈顺序：`a₁ → a₂ → a₃ → a₄ → a₅`（栈内元素从底到顶：`a₁、a₂、a₃、a₄、a₅`）
	出栈顺序：`a₅ → a₄ → a₃ → a₂ → a₁`（完全逆序）。
- 情况 2：进栈与出栈操作穿插
	操作序列：`a₁进栈 → a₂进栈 → a₂出栈 → a₃进栈 → a₄进栈 → a₅进栈 → a₅出栈 → a₄出栈 → a₃出栈 → a₁出栈`
	最终出栈顺序：`a₂ → a₅ → a₄ → a₃ → a₁`（合法顺序）。

## 3. 栈的关键术语

| 术语     | 定义                                                         |
| -------- | ------------------------------------------------------------ |
| 空栈     | 栈中无任何数据元素，对应普通线性表的 “空表”，是栈的初始状态。 |
| 栈顶     | 允许进行插入（进栈）和删除（出栈）操作的一端，栈顶元素是 “最后进栈” 的元素。 |
| 栈底     | 不允许进行插入和删除操作的一端，栈底元素是 “最先进栈” 的元素。 |
| 栈顶元素 | 位于栈顶位置的数据元素，是每次出栈 / 读栈顶操作的目标对象。  |
| 栈底元素 | 位于栈底位置的数据元素，只有当栈中所有其他元素都出栈后，才能被访问。 |

## 4. 栈的基本操作（功能定义与代码实现）

栈的基本操作围绕 “创建 - 销毁 - 增 - 删 - 查 - 判空” 展开，视频明确了各操作的核心功能，以下是基于 C 语言的顺序栈实现（王道考研常用风格，符合视频 “后续讲存储结构” 的铺垫）。

### 4.1 操作定义

1. **创建（初始化）**：为栈分配内存空间，将栈初始化为 “空栈” 状态。
2. **销毁**：释放栈占用的全部内存空间，避免内存泄漏。
3. **进栈（Push）**：将数据元素 `x` 插入到栈的栈顶位置（需先判断栈是否已满）。
4. **出栈（Pop）**：删除栈的栈顶元素，并将该元素的值通过变量 `x` 带回（需先判断栈是否为空）。
5. **读栈顶（GetTop）**：读取栈顶元素的值并通过变量 `x` 带回，但**不删除**栈顶元素（区别于出栈）。
6. **判空（StackEmpty）**：判断栈是否为空，返回布尔值（空为`true`，非空为`false`）。

### 4.2 完整代码实现（顺序栈）

c

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// 1. 定义栈的结构体（顺序存储，元素类型为int，可按需修改）
#define MAXSIZE 100  // 栈的最大容量（可自定义）
typedef int ElemType; // 栈元素类型，若需存储其他类型，修改此处即可
typedef struct {
    ElemType data[MAXSIZE]; // 用数组存储栈元素（从栈底到栈顶依次存储）
    int top;                // 栈顶指针：top=-1 表示空栈；top=MAXSIZE-1 表示栈满
} SqStack;                 // 顺序栈类型名


// 2. 创建（初始化）栈：将栈初始化为空栈
void InitStack(SqStack *&S) { // 指针引用：修改实参的栈地址
    // 为栈结构体分配内存
    S = (SqStack *)malloc(sizeof(SqStack));
    // 初始化栈顶指针为-1，标记栈为空
    S->top = -1;
}


// 3. 销毁栈：释放栈占用的内存，避免野指针
void DestroyStack(SqStack *&S) {
    // 释放栈结构体的内存
    free(S);
    // 将栈指针置空，防止后续误用
    S = NULL;
}


// 4. 进栈（Push）：将元素x插入栈顶
// 返回值：true=进栈成功；false=栈满，进栈失败
bool Push(SqStack *&S, ElemType x) {
    // 先判断栈是否已满（栈顶指针达到最大容量-1）
    if (S->top == MAXSIZE - 1) {
        printf("栈满，进栈失败！\n");
        return false;
    }
    // 栈顶指针上移1位，指向新的栈顶位置
    S->top++;
    // 将元素x存入新的栈顶位置
    S->data[S->top] = x;
    return true;
}


// 5. 出栈（Pop）：删除栈顶元素，并通过x带回该元素的值
// 返回值：true=出栈成功；false=栈空，出栈失败
bool Pop(SqStack *&S, ElemType &x) { // x为引用：将删除的栈顶元素带回实参
    // 先判断栈是否为空（栈顶指针为-1）
    if (S->top == -1) {
        printf("栈空，出栈失败！\n");
        return false;
    }
    // 将栈顶元素的值存入x（带回）
    x = S->data[S->top];
    // 栈顶指针下移1位，删除栈顶元素（逻辑删除）
    S->top--;
    return true;
}


// 6. 读栈顶（GetTop）：读取栈顶元素，不删除
// 返回值：true=读取成功；false=栈空，无栈顶元素
bool GetTop(SqStack *&S, ElemType &x) {
    // 先判断栈是否为空
    if (S->top == -1) {
        printf("栈空，无栈顶元素！\n");
        return false;
    }
    // 将栈顶元素的值存入x（带回），不修改栈顶指针
    x = S->data[S->top];
    return true;
}


// 7. 判空（StackEmpty）：判断栈是否为空
// 返回值：true=空栈；false=非空栈
bool StackEmpty(SqStack *S) {
    // 栈顶指针为-1即空栈
    return (S->top == -1);
}


// 测试代码（验证上述操作）
int main() {
    SqStack *S;
    ElemType x;

    // 1. 初始化栈
    InitStack(S);
    printf("栈初始化后，是否为空？%s\n", StackEmpty(S) ? "是" : "否");

    // 2. 进栈：插入10、20、30
    Push(S, 10);
    Push(S, 20);
    Push(S, 30);
    printf("进栈10、20、30后，是否为空？%s\n", StackEmpty(S) ? "是" : "否");

    // 3. 读栈顶
    if (GetTop(S, x)) {
        printf("当前栈顶元素：%d\n", x); // 预期输出30
    }

    // 4. 出栈
    if (Pop(S, x)) {
        printf("出栈元素：%d\n", x); // 预期输出30
    }
    if (GetTop(S, x)) {
        printf("出栈后，当前栈顶元素：%d\n", x); // 预期输出20
    }

    // 5. 销毁栈
    DestroyStack(S);
    printf("栈销毁后，指针是否为空？%s\n", (S == NULL) ? "是" : "否");

    return 0;
}
```

## 5. 栈的出站顺序合法性与卡特兰数

视频明确提及栈的核心考点：**已知进栈顺序，判断出站顺序是否合法**。

### 5.1 合法出站顺序的判断核心

任意时刻出栈的元素，必须是当前栈的 “栈顶元素”—— 即不能跳过栈内未出栈的元素，直接删除非栈顶元素（违反栈的操作约束）。

#### 示例（视频举例）

进栈顺序：`a→b→c→d→e`

- 合法顺序：`b→a→e→d→c`（操作：a 进→b 进→b 出→a 出→c 进→d 进→e 进→e 出→d 出→c 出）
- 非法顺序：`a→c→b→e→d`（错误：c 进栈后未出栈，直接出 b，b 此时非栈顶）

### 5.2 卡特兰数（合法出站顺序总数）

视频提到：`n个不同元素进栈后，合法的出站顺序总数为第n个卡特兰数`，无需掌握证明，仅需了解结论：

- 卡特兰数公式：`Cₙ = (1/(n+1)) × C(2n, n)`（其中`C(2n, n)`是组合数，表示从 2n 个元素中选 n 个的方案数）
- 实例：n=5 时，`C₅ = 42`（5 个元素进栈，合法出站顺序共 42 种）
- 考试形式：多为选择题，给出选项后判断 “某出站顺序是否合法”，无需枚举所有顺序。



# 顺序栈的顺序存储实现

## 1. 顺序栈的核心定义

### 1.1 概念本质

顺序栈是采用**静态数组**实现的栈结构，遵循 “先进后出”（LIFO）原则，核心是通过 “静态数组存储元素 + 栈顶指针定位栈顶” 实现所有操作，数组容量由`maxSize`固定（静态分配，无法动态扩展）。

### 1.2 结构体定义（C 语言实现）

视频中用`typedef`将结构体重命名为`SqStack`（`Sq`为`Sequence`缩写，表 “顺序”），包含两个关键成员：

- 静态数组`data`：存储栈内元素；
- 栈顶指针`top`：记录栈顶元素的数组下标（从 0 开始），用于判断栈空 / 栈满及定位栈顶。

c

```c
#include <stdio.h>
#include <stdbool.h>

// 宏定义栈的最大容量（视频中示例用maxSize=10，可根据需求修改）
#define maxSize 10

// 顺序栈结构体定义
typedef struct {
    int data[maxSize];  // 静态数组：存储栈元素
    int top;            // 栈顶指针：记录栈顶元素的数组下标
} SqStack;
```

## 2. 顺序栈的初始化（Top 指针方案 1：指向栈顶元素）

视频中优先讲解的核心方案，`top`的含义是 “直接指向当前栈顶元素”，初始化逻辑围绕`top`的初始值展开。

### 2.1 初始化核心规则

- 栈空条件：`top == -1`（数组下标从 0 开始，`-1`表示无有效元素）；
- 初始化操作：仅需将`top`置为`-1`，无需初始化数组（逻辑上空栈，数组元素无意义）。

### 2.2 初始化及栈空判断函数

c

```c
// 初始化顺序栈：将top置为-1，标识栈空
void InitStack(SqStack *S) {
    S->top = -1;
}

// 判断栈是否为空（基于方案1）
bool StackEmpty(SqStack S) {
    return S.top == -1;  // 栈空返回true，非空返回false
}
```

## 3. 顺序栈的基本操作（基于 Top 指针方案 1）

### 3.1 入栈操作（Push：添加元素到栈顶）

#### 3.1.1 操作逻辑

1. **判断栈满**：若`top == maxSize - 1`（数组最后一个下标为`maxSize-1`），栈满无法入栈，返回`false`；
2. **栈顶指针上移**：`top`先加 1（`top++`），指向新的栈顶位置；
3. **存入元素**：将待入栈元素`x`存入`data[top]`；
4. **返回成功**：入栈完成，返回`true`。

#### 3.1.2 关键易错点：`++top`与`top++`的区别

视频重点强调：入栈必须用**先增后用**（`++top`），不可用**先用后增**（`top++`），否则会覆盖原有栈顶元素。

- 正确写法：`S->data[++(S->top)] = x;`（先让`top+1`，再向新位置存元素）；
- 错误写法：`S->data[(S->top)++] = x;`（先向当前`top`位置存元素，再`top+1`，会覆盖原栈顶元素）。

#### 3.1.3 入栈函数实现

c

```c
// 入栈操作：将元素x压入栈S，成功返回true，栈满返回false
bool Push(SqStack *S, int x) {
    // 1. 判断栈满：top达到数组最大下标，无法入栈
    if (S->top == maxSize - 1) {
        printf("栈满，无法入栈！\n");
        return false;
    }
    // 2. 栈顶指针上移，再存入元素（等价于 S->data[++(S->top)] = x;）
    S->top++;
    S->data[S->top] = x;
    
    return true;  // 入栈成功
}

// 辅助函数：判断栈是否已满（基于方案1）
bool StackFull(SqStack S) {
    return S.top == maxSize - 1;
}
```

### 3.2 出栈操作（Pop：删除栈顶元素并返回）

#### 3.2.1 操作逻辑

1. **判断栈空**：若`StackEmpty(S)`（`top == -1`），栈空无元素可删，返回`false`；
2. **返回栈顶元素**：通过**引用参数`x`**（视频强调 “加引用符号，操作同一份数据”）获取栈顶元素；
3. **栈顶指针下移**：`top`减 1（`top--`），逻辑上删除栈顶元素（内存中元素仍存在，只是不再被栈访问）；
4. **返回成功**：出栈完成，返回`true`。

#### 3.2.2 关键易错点：`top--`与`--top`的区别

视频重点强调：出栈必须用**先用后减**（`top--`），不可用**先减后用**（`--top`），否则会返回错误的元素。

- 正确写法：`*x = S->data[(S->top)--];`（先取当前`top`位置的元素，再`top-1`）；
- 错误写法：`*x = S->data[--(S->top)];`（先`top-1`，再取元素，返回的是原栈顶下一层元素）。

#### 3.2.3 出栈函数实现（C 语言用指针模拟引用）

视频中提到 “`x`加引用符号”，C 语言无原生引用，故用指针实现 “同一份数据访问”：

c

```c
// 出栈操作：删除栈顶元素，通过指针x返回该元素，成功返回true，栈空返回false
bool Pop(SqStack *S, int *x) {
    // 1. 判断栈空：栈空无元素可出
    if (StackEmpty(*S)) {
        printf("栈空，无法出栈！\n");
        return false;
    }
    // 2. 先获取栈顶元素，再让栈顶指针下移（等价于 *x = S->data[(S->top)--];）
    *x = S->data[S->top];
    S->top--;
    
    return true;  // 出栈成功
}
```

### 3.3 获取栈顶元素（GetTop：仅读取，不修改栈）

#### 3.3.1 操作逻辑

与出栈类似，但**不改变栈结构**（`top`指针不变），仅读取栈顶元素的值。

#### 3.3.2 函数实现

c

```c
// 获取栈顶元素：通过指针x返回栈顶元素，成功返回true，栈空返回false
bool GetTop(SqStack S, int *x) {
    // 1. 判断栈空：栈空无栈顶元素
    if (StackEmpty(S)) {
        printf("栈空，无栈顶元素！\n");
        return false;
    }
    // 2. 读取栈顶元素（top指针不变）
    *x = S.data[S.top];
    
    return true;  // 读取成功
}
```

## 4. Top 指针的第二种设计方案（指向 next 可插入位置）

视频中补充的方案，`top`的含义是 “指向**下一个可插入元素**的位置”，而非当前栈顶元素，核心参数与操作逻辑均发生变化。

### 4.1 方案 2 与方案 1 的核心对比

| 对比项        | Top 指针方案 1（指向栈顶元素） | Top 指针方案 2（指向 next 插入位置） |
| ------------- | ------------------------------ | ------------------------------------ |
| 初始化`top`值 | `-1`                           | `0`                                  |
| 栈空条件      | `top == -1`                    | `top == 0`                           |
| 栈满条件      | `top == maxSize - 1`           | `top == maxSize`                     |
| 入栈步骤      | 先`top++`，再存元素            | 先存元素，再`top++`                  |
| 出栈步骤      | 先取元素，再`top--`            | 先`top--`，再取元素                  |

### 4.2 方案 2 的关键操作实现

#### 4.2.1 初始化与栈空 / 栈满判断

c

```c
// 方案2初始化：top置为0，标识next插入位置为data[0]
void InitStack2(SqStack *S) {
    S->top = 0;
}

// 方案2判断栈空
bool StackEmpty2(SqStack S) {
    return S.top == 0;
}

// 方案2判断栈满
bool StackFull2(SqStack S) {
    return S.top == maxSize;
}
```

#### 4.2.2 方案 2 入栈函数

c

```c
// 方案2入栈：先向top位置存元素，再top++（top指向next位置）
bool Push2(SqStack *S, int x) {
    if (StackFull2(*S)) {
        printf("栈满，无法入栈！\n");
        return false;
    }
    // 先存元素，再top++（等价于 S->data[(S->top)++] = x;）
    S->data[S->top] = x;
    S->top++;
    
    return true;
}
```

#### 4.2.3 方案 2 出栈函数

c

```c
// 方案2出栈：先top--（指向真实栈顶），再取元素
bool Pop2(SqStack *S, int *x) {
    if (StackEmpty2(*S)) {
        printf("栈空，无法出栈！\n");
        return false;
    }
    // 先top--，再取元素（等价于 *x = S->data[--(S->top)];）
    S->top--;
    *x = S->data[S->top];
    
    return true;
}
```

## 5. 共享栈（双栈共享静态数组）

### 5.1 概念本质

顺序栈的缺点是静态数组容量固定，易造成内存浪费。共享栈通过**两个栈共享同一片静态数组**，提高内存利用率：

- 栈 0（左栈）：从数组左端（`data[0]`）开始，栈顶指针`top0`初始为`-1`，向上增长（`top0++`）；
- 栈 1（右栈）：从数组右端（`data[maxSize-1]`）开始，栈顶指针`top1`初始为`maxSize`，向下增长（`top1--`）；
- 栈满条件：`top0 + 1 == top1`（两个栈顶指针相邻，无剩余空间）。

### 5.2 共享栈结构体定义

c

```c
// 共享栈结构体定义
typedef struct {
    int data[maxSize];  // 共享的静态数组
    int top0;           // 栈0的栈顶指针（初始-1，向上增长）
    int top1;           // 栈1的栈顶指针（初始maxSize，向下增长）
} SharedStack;
```

### 5.3 共享栈的核心操作

#### 5.3.1 初始化

c

```c
// 初始化共享栈：top0=-1（栈0空），top1=maxSize（栈1空）
void InitSharedStack(SharedStack *SS) {
    SS->top0 = -1;
    SS->top1 = maxSize;
}
```

#### 5.3.2 入栈（分栈 0 和栈 1）

c

```c
// 共享栈入栈：stackNo=0表示栈0，stackNo=1表示栈1，x为入栈元素
bool PushSharedStack(SharedStack *SS, int stackNo, int x) {
    // 1. 判断共享栈是否已满（两个栈顶指针相邻）
    if (SS->top0 + 1 == SS->top1) {
        printf("共享栈满，无法入栈！\n");
        return false;
    }
    // 2. 按栈号入栈
    if (stackNo == 0) {
        // 栈0：top0先增后存
        SS->top0++;
        SS->data[SS->top0] = x;
    } else if (stackNo == 1) {
        // 栈1：top1先减后存
        SS->top1--;
        SS->data[SS->top1] = x;
    } else {
        printf("栈号错误，仅支持0或1！\n");
        return false;
    }
    return true;
}
```

#### 5.3.3 出栈（分栈 0 和栈 1）

c

```c
// 共享栈出栈：stackNo=0/1，x通过指针返回出栈元素
bool PopSharedStack(SharedStack *SS, int stackNo, int *x) {
    // 按栈号出栈
    if (stackNo == 0) {
        // 判断栈0是否为空
        if (SS->top0 == -1) {
            printf("栈0空，无法出栈！\n");
            return false;
        }
        // 栈0：先取元素，再top0--
        *x = SS->data[SS->top0];
        SS->top0--;
    } else if (stackNo == 1) {
        // 判断栈1是否为空
        if (SS->top1 == maxSize) {
            printf("栈1空，无法出栈！\n");
            return false;
        }
        // 栈1：先取元素，再top1++
        *x = SS->data[SS->top1];
        SS->top1++;
    } else {
        printf("栈号错误，仅支持0或1！\n");
        return false;
    }
    return true;
}
```

## 6. 顺序栈的销毁

视频中明确说明：

- 若顺序栈通过**局部变量声明**（如`SqStack S;`）分配内存，无需手动销毁 —— 函数执行结束后，系统会自动回收栈内存；
- 逻辑清空：若需在使用中清空栈，只需将`top`置为对应方案的初始值（方案 1 置`-1`，方案 2 置`0`），无需处理数组元素。



# 栈的链式存储实现（链栈）知识点总结

## 1. 链栈的定义与本质

- **定义**：用**链式存储结构实现的栈**称为 “链栈”（视频中口误 “恋战”，正确表述为 “链栈”）。
- **本质**：链栈是**受限制的单链表**—— 仅允许在单链表的**表头位置**进行插入（对应栈的 “进栈”）和删除（对应栈的 “出栈”）操作，因此单链表的 “表头” 即链栈的 “栈顶”。
- **核心优势**：
	1. 避免顺序栈的 “栈满溢出” 问题（链式存储动态分配内存，无需预设固定容量）；
	2. 进栈、出栈操作效率均为**O(1)**（表头操作无需遍历链表）。

## 2. 链栈的两种存储设计（核心差异：是否带头节点）

视频明确指出：链栈存在 “带头节点” 和 “不带头节点” 两种实现方式，核心差异在于**栈空判断条件**和**操作细节**，且课本推荐使用 “不带头节点” 的设计。

### 2.1 通用节点结构定义

链栈的节点结构与单链表节点完全一致，包含 “数据域”（存储栈元素）和 “指针域”（指向后继节点），C 语言定义如下：

c

```c
#include <stdio.h>
#include <stdlib.h>

// 1. 链栈节点结构（数据域+指针域）
typedef struct LinkStackNode {
    int data;                  // 数据域：存储栈元素（以int类型为例）
    struct LinkStackNode *next;// 指针域：指向后一个栈节点
} LinkStackNode;

// 2. 链栈管理结构（用栈顶指针管理整个栈）
typedef struct {
    LinkStackNode *top;        // 栈顶指针：指向栈顶节点（核心标识）
} LinkStack;
```

### 2.2 两种设计的核心差异对比

| 设计方式   | 栈空判断条件              | 特点                                       | 适用场景                   |
| ---------- | ------------------------- | ------------------------------------------ | -------------------------- |
| 不带头节点 | `stack.top == NULL`       | 课本推荐，无额外头节点内存开销，操作稍简洁 | 多数场景（元素个数不确定） |
| 带头节点   | `stack.top->next == NULL` | 操作逻辑与单链表完全一致，避免空栈指针异常 | 需统一单链表操作逻辑场景   |

## 3. 链栈的基本操作实现

### 3.1 不带头节点的链栈

#### 3.1.1 初始化（LinkStackInit）

- 功能：创建空链栈，栈顶指针设为`NULL`（无任何节点）。

c

```c
// 初始化不带头节点的链栈
void LinkStackInit(LinkStack *stack) {
    if (stack == NULL) return; // 防止传入空指针（参数合法性检查）
    stack->top = NULL;         // 空栈标识：栈顶指针指向NULL
}
```

#### 3.1.2 判空（LinkStackIsEmpty）

- 功能：判断链栈是否为空，返回`1`（空）或`0`（非空）。

c

```c
int LinkStackIsEmpty(LinkStack stack) {
    // 不带头节点：栈顶指针为NULL即空栈
    return (stack.top == NULL) ? 1 : 0;
}
```

#### 3.1.3 进栈（LinkStackPush）

- 逻辑：单链表**头插法**—— 新节点插入栈顶（表头），成为新栈顶。
- 步骤：
	1. 分配新节点内存；
	2. 新节点数据域赋值，指针域指向原栈顶；
	3. 栈顶指针更新为新节点。

c

```c
// 进栈：将元素x插入栈顶（不带头节点）
int LinkStackPush(LinkStack *stack, int x) {
    // 参数合法性检查
    if (stack == NULL) return 0;

    // 1. 分配新节点内存
    LinkStackNode *newNode = (LinkStackNode *)malloc(sizeof(LinkStackNode));
    if (newNode == NULL) return 0; // 内存分配失败（如堆内存不足）

    // 2. 新节点赋值与指针指向
    newNode->data = x;
    newNode->next = stack->top; // 新节点next指向原栈顶（确保链表连续）

    // 3. 更新栈顶指针：新节点成为新栈顶
    stack->top = newNode;

    return 1; // 进栈成功
}
```

#### 3.1.4 出栈（LinkStackPop）

- 逻辑：单链表**头删法**—— 删除栈顶节点，通过参数`x`返回删除的元素。
- 步骤：
	1. 判空（空栈无法出栈）；
	2. 临时指针保存栈顶节点（待删除）；
	3. 用`x`接收栈顶数据；
	4. 栈顶指针后移，释放临时节点内存。

c

```c
// 出栈：删除栈顶元素，通过x返回（不带头节点）
int LinkStackPop(LinkStack *stack, int *x) {
    // 参数合法性+空栈检查
    if (stack == NULL || x == NULL || LinkStackIsEmpty(*stack)) {
        return 0; // 失败（参数非法或空栈）
    }

    // 1. 临时保存栈顶节点（避免删除后指针丢失）
    LinkStackNode *temp = stack->top;

    // 2. 接收出栈元素
    *x = temp->data;

    // 3. 栈顶指针后移：指向原栈顶的下一个节点
    stack->top = temp->next;

    // 4. 释放删除节点的内存（避免内存泄漏）
    free(temp);
    temp = NULL; // 避免野指针（指向已释放内存）

    return 1; // 出栈成功
}
```

#### 3.1.5 取栈顶元素（LinkStackGetTop）

- 功能：获取栈顶元素（不删除），通过参数`x`返回。

c

```c
// 取栈顶：获取栈顶元素（不删除，不带头节点）
int LinkStackGetTop(LinkStack stack, int *x) {
    // 参数合法性+空栈检查
    if (x == NULL || LinkStackIsEmpty(stack)) {
        return 0; // 失败
    }

    *x = stack.top->data; // 直接读取栈顶节点的数据域
    return 1; // 成功
}
```

#### 3.1.6 销毁链栈（LinkStackDestroy）

- 功能：释放所有节点内存（避免内存泄漏），恢复空栈状态。

c

```c
// 销毁链栈：释放所有节点内存（不带头节点）
void LinkStackDestroy(LinkStack *stack) {
    if (stack == NULL) return;

    LinkStackNode *temp = NULL;
    // 遍历所有节点，逐个释放
    while (stack->top != NULL) {
        temp = stack->top;          // 保存当前栈顶节点
        stack->top = stack->top->next; // 栈顶指针后移（指向 next 节点）
        free(temp);                 // 释放当前节点内存
    }

    stack->top = NULL; // 确保栈顶指针为NULL（空栈标识）
}
```

### 3.2 带头节点的链栈

带头节点的链栈中，“头节点始终存在（不存储实际数据），栈元素存储在头节点之后”，操作逻辑与单链表完全对齐。

#### 3.2.1 初始化（LinkStackInit_WithHead）

- 需创建头节点，栈顶指针指向头节点，头节点`next`设为`NULL`（栈空）。

c

```c
// 初始化带头节点的链栈
void LinkStackInit_WithHead(LinkStack *stack) {
    if (stack == NULL) return;

    // 1. 创建头节点（不存储实际数据）
    LinkStackNode *headNode = (LinkStackNode *)malloc(sizeof(LinkStackNode));
    if (headNode == NULL) return; // 内存分配失败

    // 2. 头节点next设为NULL（栈空：无元素节点）
    headNode->next = NULL;
    stack->top = headNode; // 栈顶指针指向头节点
}
```

#### 3.2.2 判空（LinkStackIsEmpty_WithHead）

- 栈空条件：头节点的`next`为`NULL`（无元素节点）。

c

```c
// 判空：带头节点的链栈
int LinkStackIsEmpty_WithHead(LinkStack stack) {
    // 带头节点：头节点next为NULL即空栈
    return (stack.top->next == NULL) ? 1 : 0;
}
```

#### 3.2.3 进栈（LinkStackPush_WithHead）

- 逻辑：新节点插入 “头节点之后”（即原栈顶元素之前），仍为头插法。

c

```c
// 进栈：带头节点（新节点插入头节点之后）
int LinkStackPush_WithHead(LinkStack *stack, int x) {
    if (stack == NULL) return 0;

    // 1. 创建新节点
    LinkStackNode *newNode = (LinkStackNode *)malloc(sizeof(LinkStackNode));
    if (newNode == NULL) return 0;

    // 2. 新节点插入头节点之后
    newNode->data = x;
    newNode->next = stack->top->next; // 新节点next指向原栈顶元素
    stack->top->next = newNode;       // 头节点next指向新节点（新栈顶）

    return 1;
}
```

#### 3.2.4 出栈（LinkStackPop_WithHead）

- 逻辑：删除 “头节点之后的节点”（栈顶元素）。

c

```c
// 出栈：带头节点（删除头节点之后的栈顶元素）
int LinkStackPop_WithHead(LinkStack *stack, int *x) {
    if (stack == NULL || x == NULL || LinkStackIsEmpty_WithHead(*stack)) {
        return 0; // 失败
    }

    // 1. 保存栈顶元素节点（头节点的next）
    LinkStackNode *temp = stack->top->next;

    // 2. 接收出栈元素
    *x = temp->data;

    // 3. 头节点next指向原栈顶的下一个节点
    stack->top->next = temp->next;

    // 4. 释放删除节点
    free(temp);
    temp = NULL;

    return 1;
}
```

## 4. 核心结论与要求

1. **链栈与单链表的关系**：链栈是 “仅允许表头操作的单链表”，进栈 = 头插、出栈 = 头删，需复用单链表知识。
2. **判空条件是关键**：
	- 不带头节点：`top == NULL`（课本推荐）；
	- 带头节点：`top->next == NULL`。
3. **动手练习是核心**：视频强调 “仅听课 / 看书是知识输入，动手写代码、讲给他人听是知识输出，需通过练习提升输出能力（应对考试）”。
4. **链栈的适用场景**：元素个数不确定、需避免栈满溢出的场景（动态内存分配优势）。





# 队列的基本概念

## 1. 队列的核心定义

队列是一种**操作受限的线性表**，其核心限制在于对 “插入” 和 “删除” 操作的位置约束，具体定义如下：

- 仅允许在线性表的**某一端**执行**插入操作**，该操作被统一称为**入队**；
- 仅允许在线性表的**另一端**执行**删除操作**，该操作被统一称为**出队**；
- 本质仍是线性表，仅在 “插入 / 删除的位置” 上存在特殊限制（区别于普通线性表可在任意位置操作）。

视频中提及的生活场景示例（辅助理解）：

- 食堂打饭排队：新加入的人只能从 “队尾” 插入（入队），仅 “队头” 的人能先打饭并离开（出队）；
- 收费站汽车排队：汽车从 “队尾” 加入队列，仅 “队头” 的汽车完成缴费后离开（出队）。

## 2. 队列的关键术语

视频中明确界定了队列的核心术语及含义，具体如下：

- **队头（Front）**：
	- 定义：允许执行**删除操作**的一端；
	- 关联元素：队列中靠近队头的元素称为 “队头元素”，是每次 “出队” 操作的对象。
- **队尾（Rear）**：
	- 定义：允许执行**插入操作**的一端；
	- 关联元素：队列中靠近队尾的元素称为 “队尾元素”，是每次 “入队” 操作后新产生的元素。
- **空队列**：
	- 定义：队列中不包含任何数据元素的状态；
	- 地位：是队列的初始状态之一，也是 “判断队列是否为空” 操作的判断标准。

## 3. 队列的核心特点（与栈对比）

队列最核心的特点是**先进先出（FIFO，First In First Out）**：即 “先进入队列的元素，必然先离开队列”（先入队的元素先出队）。

视频中明确将队列与已学的 “栈” 进行对比，二者核心特点差异如下表：

| 数据结构 | 核心特点 | 英文缩写 | 英文全称           | 操作位置约束               |
| -------- | -------- | -------- | ------------------ | -------------------------- |
| 队列     | 先进先出 | FIFO     | First In First Out | 插入（队尾）、删除（队头） |
| 栈       | 后进先出 | LIFO     | Last In First Out  | 插入 / 删除（均在栈顶）    |

## 4. 队列的基本操作

视频中强调：队列的基本操作与线性表一致（核心为 “创、销、增、删、改、查”），但需结合队列的 “操作位置限制”，关键操作及细节如下：

### 4.1 队列的基础管理操作

- **创建队列**：
	- 作用：为队列分配对应的内存空间，初始化队列状态（通常初始化为 “空队列”）；
	- 逻辑：与线性表、栈的 “创建” 逻辑一致，均为 “分配内存 + 初始化状态”。
- **销毁队列**：
	- 作用：回收队列占用的内存空间，释放系统资源；
	- 逻辑：与线性表、栈的 “销毁” 逻辑一致，均为 “回收内存 + 清空状态”。

### 4.2 队列的核心操作（含位置约束）

- **入队（Enqueue）**：
	- 操作对象：新数据元素`x`；
	- 操作位置：**仅允许在队尾插入**（不可在其他位置插入）；
	- 结果：元素`x`被加入队列，成为新的 “队尾元素”。
- **出队（Dequeue）**：
	- 操作位置：**仅允许在队头删除**（不可在其他位置删除）；
	- 结果：删除当前 “队头元素”，并将该元素的值通过变量（如`x`）返回给调用者（需返回删除的元素值）。
- **读队头元素（Get Front）**：
	- 核心区别：与 “出队” 不同，该操作**仅读取队头元素的值**（通过变量如`x`返回），**不删除队头元素**；
	- 类比关系：对应栈的 “读栈顶元素” 操作（仅读取不删除，属于 “查” 操作的细分）。

### 4.3 队列的常用判断操作

- **判断队列是否为空**：
	- 作用：检查队列当前是否包含数据元素（若无线性表元素，则为 “空队列”）；
	- 考试提示：视频明确提及该操作为 “选择题中比较喜欢考的考点”，是队列操作的高频考点。



# 队列的顺序实现

## 1. 队列的基本概念

- 队列是**操作受限的线性表**，遵循**FIFO（先进先出）** 原则：
	- 仅允许在**队尾（Rear）** 执行插入操作（称为 “入队”）；
	- 仅允许在**队头（Front）** 执行删除操作（称为 “出队”）；
	- 核心特征：先进入队列的元素，优先从队列中删除。

## 2. 队列的顺序存储核心设计

### 2.1 存储结构组成

采用 “**静态数组 + 双指针**” 实现，核心组件如下：

| 组件            | 作用说明                                                     |
| --------------- | ------------------------------------------------------------ |
| 静态数组        | 固定容量（用`maxSize`定义），存储队列的元素（元素类型用`ElemType`泛化） |
| 队头指针`front` | 指向**队头元素**（视频中默认设计，需注意与 “rear 指向队尾元素” 的区别） |
| 队尾指针`rear`  | 指向**队尾元素的下一个位置**（视频核心设计，后续操作均基于此） |

### 2.2 初始状态定义

- 初始化目标：队列空时，`front`与`rear`指向同一位置；
- 初始化规则：`front = 0` 且 `rear = 0`（此时数组中无元素，`rear`指向 “待插入第一个元素的位置”）。

## 3. 循环队列的必要性与实现原理

### 3.1 为什么需要循环队列？

静态数组容量固定，若按 “`rear`一直后移” 的线性逻辑：

- 当`rear == maxSize`时，数组尾部满，但数组头部可能因元素出队产生空闲空间（称为 “假溢出”）；
- 解决方案：用**模运算（取余）** 将静态数组 “逻辑上变为环状”，让`front`和`rear`指针循环移动，重复利用空闲空间。

### 3.2 模运算的核心作用

- 定义：`(x + 1) % maxSize`，将`x`的取值范围限制在`[0, maxSize-1]`（把无限整数映射到有限集合）；
- 示例：若`maxSize=10`，当`rear=9`（数组最后一个索引）时，`(rear+1)%10 = 0`，`rear`回到数组头部，实现循环。

## 4. 队列的核心操作（基于 “rear 指向队尾下一个位置”）

### 4.1 前提说明

- 队列结构体定义（C 语言风格）：

	c

	```c
	#include <stdio.h>
	#include <stdbool.h>
	#define maxSize 10  // 队列最大容量（视频中示例值）
	typedef int ElemType;  // 元素类型（示例用int，可泛化）
	
	// 队列结构体
	typedef struct {
	    ElemType data[maxSize];  // 静态数组存储元素
	    int front;               // 队头指针（指向队头元素）
	    int rear;                // 队尾指针（指向队尾下一个位置）
	} SqQueue;
	```

### 4.2 操作 1：队列初始化

- 功能：将队列初始化为空状态（`front`与`rear`均指向 0）；

- 代码：

	c

	```c
	void InitQueue(SqQueue *Q) {
	    // 初始化时，队头、队尾指针均指向0（空队列标志）
	    Q->front = 0;
	    Q->rear = 0;
	}
	```

### 4.3 操作 2：入队（插入元素）

- 逻辑：先判满 → 若未满，将元素存入`rear`指向位置 → `rear`循环后移；

- 关键：入队前必须判断队列是否已满（避免数组越界）；

- 代码：

	c

	```c
	// 入队：将元素x插入队尾，成功返回true，失败（队满）返回false
	bool EnQueue(SqQueue *Q, ElemType x) {
	    // 第一步：判断队列是否已满（判满条件：(rear+1)%maxSize == front）
	    if ((Q->rear + 1) % maxSize == Q->front) {
	        printf("队列已满，入队失败！\n");
	        return false;
	    }
	    // 第二步：将x存入rear指向的当前位置
	    Q->data[Q->rear] = x;
	    // 第三步：rear循环后移（模运算实现循环）
	    Q->rear = (Q->rear + 1) % maxSize;
	    return true;
	}
	```

### 4.4 操作 3：出队（删除元素）

- 逻辑：先判空 → 若未空，取出`front`指向的队头元素 → `front`循环后移；

- 关键：出队前必须判断队列是否为空（避免无效删除）；

- 代码：

	c

	```c
	// 出队：将队头元素存入x，成功返回true，失败（队空）返回false
	bool DeQueue(SqQueue *Q, ElemType *x) {
	    // 第一步：判断队列是否为空（判空条件：front == rear）
	    if (Q->front == Q->rear) {
	        printf("队列为空，出队失败！\n");
	        return false;
	    }
	    // 第二步：取出front指向的队头元素，存入x
	    *x = Q->data[Q->front];
	    // 第三步：front循环后移（模运算实现循环）
	    Q->front = (Q->front + 1) % maxSize;
	    return true;
	}
	```

### 4.5 操作 4：取队头元素（仅查询，不删除）

- 逻辑：先判空 → 若未空，返回`front`指向的元素（不移动`front`）；

- 代码：

	c

	```c
	// 取队头：将队头元素存入x，成功返回true，失败（队空）返回false
	bool GetHead(SqQueue Q, ElemType *x) {
	    // 第一步：判断队列是否为空
	    if (Q.front == Q.rear) {
	        printf("队列为空，无法取队头！\n");
	        return false;
	    }
	    // 第二步：取出front指向的队头元素（不移动front）
	    *x = Q.data[Q.front];
	    return true;
	}
	```

## 5. 队列 “空 / 满” 的判断方法（视频核心考点）

### 5.1 方法 1：牺牲 1 个存储单元（默认方法）

- 核心思想：故意保留 1 个空闲单元，用 “`(rear+1)%maxSize == front`” 区分 “满” 与 “空”；
- 判空条件：`front == rear`（初始化及所有元素出队后满足）；
- 判满条件：`(rear + 1) % maxSize == front`（队尾下一个位置是队头，无法插入）；
- 优缺点：实现简单，无需额外变量；但浪费 1 个存储单元。

### 5.2 方法 2：增加`size`变量（不牺牲空间）

- 核心思想：用`size`记录队列中元素个数，直接通过`size`判断空 / 满；

- 结构体修改（增加`size`）：

	c

	```c
	typedef struct {
	    ElemType data[maxSize];
	    int front;
	    int rear;
	    int size;  // 新增：记录队列中元素个数
	} SqQueue_Size;
	```
	
- 初始化：`front=0, rear=0, size=0`；

- 判空条件：`size == 0`；

- 判满条件：`size == maxSize`；

- 操作调整：

	- 入队成功后：`size++`；
	- 出队成功后：`size--`；

- 优缺点：无需牺牲空间，判断直观；需维护`size`变量（增加少量操作）。

### 5.3 方法 3：增加`tag`变量（不牺牲空间）

- 核心思想：用`tag`标记 “最近一次操作类型”，区分`front==rear`时的 “空” 与 “满”；

- `tag`定义：

	- `tag=0`：最近一次操作是 “出队”（`front==rear`时为 “空”）；
	- `tag=1`：最近一次操作是 “入队”（`front==rear`时为 “满”）；

- 结构体修改（增加`tag`）：

	c

	```c
	typedef struct {
	    ElemType data[maxSize];
	    int front;
	    int rear;
	    int tag;  // 新增：标记最近操作（0=出队，1=入队）
	} SqQueue_Tag;
	```
	
- 初始化：`front=0, rear=0, tag=0`（初始无元素，最近无操作，默认标记为 0）；

- 判空条件：`front == rear && tag == 0`；

- 判满条件：`front == rear && tag == 1`；

- 操作调整：

	- 入队成功后：`tag=1`（最近操作是入队）；
	- 出队成功后：`tag=0`（最近操作是出队）；

- 优缺点：无需牺牲空间，仅需维护 1 个整型变量；逻辑需结合`tag`判断。

## 6. 队列中元素个数的计算

- 公式：`(rear - front + maxSize) % maxSize`（适用于 “rear 指向队尾下一个位置” 的设计）；
- 推导逻辑：
	- 当`rear > front`时：元素个数 = `rear - front`（如`front=0, rear=5`，个数 = 5）；
	- 当`rear < front`时（循环状态）：元素个数 = `(rear + maxSize) - front`（如`front=3, rear=2, maxSize=10`，个数 = 9）；
	- 模`maxSize`：确保结果在`[0, maxSize-1]`范围内；
- 示例：`front=3, rear=2, maxSize=10` → `(2-3+10)%10 = 9`（正确，队列有 9 个元素）。

## 7. 特殊设计：rear 指向 “队尾元素” 的实现

### 7.1 核心区别

- 常规设计：`rear`指向 “队尾下一个位置”；
- 特殊设计：`rear`直接指向 “队尾元素”（考试需注意审题区分）。

### 7.2 关键调整

1. **初始化**：`front=0, rear=maxSize-1`（确保第一个元素插入时，`rear`先循环后移到 0）；

2. **入队逻辑**：先循环后移`rear` → 再存入元素（与常规设计相反）；

	c

	```c
	bool EnQueue_Special(SqQueue *Q, ElemType x) {
	    // 判满条件：(rear + 1) % maxSize == front（与常规一致）
	    if ((Q->rear + 1) % maxSize == Q->front) {
	        printf("队列已满，入队失败！\n");
	        return false;
	    }
	    // 第一步：rear先循环后移（因rear指向队尾元素，需先找新队尾位置）
	    Q->rear = (Q->rear + 1) % maxSize;
	    // 第二步：存入元素
	    Q->data[Q->rear] = x;
	    return true;
	}
	```
	
3. **判空条件**：`(rear + 1) % maxSize == front`（与常规设计的 “判满条件” 相同，需结合上下文区分）；

4. **判满条件**：需额外用`size`或`tag`变量（同方法 2、3，避免与判空混淆）。

## 8. 考试关键注意点

1. **优先审题**：明确题目中`rear`的定义（指向 “队尾下一个位置” 还是 “队尾元素”，两种设计操作逻辑不同）；
2. **空 / 满判断**：记住三种判空判满方法的适用场景（牺牲空间、`size`、`tag`）；
3. **公式记忆**：元素个数计算公式`(rear - front + maxSize) % maxSize`（高频考点）；
4. **循环核心**：模运算的作用（实现指针循环移动，解决 “假溢出”）。



# 3.2.3 队列的链式实现

## 一、核心概念

- **队列特性**：严格遵循**先进先出（FIFO）** 原则，仅在**队头（front）** 执行删除操作，仅在**队尾（rear）** 执行插入操作。
- **链式存储优势**：解决顺序队列的 “假溢出” 问题，存储空间动态分配，无需预先定义最大容量，内存利用率更高。
- **存储结构选择**：视频中明确采用**带头节点的单链表**实现，核心原因是 “简化操作逻辑”—— 避免入队 / 出队时判断队头指针是否为空的特殊情况。
- **关键指针定义**：
	- `front`：指向**头节点**（非数据节点，仅用于统一操作），其`next`指向真正的队头数据节点。
	- `rear`：指向**队尾数据节点**，用于快速执行入队操作。
- **队空 / 队满判定**：
	- 队空：`front == rear`（带头节点时，空队列无数据节点，`front`和`rear`均指向头节点）。
	- 队满：链式队列无固定 “队满” 状态，仅当`malloc`分配节点失败（返回`NULL`）时，入队操作失败。

## 二、存储结构定义

视频中采用标准结构体封装，包含 “节点结构” 和 “队列结构”，并通过`typedef`实现数据类型灵活性。

### 1. 头文件与宏定义

c

```c
#include <stdio.h>
#include <stdlib.h>

// 函数执行状态：OK=成功，ERROR=失败
#define OK 1
#define ERROR 0
// 布尔值定义：用于判空操作
#define TRUE 1
#define FALSE 0
// 队列元素类型（视频默认int，可按需修改）
typedef int ElemType;
// 状态类型（统一函数返回值格式）
typedef int Status;
```

### 2. 队列节点结构（单链表节点）

每个节点包含 “数据域”（存储元素）和 “指针域”（指向后续节点）：

c

```c
typedef struct QNode {
    ElemType data;       // 数据域：存储队列元素
    struct QNode *next;  // 指针域：指向后一个节点（连接链表）
} QNode, *QueuePtr;  // QueuePtr为节点指针类型
```

### 3. 队列结构（管理队头 / 队尾指针）

用结构体封装`front`和`rear`，便于统一管理队列：

c

```c
typedef struct {
    QueuePtr front;  // 头指针：指向头节点
    QueuePtr rear;   // 尾指针：指向队尾数据节点
} LinkQueue;
```

## 三、核心操作实现

视频详细讲解 6 个必备操作，每个操作均包含 “异常处理→核心逻辑→资源管理” 三步，代码与视频完全一致。

### 1. 队列初始化（InitQueue）

#### 功能：创建空队列（含头节点）

c

```c
Status InitQueue(LinkQueue *Q) {
    // 1. 分配头节点内存：front和rear初始均指向头节点
    Q->front = Q->rear = (QueuePtr)malloc(sizeof(QNode));
    if (Q->front == NULL) {  // 极端情况：内存分配失败
        return ERROR;
    }
    // 2. 头节点指针域置空（空队列无数据节点）
    Q->front->next = NULL;
    return OK;
}
```

#### 视频逻辑说明：

- 头节点不存储实际数据，仅用于 “统一操作入口”—— 无论队列是否为空，`front`始终指向头节点，避免后续操作的指针判断。
- 初始化后`front == rear`，满足 “队空判定条件”。

### 2. 判空操作（QueueEmpty）

#### 功能：判断队列是否为空

c

```c
Status QueueEmpty(LinkQueue Q) {
    // 带头节点的核心判空逻辑：front与rear是否指向同一节点
    if (Q.front == Q.rear) {
        return TRUE;  // 空队列
    } else {
        return FALSE; // 非空队列
    }
}
```

#### 视频逻辑说明：

- 无需遍历链表，直接比较指针，时间复杂度`O(1)`，效率极高。

### 3. 入队操作（EnQueue）

#### 功能：在队尾插入新元素`e`

c

```c
Status EnQueue(LinkQueue *Q, ElemType e) {
    QueuePtr newNode;  // 临时指针：指向新创建的数据节点
    
    // 1. 分配新节点内存
    newNode = (QueuePtr)malloc(sizeof(QNode));
    if (newNode == NULL) {  // 内存不足，入队失败
        return ERROR;
    }
    
    // 2. 给新节点赋值
    newNode->data = e;      // 数据域存入e
    newNode->next = NULL;   // 新节点为队尾，指针域置空
    
    // 3. 接入队尾：原队尾节点的next指向新节点
    Q->rear->next = newNode;
    // 4. 更新尾指针：rear指向新队尾节点
    Q->rear = newNode;
    
    return OK;
}
```

#### 视频逻辑说明：

- 入队本质是 “单链表尾插法”，利用`rear`直接定位队尾，无需遍历，时间复杂度`O(1)`。
- 新节点`next`必须置空，否则后续出队 / 销毁时会出现 “野指针”。

### 4. 出队操作（DeQueue）

#### 功能：删除队头元素，将元素值通过`e`带回（视频重点难点）

c

```c
Status DeQueue(LinkQueue *Q, ElemType *e) {
    QueuePtr p;  // 临时指针：指向待删除的队头数据节点
    
    // 1. 先判空：空队列无法出队
    if (QueueEmpty(*Q)) {
        return ERROR;
    }
    
    // 2. 定位队头数据节点：front的next（头节点的下一个节点）
    p = Q->front->next;
    // 3. 保存队头元素值（通过指针e带回）
    *e = p->data;
    // 4. 移除队头节点：front的next指向p的下一个节点
    Q->front->next = p->next;
    
    // 5. 关键特殊处理：若出队后队列空，需重置rear（避免野指针）
    if (Q->rear == p) {  // 说明出队前队列仅1个数据节点
        Q->rear = Q->front;  // 让rear指向头节点，恢复队空状态
    }
    
    // 6. 释放待删除节点内存（避免内存泄漏，视频反复强调）
    free(p);
    return OK;
}
```

#### 视频逻辑说明：

- 队头数据节点是`front->next`，而非`front`（`front`指向头节点，不能删除）。
- 特殊情况处理是核心：若出队前队列仅 1 个数据节点（`rear == p`），出队后队列空，若不重置`rear`，`rear`会指向已释放的节点（野指针），后续入队会出错。
- 时间复杂度`O(1)`，无需遍历链表。

### 5. 取队头元素（GetHead）

#### 功能：获取队头元素值（不删除，仅读取）

c

```c
Status GetHead(LinkQueue Q, ElemType *e) {
    // 1. 判空：空队列无队头元素
    if (QueueEmpty(Q)) {
        return ERROR;
    }
    // 2. 读取队头元素：front->next->data（头节点的下一个节点的数据域）
    *e = Q.front->next->data;
    return OK;
}
```

#### 视频逻辑说明：

- 仅读取数据，不修改队列结构，操作简单，时间复杂度`O(1)`。
- 必须通过指针`e`带回数据（C 语言函数无法直接返回多个值）。

### 6. 销毁队列（DestroyQueue）

#### 功能：释放队列所有节点（头节点 + 数据节点），避免内存泄漏

c

```c
Status DestroyQueue(LinkQueue *Q) {
    // 1. 遍历链表，逐个释放节点（从头部开始）
    while (Q->front != NULL) {
        Q->rear = Q->front->next;  // 保存当前节点的下一个节点
        free(Q->front);            // 释放当前节点（先释放front指向的节点）
        Q->front = Q->rear;        // front移动到下一个节点
    }
    // 2. 销毁后指针置空（可选，但更安全，避免野指针）
    Q->front = NULL;
    Q->rear = NULL;
    return OK;
}
```

#### 视频逻辑说明：

- 销毁核心是 “循环释放”：用`rear`临时保存下一个节点，避免释放`front`后无法继续遍历。
- 时间复杂度`O(n)`（`n`为队列长度），需遍历所有节点。

## 四、关键注意事项

1. **带头节点的不可替代性**：
	- 若无头节点，空队列时`front`和`rear`均为`NULL`，入队时需额外判断 “`front`是否为空”，逻辑复杂；
	- 带头节点后，所有操作（入队 / 出队）无需判断`front`是否为`NULL`，逻辑统一。
2. **野指针规避（视频高频考点）**：
	- 入队：新节点`next`必须置空；
	- 出队：队列空时`rear`必须指向`front`；
	- 销毁：最终`front`和`rear`需置空。
3. **内存泄漏问题**：
	- 出队和销毁操作必须调用`free`释放节点内存，否则会导致内存持续占用（视频中用 “内存泄漏” 重点警示）。
4. **数据类型灵活性**：
	- 用`typedef int ElemType`定义元素类型，后续需存储`char`、结构体等类型时，仅需修改`ElemType`的定义，无需修改所有操作函数。



# 双端队列（Deque）知识点总结

## 1. 双端队列基本概念

### 1.1 定义

双端队列是**操作受限的线性表**，核心特征为：允许从**两端**执行插入操作，同时允许从**两端**执行删除操作，是栈和队列的功能扩展。

### 1.2 与栈、队列的对比

三者均属于 “操作受限的线性表”，核心区别在于插入和删除的操作范围限制，具体对比如下：

| 数据结构          | 插入操作限制                 | 删除操作限制                   | 核心逻辑         |
| ----------------- | ---------------------------- | ------------------------------ | ---------------- |
| 栈（Stack）       | 仅允许从**一端**插入（栈顶） | 仅允许从**一端**删除（栈顶）   | 先进后出（LIFO） |
| 队列（Queue）     | 仅允许从**一端**插入（队尾） | 仅允许从**另一端**删除（队头） | 先进先出（FIFO） |
| 双端队列（Deque） | 允许从**两端**插入           | 允许从**两端**删除             | 无固定进出顺序   |

### 1.3 双端队列与栈的关联

当双端队列的**插入和删除操作仅限制在同一端**时，双端队列退化为栈。因此得出核心结论：**栈能实现的所有合法输出序列，双端队列均能实现**（双端队列功能覆盖栈）。

## 2. 双端队列的两个核心变种

视频明确提出双端队列的两种常见变种，区别在于对 “插入” 或 “删除” 操作进一步限制，具体如下：

### 2.1 输入受限的双端队列

- **操作限制**：仅允许从**某一端**（固定端）执行插入操作，删除操作可从**两端**执行。
- 核心特点：插入顺序固定（如按 1→2→3→4 的输入顺序，插入端固定则元素入队顺序必为 1、2、3、4），删除端灵活，可通过两端删除调整输出顺序。

### 2.2 输出受限的双端队列

- **操作限制**：仅允许从**某一端**（固定端）执行删除操作，插入操作可从**两端**执行。
- 核心特点：删除顺序需匹配固定端的输出规则，插入端灵活，可通过两端插入调整队列内部元素的排列顺序，以满足目标输出序列。

## 3. 输出序列合法性判断（核心考点）

视频以 “输入序列固定为 1、2、3、4（按此顺序依次输入）” 为案例，分三种场景（栈、输入受限双端队列、输出受限双端队列）分析输出序列的合法性，核心判断原则：**若某元素 x 在输出序列中出现，则所有序号小于 x 的元素（1~x-1）已完成输入**。

### 3.1 栈的输出序列合法性（基础参考）

栈遵循 “先进后出（LIFO）”，视频中通过具体案例分析合法与非法序列：

#### 3.1.1 合法序列案例（含操作过程）

1. **序列 1：1、2、3、4**
	- 操作流程：1 入栈 → 1 出栈 → 2 入栈 → 2 出栈 → 3 入栈 → 3 出栈 → 4 入栈 → 4 出栈（“入一个出一个”，符合栈规则）。
2. **序列 2：3、2、4、1**
	- 操作流程：1 入栈 → 2 入栈 → 3 入栈 → 3 出栈 → 2 出栈 → 4 入栈 → 4 出栈 → 1 出栈（先入 1、2、3，出 3、2；再入 4 出 4，最后出 1）。
3. **序列 3：4、3、2、1**
	- 操作流程：1 入栈 → 2 入栈 → 3 入栈 → 4 入栈 → 4 出栈 → 3 出栈 → 2 出栈 → 1 出栈（“全入后全出”，典型先进后出）。

#### 3.1.2 非法序列案例（含分析逻辑）

1. **序列 1：2、4、1、3**
	- 分析：若首元素输出 2，需先入 1、2（1 在栈底，2 在栈顶）；2 出栈后栈内剩 1；要输出 4，需继续入 3、4（3 在栈中 1 上方，4 在栈顶）；4 出栈后栈顶为 3，只能先出 3，无法直接出 1，故序列非法。
2. **序列 2：3、4、1、2**
	- 分析：首元素输出 3，需先入 1、2、3（1 在栈底，2 在中间，3 在栈顶）；3 出栈后栈内剩 1、2（2 在栈顶）；后续无论如何操作，2 必须在 1 前出栈，而序列中 1 在 2 前，故非法。

#### 3.1.3 合法序列数量计算（卡特兰数）

- 视频提及：n 个元素的合法栈输出序列数量遵循**卡特兰数**，公式为：
	*C**n*​=*n*+11​(*n*2*n*​)（(*n*2*n*​)为组合数，即从 2n 个元素中选 n 个的数量）。
- 当 n=4（输入序列 1~4）时，卡特兰数*C*4=14，即 1~4 的合法栈输出序列共 14 种。

### 3.2 输入受限的双端队列输出序列合法性

输入受限（仅一端插入），故元素入队顺序固定为 1→2→3→4，删除可从两端执行。核心结论：**栈的合法序列均合法，部分栈的非法序列在此场景下合法**。

#### 3.2.1 栈非法但输入受限双端队列合法的案例

1. **序列 1：1、4、2、3**
	- 操作流程：1 入队（插入端） → 1 出队（左端 / 右端） → 2 入队（插入端） → 3 入队（插入端） → 4 入队（插入端） → 4 出队（右端） → 2 出队（左端） → 3 出队（右端）（通过 “右端删 4、左端删 2”，实现栈无法完成的序列）。
2. **序列 2：3、1、4、2**
	- 操作流程：1 入队（插入端） → 2 入队（插入端） → 3 入队（插入端） → 3 出队（右端） → 1 出队（左端） → 4 入队（插入端） → 4 出队（右端） → 2 出队（左端）（通过 “右端删 3、左端删 1”，实现栈无法完成的序列）。

#### 3.2.2 输入受限双端队列的非法序列

- 视频明确非法序列：**4、2、1、3** 和 **4、2、3、1**。
- 分析逻辑：若首元素输出 4，需先入 1、2、3、4（插入端固定，队列内顺序为 1→2→3→4）；4 出队后队列内剩 1→2→3，删除仅能从两端（左端删 1、右端删 3），无法直接删除中间的 2，故 “4 后紧跟 2” 的序列均非法。

### 3.3 输出受限的双端队列输出序列合法性

输出受限（仅一端删除），故删除需从固定端执行，插入可从两端调整元素顺序。核心结论：**栈的合法序列均合法，部分栈的非法序列在此场景下合法**。

#### 3.3.1 栈非法但输出受限双端队列合法的案例

1. **序列 1：1、4、2、3**
	- 操作流程：1 入队（右端） → 1 出队（右端） → 2 入队（左端） → 3 入队（左端） → 4 入队（右端） → 4 出队（右端） → 2 出队（右端） → 3 出队（右端）（通过 “左端插入 2、3”，使队列内顺序为 2→3→4，匹配输出序列）。
2. **序列 2：3、1、4、2**
	- 操作流程：1 入队（右端） → 2 入队（左端） → 3 入队（右端） → 3 出队（右端） → 1 出队（右端） → 4 入队（右端） → 4 出队（右端） → 2 出队（右端）（通过 “左端插入 2、右端插入 3”，使队列内顺序为 2→1→3，匹配输出序列）。

#### 3.3.2 输出受限双端队列的非法序列

- 视频明确非法序列：**4、1、3、2** 和 **4、2、3、1**。
- 分析逻辑：若首元素输出 4，需先入 1、2、3、4（插入可两端，但 1 入队后，2 无论从左端还是右端插入，均与 1 相邻，即队列内 1 和 2 必相邻）；而序列 4、1、3、2 中 1 和 3 相邻，4、2、3、1 中 2 和 3 相邻，均违背 “1 和 2 必相邻” 的逻辑，故非法。

## 4. 核心总结

1. 双端队列是栈和队列的扩展，可通过限制操作退化为栈。
2. 输入受限双端队列：插入固定、删除灵活，非法序列仅 “大元素后紧跟中间小元素”（如 4 后跟 2）。
3. 输出受限双端队列：删除固定、插入灵活，非法序列因 “必相邻元素拆分”（如 1 和 2 不相邻）导致。
4. 合法性判断核心：某元素输出前，其所有前置输入元素已入队 / 栈，再结合操作限制推导元素顺序。



# 队列及其衍生结构知识点总结

## 一、队列基础回顾

### 1.1 队列核心特性

- **先进先出（FIFO）**：元素从**队尾（rear）入队**，从**队头（front）出队**，符合 “先来后到” 逻辑。
- 普通队列的数组实现问题：
	用固定大小数组存储时，会出现**假溢出**—— 队尾指针已达数组边界（rear = maxSize-1），但队头前方仍有空闲空间，此时无法直接入队，需移动所有元素至队头，效率极低（若有 1 亿个元素，需移动 1 亿次）。

## 二、循环队列（顺序结构优化）

### 2.1 循环队列的设计目的

解决普通数组队列的**假溢出问题**：将数组逻辑上 “首尾相连”，形成环形结构，队尾满时可绕回数组起始位置继续入队（前提是队头有空）。

### 2.2 循环队列的关键概念

#### 2.2.1 核心参数

- `maxSize`：循环队列的最大容量（数组长度）。
- `front`：队头指针，指向**队头元素的位置**（视频中默认初始值为 0，特殊场景需调整）。
- `rear`：队尾指针，视频中提到两种指向逻辑：
	1. **默认逻辑**：指向**队尾元素的下一个位置**（初始值与 front 相同，均为 0）；
	2. **特殊逻辑**：指向**队尾元素本身**（初始值需设为`maxSize-1`，需配合入队顺序调整）。
- 数据存储：用动态内存分配的数组（`ElementType *data`），而非固定大小数组（视频强调 “老生常谈，与栈、顺序表的动态分配一致”）。

#### 2.2.2 判空与判满条件

| 状态   | 条件（默认逻辑：rear 指向队尾元素下一个位置） | 说明                                                         |
| ------ | --------------------------------------------- | ------------------------------------------------------------ |
| 队列空 | `front == rear`                               | 队头与队尾指针重合，无元素存储。                             |
| 队列满 | `(rear + 1) % maxSize == front`               | 故意空出 1 个位置，避免与 “空队列” 条件冲突（视频称 “循环队列无法真正满”） |

> 视频吐槽：教材直接讲循环队列，未先说明 “假溢出” 问题，初学者难理解；需先讲普通队列的缺陷，再引入循环队列的必要性。

### 2.3 循环队列的代码实现（C 语言）

#### 2.3.1 结构体定义

c

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// 定义元素类型（可根据需求修改，此处以int为例）
typedef int ElementType;

// 循环队列结构体（动态内存分配）
typedef struct {
    ElementType *data;  // 动态数组存储元素（而非固定数组：ElementType data[maxSize]）
    int front;          // 队头指针
    int rear;           // 队尾指针（指向队尾元素下一个位置）
    int maxSize;        // 队列最大容量
} SqQueue;
```

#### 2.3.2 初始化队列（动态分配内存）

c

```c
// 初始化循环队列，参数为队列指针和最大容量
bool InitQueue(SqQueue *Q, int maxSize) {
    // 为数据数组分配堆内存
    Q->data = (ElementType *)malloc(maxSize * sizeof(ElementType));
    if (Q->data == NULL) {  // 内存分配失败
        printf("内存分配失败！\n");
        return false;
    }
    Q->front = 0;       // 初始队头指针为0
    Q->rear = 0;        // 初始队尾指针为0（指向队尾元素下一个位置）
    Q->maxSize = maxSize;
    return true;
}
```

#### 2.3.3 判空操作

c

```c
// 判断队列是否为空
bool QueueEmpty(SqQueue Q) {
    return Q.front == Q.rear;  // 队头与队尾重合则为空
}
```

#### 2.3.4 判满操作

```c
// 判断队列是否为满
bool QueueFull(SqQueue Q) {
    // 队尾+1取余后等于队头，说明满（空1个位置）
    return (Q.rear + 1) % Q.maxSize == Q.front;
}
```

#### 2.3.5 入队操作

c

```c
// 入队：将元素e插入队尾
bool EnQueue(SqQueue *Q, ElementType e) {
    if (QueueFull(*Q)) {  // 先判满，满则无法入队
        printf("队列已满，无法入队！\n");
        return false;
    }
    Q->data[Q->rear] = e;  // 将元素存入队尾指针指向的位置
    // 队尾指针后移（绕圈：取余实现循环）
    Q->rear = (Q->rear + 1) % Q->maxSize;
    return true;
}
```

#### 2.3.6 出队操作

c

```c
// 出队：删除队头元素，并用e接收出队元素
bool DeQueue(SqQueue *Q, ElementType *e) {
    if (QueueEmpty(*Q)) {  // 先判空，空则无法出队
        printf("队列为空，无法出队！\n");
        return false;
    }
    *e = Q->data[Q->front];  // 接收队头元素
    // 队头指针后移（绕圈：取余实现循环）
    Q->front = (Q->front + 1) % Q->maxSize;
    return true;
}
```

#### 2.3.7 获取队头元素

c

```c
// 获取队头元素（不删除），用e接收
bool GetHead(SqQueue Q, ElementType *e) {
    if (QueueEmpty(Q)) {  // 先判空
        printf("队列为空，无队头元素！\n");
        return false;
    }
    *e = Q.data[Q.front];  // 直接取队头指针指向的元素
    return true;
}
```

#### 2.3.8 视频中的测试示例（Test3）

c

```c
void Test3() {
    SqQueue Q;
    int maxSize = 8;  // 队列最大容量为8（实际存储7个元素，空1个位置）
    InitQueue(&Q, maxSize);

    // 入队：10,20,30,40,50
    EnQueue(&Q, 10);
    EnQueue(&Q, 20);
    EnQueue(&Q, 30);
    EnQueue(&Q, 40);
    EnQueue(&Q, 50);

    // 出队2次（出队10、20）
    ElementType e1, e2;
    DeQueue(&Q, &e1);
    DeQueue(&Q, &e2);
    printf("出队元素：%d, %d\n", e1, e2);  // 输出：10, 20

    // 获取队头元素（此时队头为30）
    ElementType head;
    GetHead(Q, &head);
    printf("当前队头元素：%d\n", head);  // 输出：30

    // 释放动态内存（避免内存泄漏）
    free(Q.data);
    Q.data = NULL;
}

// 主函数调用测试
int main() {
    Test3();
    return 0;
}
```

### 2.4 循环队列的特殊场景：队尾指针指向队尾元素

视频中提到 “若想让 rear 直接指向队尾元素”，需调整两点：

1. **初始值**：`front = 0`，`rear = maxSize - 1`（如 maxSize=8 时，初始 rear=7）；
2. **入队顺序**：先移动 rear（`rear = (rear+1)%maxSize`），再判满，最后存入元素。

- 缺陷：仍会出现 “空 1 个位置” 的问题，无法彻底解决 “满队列” 判断冲突。

## 三、队列的链式结构（LinkQueue）

### 3.1 设计背景

顺序队列（含循环队列）需提前确定`maxSize`，若元素数量超过容量则无法扩展；链式队列通过链表节点动态分配内存，无固定容量限制，仅受堆内存大小约束。

### 3.2 链式队列的核心结构

视频中采用**带头节点的链表**（头节点不存储数据，仅用于简化操作），结构定义分两层：

1. **节点结构（QNode）**：存储单个元素及下一个节点的指针；
2. **队列结构（LinkQueue）**：存储队头（front）和队尾（rear）指针，均指向 QNode 类型。

### 3.3 链式队列的代码实现（C 语言）

#### 3.3.1 结构体定义

c

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef int ElementType;

// 链表节点结构（存储单个元素）
typedef struct QNode {
    ElementType data;    // 数据域
    struct QNode *next;  // 指针域：指向后一个节点
} QNode, *QueuePtr;

// 链式队列结构（管理队头和队尾）
typedef struct {
    QueuePtr front;  // 队头指针（指向头节点）
    QueuePtr rear;   // 队尾指针（指向尾节点）
} LinkQueue;
```

#### 3.3.2 初始化队列（带头节点）

c

```c
// 初始化链式队列：front和rear均指向头节点
bool InitLinkQueue(LinkQueue *Q) {
    // 创建头节点（不存储数据）
    Q->front = Q->rear = (QueuePtr)malloc(sizeof(QNode));
    if (Q->front == NULL) {  // 内存分配失败
        printf("内存分配失败！\n");
        return false;
    }
    Q->front->next = NULL;  // 头节点的next初始为NULL（队列空）
    return true;
}
```

#### 3.3.3 判空操作

c

```c
// 判断链式队列是否为空（头节点的next为NULL，或front==rear）
bool LinkQueueEmpty(LinkQueue Q) {
    // 两种等价判断：front==rear（初始均指向头节点） 或 front->next==NULL
    return Q.front == Q.rear;
}
```

#### 3.3.4 入队操作（尾插法）

视频中明确 “链式队列入队用尾插法”，因队尾入队符合 FIFO 逻辑：

c

```c
// 入队：将元素e插入队尾（尾插法）
bool EnLinkQueue(LinkQueue *Q, ElementType e) {
    // 1. 创建新节点并赋值
    QueuePtr newNode = (QueuePtr)malloc(sizeof(QNode));
    if (newNode == NULL) {
        printf("内存分配失败！\n");
        return false;
    }
    newNode->data = e;
    newNode->next = NULL;  // 新节点为尾节点，next设为NULL

    // 2. 将新节点接入队尾
    Q->rear->next = newNode;  // 原尾节点的next指向新节点
    Q->rear = newNode;        // 队尾指针后移至新节点

    return true;
}
```

#### 3.3.5 出队操作（删除首节点）

出队需删除 “头节点的下一个节点”（即队头元素），并处理 “删除后队列为空” 的情况：

c

```c
// 出队：删除队头元素（头节点的next），用e接收出队元素
bool DeLinkQueue(LinkQueue *Q, ElementType *e) {
    if (LinkQueueEmpty(*Q)) {  // 先判空
        printf("队列为空，无法出队！\n");
        return false;
    }

    // 1. 记录要删除的队头节点（头节点的next）
    QueuePtr delNode = Q->front->next;
    *e = delNode->data;  // 接收出队元素

    // 2. 头节点的next指向删除节点的下一个节点
    Q->front->next = delNode->next;

    // 3. 若删除的是尾节点（队列空），需将rear重新指向头节点
    if (Q->rear == delNode) {
        Q->rear = Q->front;
    }

    // 4. 释放删除节点的内存
    free(delNode);
    delNode = NULL;

    return true;
}
```

#### 3.3.6 获取队头元素

c

```c
// 获取队头元素（不删除），用e接收
bool GetLinkHead(LinkQueue Q, ElementType *e) {
    if (LinkQueueEmpty(Q)) {  // 先判空
        printf("队列为空，无队头元素！\n");
        return false;
    }
    // 队头元素是头节点的next节点的数据
    *e = Q.front->next->data;
    return true;
}
```

#### 3.3.7 视频中的测试示例

c

```c
void TestLinkQueue() {
    LinkQueue Q;
    InitLinkQueue(&Q);

    // 入队：10,20,30,40,50
    EnLinkQueue(&Q, 10);
    EnLinkQueue(&Q, 20);
    EnLinkQueue(&Q, 30);
    EnLinkQueue(&Q, 40);
    EnLinkQueue(&Q, 50);

    // 出队2次（出队10、20）
    ElementType e1, e2;
    DeLinkQueue(&Q, &e1);
    DeLinkQueue(&Q, &e2);
    printf("出队元素：%d, %d\n", e1, e2);  // 输出：10, 20

    // 获取队头元素（此时队头为30）和队尾元素（50）
    ElementType head, rear;
    GetLinkHead(Q, &head);
    rear = Q.rear->data;  // 队尾指针直接指向尾节点，可直接取data
    printf("当前队头元素：%d，当前队尾元素：%d\n", head, rear);  // 输出：30, 50

    // 释放头节点内存（避免内存泄漏）
    free(Q.front);
    Q.front = Q.rear = NULL;
}

// 主函数调用测试
int main() {
    TestLinkQueue();
    return 0;
}
```

## 四、特殊队列：双端队列（Deque）

### 4.1 定义

视频中提到 “双端队列是队列的变种”，允许在**两端进行入队操作**，出队操作则分两种场景：

1. 两端可入队 + 一端可出队；
2. 两端可入队 + 两端可出队。

### 4.2 核心考点

- 选择题常考 “出队序列可能性”：需基于 “入队顺序” 和 “双端队列的操作限制” 判断序列是否合法（如元素依次入队，能否通过双端操作得到目标出队序列）。
- 视频强调：双端队列代码实现可能性低，但需掌握逻辑判断（如 2010 年考研题：判断双端队列的不可能出队序列）。

## 五、关键考点梳理

### 5.1 循环队列 front/rear 初始值判断

- 场景：循环队列存储在数组 A [0..N-1]，第一个入队元素在 A [0]，且`front指向队头元素，rear指向队尾元素`。
- 结论：初始`front=0`，`rear=N-1`（因 rear 需指向队尾元素，第一个元素入队后 rear 需变为 0，故初始设为 N-1，入队时`rear=(rear+1)%N`后指向 0）。

### 5.2 栈与队列结合的容量问题

- 场景：元素依次进栈，出栈后立即进队列，已知出队序列，求栈的最小容量。
- 方法：模拟 “入栈 - 出栈 - 入队” 过程，记录栈中元素的最大个数（即栈的最小容量）。
- 示例（视频 2009 年题）：元素 A~G 进栈后入队，出队序列 BDCFEAG，栈最小容量为 3。

### 5.3 双端队列的出队序列合法性

- 场景：元素依次入双端队列（两端可入），仅一端可出队，判断出队序列是否合法。
- 核心：入队时可选择 “左端入” 或 “右端入”，但出队端固定，需验证序列能否通过该操作生成（如 2010 年考研题：排除 “连续多次出队违反限制” 的序列）。

### 5.4 栈的出栈序列个数问题

- 场景：元素 1~N 依次入栈，已知第 k 个出栈元素为 X，求第 k+1 个出栈元素的可能取值个数。
- 示例（2011 年考研题）：元素 1~5 入栈，第 2 个出栈元素为 3，第 3 个出栈元素的可能取值个数为 3（2、4、5）。







# 栈在括号匹配中的应用

## 1. 括号匹配问题定义

视频中明确括号匹配问题是栈的经典应用，核心需求是确保代码或文本中的括号满足「双重匹配规则」，具体定义如下：

- **匹配核心要求**：括号需同时满足「数量匹配」和「形状匹配」
	- 数量匹配：左括号（`(`、`[`、`{`）与对应右括号（`)`、`]`、`}`）的数量完全相等，无 “单身” 括号（即无左括号无右括号配对，或右括号无左括号配对）
	- 形状匹配：左括号必须与同类型右括号配对（如`(`只能与`)`配对，不能与`]`或`}`配对）
- **实际应用场景**：代码开发中，IDE（可视化编程环境，视频中解释：“大家用来写代码的工具”）和编译器会自动执行括号匹配检查，若不匹配则提示错误

## 2. 栈应用的核心原理

视频中强调栈的「后进先出（LIFO）」特性与括号匹配逻辑高度契合，是选择栈实现该问题的核心原因：

- **括号匹配的关键规律**：**越靠后出现的左括号，越先被对应的右括号匹配**
	示例：扫描序列`(([]))`时，最后一个左括号`[`会先被第一个右括号`]`匹配，再依次匹配外侧的`(`与`)`，符合 “后入先出”
- **栈与括号匹配的映射关系**：
	- 左括号：遇到时执行「入栈操作」，暂存到栈中，等待后续右括号匹配
	- 右括号：遇到时执行「出栈操作」，弹出栈顶的左括号进行匹配检查
	- 栈的 “后进先出” 特性确保了 “后出现的左括号优先匹配”，完美贴合括号匹配逻辑

## 3. 括号匹配算法详细步骤

视频中拆解的算法步骤（从左到右完整扫描括号序列）：

1. **初始化阶段**：创建一个空的顺序栈，用于存储待匹配的左括号（栈顶指针初始化为`-1`，表示栈空）
2. **遍历扫描阶段**：从左到右依次扫描括号序列中的每个字符（记当前字符为`current`），分两种情况处理：
	- **情况 1：当前字符是左括号（`(`/`[`/`{`）**
		执行「入栈操作」：栈顶指针上移，将当前左括号压入栈顶，继续扫描下一个字符
	- **情况 2：当前字符是右括号（`)`/`]`/`}`）**
		分两步处理：
		① 检查栈是否为空：若栈空，说明当前右括号无对应的左括号（右括号 “单身”），直接返回「匹配失败」；若栈非空，执行「出栈操作」，弹出栈顶的左括号（记为`topChar`）
		② 检查形状匹配：判断`topChar`与`current`是否为同类型括号（如`topChar='('`且`current=')'`为匹配），若不匹配则返回「匹配失败」，若匹配则继续扫描下一个字符
3. **扫描结束检查阶段**：遍历完所有字符后，需检查栈是否为空：
	- 若栈非空：说明存在未匹配的左括号（左括号 “单身”），返回「匹配失败」
	- 若栈空：所有括号均完成匹配，返回「匹配成功」

## 4. 匹配失败的三种场景及示例

视频中通过具体示例拆解了三种匹配失败的场景，每种场景对应明确的失败原因：

### 4.1 场景 1：右括号 “单身”（栈空时遇到右括号）

- 示例序列：`(()))`
- 扫描过程：
	1. 前 3 个字符`(、(、)`：前两个`(`依次入栈，第三个`)`弹出栈顶`(`匹配，栈内剩余 1 个`(`
	2. 第四个字符`)`：弹出栈顶`(`匹配，栈空（栈顶指针 =-1）
	3. 第五个字符`)`：栈已空，无左括号可匹配 → 匹配失败（右括号单身）

### 4.2 场景 2：左括号 “单身”（扫描完栈非空）

- 示例序列：`(([])`
- 扫描过程：
	1. 前 4 个字符`(、(、[、]`：前两个`(`入栈，`[`入栈，`]`弹出`[`匹配，栈内剩余 2 个`(`
	2. 扫描结束：栈内仍有 2 个`(`未找到对应右括号 → 匹配失败（左括号单身）

### 4.3 场景 3：括号形状不匹配

- 示例序列：`([)]`
- 扫描过程：
	1. 第一个字符`(`：入栈，栈内元素为`[ ( ]`（栈顶为`(`）
	2. 第二个字符`[`：入栈，栈内元素为`[ (, [ ]`（栈顶为`[`）
	3. 第三个字符`)`：弹出栈顶`[`，检查形状：`[`与`)`不匹配 → 匹配失败（形状不匹配）

## 5. 完整代码实现

### 5.1 顺序栈结构定义

c

```c
#include <stdio.h>
#include <stdlib.h>

// 顺序栈最大容量（视频未指定具体值，取常用值100，避免溢出）
#define MAXSIZE 100

// 顺序栈结构定义（存储待匹配的左括号）
typedef struct {
    char data[MAXSIZE];  // 数组：存储左括号字符
    int top;             // 栈顶指针：-1表示栈空，指向栈顶元素下标
} SqStack;
```

### 5.2 栈的基本操作

c

```c
/**
 * @brief 初始化顺序栈
 * @param S 指向顺序栈的指针（需修改栈内部状态，用指针）
 * @return 无返回值，初始化后栈顶指针top=-1（栈空）
 */
void InitStack(SqStack *S) {
    S->top = -1;  // 栈空标志
}

/**
 * @brief 判断顺序栈是否为空
 * @param S 顺序栈（仅读取状态，值传递）
 * @return 1：栈空；0：栈非空
 */
int StackEmpty(SqStack S) {
    return (S.top == -1) ? 1 : 0;
}

/**
 * @brief 入栈操作（压入左括号）
 * @param S 指向顺序栈的指针
 * @param ch 待入栈的左括号字符（`(`、`[`、`{`）
 * @return 1：入栈成功；0：栈满（溢出），入栈失败
 */
int Push(SqStack *S, char ch) {
    // 栈满判断：top达到数组最大下标（MAXSIZE-1）
    if (S->top == MAXSIZE - 1) {
        printf("栈溢出：括号序列长度超过栈最大容量\n");
        return 0;
    }
    S->top++;              // 栈顶指针上移
    S->data[S->top] = ch;  // 左括号存入栈顶
    return 1;
}

/**
 * @brief 出栈操作（弹出栈顶左括号）
 * @param S 指向顺序栈的指针
 * @param ch 指向存储出栈字符的变量（接收弹出的左括号）
 * @return 1：出栈成功；0：栈空，出栈失败
 */
int Pop(SqStack *S, char *ch) {
    // 栈空判断：无法弹出元素
    if (StackEmpty(*S)) {
        return 0;
    }
    *ch = S->data[S->top];  // 取出栈顶左括号
    S->top--;               // 栈顶指针下移（栈顶元素逻辑删除）
    return 1;
}
```

### 5.3 括号匹配核心函数

c

```c
/**
 * @brief 检查括号序列是否匹配（核心函数）
 * @param bracketArr 存储括号序列的字符数组（如"(([]))"）
 * @param length 括号序列的长度（字符数组元素个数）
 * @return 1：匹配成功；0：匹配失败
 */
int BracketMatch(char bracketArr[], int length) {
    SqStack S;
    InitStack(&S);  // 初始化栈，准备存储左括号

    // 从左到右遍历括号序列
    for (int i = 0; i < length; i++) {
        char current = bracketArr[i];

        // 情况1：当前字符是左括号 → 入栈
        if (current == '(' || current == '[' || current == '{') {
            Push(&S, current);
        }
        // 情况2：当前字符是右括号 → 出栈匹配
        else if (current == ')' || current == ']' || current == '}') {
            char topChar;  // 存储弹出的栈顶左括号
            // 子情况2.1：栈空 → 右括号单身，匹配失败
            if (!Pop(&S, &topChar)) {
                printf("匹配失败：存在未配对的右括号（右括号单身）\n");
                return 0;
            }
            // 子情况2.2：检查括号形状是否匹配
            if ((current == ')' && topChar != '(') ||    // 右小括号匹配左小括号
                (current == ']' && topChar != '[') ||    // 右中括号匹配左中括号
                (current == '}' && topChar != '{')) {    // 右大括号匹配左大括号
                printf("匹配失败：括号形状不匹配（如左中括号与右小括号配对）\n");
                return 0;
            }
        }
        // 视频中未提及非括号字符，故不处理非括号情况
    }

    // 情况3：扫描结束后检查栈是否为空 → 左括号单身判断
    if (!StackEmpty(S)) {
        printf("匹配失败：存在未配对的左括号（左括号单身）\n");
        return 0;
    }

    // 所有检查通过，匹配成功
    printf("括号序列匹配成功\n");
    return 1;
}
```

## 6. 顺序栈与链栈的对比

视频中明确两种栈的适用场景差异，核心区别在于存储方式和容量限制，具体对比如下：

| 对比维度   | 顺序栈（视频代码实现）            | 链栈（实际开发推荐）              |
| ---------- | --------------------------------- | --------------------------------- |
| 存储方式   | 静态数组（固定容量）              | 动态链表（节点存储）              |
| 容量限制   | 有（受 MAXSIZE 限制，易溢出）     | 无（仅受内存大小限制）            |
| 实现复杂度 | 低（数组操作简单，代码短）        | 高（需处理指针 / 节点创建销毁）   |
| 适用场景   | 考试答题（代码简洁，易书写）      | 实际开发（括号序列长，无溢出）    |
| 核心问题   | 括号序列过长时可能栈溢出          | 无溢出问题                        |
| 操作效率   | 入栈 / 出栈 O (1)（数组随机访问） | 入栈 / 出栈 O (1)（仅操作头节点） |



# 栈在表达式求值中的应用

## 1. 核心术语与三种算术表达式定义

视频中首先明确了算术表达式的组成要素及三种常见形式，是后续转换与计算的基础。

### 1.1 基础术语

- **操作数**：参与运算的数值（如 `1、2、a、b`）。
- **运算符**：表示运算规则的符号（如 `+、-、*、/`）。
- **界限符**：用于明确运算顺序的符号（仅中缀表达式需要，如 `()`），作用是避免运算顺序歧义。

### 1.2 三种表达式的定义与特点

| 表达式类型 | 别名         | 定义（核心特征）                           | 优点                             | 缺点                                         |
| ---------- | ------------ | ------------------------------------------ | -------------------------------- | -------------------------------------------- |
| 中缀表达式 | 标准表达式   | 运算符位于两个操作数**中间**（如 `a+b*c`） | 符合人类阅读习惯                 | 需界限符（括号）明确运算顺序，计算机处理复杂 |
| 后缀表达式 | 逆波兰表达式 | 运算符位于两个操作数**后面**（如 `abc*+`） | 无界限符，计算机可通过栈高效计算 | 不符合人类阅读习惯                           |
| 前缀表达式 | 波兰表达式   | 运算符位于两个操作数**前面**（如 `+a*bc`） | 无界限符，可通过栈计算           | 不符合人类阅读习惯，应用场景少（考试考得少） |

> 视频强调：后缀表达式因 “计算机处理效率高”，是考研与面试的核心考点，前缀表达式应用较少。

## 2. 中缀表达式与后缀表达式的转换

视频中转换的核心是**确定运算顺序**，并通过 “左优先原则” 保证转换结果唯一（符合算法的 “确定性” 要求：同一输入仅一个输出）。

### 2.1 转换核心原则：左优先原则

- 定义：在中缀表达式中，若多个运算符满足 “运算优先级允许”（如先乘除后加减、括号内优先），**优先计算左边的运算符**，避免转换结果歧义。
- 优先级规则（默认）：`()` > `*、/`（同级） > `+、-`（同级）；同级运算符按 “左优先” 处理。

### 2.2 手动转换步骤（视频核心方法）

1. **步骤 1：确定中缀表达式的运算顺序**
	根据 “左优先原则” 和优先级规则，标注每个运算符的生效顺序（用 1、2、3... 表示）。
	示例：中缀表达式 `a+b-c*d`
	- 优先级：`*`（1 级） > `+`（2 级） > `-`（3 级），运算顺序为 `*`→`+`→`-`。
2. **步骤 2：按运算顺序生成后缀表达式**
	对每个 “生效的运算符”，将其**放在对应两个操作数的后面**，并将运算结果视为 “新操作数”，重复此过程直到合并为完整后缀表达式。
	示例：`a+b-c*d` 转换过程
	- 1 级运算 `c*d`：转换为 `cd*`（运算符 `*` 放 `c、d` 后）；
	- 2 级运算 `a+b`：转换为 `ab+`（运算符 `+` 放 `a、b` 后）；
	- 3 级运算 `(a+b)-(c*d)`：将 `ab+` 和 `cd*` 视为新操作数，运算符 `-` 放后面，最终后缀为 `ab+cd*-`。

### 2.3 视频经典示例解析（复杂中缀转后缀）

中缀表达式：`15/(7-(1+1))*3-(2+(1+1))`

1. **确定运算顺序**（左优先原则）：
	1. `1+1`（最内层括号）；2. `7-(1+1)`；3. `15/(7-(1+1))`；4. `(结果)*3`；5. `1+1`（右侧括号）；6. `2+(1+1)`；7. `(前面结果)-(右侧结果)`。
2. **逐步转换**：
	- 1 级 `1+1` → `11+`；
	- 2 级 `7-(11+)` → `711+-`；
	- 3 级 `15/(711+-)` → `15711+-/`；
	- 4 级 `(15711+-/)*3` → `15711+-/3*`；
	- 5 级 `1+1` → `11+`；
	- 6 级 `2+(11+)` → `211++`；
	- 7 级 `(15711+-/3*)-(211++)` → 最终后缀：`15711+-/3*211++-`。

## 3. 中缀表达式与前缀表达式的转换

视频中前缀转换的核心是**右优先原则**，与后缀转换的 “左优先” 对应，确保转换结果唯一。

### 3.1 转换核心原则：右优先原则

- 定义：在中缀表达式中，若多个运算符满足 “运算优先级允许”，**优先计算右边的运算符**，避免转换结果歧义。
- 优先级规则与后缀转换一致：`()` > `*、/` > `+、-`；同级运算符按 “右优先” 处理。

### 3.2 手动转换步骤

1. **步骤 1：确定中缀表达式的运算顺序**
	根据 “右优先原则” 标注运算符生效顺序（用 1、2、3... 表示）。
	示例：中缀表达式 `a+b-c*d`
	- 优先级：`*`（1 级，右侧优先） > `+`（2 级） > `-`（3 级），运算顺序为 `*`→`+`→`-`（与后缀一致，但复杂表达式顺序可能不同）。
2. **步骤 2：按运算顺序生成前缀表达式**
	对每个 “生效的运算符”，将其**放在对应两个操作数的前面**，并将运算结果视为 “新操作数”，重复此过程直到合并为完整前缀表达式。
	示例：`a+b-c*d` 转换过程
	- 1 级运算 `c*d`：转换为 `*cd`（运算符 `*` 放 `c、d` 前）；
	- 2 级运算 `a+b`：转换为 `+ab`（运算符 `+` 放 `a、b` 前）；
	- 3 级运算 `(a+b)-(c*d)`：将 `+ab` 和 `*cd` 视为新操作数，运算符 `-` 放前面，最终前缀为 `-+ab*cd`。

## 4. 后缀表达式的计算（栈的核心应用）

视频强调：后缀表达式的计算是 “栈” 的经典应用，核心逻辑是 “后进先出（LIFO）” 匹配操作数的使用顺序。

### 4.1 手动计算步骤（视频示例方法）

1. 从**左到右**扫描后缀表达式；
2. 遇到**操作数**：记录下来（或暂存）；
3. 遇到**运算符**：取 “最近记录的两个操作数” 执行运算，将结果作为 “新操作数” 继续扫描；
4. 扫描结束后，剩余的 “新操作数” 即为最终结果。

> 关键：操作数顺序不可颠倒！如 `a/b` 的后缀是 `ab/`，计算时必须用 “前面的操作数 ÷ 后面的操作数”（即 `a÷b`，而非 `b÷a`）。

### 4.2 栈实现算法原理（视频重点）

- 栈的作用：暂存操作数，确保 “遇到运算符时，能快速取出最近的两个操作数”（符合后进先出）。
- 核心逻辑：操作数入栈，运算符触发弹栈计算，结果再入栈。

### 4.3 栈实现详细步骤（视频分步模拟）

以后缀表达式 `15711+-/3*211++-`（对应中缀 `15/(7-(1+1))*3-(2+(1+1))`）为例：

1. **初始化栈**：空栈 `stack = []`；
2. **遍历后缀表达式的每个元素**：
	- 元素 `15`（操作数）：入栈 → `stack = [15]`；
	- 元素 `7`（操作数）：入栈 → `stack = [15,7]`；
	- 元素 `1`（操作数）：入栈 → `stack = [15,7,1]`；
	- 元素 `1`（操作数）：入栈 → `stack = [15,7,1,1]`；
	- 元素 `+`（运算符）：弹栈两个操作数（先弹 `1`，再弹 `1`），计算 `1+1=2`，结果入栈 → `stack = [15,7,2]`；
	- 元素 `-`（运算符）：弹栈两个操作数（先弹 `2`，再弹 `7`），计算 `7-2=5`，结果入栈 → `stack = [15,5]`；
	- 元素 `/`（运算符）：弹栈两个操作数（先弹 `5`，再弹 `15`），计算 `15/5=3`，结果入栈 → `stack = [3]`；
	- 元素 `3`（操作数）：入栈 → `stack = [3,3]`；
	- 元素 `*`（运算符）：弹栈两个操作数（先弹 `3`，再弹 `3`），计算 `3*3=9`，结果入栈 → `stack = [9]`；
	- 元素 `2`（操作数）：入栈 → `stack = [9,2]`；
	- 元素 `1`（操作数）：入栈 → `stack = [9,2,1]`；
	- 元素 `1`（操作数）：入栈 → `stack = [9,2,1,1]`；
	- 元素 `+`（运算符）：弹栈两个操作数（先弹 `1`，再弹 `1`），计算 `1+1=2`，结果入栈 → `stack = [9,2,2]`；
	- 元素 `+`（运算符）：弹栈两个操作数（先弹 `2`，再弹 `2`），计算 `2+2=4`，结果入栈 → `stack = [9,4]`；
	- 元素 `-`（运算符）：弹栈两个操作数（先弹 `4`，再弹 `9`），计算 `9-4=5`，结果入栈 → `stack = [5]`；
3. **扫描结束**：栈中剩余元素 `5` 即为最终结果。

### 4.4 后缀计算的伪代码（视频逻辑实现）

python

```python
def calculate_postfix(postfix_expr):
    """
    计算后缀表达式的值
    参数：postfix_expr -> 字符串类型的后缀表达式（元素用空格分隔，如 "15 7 1 1 + - / 3 * 2 1 1 + + -"）
    返回：表达式的计算结果
    """
    stack = []
    # 分割表达式为单个元素（操作数或运算符）
    tokens = postfix_expr.split()
    
    for token in tokens:
        # 情况1：token是操作数（数字），入栈
        if token.isdigit():
            stack.append(int(token))
        # 情况2：token是运算符，弹栈计算后入栈
        else:
            if len(stack) < 2:
                raise ValueError("后缀表达式格式错误，操作数不足")
            # 注意：先弹右操作数，再弹左操作数（关键！）
            right_operand = stack.pop()
            left_operand = stack.pop()
            
            # 执行对应运算
            if token == '+':
                result = left_operand + right_operand
            elif token == '-':
                result = left_operand - right_operand
            elif token == '*':
                result = left_operand * right_operand
            elif token == '/':
                # 视频中默认整数除法，需注意除数不为0
                if right_operand == 0:
                    raise ZeroDivisionError("除数不能为0")
                result = left_operand // right_operand  # 按视频示例的整数运算
            else:
                raise ValueError(f"不支持的运算符：{token}")
            
            # 计算结果入栈
            stack.append(result)
    
    # 扫描结束后，栈应只剩一个元素（最终结果）
    if len(stack) != 1:
        raise ValueError("后缀表达式格式错误，多余操作数或运算符")
    return stack[0]

# 测试视频示例：后缀表达式 "15 7 1 1 + - / 3 * 2 1 1 + + -"
postfix = "15 7 1 1 + - / 3 * 2 1 1 + + -"
print(calculate_postfix(postfix))  # 输出：5（与视频结果一致）
```

## 5. 前缀表达式的计算（栈的应用）

视频中前缀计算的逻辑与后缀类似，但扫描方向和操作数弹出顺序相反，且应用较少（考试次要考点）。

### 5.1 核心差异（与后缀计算对比）

| 对比维度       | 后缀表达式计算                                | 前缀表达式计算                                |
| -------------- | --------------------------------------------- | --------------------------------------------- |
| 扫描方向       | 从左到右                                      | 从右到左                                      |
| 操作数弹出顺序 | 先弹右操作数，再弹左操作数                    | 先弹左操作数，再弹右操作数                    |
| 示例（`a+b`）  | 后缀 `ab+`：扫描到 `+`，弹 `b`、`a`，算 `a+b` | 前缀 `+ab`：扫描到 `+`，弹 `a`、`b`，算 `a+b` |

### 5.2 栈实现步骤（视频示例）

以前缀表达式 `-+ab*cd`（对应中缀 `a+b-c*d`）为例：

1. **初始化栈**：空栈 `stack = []`；
2. **从右到左扫描前缀表达式**：
	- 元素 `d`（操作数）：入栈 → `stack = [d]`；
	- 元素 `c`（操作数）：入栈 → `stack = [d, c]`；
	- 元素 `*`（运算符）：弹栈两个操作数（先弹 `c`，再弹 `d`），计算 `c*d`，结果入栈 → `stack = [c*d]`；
	- 元素 `b`（操作数）：入栈 → `stack = [c*d, b]`；
	- 元素 `a`（操作数）：入栈 → `stack = [c*d, b, a]`；
	- 元素 `+`（运算符）：弹栈两个操作数（先弹 `a`，再弹 `b`），计算 `a+b`，结果入栈 → `stack = [c*d, a+b]`；
	- 元素 `-`（运算符）：弹栈两个操作数（先弹 `a+b`，再弹 `c*d`），计算 `(a+b)-(c*d)`，结果入栈 → `stack = [(a+b)-(c*d)]`；
3. **扫描结束**：栈中剩余元素即为最终结果。

### 5.3 前缀计算的伪代码（视频逻辑实现）

python

```python
def calculate_prefix(prefix_expr):
    """
    计算前缀表达式的值
    参数：prefix_expr -> 字符串类型的前缀表达式（元素用空格分隔，如 "- + a b * c d"）
    返回：表达式的计算结果
    """
    stack = []
    # 分割表达式为单个元素，从右到左扫描（反转列表）
    tokens = prefix_expr.split()[::-1]
    
    for token in tokens:
        # 情况1：token是操作数（数字），入栈
        if token.isdigit():
            stack.append(int(token))
        # 情况2：token是运算符，弹栈计算后入栈
        else:
            if len(stack) < 2:
                raise ValueError("前缀表达式格式错误，操作数不足")
            # 注意：先弹左操作数，再弹右操作数（与后缀相反！）
            left_operand = stack.pop()
            right_operand = stack.pop()
            
            # 执行对应运算
            if token == '+':
                result = left_operand + right_operand
            elif token == '-':
                result = left_operand - right_operand
            elif token == '*':
                result = left_operand * right_operand
            elif token == '/':
                if right_operand == 0:
                    raise ZeroDivisionError("除数不能为0")
                result = left_operand // right_operand
            else:
                raise ValueError(f"不支持的运算符：{token}")
            
            # 计算结果入栈
            stack.append(result)
    
    if len(stack) != 1:
        raise ValueError("前缀表达式格式错误，多余操作数或运算符")
    return stack[0]

# 测试示例：前缀表达式 "- + 3 4 * 2 5"（对应中缀 3+4-2*5 = 7-10 = -3）
prefix = "- + 3 4 * 2 5"
print(calculate_prefix(prefix))  # 输出：-3
```

## 6. 考试核心考点与注意事项（重点强调）

1. **后缀表达式是重点**：应用更广，考研 / 面试更常考转换与计算，前缀仅需理解基本逻辑。
2. **操作数顺序不可颠倒**：
	- 除法（`a/b` → 后缀 `ab/`，计算时 `a÷b`）、减法（`a-b` → 后缀 `ab-`，计算时 `a-b`）是高频易错点；
	- 后缀计算弹栈顺序：先右后左；前缀计算弹栈顺序：先左后右。
3. **左 / 右优先原则的作用**：仅为 “方便理解” 的通俗说法（视频老师强调非学术术语），核心是保证转换结果唯一，符合算法 “确定性” 要求，考试答题需用 “优先级规则 + 同级左 / 右结合” 表述。
4. **栈的核心作用**：暂存操作数，解决 “运算符与对应操作数的匹配问题”，本质是利用 “后进先出” 特性匹配 “最近操作数优先使用” 的逻辑。
5. **手动转换与计算是基础**：考试常考 “手动推导后缀表达式” 和 “手动模拟栈计算过程”，需多练视频中的示例（如 `15/(7-(1+1))*3-(2+(1+1))`）。



# 栈在表达式求值中的应用

## 1. 核心前提概念

### 1.1 运算符优先级规则

视频明确仅讨论 **加减乘除（+、-、\*、/）** 四种运算符，优先级从高到低定义为：

- 第一优先级：`*`（乘法）、`/`（除法），两者优先级**相等**；
- 第二优先级：`+`（加法）、`-`（减法），两者优先级**相等**；
- 结论：`* = / > + = -`（乘除优先级高于加减，同优先级内相等）。

### 1.2 左优先原则

视频核心规则：当两个运算符**优先级相等**时，**左侧运算符先生效**（按从左到右的顺序计算），用于确定同优先级运算符的处理顺序。

- 示例：中缀表达式`a+b-c`，`+`和`-`优先级相等，先计算`a+b`，再用结果减`c`。

### 1.3 操作数与运算符的关键特性

视频观察结论：中缀表达式转后缀表达式时，**操作数的相对顺序保持不变**，仅**运算符的相对顺序随优先级 / 左优先原则调整**。

## 2. 中缀表达式转后缀表达式（栈实现）

### 2.1 算法核心规则

从左往右依次扫描中缀表达式的每个元素（操作数、运算符、括号），用 **运算符栈（op_stack）** 存储暂时无法确定顺序的运算符，最终生成后缀表达式（postfix），具体规则如下：

1. **扫描到操作数**：直接追加到后缀表达式（postfix）末尾；
2. **扫描到左括号（(）**：直接压入运算符栈（op_stack），暂不处理；
3. **扫描到右括号（)）**：
	- 依次弹出运算符栈顶元素，追加到 postfix，直到弹出左括号（(）为止；
	- 左括号（(）弹出后**不追加到 postfix**（后缀表达式无括号）；
4. **扫描到运算符（op_current）**：
	- 若运算符栈为空，直接压入 op_stack；
	- 若运算符栈非空，对比栈顶运算符（op_top）与 op_current 的优先级：
		- 若`op_top优先级 > op_current优先级`：弹出 op_top 追加到 postfix，重复对比新栈顶，直到栈空或`op_top优先级 ≤ op_current优先级`；
		- 若`op_top优先级 == op_current优先级`（同优先级）：按左优先原则，弹出 op_top 追加到 postfix，重复对比新栈顶，直到栈空或`op_top优先级 < op_current优先级`；
		- 若`op_top优先级 < op_current优先级`：停止弹出，将 op_current 压入 op_stack；
5. **扫描结束后**：依次弹出运算符栈中剩余的所有运算符，追加到 postfix。

### 2.2 视频示例解析（无括号 + 带括号）

#### 示例 1：无括号中缀表达式`a+b-c*d/e+f`

| 扫描元素 | 运算符栈（op_stack） | 后缀表达式（postfix） | 处理逻辑                                                     |
| -------- | -------------------- | --------------------- | ------------------------------------------------------------ |
| a        | 空                   | a                     | 操作数，直接追加                                             |
| +        | [+]                  | a                     | 栈空，压入`+`                                                |
| b        | [+]                  | ab                    | 操作数，直接追加                                             |
| -        | [-]                  | ab+                   | op_top=`+`（与`-`同优先级），弹出`+`追加，压入`-`            |
| c        | [-]                  | ab+c                  | 操作数，直接追加                                             |
| *        | [- , *]              | ab+c                  | op_top=`-`（优先级 < `*`），压入`*`                          |
| d        | [- , *]              | ab+cd                 | 操作数，直接追加                                             |
| /        | [- , /]              | ab+cd*                | op_top=`*`（与`/`同优先级），弹出`*`追加，压入`/`            |
| e        | [- , /]              | ab+cd*e               | 操作数，直接追加                                             |
| +        | [+]                  | ab+cd*e/-             | op_top=`/`（优先级 > `+`），弹出`/`追加；新 op_top=`-`（优先级 > `+`），弹出`-`追加；栈空，压入`+` |
| f        | [+]                  | ab+cd*e/-f            | 操作数，直接追加                                             |
| 扫描结束 | 空                   | ab+cd*e/-f+           | 弹出栈中剩余`+`，追加到 postfix                              |

#### 示例 2：带括号中缀表达式`a+b-(c-d)*e/f`

关键括号处理步骤：

| 扫描元素 | 运算符栈（op_stack） | 后缀表达式（postfix） | 处理逻辑                              |
| -------- | -------------------- | --------------------- | ------------------------------------- |
| a        | 空                   | a                     | 操作数追加                            |
| +        | [+]                  | a                     | 栈空压入`+`                           |
| b        | [+]                  | ab                    | 操作数追加                            |
| -        | [-]                  | ab+                   | 同优先级弹出`+`，压入`-`              |
| (        | [- , (]              | ab+                   | 左括号压栈                            |
| c        | [- , (]              | ab+c                  | 操作数追加                            |
| -        | [- , ( , -]          | ab+c                  | 栈顶是`(`，压入`-`                    |
| d        | [- , ( , -]          | ab+cd                 | 操作数追加                            |
| )        | [-]                  | ab+cd-                | 弹出`-`追加，直到弹出`(`（`(`不追加） |
| *        | [- , *]              | ab+cd-                | 栈顶`-` < `*`，压入`*`                |
| e        | [- , *]              | ab+cd-e               | 操作数追加                            |
| /        | [- , /]              | ab+cd-e*              | 同优先级弹出`*`，压入`/`              |
| f        | [- , /]              | ab+cd-e*f             | 操作数追加                            |
| 扫描结束 | 空                   | ab+cd-e*f/-           | 弹出`/`、`-`，追加到 postfix          |

### 2.3 视频提及的伪代码实现（完整）



```plaintext
// 功能：将中缀表达式转换为后缀表达式
// 输入：infix - 字符串（合法中缀表达式，含a-z操作数、+、-、*、/、()）
// 输出：postfix - 字符串（对应的后缀表达式）
function infixToPostfix(infix):
    // 初始化运算符栈和后缀表达式
    op_stack = 空栈  // 存储暂时无法确定顺序的运算符
    postfix = ""     // 最终生成的后缀表达式
    // 运算符优先级映射（视频定义：*=/ > +=-，左括号优先级最低）
    priority = {
        "+": 1,
        "-": 1,
        "*": 2,
        "/": 2,
        "(": 0
    }
    
    // 从左到右扫描中缀表达式的每个字符
    for char in infix:
        // 情况1：字符是操作数（a-z）
        if char is between 'a' and 'z':
            postfix = postfix + char
        // 情况2：字符是左括号(
        elif char == '(':
            push(op_stack, char)
        // 情况3：字符是右括号)
        elif char == ')':
            // 弹出运算符直到左括号，左括号不追加
            while not isEmpty(op_stack) and top(op_stack) != '(':
                op = pop(op_stack)
                postfix = postfix + op
            pop(op_stack)  // 弹出左括号并丢弃
        // 情况4：字符是运算符（+、-、*、/）
        else:
            // 弹出优先级≥当前运算符的栈顶元素（左优先原则）
            while not isEmpty(op_stack) and priority[top(op_stack)] >= priority[char]:
                op = pop(op_stack)
                postfix = postfix + op
            push(op_stack, char)  // 压入当前运算符
    
    // 扫描结束，弹出栈中剩余所有运算符
    while not isEmpty(op_stack):
        op = pop(op_stack)
        postfix = postfix + op
    
    return postfix
```

## 3. 栈实现中缀表达式求值（双栈法）

### 3.1 算法核心原理（视频重点）

视频明确：中缀表达式求值 = 「中缀转后缀」与「后缀求值」的**实时结合**，无需单独生成后缀表达式，而是用**两个栈**同步处理：

- 操作数栈（num_stack）：存储操作数和中间计算结果；
- 运算符栈（op_stack）：存储暂时无法确定顺序的运算符（同中缀转后缀的栈）；
- 核心逻辑：扫描到运算符需弹出时，同步从操作数栈弹出两个操作数计算，结果压回操作数栈，实现 “边转边算”。

### 3.2 算法详细规则（视频推导）

从左往右扫描中缀表达式，步骤如下：

1. **扫描到操作数**：将操作数（视频中用变量或具体数值表示）压入 num_stack；
2. **扫描到左括号（(）**：直接压入 op_stack；
3. **扫描到右括号（)）**：
	- 依次弹出 op_stack 的栈顶运算符（op）；
	- 从 num_stack 弹出两个操作数：**先弹右操作数（num_right），再弹左操作数（num_left）**（视频强调顺序，避免计算错误）；
	- 计算`result = num_left op num_right`，将 result 压入 num_stack；
	- 直到弹出左括号（(），左括号弹出后丢弃；
4. **扫描到运算符（op_current）**：
	- 若 op_stack 为空，直接压入 op_stack；
	- 若 op_stack 非空，对比 op_top（栈顶运算符）与 op_current 的优先级：
		- 若`op_top优先级 > 或 == op_current优先级`：弹出 op_top；
			- 从 num_stack 弹出 num_right、num_left，计算`result = num_left op_top num_right`；
			- 将 result 压入 num_stack；
			- 重复对比新 op_top，直到栈空或`op_top优先级 < op_current优先级`；
		- 若`op_top优先级 < op_current优先级`：压入 op_current 到 op_stack；
5. **扫描结束后**：
	- 依次弹出 op_stack 剩余的每个运算符（op）；
	- 每次弹出 op 时，从 num_stack 弹出 num_right、num_left，计算`result = num_left op num_right`，压入 num_stack；
	- 最终 num_stack 中剩余的唯一元素即为中缀表达式的结果。

### 3.3 视频示例解析（以`a+b-c*d/e+f`为例，假设`a=1、b=2、c=3、d=4、e=5、f=6`）

| 扫描元素 | 操作数栈（num_stack） | 运算符栈（op_stack） | 处理逻辑（计算过程）                                         |
| -------- | --------------------- | -------------------- | ------------------------------------------------------------ |
| a=1      | [1]                   | 空                   | 操作数压栈                                                   |
| +        | [1]                   | [+]                  | 栈空，压入`+`                                                |
| b=2      | [1, 2]                | [+]                  | 操作数压栈                                                   |
| -        | [3]                   | [-]                  | op_top=`+`（同优先级），弹出`+`；弹 2（右）、1（左），算`1+2=3`；压 3；压`-` |
| c=3      | [3, 3]                | [-]                  | 操作数压栈                                                   |
| *        | [3, 3]                | [- , *]              | op_top=`-` < `*`，压入`*`                                    |
| d=4      | [3, 3, 4]             | [- , *]              | 操作数压栈                                                   |
| /        | [3, 12]               | [- , /]              | op_top=`*`（同优先级），弹出`*`；弹 4（右）、3（左），算`3*4=12`；压 12；压`/` |
| e=5      | [3, 12, 5]            | [- , /]              | 操作数压栈                                                   |
| +        | [0.6]                 | [+]                  | op_top=`/`（> `+`），弹出`/`；弹 5（右）、12（左），算`12/5=2.4`；压 2.4；新 op_top=`-`（> `+`），弹出`-`；弹 2.4（右）、3（左），算`3-2.4=0.6`；压 0.6；压`+` |
| f=6      | [0.6, 6]              | [+]                  | 操作数压栈                                                   |
| 扫描结束 | [6.6]                 | 空                   | 弹出`+`；弹 6（右）、0.6（左），算`0.6+6=6.6`；num_stack 剩余 6.6，即结果 |

### 3.4 视频提及的伪代码实现（完整，含计算逻辑）

plaintext

```plaintext
// 功能：计算中缀表达式的值
// 输入：infix - 字符串（合法中缀表达式，含a-z变量/数字、+、-、*、/、()）；num_map - 变量-数值映射表（如{a:1, b:2}）
// 输出：result - 数值（表达式的计算结果）
function calculateInfix(infix, num_map):
    // 初始化双栈：操作数栈（存数值/中间结果）、运算符栈（存运算符）
    num_stack = 空栈
    op_stack = 空栈
    // 运算符优先级映射（同中缀转后缀）
    priority = {
        "+": 1,
        "-": 1,
        "*": 2,
        "/": 2,
        "(": 0
    }
    
    // 辅助函数：执行二元运算（左操作数 op 右操作数）
    function compute(op, num_left, num_right):
        if op == "+":
            return num_left + num_right
        elif op == "-":
            return num_left - num_right
        elif op == "*":
            return num_left * num_right
        elif op == "/":
            return num_left / num_right  // 视频未提及整除，按常规除法处理
    
    // 从左到右扫描中缀表达式的每个字符
    for char in infix:
        // 情况1：字符是操作数（a-z变量或0-9数字）
        if (char is between 'a' and 'z') or (char is between '0' and '9'):
            // 变量从num_map取数值，数字直接转数值
            num = num_map[char] if (char is between 'a' and 'z') else parseInt(char)
            push(num_stack, num)
        // 情况2：字符是左括号(
        elif char == '(':
            push(op_stack, char)
        // 情况3：字符是右括号)
        elif char == ')':
            // 弹出运算符计算，直到左括号
            while not isEmpty(op_stack) and top(op_stack) != '(':
                op = pop(op_stack)
                // 先弹右操作数，再弹左操作数（视频强调顺序）
                num_right = pop(num_stack)
                num_left = pop(num_stack)
                res = compute(op, num_left, num_right)
                push(num_stack, res)
            pop(op_stack)  // 弹出左括号，丢弃
        // 情况4：字符是运算符（+、-、*、/）
        else:
            // 弹出优先级≥当前运算符的栈顶元素并计算
            while not isEmpty(op_stack) and priority[top(op_stack)] >= priority[char]:
                op = pop(op_stack)
                num_right = pop(num_stack)
                num_left = pop(num_stack)
                res = compute(op, num_left, num_right)
                push(num_stack, res)
            push(op_stack, char)  // 压入当前运算符
    
    // 扫描结束，处理栈中剩余运算符
    while not isEmpty(op_stack):
        op = pop(op_stack)
        num_right = pop(num_stack)
        num_left = pop(num_stack)
        res = compute(op, num_left, num_right)
        push(num_stack, res)
    
    // 操作数栈剩余唯一元素即为结果
    return pop(num_stack)
```

## 4. 强调关键注意事项

1. **操作数弹出顺序**：计算时必须**先弹右操作数，再弹左操作数**（视频反复强调，如`a+b`需先弹`b`、再弹`a`，避免因顺序错误导致结果错误）；
2. **括号处理边界**：右括号仅触发 “弹出到左括号”，左括号弹出后不参与计算，后缀表达式中无括号；
3. **栈的核心作用**：存储 “暂时无法确定顺序” 的元素（运算符或操作数），利用栈 “先进后出” 特性匹配优先级和左优先原则；
4. **考试重点**：中缀转后缀过程中 “运算符栈的状态变化” 是高频考点（视频明确提及可能出选择题，考查某一步栈内元素）；
5. **算法价值**：该算法是编译原理基础 ——CPU 仅能执行单个基本运算（加减乘除），复杂表达式需通过此算法拆解为单个运算，实现机器可执行的指令转换。



# 栈在递归中的应用知识点总结

## 一、函数调用栈的原理

函数调用的底层依赖**函数调用栈**（内存中的一块连续存储区域）实现，其核心符合**LIFO（后进先出）** 特性，是理解递归与栈关系的基础。

### 1.1 函数调用的核心特性

- 函数调用具有 “**最后被调用的函数，最先执行结束**” 的特性，与栈的 “后进先出” 逻辑完全一致。
- 例如：`main()` 调用 `func1()`，`func1()` 调用 `func2()`，执行顺序为 `main() → func1() → func2()`，结束顺序为 `func2() → func1() → main()`。

### 1.2 函数调用栈的定义与作用

- **定义**：程序运行前，系统自动开辟的一块内存区域，用于存储函数调用过程中必须保留的信息。
- **隐藏细节**：编译器会在 `main()` 函数执行前，自动添加额外代码，将初始化信息压入栈中（调试时可见，无需开发者手动处理）。
- **调试支持**：使用 IDE（如 CLion、VS）调试时，可查看函数调用栈的实时状态，包括各层函数的局部变量、参数值（但不显示返回地址）。

### 1.3 函数调用栈存储的关键信息

每次函数调用时，栈会压入该函数的三类核心信息，弹出时则释放对应内存：

1. **函数的局部变量**：函数内部定义的变量（如 `main()` 中的 `a, b, c`，`func1()` 中的 `x`）。
2. **返回地址**：当前函数执行结束后，需回到调用者继续执行的代码地址（如 `func2()` 结束后，需回到 `func1()` 中调用 `func2()` 的下一行代码）。
3. **函数的实参**：调用者传递给被调用函数的参数（如 `main()` 调用 `func1()` 时传递的 `a, b`），实参与调用者的变量是内存中独立的两份数据，被调用函数修改实参不影响调用者变量。

### 1.4 函数调用栈的工作流程

#### 1.4.1 示例程序代码

c

```c
#include <stdio.h>

// 被调用函数2
void func2(int x) {
    // 局部变量
    int m = 2, n = 3;
    // 函数体逻辑（无额外调用，执行后直接返回）
    printf("func2: x=%d, m=%d, n=%d\n", x, m, n);
}

// 被调用函数1
void func1(int a, int b) {
    // 局部变量
    int x = a + b;
    // 调用func2，传入x作为实参
    func2(x);
    // func2执行结束后，需回到此处继续执行
    printf("func1: a=%d, b=%d, x=%d\n", a, b, x);
}

int main() {
    // 局部变量
    int a = 1, b = 2, c = 3;
    // 调用func1，传入a和b作为实参
    func1(a, b);
    // func1执行结束后，需回到此处继续执行
    printf("main: a=%d, b=%d, c=%d\n", a, b, c);
    return 0;
}
```

#### 1.4.2 栈工作流程分步解析

1. **初始化：main () 入栈**
	程序启动后，系统先压入编译器添加的初始化信息，再压入 `main()` 的信息：
	- 局部变量：`a=1, b=2, c=3`
	- 无返回地址（`main()` 是程序入口，无需返回）。
2. **main () 调用 func1 ()：func1 () 入栈**
	执行 `func1(a, b)` 时，栈压入 `func1()` 的三类信息：
	- 实参：`a=1, b=2`（与 `main()` 的 `a, b` 内存独立）；
	- 局部变量：`x`（未赋值，待函数执行时初始化）；
	- 返回地址：`main()` 中 `func1(a, b)` 的下一行代码（即 `printf("main: ...")` 的地址）。
3. **func1 () 调用 func2 ()：func2 () 入栈**
	执行 `func2(x)` 时，栈压入 `func2()` 的三类信息：
	- 实参：`x=3`（`func1()` 中 `a+b` 的结果）；
	- 局部变量：`m=2, n=3`；
	- 返回地址：`func1()` 中 `func2(x)` 的下一行代码（即 `printf("func1: ...")` 的地址）。
4. **func2 () 执行结束：func2 () 出栈**
	`func2()` 执行完打印逻辑后，根据栈顶的 “返回地址” 回到 `func1()`，同时弹出 `func2()` 的所有信息（实参 `x`、局部变量 `m, n`、返回地址），释放对应内存。
5. **func1 () 执行结束：func1 () 出栈**
	`func1()` 执行完打印逻辑后，根据栈顶的 “返回地址” 回到 `main()`，同时弹出 `func1()` 的所有信息（实参 `a, b`、局部变量 `x`、返回地址）。
6. **main () 执行结束：main () 出栈**
	`main()` 执行完打印逻辑后，弹出其局部变量信息，程序正常退出。

## 二、栈在递归中的应用

递归的本质是 “函数调用自身”，因此递归的底层依赖**递归工作栈**（本质与 “函数调用栈” 是同一个栈，仅名称侧重递归场景）实现。

### 2.1 递归算法的核心要素

视频明确递归算法需满足两个条件：

1. **递归表达式**：将原问题拆解为 “属性相同、规模更小” 的子问题（如 `n! = n * (n-1)!`）；
2. **边界条件**（递归出口）：当问题规模缩小到特定值时，直接返回结果（如 `n=1` 或 `n=0` 时，`n! = 1`）。

### 2.2 递归工作栈的本质

- 递归工作栈 = 函数调用栈，每次递归调用时，栈会压入当前递归层的信息（实参、局部变量、返回地址）；
- 递归返回时，栈顶信息弹出，回到上一层递归继续计算，直到回到初始调用者（如 `main()`）。

### 2.3 阶乘递归的实现与栈工作流程

视频以 “计算 10 的阶乘” 为例，演示递归与栈的配合过程。

#### 2.3.1 阶乘递归的完整代码

c

```c
#include <stdio.h>

// 递归计算阶乘
int factorial(int n) {
    // 边界条件：n=0或n=1时，阶乘为1
    if (n == 0 || n == 1) {
        return 1;
    }
    // 递归表达式：n! = n * (n-1)!
    return n * factorial(n - 1);
}

int main() {
    // 计算10的阶乘，结果存入x
    int x = factorial(10);
    // 打印结果
    printf("10! = %d\n", x);
    return 0;
}
```

#### 2.3.2 阶乘递归的栈工作流程

1. **递归调用阶段（压栈）**
	- `main()` 调用 `factorial(10)`，栈压入：实参 `n=10`、返回地址（`main()` 中 `int x = ...` 的下一行代码）、局部变量（无额外局部变量）；
	- 因 `n≠0且≠1`，执行 `10 * factorial(9)`，调用 `factorial(9)`，栈压入：实参 `n=9`、返回地址（`factorial(10)` 中 `return 10 * ...` 的地址）；
	- 重复上述过程，直到调用 `factorial(1)`：栈压入 `n=1`、返回地址（`factorial(2)` 中 `return 2 * ...` 的地址）。
2. **递归返回阶段（出栈）**
	- `factorial(1)` 触发边界条件，返回 `1`，弹出栈顶的 `n=1` 及对应返回地址；
	- 回到 `factorial(2)`，计算 `2 * 1 = 2`，返回 `2`，弹出 `n=2` 及对应地址；
	- 回到 `factorial(3)`，计算 `3 * 2 = 6`，返回 `6`，弹出 `n=3` 及对应地址；
	- 以此类推，直到回到 `factorial(10)`，计算 `10 * 362880 = 3628800`，返回结果给 `main()`；
	- `main()` 接收结果，存入 `x` 并打印，弹出 `main()` 相关信息，程序结束。

### 2.4 斐波那契数列递归的实现与问题

视频以 “计算 fib (4)” 为例，演示递归的栈流程，并指出其核心缺陷。

#### 2.4.1 斐波那契递归的完整代码

c

```c
#include <stdio.h>

// 递归计算斐波那契数列（fib(n) = fib(n-1) + fib(n-2)）
int fib(int n) {
    // 边界条件：n=0或n=1时，返回1
    if (n == 0 || n == 1) {
        return 1;
    }
    // 递归表达式：拆分为fib(n-1)和fib(n-2)的和
    return fib(n - 1) + fib(n - 2);
}

int main() {
    // 计算fib(4)，结果存入result
    int result = fib(4);
    // 打印结果
    printf("fib(4) = %d\n", result);
    return 0;
}
```

#### 2.4.2 斐波那契递归的栈工作流程

1. **递归调用阶段（压栈）**
	- `main()` 调用 `fib(4)`，栈压入：`n=4`、返回地址（`main()` 中 `int result = ...` 的下一行）；
	- 因 `n≠0且≠1`，执行 `fib(3) + fib(2)`，先调用 `fib(3)`，栈压入：`n=3`、返回地址（`fib(4)` 中 `return fib(3) + ...` 的地址）；
	- `fib(3)` 执行 `fib(2) + fib(1)`，先调用 `fib(2)`，栈压入：`n=2`、返回地址（`fib(3)` 中 `return fib(2) + ...` 的地址）；
	- `fib(2)` 执行 `fib(1) + fib(0)`，先调用 `fib(1)`，栈压入：`n=1`、返回地址（`fib(2)` 中 `return fib(1) + ...` 的地址）。
2. **递归返回阶段（出栈）**
	- `fib(1)` 返回 `1`，弹出 `n=1`，回到 `fib(2)`，继续调用 `fib(0)`；
	- `fib(0)` 返回 `1`，弹出 `n=0`，回到 `fib(2)`，计算 `1 + 1 = 2`，返回 `2`，弹出 `n=2`；
	- 回到 `fib(3)`，继续调用 `fib(1)`，`fib(1)` 返回 `1`，计算 `2 + 1 = 3`，返回 `3`，弹出 `n=3`；
	- 回到 `fib(4)`，继续调用 `fib(2)`（此处 `fib(2)` 需重新计算，而非复用之前结果），`fib(2)` 返回 `2`，计算 `3 + 2 = 5`，返回 `5` 给 `main()`；
	- `main()` 打印 `fib(4) = 5`，程序结束。

#### 2.4.3 斐波那契递归的核心问题 —— 重复计算

- 视频明确指出：递归实现斐波那时，**子问题会被重复计算**（如 `fib(2)` 在 `fib(4)` 和 `fib(3)` 中各计算 1 次，`fib(1)` 计算 3 次，`fib(0)` 计算 2 次）；
- 重复计算导致递归效率低下，是递归算法的常见缺陷。

### 2.5 递归算法的三大缺点（基于视频内容）

1. **栈溢出风险**：递归层数过多（如计算 `factorial(100000)`）时，函数调用栈会因压入信息过多而超出内存上限，导致程序崩溃；
2. **空间复杂度高**：递归的空间复杂度 = 递归层数（每层递归需占用栈空间），层数越多，空间开销越大；
3. **重复计算（部分场景）**：如斐波那契递归，子问题重复计算导致时间效率低下。

## 三、关键结论

1. 函数调用的底层依赖**函数调用栈**，递归的底层依赖**递归工作栈**（二者本质是同一个栈）；
2. 栈的 “后进先出” 特性是函数调用与递归实现的核心保障；
3. 递归算法可通过 “手动实现栈” 改造成非递归版本（视频提及，未展开代码，仅需了解结论）；
4. 调试时可通过 IDE 查看函数调用栈，辅助定位递归或函数调用相关的 bug。



# 队列的应用知识点总结

## 一、队列应用概述

视频中重点介绍队列的 4 类核心应用，均依赖队列**先进先出（FIFO）** 的核心特性，分别为：

1. 树的层次遍历
2. 图的广度优先遍历（BFS）
3. 操作系统中的 CPU 就绪队列管理
4. 操作系统中的打印机缓冲区队列管理

## 二、应用 1：树的层次遍历

### 1. 核心原理

树是 “分层” 的数据结构，**层次遍历**指 “按树的层级顺序（从根节点开始，一层一层、从左到右）遍历所有节点”。由于需保证 “先访问的节点，其孩子节点后访问”，队列的 FIFO 特性可完美匹配该需求（用队列暂存待访问节点的孩子）。

### 2. 实现步骤

视频中以 “根节点为 1 的树” 为例（树结构：1 的左孩子 2、右孩子 3；2 的左孩子 4、右孩子 5；3 的左孩子 6、右孩子 7；5 的左孩子 8、右孩子 9；7 的左孩子 10、右孩子 11），步骤如下：

1. 新建一个空队列；
2. 将**根节点（1 号）** 入队；
3. 循环执行（直到队列为空）：
	- 出队头节点（当前层级的节点），并处理该节点；
	- 若该节点有**左孩子**，将左孩子入队尾；
	- 若该节点有**右孩子**，将右孩子入队尾；
4. 遍历顺序：`1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 10 → 11`。

### 3. 完整实现代码（C 语言，基于视频逻辑）

c

```c
#include <stdio.h>
#include <stdlib.h>

// 1. 定义树节点结构（视频中树节点含“值”和“左右孩子指针”）
typedef struct TreeNode {
    int data;                  // 节点值（视频示例中为1~11）
    struct TreeNode* left;     // 左孩子指针
    struct TreeNode* right;    // 右孩子指针
} TreeNode;

// 2. 定义链式队列节点结构（用于存储树节点的指针）
typedef struct QueueNode {
    TreeNode* treeNode;        // 指向树节点
    struct QueueNode* next;    // 指向队列中下一个节点
} QueueNode;

// 3. 定义队列结构（含队头、队尾指针，方便入队/出队）
typedef struct Queue {
    QueueNode* front;          // 队头指针
    QueueNode* rear;           // 队尾指针
} Queue;

// 4. 队列初始化：创建空队列
Queue* initQueue() {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    q->front = NULL;
    q->rear = NULL;
    return q;
}

// 5. 入队操作：将树节点指针加入队尾
void enQueue(Queue* q, TreeNode* tn) {
    QueueNode* newQNode = (QueueNode*)malloc(sizeof(QueueNode));
    newQNode->treeNode = tn;
    newQNode->next = NULL;
    
    // 若队列为空，队头和队尾均指向新节点
    if (q->front == NULL) {
        q->front = newQNode;
        q->rear = newQNode;
    } else {
        // 否则，队尾节点的next指向新节点，更新队尾
        q->rear->next = newQNode;
        q->rear = newQNode;
    }
}

// 6. 出队操作：从队头取出树节点指针，返回该指针（若队空返回NULL）
TreeNode* deQueue(Queue* q) {
    if (q->front == NULL) {
        return NULL; // 队空，无节点可出
    }
    
    // 保存队头节点
    QueueNode* temp = q->front;
    // 取出队头节点对应的树节点指针
    TreeNode* tn = temp->treeNode;
    
    // 更新队头：若队列只有一个节点，出队后队空
    if (q->front == q->rear) {
        q->front = NULL;
        q->rear = NULL;
    } else {
        q->front = q->front->next;
    }
    
    free(temp); // 释放队列节点的内存
    return tn;
}

// 7. 判断队列是否为空（空返回1，非空返回0）
int isQueueEmpty(Queue* q) {
    return q->front == NULL ? 1 : 0;
}

// 8. 创建树节点（辅助函数：简化树的构建）
TreeNode* createTreeNode(int data) {
    TreeNode* tn = (TreeNode*)malloc(sizeof(TreeNode));
    tn->data = data;
    tn->left = NULL;
    tn->right = NULL;
    return tn;
}

// 9. 树的层次遍历函数（核心函数，基于视频步骤）
void levelOrderTraversal(TreeNode* root) {
    if (root == NULL) {
        printf("树为空，无法遍历！\n");
        return;
    }
    
    Queue* q = initQueue(); // 新建队列
    enQueue(q, root);       // 根节点入队
    
    printf("树的层次遍历结果：");
    while (!isQueueEmpty(q)) {
        TreeNode* curr = deQueue(q); // 出队头节点
        printf("%d ", curr->data);   // 处理当前节点（视频中“处理”为打印节点值）
        
        // 左孩子入队（若存在）
        if (curr->left != NULL) {
            enQueue(q, curr->left);
        }
        // 右孩子入队（若存在）
        if (curr->right != NULL) {
            enQueue(q, curr->right);
        }
    }
    printf("\n");
    
    free(q); // 释放队列结构内存
}

// 主函数：构建视频中的示例树，并测试层次遍历
int main() {
    // 构建视频中的树（1为根，层级结构如下）
    //        1
    //      /   \
    //     2     3
    //    / \   / \
    //   4   5 6   7
    //      / \     \
    //     8   9    10 11（注：视频中7的左10、右11，此处修正为7的左10、右11）
    TreeNode* root = createTreeNode(1);
    root->left = createTreeNode(2);
    root->right = createTreeNode(3);
    root->left->left = createTreeNode(4);
    root->left->right = createTreeNode(5);
    root->right->left = createTreeNode(6);
    root->right->right = createTreeNode(7);
    root->left->right->left = createTreeNode(8);
    root->left->right->right = createTreeNode(9);
    root->right->right->left = createTreeNode(10);
    root->right->right->right = createTreeNode(11);
    
    // 执行层次遍历
    levelOrderTraversal(root);
    
    // （注：实际工程中需添加内存释放代码，此处为简化示例省略）
    return 0;
}
```

## 三、应用 2：图的广度优先遍历（BFS）

### 1. 核心原理

图的**广度优先遍历**指 “从起始节点出发，优先访问该节点的所有邻接节点（同层节点），再依次访问邻接节点的邻接节点”。由于需保证 “先访问的节点，其邻接节点后访问”，且需避免重复访问，需用队列暂存待访问节点，并通过 “已访问标记” 防止重复。

### 2. 实现步骤

视频中以 “起始节点为 1 的图” 为例（图结构：1 的邻接节点 2、3；2 的邻接节点 1、4；3 的邻接节点 1、5、6；4 的邻接节点 2；5 的邻接节点 3、7、8；6 的邻接节点 3；7 的邻接节点 5；8 的邻接节点 5），步骤如下：

1. 新建一个空队列；
2. 定义 “已访问数组”（标记节点是否被遍历，初始全为 “未访问”）；
3. 将**起始节点（1 号）** 入队，并标记为 “已访问”；
4. 循环执行（直到队列为空）：
	- 出队头节点，并处理该节点；
	- 遍历该节点的所有邻接节点：
		- 若邻接节点 “未访问”，则将其入队，并标记为 “已访问”；
5. 遍历顺序：`1 → 2 → 3 → 4 → 5 → 6 → 7 → 8`。

### 3. 完整实现代码

c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NODE_NUM 100 // 最大节点数（视频示例中节点数为8，此处设为100方便扩展）

// 1. 定义邻接表节点结构（存储邻接节点的索引）
typedef struct AdjNode {
    int adjNodeIdx;            // 邻接节点的索引（如1、2、3...）
    struct AdjNode* next;      // 指向同一顶点的下一个邻接节点
} AdjNode;

// 2. 定义图的顶点结构（每个顶点含“顶点值”和“邻接节点链表头指针”）
typedef struct Vertex {
    int data;                  // 顶点值（视频示例中为1~8）
    AdjNode* adjListHead;      // 邻接节点链表的头指针
} Vertex;

// 3. 定义图结构（含顶点数组、节点总数、边总数）
typedef struct Graph {
    Vertex vertices[MAX_NODE_NUM]; // 顶点数组
    int nodeCount;                 // 实际节点总数
    int edgeCount;                 // 实际边总数
} Graph;

// 4. 定义链式队列结构（用于存储待访问的节点索引）
typedef struct QueueNode {
    int nodeIdx;           // 图节点的索引（如1、2...）
    struct QueueNode* next;
} QueueNode;

typedef struct Queue {
    QueueNode* front;
    QueueNode* rear;
} Queue;

// 5. 队列初始化
Queue* initQueue() {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    q->front = NULL;
    q->rear = NULL;
    return q;
}

// 6. 入队操作（存储图节点索引）
void enQueue(Queue* q, int idx) {
    QueueNode* newQNode = (QueueNode*)malloc(sizeof(QueueNode));
    newQNode->nodeIdx = idx;
    newQNode->next = NULL;
    
    if (q->front == NULL) {
        q->front = newQNode;
        q->rear = newQNode;
    } else {
        q->rear->next = newQNode;
        q->rear = newQNode;
    }
}

// 7. 出队操作（返回图节点索引，队空返回-1）
int deQueue(Queue* q) {
    if (q->front == NULL) {
        return -1; // 队空
    }
    
    QueueNode* temp = q->front;
    int idx = temp->nodeIdx;
    
    if (q->front == q->rear) {
        q->front = NULL;
        q->rear = NULL;
    } else {
        q->front = q->front->next;
    }
    
    free(temp);
    return idx;
}

// 8. 判断队列是否为空
int isQueueEmpty(Queue* q) {
    return q->front == NULL ? 1 : 0;
}

// 9. 创建邻接表节点（辅助函数）
AdjNode* createAdjNode(int adjIdx) {
    AdjNode* an = (AdjNode*)malloc(sizeof(AdjNode));
    an->adjNodeIdx = adjIdx;
    an->next = NULL;
    return an;
}

// 10. 初始化图（参数：节点总数，每个节点的初始值）
Graph* initGraph(int nodeCount, int* nodeData) {
    Graph* g = (Graph*)malloc(sizeof(Graph));
    g->nodeCount = nodeCount;
    g->edgeCount = 0;
    
    // 初始化每个顶点：邻接链表头指针设为NULL，顶点值设为nodeData[i]
    for (int i = 0; i < nodeCount; i++) {
        g->vertices[i].data = nodeData[i];
        g->vertices[i].adjListHead = NULL;
    }
    
    return g;
}

// 11. 向图中添加无向边（视频中的图为无向图，如1-2等价于2-1）
void addUndirectedEdge(Graph* g, int fromIdx, int toIdx) {
    // 1. 添加“fromIdx → toIdx”的边
    AdjNode* newAn1 = createAdjNode(toIdx);
    newAn1->next = g->vertices[fromIdx].adjListHead;
    g->vertices[fromIdx].adjListHead = newAn1;
    
    // 2. 添加“toIdx → fromIdx”的边（无向图双向）
    AdjNode* newAn2 = createAdjNode(fromIdx);
    newAn2->next = g->vertices[toIdx].adjListHead;
    g->vertices[toIdx].adjListHead = newAn2;
    
    g->edgeCount++; // 边数加1
}

// 12. 图的广度优先遍历（BFS，核心函数，基于视频步骤）
void bfsGraph(Graph* g, int startIdx) {
    if (g == NULL || startIdx < 0 || startIdx >= g->nodeCount) {
        printf("图为空或起始节点索引无效！\n");
        return;
    }
    
    // 初始化已访问数组：0=未访问，1=已访问
    int* visited = (int*)malloc(sizeof(int) * g->nodeCount);
    memset(visited, 0, sizeof(int) * g->nodeCount);
    
    Queue* q = initQueue();       // 新建队列
    enQueue(q, startIdx);         // 起始节点入队
    visited[startIdx] = 1;        // 标记为已访问
    
    printf("图的BFS遍历结果（起始节点：%d）：", g->vertices[startIdx].data);
    while (!isQueueEmpty(q)) {
        int currIdx = deQueue(q); // 出队头节点索引
        // 处理当前节点（视频中“处理”为打印节点值）
        printf("%d ", g->vertices[currIdx].data);
        
        // 遍历当前节点的所有邻接节点
        AdjNode* currAdj = g->vertices[currIdx].adjListHead;
        while (currAdj != NULL) {
            int adjIdx = currAdj->adjNodeIdx;
            // 若邻接节点未访问，入队并标记
            if (visited[adjIdx] == 0) {
                enQueue(q, adjIdx);
                visited[adjIdx] = 1;
            }
            currAdj = currAdj->next;
        }
    }
    printf("\n");
    
    // 释放内存
    free(visited);
    free(q);
}

// 主函数：构建视频中的示例图，并测试BFS
int main() {
    int nodeCount = 8;                // 视频示例中节点数为8（1~8）
    int nodeData[] = {1, 2, 3, 4, 5, 6, 7, 8}; // 节点值（索引0对应值1，索引1对应值2...）
    
    // 1. 初始化图
    Graph* g = initGraph(nodeCount, nodeData);
    
    // 2. 添加视频中的无向边（根据视频示例的邻接关系）
    addUndirectedEdge(g, 0, 1);  // 1（索引0）- 2（索引1）
    addUndirectedEdge(g, 0, 2);  // 1（索引0）- 3（索引2）
    addUndirectedEdge(g, 1, 3);  // 2（索引1）- 4（索引3）
    addUndirectedEdge(g, 2, 4);  // 3（索引2）- 5（索引4）
    addUndirectedEdge(g, 2, 5);  // 3（索引2）- 6（索引5）
    addUndirectedEdge(g, 4, 6);  // 5（索引4）- 7（索引6）
    addUndirectedEdge(g, 4, 7);  // 5（索引4）- 8（索引7）
    
    // 3. 执行BFS（起始节点为1，对应索引0）
    bfsGraph(g, 0);
    
    // （注：实际工程中需添加内存释放代码，此处为简化示例省略）
    return 0;
}
```

## 四、应用 3：操作系统中的队列应用

视频中强调 “操作系统通过队列实现‘先来先服务’策略，解决资源竞争和速度不匹配问题”，核心分为两个场景：

### 1. 场景 1：CPU 就绪队列

#### 核心逻辑

- **问题背景**：CPU 是稀缺资源，系统中多个进程并发运行，需争抢 CPU 使用权；
- **队列作用**：操作系统将 “等待 CPU 的进程” 排成**就绪队列**，遵循 “先来先服务”（与队列 FIFO 一致）；
- **执行流程（视频描述）**：
	1. 进程申请 CPU 时，进入就绪队列队尾；
	2. CPU 空闲时，取出队头进程，分配一个 “短时间片” 执行；
	3. 时间片结束后，进程下 CPU，回到就绪队列队尾（若未执行完）；
	4. 循环此过程，实现所有进程轮流使用 CPU（用户感知 “多程序同时运行”）。

### 2. 场景 2：打印机缓冲区队列

#### 核心逻辑

- **问题背景**：打印机是 “慢速设备”，主机是 “快速设备”，主机可短时间内发送多个打印任务，打印机无法实时处理；
- **队列作用**：系统开辟 “打印缓冲区”，将 “待打印任务” 按 “先来后到” 排成**打印队列**（FIFO）；
- **执行流程（视频描述）**：
	1. 用户发送打印任务时，任务直接进入打印队列队尾；
	2. 打印机完成当前任务后，从队列头取出下一个任务执行；
	3. 核心效果：缓解 “主机与打印机速度不匹配”，避免任务丢失或混乱。

### 补充说明

两个场景的核心共性：均依赖队列 “先进先出” 特性，实现 “先来先服务”，保证资源分配的公平性和顺序性（视频中未提供操作系统级代码，因涉及内核实现，故仅描述逻辑）。

# 特殊矩阵的压缩存储知识点总结

## 1. 数组存储基础

视频中以 C 语言为例，先讲解数组的底层存储逻辑，为矩阵压缩存储奠定基础，核心是**连续存储**和**随机存取特性**。

### 1.1 一维数组

#### 1.1.1 定义与存储特性

- **定义格式**（C 语言）：`ElemType arr[n];`（`ElemType`为元素类型，如`int`/`float`）
- **核心特性**：
	1. 所有元素类型相同，占用存储空间大小相等（记为`u`，如`int`占 4 字节）；
	2. 元素在内存中**连续存放**，支持随机存取。

#### 1.1.2 地址计算

已知数组起始地址`LOC(arr[0])`，计算下标为`i`的元素地址（需注意下标起始值）：

- **下标从 0 开始**（默认）：`LOC(arr[i]) = LOC(arr[0]) + i * u`
- **下标从 1 开始**：`LOC(arr[i]) = LOC(arr[1]) + (i-1) * u`
- 关键提醒：题目未说明时，数组下标默认从 0 开始，矩阵下标默认从 1 开始（需特别注意题干条件）。

### 1.2 二维数组

#### 1.2.1 定义与逻辑 / 物理存储差异

- **定义格式**（C 语言）：`ElemType arr[m][n];`（`m`行`n`列）
- **逻辑视角**：二维表格（行 × 列）；
- **物理视角**：内存是线性连续空间，需通过 “行优先” 或 “列优先” 将二维结构 “拉平” 为一维存储。

#### 1.2.2 两种存储方式

| 存储方式 | 核心规则                             | 适用场景                   |
| -------- | ------------------------------------ | -------------------------- |
| 行优先   | 先存完第 1 行，再存第 2 行，依次类推 | C/C++、Java 等主流语言默认 |
| 列优先   | 先存完第 1 列，再存第 2 列，依次类推 | Fortran 语言默认           |

#### 1.2.3 地址计算（关键公式）

设二维数组`arr[m][n]`，起始地址`LOC(arr[0][0])`，元素`arr[i][j]`的地址计算：

1. **行优先存储**：
	- 前`i`行共`i * n`个元素，第`i`行中`j`之前有`j`个元素；
	- 公式：`LOC(arr[i][j]) = LOC(arr[0][0]) + (i * n + j) * u`
2. **列优先存储**：
	- 前`j`列共`j * m`个元素，第`j`列中`i`之前有`i`个元素；
	- 公式：`LOC(arr[i][j]) = LOC(arr[0][0]) + (j * m + i) * u`

- 注意：若矩阵下标从 1 开始（如`arr[i][j]`中`i∈[1,m],j∈[1,n]`），需将公式中`i`替换为`i-1`，`j`替换为`j-1`。

## 2. 特殊矩阵的压缩存储

普通矩阵用二维数组存储无浪费，但**特殊矩阵（含大量重复 / 零元素）** 可通过压缩策略节省空间，核心是 “只存必要元素”。

### 2.1 对称矩阵

#### 2.1.1 定义

- 满足两个条件：
	1. 是**n 阶方阵**（行数 = 列数 = n）；
	2. 对任意`i,j`，有`a[i][j] = a[j][i]`（元素关于主对角线对称）。
- 示例：`a[1][2] = a[2][1]`，`a[1][3] = a[3][1]`，主对角线（`i=j`）元素自身对称。

#### 2.1.2 压缩策略

- 核心：只需存储**主对角线 + 下三角区**（或 “主对角线 + 上三角区”），避免重复存储对称元素。
- 存储容量计算：非重复元素个数为`1+2+...+n = n(n+1)/2`，故用大小为`n(n+1)/2`的一维数组`B`存储。

#### 2.1.3 地址映射（行优先存储 “主对角线 + 下三角区”）

目标：将矩阵`a[i][j]`（下标从 1 开始）映射到一维数组`B[k]`（下标从 0 开始）。

1. **当`i >= j`（下三角区 / 主对角线）**：
	- 前`i-1`行共`1+2+...+(i-1) = i(i-1)/2`个元素；
	- 第`i`行中`j`之前有`j-1`个元素（因从第 1 列开始存）；
	- 总位置：`k = i(i-1)/2 + j - 1`（减 1 是因`B`下标从 0 开始）。
2. **当`i < j`（上三角区）**：
	- 利用对称性`a[i][j] = a[j][i]`，将其转换为`a[j][i]`（此时`j >= i`），再用上述公式计算`k`。

#### 2.1.4 代码示例（C 语言）

c

```c
#include <stdio.h>
#define MAX_N 100  // 最大阶数

// 对称矩阵压缩存储：将a[i][j]（1-based）映射到B[k]（0-based）
int symMatrixTo1D(int a[MAX_N][MAX_N], int n, int B[], int i, int j) {
    if (i < 1 || i > n || j < 1 || j > n) {
        printf("下标越界！\n");
        return -1;
    }
    int k;
    if (i >= j) {
        k = i * (i - 1) / 2 + j - 1;  // 下三角区/主对角线映射公式
    } else {
        k = j * (j - 1) / 2 + i - 1;  // 上三角区：利用对称性转换为j>=i
    }
    B[k] = a[i][j];  // 存储到一维数组
    return k;        // 返回映射后的下标
}

// 从压缩数组B中读取a[i][j]的值
int getSymMatrixVal(int B[], int n, int i, int j) {
    if (i < 1 || i > n || j < 1 || j > n) {
        printf("下标越界！\n");
        return -1;
    }
    int k;
    if (i >= j) {
        k = i * (i - 1) / 2 + j - 1;
    } else {
        k = j * (j - 1) / 2 + i - 1;
    }
    return B[k];
}

int main() {
    int n = 3;
    int a[4][4] = {  // 1-based下标，忽略a[0][*]和a[*][0]
        {0,0,0,0},
        {0,1,2,3},
        {0,2,4,5},
        {0,3,5,6}
    };
    int B[MAX_N*(MAX_N+1)/2];  // 压缩数组
    
    // 压缩存储所有元素
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=n; j++) {
            symMatrixTo1D(a, n, B, i, j);
        }
    }
    
    // 读取测试：a[1][3] = a[3][1] = 3
    printf("a[1][3] = %d\n", getSymMatrixVal(B, n, 1, 3));  // 输出3
    printf("a[3][1] = %d\n", getSymMatrixVal(B, n, 3, 1));  // 输出3
    return 0;
}
```

### 2.2 三角矩阵

#### 2.2.1 定义与分类

三角矩阵是 n 阶方阵，分为两类：

| 类型       | 核心特征                                                 | 示例                    |
| ---------- | -------------------------------------------------------- | ----------------------- |
| 下三角矩阵 | 下三角区（`i >= j`）非零，上三角区（`i < j`）全为常量`c` | `a[1][2] = a[1][3] = c` |
| 上三角矩阵 | 上三角区（`i <= j`）非零，下三角区（`i > j`）全为常量`c` | `a[2][1] = a[3][1] = c` |

#### 2.2.2 压缩策略

- 核心：存储 “非零区（下三角 / 上三角） + 1 个常量`c`”（无需重复存储常量区元素）。
- 存储容量计算：非零区元素个数为`n(n+1)/2`，加 1 个常量，故一维数组`B`大小为`n(n+1)/2 + 1`（最后一个位置存`c`）。

#### 2.2.3 地址映射（行优先存储）

以**下三角矩阵**（`i >= j`非零，`i < j`为`c`）为例（矩阵下标从 1 开始，`B`下标从 0 开始）：

1. **当`i >= j`（非零区）**：
	- 映射公式与对称矩阵下三角区完全相同：`k = i(i-1)/2 + j - 1`；
2. **当`i < j`（常量区）**：
	- 所有元素映射到`B`的最后一个位置：`k = n(n+1)/2`（存常量`c`）。

以上三角矩阵（`i <= j`非零，`i > j`为`c`）为例：

1. **当`i <= j`（非零区）**：
	- 前`i-1`行共`n + (n-1) + ... + (n-i+2) = (i-1)(2n - i + 2)/2`个元素；
	- 第`i`行中`j`之前有`j - i`个元素；
	- 映射公式：`k = (i-1)(2n - i + 2)/2 + (j - i)`；
2. **当`i > j`（常量区）**：
	- 映射到`B`的最后一个位置：`k = n(n+1)/2`。

#### 2.2.4 代码示例（下三角矩阵压缩）

c

```c
#include <stdio.h>
#define MAX_N 100

// 下三角矩阵压缩：a[i][j]（1-based）→ B[k]（0-based），常量c存在B末尾
int lowerTriMatrixTo1D(int a[MAX_N][MAX_N], int n, int B[], int i, int j, int c) {
    if (i < 1 || i > n || j < 1 || j > n) {
        printf("下标越界！\n");
        return -1;
    }
    int k;
    if (i >= j) {
        k = i * (i - 1) / 2 + j - 1;  // 非零区映射
        B[k] = a[i][j];
    } else {
        k = n * (n + 1) / 2;          // 常量区映射到最后
        B[k] = c;
    }
    return k;
}

// 读取下三角矩阵元素
int getLowerTriVal(int B[], int n, int i, int j) {
    if (i < 1 || i > n || j < 1 || j > n) {
        printf("下标越界！\n");
        return -1;
    }
    int k;
    if (i >= j) {
        k = i * (i - 1) / 2 + j - 1;
    } else {
        k = n * (n + 1) / 2;
    }
    return B[k];
}

int main() {
    int n = 3;
    int c = 0;  // 上三角区常量
    int a[4][4] = {  // 1-based，上三角区为0
        {0,0,0,0},
        {0,1,0,0},
        {0,2,3,0},
        {0,4,5,6}
    };
    int B[MAX_N*(MAX_N+1)/2 + 1];  // 压缩数组（含常量位）
    
    // 压缩存储
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=n; j++) {
            lowerTriMatrixTo1D(a, n, B, i, j, c);
        }
    }
    
    // 测试：a[1][2]是常量0，a[2][1]是非零2
    printf("a[1][2] = %d\n", getLowerTriVal(B, n, 1, 2));  // 输出0
    printf("a[2][1] = %d\n", getLowerTriVal(B, n, 2, 1));  // 输出2
    return 0;
}
```

### 2.3 三对角矩阵（带状矩阵）

#### 2.3.1 定义

- 满足：对 n 阶方阵，当`|i - j| > 1`时，`a[i][j] = 0`（非零元素仅分布在 “主对角线 ±1” 的带状区域）。
- 非零元素分布规律：
	1. 第 1 行和第 n 行：各有 2 个非零元素（`a[1][1],a[1][2]`和`a[n][n-1],a[n][n]`）；
	2. 第 2~n-1 行：各有 3 个非零元素（`a[i][i-1],a[i][i],a[i][i+1]`）。

#### 2.3.2 压缩策略

- 核心：只存储带状区域的非零元素，行优先存储到一维数组`B`中。
- 存储容量计算：总非零元素个数 = 2 + 3*(n-2) = 3n - 2，故`B`大小为`3n - 2`。

#### 2.3.3 地址映射（行优先，矩阵下标从 1 开始，`B`下标从 0 开始）

目标：将非零元素`a[i][j]`（满足`|i-j|<=1`）映射到`B[k]`。

1. **前`i-1`行的非零元素总数**：
	- 第 1 行：2 个；
	- 第 2~i-1 行：共`(i-2)*3`个；
	- 总计：`2 + 3*(i-2) = 3i - 4`。
2. **第`i`行中`j`的位置偏移**：
	- 第 1 行（`i=1`）：`j`只能是 1 或 2 → 偏移量`j - 1`（`j=1`→0，`j=2`→1）；
	- 第 n 行（`i=n`）：`j`只能是 n-1 或 n → 偏移量`j - (n-1)`（`j=n-1`→0，`j=n`→1）；
	- 第 2~n-1 行（`2<=i<=n-1`）：`j`只能是 i-1、i、i+1 → 偏移量`j - (i-1)`（`j=i-1`→0，`j=i`→1，`j=i+1`→2）。
3. **总映射公式**：
	- `i=1`：`k = (3*1 - 4) + (j - 1) = j - 2`（简化：`k = j - 1`，因`3*1-4=-1`，`-1 + j-1 = j-2`？实际验证：`i=1,j=1`→k=0，`j=2`→k=1，故`k = j - 1`）；
	- `2<=i<=n-1`：`k = (3i - 4) + (j - (i-1)) = 2i + j - 5`；
	- `i=n`：`k = (3n - 4) + (j - (n-1)) = 2n + j - 5`（验证：`i=n,j=n-1`→k=3n-3，`j=n`→k=3n-2，符合`B`大小）。

#### 2.3.4 反向映射（从`B[k]`找`i`和`j`）

已知`k`，求对应的`i`（行号）和`j`（列号）：

1. **求行号`i`**：
	- 若`k < 2`（前 2 个元素）→ `i=1`；
	- 若`k >= 3n - 2 - 2 = 3n - 4`（后 2 个元素）→ `i=n`；
	- 否则：`i = floor((k - 2)/3) + 2`（或向上取整`(k+1)/3`，需结合具体值验证）。
2. **求列号`j`**：
	- `i=1`：`j = k + 1`；
	- `i=n`：`j = k - (3n - 4) + (n-1) = k - 2n + 3`；
	- `2<=i<=n-1`：`j = (k - (3i - 4)) + (i-1) = k - 2i + 5`。

#### 2.3.5 代码示例

c

```c
#include <stdio.h>
#define MAX_N 100

// 三对角矩阵压缩：a[i][j]（1-based，|i-j|<=1）→ B[k]（0-based）
int triDiagMatrixTo1D(int a[MAX_N][MAX_N], int n, int B[], int i, int j) {
    if (i < 1 || i > n || j < 1 || j > n || abs(i-j) > 1) {
        printf("下标无效（非零元素区域）！\n");
        return -1;
    }
    int k;
    if (i == 1) {
        k = j - 1;  // i=1: j=1→0, j=2→1
    } else if (i == n) {
        k = (3*n - 4) + (j - (n-1));  // 3n-4是前n-1行总元素数
    } else {
        k = (3*i - 4) + (j - (i-1));  // 3i-4是前i-1行总元素数
    }
    B[k] = a[i][j];
    return k;
}

// 反向映射：从B[k]找i和j
void getTriDiagIdx(int k, int n, int *i, int *j) {
    if (k < 0 || k >= 3*n - 2) {
        printf("B数组下标越界！\n");
        *i = *j = -1;
        return;
    }
    if (k < 2) {  // 前2个元素属于第1行
        *i = 1;
        *j = k + 1;
    } else if (k >= 3*n - 4) {  // 后2个元素属于第n行
        *i = n;
        *j = k - (3*n - 4) + (n-1);
    } else {  // 中间行（2<=i<=n-1）
        *i = (k - 2) / 3 + 2;  // (k-2)/3是第2行开始的偏移行数
        *j = k - (3*(*i) - 4) + (*i - 1);
    }
}

int main() {
    int n = 4;  // 4阶三对角矩阵
    int a[5][5] = {  // 1-based，非零区为|i-j|<=1
        {0,0,0,0,0},
        {0,1,2,0,0},
        {0,3,4,5,0},
        {0,0,6,7,8},
        {0,0,0,9,10}
    };
    int B[3*MAX_N - 2];  // 压缩数组
    int k, i, j;
    
    // 压缩存储非零元素
    int nonZero[][2] = {{1,1},{1,2},{2,1},{2,2},{2,3},{3,2},{3,3},{3,4},{4,3},{4,4}};
    for (int idx=0; idx<10; idx++) {
        i = nonZero[idx][0];
        j = nonZero[idx][1];
        triDiagMatrixTo1D(a, n, B, i, j);
    }
    
    // 反向映射测试：k=5（对应a[3][2] = 6）
    getTriDiagIdx(5, n, &i, &j);
    printf("B[5] 对应 a[%d][%d] = %d\n", i, j, B[5]);  // 输出a[3][2] = 6
    return 0;
}
```

### 2.4 稀疏矩阵

#### 2.4.1 定义

- 核心：矩阵中**非零元素的个数远少于总元素个数**（无固定比例，需结合实际场景判断，如 1000×1000 矩阵仅 100 个非零元素）。
- 特点：零元素占比极高，用二维数组存储会浪费大量空间。

#### 2.4.2 压缩存储方式（视频讲解两种）

##### 方式 1：三元组顺序表

- **核心思想**：对每个非零元素，存储其 “行号`i`、列号`j`、值`value`”，形成三元组`(i,j,value)`，再用数组顺序存储所有三元组。
- **优缺点**：
	- 优点：结构简单，节省空间；
	- 缺点：仅支持顺序存取（查找需遍历数组），不支持随机存取。
- **代码示例（三元组结构体与存储）**：

c

```c
#include <stdio.h>
#define MAX_NONZERO 100  // 最大非零元素个数

// 三元组结构体
typedef struct {
    int i;          // 非零元素行号（1-based）
    int j;          // 非零元素列号（1-based）
    ElemType value; // 非零元素值（ElemType需提前定义，如typedef int ElemType）
} Triple;

// 稀疏矩阵的三元组存储结构（含矩阵总行数、总列数、非零元素个数）
typedef struct {
    Triple data[MAX_NONZERO];  // 存储三元组的数组
    int rows;                  // 矩阵总行数
    int cols;                  // 矩阵总列数
    int nonZeroCnt;            // 非零元素个数
} SparseMatrix;

// 构建稀疏矩阵的三元组存储
void createSparseMatrix(SparseMatrix *SM, int a[][100], int rows, int cols) {
    SM->rows = rows;
    SM->cols = cols;
    SM->nonZeroCnt = 0;
    // 遍历矩阵，收集非零元素
    for (int i=1; i<=rows; i++) {
        for (int j=1; j<=cols; j++) {
            if (a[i][j] != 0) {
                SM->data[SM->nonZeroCnt].i = i;
                SM->data[SM->nonZeroCnt].j = j;
                SM->data[SM->nonZeroCnt].value = a[i][j];
                SM->nonZeroCnt++;
            }
        }
    }
}

// 查找稀疏矩阵中a[i][j]的值（顺序查找）
ElemType getSparseVal(SparseMatrix *SM, int i, int j) {
    if (i < 1 || i > SM->rows || j < 1 || j > SM->cols) {
        printf("下标越界！\n");
        return 0;
    }
    // 顺序遍历三元组数组
    for (int k=0; k<SM->nonZeroCnt; k++) {
        if (SM->data[k].i == i && SM->data[k].j == j) {
            return SM->data[k].value;
        }
    }
    return 0;  // 未找到，返回0（零元素）
}

int main() {
    typedef int ElemType;  // 定义元素类型为int
    int rows = 4, cols = 6;
    int a[5][100] = {  // 1-based稀疏矩阵
        {0,0,0,0,0,0,0},
        {0,0,4,0,0,5,0},
        {0,3,0,0,0,0,0},
        {0,0,0,0,0,0,0},
        {0,2,0,0,0,0,0}
    };
    SparseMatrix SM;
    
    // 构建三元组存储
    createSparseMatrix(&SM, a, rows, cols);
    printf("非零元素个数：%d\n", SM.nonZeroCnt);  // 输出4（4,3,2,5）
    
    // 查找测试：a[1][3] = 4，a[2][1] = 3
    printf("a[1][3] = %d\n", getSparseVal(&SM, 1, 3));  // 输出4
    printf("a[2][1] = %d\n", getSparseVal(&SM, 2, 1));  // 输出3
    return 0;
}
```

##### 方式 2：十字链表法

- **核心思想**：用 “行指针数组 + 列指针数组 + 节点链表” 存储，每个非零元素对应一个节点，节点包含行号`i`、列号`j`、值`value`，以及两个指针（`right`：指向同一行的下一个非零节点；`down`：指向同一列的下一个非零节点）。
- **结构组成**：
	1. 行指针数组`rowHead[]`：`rowHead[i]`指向第`i`行的第一个非零节点；
	2. 列指针数组`colHead[]`：`colHead[j]`指向第`j`列的第一个非零节点；
	3. 节点结构：`i, j, value, *right, *down`。
- **优缺点**：
	- 优点：支持高效的增删操作（无需移动大量元素），适合动态稀疏矩阵；
	- 缺点：结构复杂，实现难度高于三元组。
- **代码示例（十字链表节点与初始化）**：

c

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_ROWS 100
#define MAX_COLS 100
typedef int ElemType;

// 十字链表节点结构体
typedef struct OLNode {
    int i;                  // 行号（1-based）
    int j;                  // 列号（1-based）
    ElemType value;         // 元素值
    struct OLNode *right;   // 指向同一行的下一个节点
    struct OLNode *down;    // 指向同一列的下一个节点
} OLNode, *OLink;

// 十字链表头结构（含行指针数组、列指针数组、矩阵行列数）
typedef struct {
    OLink rowHead[MAX_ROWS];  // 行指针数组
    OLink colHead[MAX_COLS];  // 列指针数组
    int rows;                 // 矩阵总行数
    int cols;                 // 矩阵总列数
    int nonZeroCnt;           // 非零元素个数
} CrossList;

// 创建十字链表节点
OLink createOLNode(int i, int j, ElemType value) {
    OLink node = (OLink)malloc(sizeof(OLNode));
    node->i = i;
    node->j = j;
    node->value = value;
    node->right = NULL;
    node->down = NULL;
    return node;
}

// 构建稀疏矩阵的十字链表
void createCrossList(CrossList *CL, int a[][MAX_COLS], int rows, int cols) {
    CL->rows = rows;
    CL->cols = cols;
    CL->nonZeroCnt = 0;
    
    // 初始化行指针和列指针数组为NULL
    for (int i=1; i<=rows; i++) CL->rowHead[i] = NULL;
    for (int j=1; j<=cols; j++) CL->colHead[j] = NULL;
    
    // 遍历矩阵，插入非零元素节点
    for (int i=1; i<=rows; i++) {
        OLink rowPrev = NULL;  // 记录当前行的前一个节点
        for (int j=1; j<=cols; j++) {
            if (a[i][j] != 0) {
                // 创建新节点
                OLink newNode = createOLNode(i, j, a[i][j]);
                CL->nonZeroCnt++;
                
                // 插入当前行的链表（right指针）
                if (CL->rowHead[i] == NULL) {
                    CL->rowHead[i] = newNode;  // 行首节点
                } else {
                    rowPrev->right = newNode;  // 连接到前一个节点
                }
                rowPrev = newNode;  // 更新行前节点
                
                // 插入当前列的链表（down指针）
                OLink colPrev = NULL;
                OLink colCurr = CL->colHead[j];
                // 找到列链表中插入位置（按行号递增）
                while (colCurr != NULL && colCurr->i < i) {
                    colPrev = colCurr;
                    colCurr = colCurr->down;
                }
                if (colPrev == NULL) {
                    CL->colHead[j] = newNode;  // 列首节点
                } else {
                    colPrev->down = newNode;   // 连接到前一个节点
                }
                newNode->down = colCurr;  // 新节点指向后一个节点
            }
        }
    }
}

// 遍历十字链表（按行输出非零元素）
void traverseCrossList(CrossList *CL) {
    printf("稀疏矩阵非零元素（按行输出）：\n");
    for (int i=1; i<=CL->rows; i++) {
        OLink curr = CL->rowHead[i];
        while (curr != NULL) {
            printf("a[%d][%d] = %d  ", curr->i, curr->j, curr->value);
            curr = curr->right;
        }
        if (CL->rowHead[i] != NULL) printf("\n");
    }
}

int main() {
    int rows = 4, cols = 6;
    int a[5][MAX_COLS] = {  // 1-based稀疏矩阵
        {0,0,0,0,0,0,0},
        {0,0,4,0,0,5,0},
        {0,3,0,0,0,0,0},
        {0,0,0,0,0,0,0},
        {0,2,0,0,0,0,0}
    };
    CrossList CL;
    
    // 构建十字链表
    createCrossList(&CL, a, rows, cols);
    // 遍历输出
    traverseCrossList(&CL);
    // 输出：a[1][3]=4  a[1][6]=5; a[2][2]=3; a[4][2]=2
    return 0;
}
```

## 3. 关键注意事项

1. **下标起始值**：数组默认从 0 开始，矩阵默认从 1 开始，题目未说明时需按此默认处理，若有特殊说明需调整公式；
2. **存储优先级**：行优先是主流（C/C++ 默认），列优先需特别注意题干提示；
3. **压缩核心**：所有特殊矩阵压缩的本质是 “只存必要元素”（非重复、非零、非常量），避免空间浪费；
4. **公式推导**：无需死记公式，需理解 “前 n 行 / 列的元素总数 + 当前行 / 列的偏移量” 的推导逻辑，应对题目条件变化（如下标起始、存储优先级修改）。



# 数据结构之队列（逊哥带你学计算机）

## 1. 普通顺序队列（问题引入）

### 1.1 普通顺序队列的结构

- 基于数组实现，核心属性：数组`data`、队头指针`front`（指向队头元素）、队尾指针`rear`（指向队尾元素的下一个位置）、最大容量`maxSize`。
- 操作原则：**先进先出（FIFO）**，仅允许从队头出队，从队尾入队。

### 1.2 核心问题：假溢出

- 现象：当队尾指针`rear`达到数组最大下标（`maxSize-1`）时，即使队头有空闲空间，也无法继续入队（存在数组越界风险），这种情况称为 “假溢出”。
- 原因：普通队列的数组空间 “单向使用”，队头元素出队后，其占用空间无法重复利用。
- 示例：
	设`maxSize=5`（数组下标 0-4），入队 A、B、C 后，`front=0`、`rear=3`；出队 A、B 后，`front=2`、`rear=3`。此时数组 0-1 空闲，但`rear=3`无法继续入队（再入队会导致`rear=4`，后续入队直接越界），即假溢出。

## 2. 循环队列（解决假溢出）

### 2.1 循环队列的核心原理

- 思想：将数组空间 “首尾相连” 形成环形结构，队尾指针`rear`达到数组末尾（`maxSize-1`）后，可绕回数组起始位置（0）复用空闲空间。
- 关键约定（视频重点强调）：
	1. 队尾指针`rear`：始终指向队尾元素的**下一个位置**（初始`rear=0`）。
	2. 队头指针`front`：始终指向队头元素（初始`front=0`）。
	3. 判空条件：`front == rear`（初始状态或所有元素出队后）。
	4. 判满条件：`(rear + 1) % maxSize == front`（故意留出 1 个空闲空间，避免与判空条件冲突 —— 循环队列最多容纳`maxSize-1`个元素，视频称此为 “无法完全装满的 bug”）。

### 2.2 循环队列的结构体定义（C++）

cpp







```cpp
#include <iostream>
using namespace std;

// 循环队列结构体（动态内存分配）
struct CirQueue {
    int* data;       // 动态数组（存储队列元素）
    int front;       // 队头指针（指向队头元素）
    int rear;        // 队尾指针（指向队尾元素的下一个位置）
    int maxSize;     // 队列最大容量
};
```

### 2.3 循环队列的核心操作代码（C++，与视频完全一致）

#### 2.3.1 初始化队列（动态分配内存）

- 视频强调：动态队列与静态队列的区别仅在初始化 —— 用`new`（对应视频中的`my_malloc`）分配数组空间，而非静态数组。

cpp







```cpp
// 初始化循环队列：参数为队列引用、最大容量
void InitCirQueue(CirQueue& q, int maxS) {
    q.maxSize = maxS;
    q.data = new int[q.maxSize];  // 动态分配数组
    q.front = 0;                  // 初始队头、队尾均为0
    q.rear = 0;
}
```

#### 2.3.2 判断队列是否为空

cpp







```cpp
bool IsCirQueueEmpty(CirQueue q) {
    return q.front == q.rear;  // 队头 == 队尾 → 空
}
```

#### 2.3.3 判断队列是否为满

- 视频高频考点公式：`(rear + 1) % maxSize == front`

cpp







```cpp
bool IsCirQueueFull(CirQueue q) {
    // 队尾+1取余后等于队头 → 满
    return (q.rear + 1) % q.maxSize == q.front;
}
```

#### 2.3.4 入队操作（从队尾插入）

- 步骤：1. 判满 → 2. 插入元素到`rear`位置 → 3. `rear`绕圈更新（`(rear+1)%maxSize`）

cpp







```cpp
bool EnCirQueue(CirQueue& q, int elem) {
    if (IsCirQueueFull(q)) {
        cout << "队列已满，无法入队！" << endl;
        return false;
    }
    q.data[q.rear] = elem;  // 元素存入队尾（rear指向的位置）
    q.rear = (q.rear + 1) % q.maxSize;  // 队尾指针绕圈
    return true;
}
```

#### 2.3.5 出队操作（从队头删除）

- 步骤：1. 判空 → 2. 保存队头元素 → 3. `front`绕圈更新 → 4. 返回元素

cpp







```cpp
bool DeCirQueue(CirQueue& q, int& elem) {
    if (IsCirQueueEmpty(q)) {
        cout << "队列为空，无法出队！" << endl;
        return false;
    }
    elem = q.data[q.front];  // 保存队头元素
    q.front = (q.front + 1) % q.maxSize;  // 队头指针绕圈
    return true;
}
```

#### 2.3.6 获取队头元素（不删除）

cpp







```cpp
bool GetCirQueueFront(CirQueue q, int& elem) {
    if (IsCirQueueEmpty(q)) {
        cout << "队列为空，无队头元素！" << endl;
        return false;
    }
    elem = q.data[q.front];  // 直接取队头指针指向的元素
    return true;
}
```

#### 2.3.7 销毁队列（释放动态内存）

- 视频强调：动态内存需手动释放，避免内存泄漏

cpp







```cpp
void DestroyCirQueue(CirQueue& q) {
    delete[] q.data;  // 释放数组空间
    q.data = nullptr; // 避免野指针
    q.front = q.rear = q.maxSize = 0;  // 重置属性
}
```

### 2.4 循环队列操作示例（与视频测试案例一致）

- 需求：初始化容量为 8 的循环队列，入队 10、20、30、40、50，出队 2 次，获取队头元素

cpp







```cpp
int main() {
    CirQueue q;
    InitCirQueue(q, 8);  // 最大容量8，实际最多存7个元素

    // 入队10、20、30、40、50
    EnCirQueue(q, 10);
    EnCirQueue(q, 20);
    EnCirQueue(q, 30);
    EnCirQueue(q, 40);
    EnCirQueue(q, 50);

    // 出队2次（出队10、20）
    int elem;
    DeCirQueue(q, elem);
    cout << "出队元素：" << elem << endl;  // 输出：10
    DeCirQueue(q, elem);
    cout << "出队元素：" << elem << endl;  // 输出：20

    // 获取队头元素（应为30）
    GetCirQueueFront(q, elem);
    cout << "当前队头元素：" << elem << endl;  // 输出：30

    DestroyCirQueue(q);
    return 0;
}
```

- 输出结果：

	plaintext

	

	

	

	```plaintext
	出队元素：10
	出队元素：20
	当前队头元素：30
	```

### 2.5 循环队列的特殊初始情况（视频补充）

- 场景：若约定 “队尾指针`rear`指向队尾元素”（而非下一个位置），则初始值调整：
	1. 初始`front=0`，`rear = maxSize - 1`（如`maxSize=8`，初始`rear=7`）。
	2. 入队步骤：先更新`rear = (rear + 1) % maxSize`，再插入元素。
	3. 判满、判空条件不变（仍为`(rear+1)%maxSize == front`和`front==rear`）。
- 视频考点：考试需根据题目对`rear`的指向约定，调整初始值和操作顺序。

## 3. 链式队列（基于链表实现）

### 3.1 链式队列的核心原理

- 思想：用链表存储队列元素，避免顺序队列的 “固定容量” 和 “假溢出” 问题（链表可动态扩容）。
- 关键约定（视频与教材一致）：
	1. 节点结构：包含数据域`data`和指针域`next`（视频称节点为`QNode`）。
	2. 队列结构：含队头指针`front`和队尾指针`rear`，**带头节点**（头节点不存数据，仅简化操作）。
	3. 判空条件：`front == rear`（队头、队尾均指向头节点）。
	4. 入队：尾插法（从`rear`后插入新节点，更新`rear`）。
	5. 出队：删除头节点的`next`（队头元素），若删完队空，需将`rear`指向头节点。

### 3.2 链式队列的结构体定义（C++）

cpp







```cpp
// 链式队列的节点结构
struct QNode {
    int data;       // 数据域
    QNode* next;    // 指针域（指向下一个节点）
};

// 链式队列的整体结构（含队头、队尾指针）
struct LinkQueue {
    QNode* front;   // 队头指针（指向头节点）
    QNode* rear;    // 队尾指针（指向队尾节点）
};
```

### 3.3 链式队列的核心操作代码（C++，与视频完全一致）

#### 3.3.1 初始化队列（创建头节点）

- 视频步骤：1. 创建头节点 → 2. 头节点`next`置空 → 3. `front`和`rear`均指向头节点

cpp







```cpp
void InitLinkQueue(LinkQueue& q) {
    // 创建头节点（不存数据）
    QNode* headNode = new QNode;
    headNode->next = nullptr;
    q.front = headNode;  // 队头、队尾均指向头节点
    q.rear = headNode;
}
```

#### 3.3.2 判断队列是否为空

cpp







```cpp
bool IsLinkQueueEmpty(LinkQueue q) {
    return q.front == q.rear;  // 均指向头节点 → 空
}
```

#### 3.3.3 入队操作（尾插法）

- 视频步骤：1. 创建新节点 → 2. 新节点赋值 → 3. 接在`rear`后 → 4. 更新`rear`

cpp







```cpp
bool EnLinkQueue(LinkQueue& q, int elem) {
    // 创建新节点
    QNode* newNode = new QNode;
    newNode->data = elem;
    newNode->next = nullptr;  // 新节点为队尾，next置空

    // 新节点接在队尾（rear的next）
    q.rear->next = newNode;
    q.rear = newNode;  // 更新队尾指针

    return true;
}
```

#### 3.3.4 出队操作（删除头节点的 next）

- 视频注意点：若删除最后一个元素（队尾节点），需将`rear`重新指向头节点

cpp







```cpp
bool DeLinkQueue(LinkQueue& q, int& elem) {
    if (IsLinkQueueEmpty(q)) {
        cout << "队列为空，无法出队！" << endl;
        return false;
    }

    QNode* delNode = q.front->next;  // 待删除节点（队头元素）
    elem = delNode->data;            // 保存出队元素

    q.front->next = delNode->next;   // 头节点跳过待删除节点

    // 若删除的是队尾节点，需将rear指向头节点（避免野指针）
    if (q.rear == delNode) {
        q.rear = q.front;
    }

    delete delNode;  // 释放节点内存
    delNode = nullptr;
    return true;
}
```

#### 3.3.5 获取队头元素（不删除）

cpp







```cpp
bool GetLinkQueueFront(LinkQueue q, int& elem) {
    if (IsLinkQueueEmpty(q)) {
        cout << "队列为空，无队头元素！" << endl;
        return false;
    }
    elem = q.front->next->data;  // 队头元素是头节点的next的数据
    return true;
}
```

#### 3.3.6 销毁队列（释放所有节点）

- 视频强调：需遍历释放所有节点（包括头节点）

cpp







```cpp
void DestroyLinkQueue(LinkQueue& q) {
    QNode* curr = q.front;
    while (curr != nullptr) {
        QNode* temp = curr;  // 保存当前节点
        curr = curr->next;   // 移动到下一个节点
        delete temp;         // 释放当前节点
    }
    q.front = q.rear = nullptr;  // 重置指针
}
```

### 3.4 链式队列操作示例（与视频测试案例一致）

- 需求：初始化链式队列，入队 10、20、30、40、50，出队 2 次，获取队头 / 队尾元素

cpp







```cpp
int main() {
    LinkQueue q;
    InitLinkQueue(q);

    // 入队10、20、30、40、50
    EnLinkQueue(q, 10);
    EnLinkQueue(q, 20);
    EnLinkQueue(q, 30);
    EnLinkQueue(q, 40);
    EnLinkQueue(q, 50);

    // 出队2次（出队10、20）
    int elem;
    DeLinkQueue(q, elem);
    cout << "出队元素：" << elem << endl;  // 输出：10
    DeLinkQueue(q, elem);
    cout << "出队元素：" << elem << endl;  // 输出：20

    // 获取队头元素（应为30）
    GetLinkQueueFront(q, elem);
    cout << "当前队头元素：" << elem << endl;  // 输出：30

    // 获取队尾元素（应为50，视频中rear指向队尾元素）
    cout << "当前队尾元素：" << q.rear->data << endl;  // 输出：50

    DestroyLinkQueue(q);
    return 0;
}
```

- 输出结果：

	plaintext

	

	

	

	```plaintext
	出队元素：10
	出队元素：20
	当前队头元素：30
	当前队尾元素：50
	```

## 4. 特殊队列（视频提及）

### 4.1 双端队列（Deque）

- 定义：允许在**两端**进行入队操作，可在**一端或两端**进行出队操作的队列（视频称 “队列的变种形态”）。
- 常见变种：
	1. 两端入队、一端出队（如仅允许从队头出队）。
	2. 两端出队、一端入队（如仅允许从队尾入队）。
- 视频考点：选择题常考 “给定入队顺序，判断可能的出队序列”，核心是遵循 “入队端自由，出队端受限” 的规则。

### 4.2 双端队列考点示例（视频考研题思路）

- 题目：元素 A、B、C、D、E 依次入双端队列（两端可入），仅允许从右端出队，判断可能的出队序列。
- 分析：
	- 序列 B、A、C、D、E：A 从左端入，B 从右端入（先出 B）→ 出 A → C、D、E 从右端入（依次出），可行。
	- 序列 E、D、C、B、A：A、B、C、D 从左端入，E 从右端入（先出 E）→ 依次出 D、C、B、A，可行。
- 结论：双端队列的出队序列需结合 “入队端选择” 和 “出队端限制” 判断，本质是 “先进先出” 的变种逻辑。

## 5. 栈与队列结合的考研真题解析（视频重点讲解）

视频中通过多道 408 考研真题强化栈（先进后出 LIFO）与队列（先进先出 FIFO）的核心逻辑，以下为真题完整解析（题干、考点、解题步骤均与视频一致）。

### 5.1 真题 1：2009 年 408 题（队列的实际应用）

#### 题干

为了解决计算机主机与打印机之间速度不匹配的问题，通常设置一个打印数据缓冲区。主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是（ ）
A. 栈 B. 队列 C. 树 D. 图

#### 核心考点

队列 “先进先出（FIFO）” 的特性与实际场景匹配度。

#### 解题步骤

1. 分析场景需求：主机 “依次写入”、打印机 “依次取出”，要求数据的处理顺序与写入顺序完全一致（即 “先写的先打”）。
2. 匹配数据结构特性：
	- 栈（LIFO）：后写入的数据先处理，不符合 “依次打印” 需求；
	- 队列（FIFO）：先写入的数据先处理，完全匹配缓冲区逻辑；
	- 树 / 图：非线性结构，用于多分支数据存储，与 “依次读写” 无关。

#### 答案：B

### 5.2 真题 2：2010 年题（栈容量计算）

#### 题干

设栈 S 和队列 Q 的初始状态均为空，元素 A、B、C、D、E、F、G 依次进入栈 S。若每个元素出栈后立即进入队列 Q，且七个元素出队的顺序是 B、D、C、F、E、A、G，则栈 S 的容量至少是多少（ ）
A. 1 B. 2 C. 3 D. 4

#### 核心考点

栈 “先进后出（LIFO）” 的模拟，计算栈的最大占用空间（容量下限）。

#### 解题步骤（与视频模拟过程一致）

需按 “入栈→出栈→入队” 的顺序模拟，记录栈的最大元素个数：

1. **A 入栈** → 栈：[A]（size=1）；
2. **B 入栈** → 栈：[A,B]（size=2）；
3. **B 出栈** → 入队 Q（Q：[B]），栈：[A]（size=1）；
4. **C 入栈** → 栈：[A,C]（size=2）；
5. **D 入栈** → 栈：[A,C,D]（size=3，此时栈容量达到最大）；
6. **D 出栈** → 入队 Q（Q：[B,D]），栈：[A,C]（size=2）；
7. **C 出栈** → 入队 Q（Q：[B,D,C]），栈：[A]（size=1）；
8. **E 入栈** → 栈：[A,E]（size=2）；
9. **F 入栈** → 栈：[A,E,F]（size=3）；
10. **F 出栈** → 入队 Q（Q：[B,D,C,F]），栈：[A,E]（size=2）；
11. **E 出栈** → 入队 Q（Q：[B,D,C,F,E]），栈：[A]（size=1）；
12. **A 出栈** → 入队 Q（Q：[B,D,C,F,E,A]），栈：[]（size=0）；
13. **G 入栈** → 栈：[G]（size=1）；
14. **G 出栈** → 入队 Q（Q：[B,D,C,F,E,A,G]），栈：[]（size=0）。

过程中栈的最大容量为 3，因此至少需要 3 个空间。

#### 答案：C

### 5.3 真题 3：2010 年题（栈的退栈限制）

#### 题干

若元素 A、B、C、D、E、F 依次进栈，允许进栈、退栈交替进行，但不允许连续三次进行退栈操作，则不可能出现的出栈序列是（ ）
A. D、C、E、B、F、A B. C、B、D、A、E、F C. B、C、A、F、E、D D. B、A、F、E、D、C

#### 核心考点

栈的 LIFO 特性 + 限制条件（不允许连续 3 次退栈）的序列合法性判断。

#### 解题步骤（视频验证逻辑）

逐一验证选项，检查是否存在 “连续 3 次退栈”：

- **选项 A（D,C,E,B,F,A）**：
	入栈 A→B→C→D（栈：[A,B,C,D]）→ 退栈 D（1 次）→ 退栈 C（2 次，未连续 3 次）→ 入栈 E→ 退栈 E（1 次）→ 退栈 B（2 次）→ 入栈 F→ 退栈 F（1 次）→ 退栈 A（2 次）→ 合法。
- **选项 B（C,B,D,A,E,F）**：
	入栈 A→B→C（栈：[A,B,C]）→ 退栈 C（1 次）→ 退栈 B（2 次）→ 入栈 D→ 退栈 D（1 次）→ 退栈 A（2 次）→ 入栈 E→ 退栈 E（1 次）→ 入栈 F→ 退栈 F（1 次）→ 合法。
- **选项 C（B,C,A,F,E,D）**：
	入栈 A→B（栈：[A,B]）→ 退栈 B（1 次）→ 入栈 C→ 退栈 C（1 次）→ 退栈 A（2 次）→ 入栈 F→ 退栈 F（1 次）→ 退栈 E（无 E 入栈，序列本身矛盾？视频修正：应为 “入栈 A→B→退 B→入 C→退 C→退 A→入 D→入 E→入 F→退 F→退 E→退 D”，过程中最多连续 2 次退栈→ 合法）。
- **选项 D（B,A,F,E,D,C）**：
	入栈 A→B（栈：[A,B]）→ 退栈 B（1 次）→ 退栈 A（2 次）→ 入栈 C→D→E→F（栈：[C,D,E,F]）→ 退栈 F（1 次）→ 退栈 E（2 次）→ 退栈 D（3 次，违反 “不允许连续 3 次退栈”）→ 非法。

#### 答案：D

### 5.4 真题 4：2010 年题（双端队列的出队序列）

#### 题干

某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作。若元素 A、B、C、D、E 依次入此队列，然后进行出队操作，则不可能得出的出队序列是（ ）
A. B、A、C、D、E B. D、B、C、A、E C. D、B、A、C、E D. E、D、C、B、A

#### 核心考点

双端队列的特性（两端入队、一端出队），视频约定 “出队端为右端”，需验证入队端选择是否能生成目标序列。

#### 解题步骤（视频模拟逻辑）

设 “右端为唯一出队端”，左端 / 右端均可入队，分析各选项：

- **选项 A（B,A,C,D,E）**：
	A 从左端入→ B 从右端入（右端元素：B）→ 出队 B→ 出队 A→ C 从右端入→ 出队 C→ D 从右端入→ 出队 D→ E 从右端入→ 出队 E→ 可行。
- **选项 B（D,B,C,A,E）**：
	需 D 为第一个出队元素，因此 D 必须最先入队且在右端（出队端）。但元素需 “依次入队”（A→B→C→D→E），D 是第 4 个入队，无法在 A、B、C 之前入队→ 无法生成此序列→ 非法。
- **选项 C（D,B,A,C,E）**：
	A 从左端入→ B 从左端入→ C 从左端入→ D 从右端入（右端元素：D）→ 出队 D→ 出队 B→ 出队 A→ C 从右端入→ 出队 C→ E 从右端入→ 出队 E→ 可行。
- **选项 D（E,D,C,B,A）**：
	A 从左端入→ B 从左端入→ C 从左端入→ D 从左端入→ E 从右端入（右端元素：E）→ 出队 E→ 出队 D→ 出队 C→ 出队 B→ 出队 A→ 可行。

#### 答案：B

### 5.5 真题 5：2011 年题（以 D 开头的出栈序列个数）

#### 题干

元素 A、B、C、D、E 依次进入初始为空的栈中，若元素进栈后可以停留、可以出栈，直到所有元素都出栈，则在所有可能的出栈序列当中，以元素 D 开头的序列个数是多少（ ）
A. 3 B. 4 C. 5 D. 6

#### 核心考点

栈的 LIFO 特性，固定首元素（D）后推导后续序列的合法性。

#### 解题步骤（视频推导逻辑）

要使 D 为第一个出栈元素，必须先将 A、B、C、D 依次入栈（栈：[A,B,C,D]），D 出栈后，栈剩余 [A,B,C]，后续需处理 E 的入栈 / 出栈，以及 A、B、C 的出栈顺序：

1. **情况 1**：D 出栈→ E 入栈→ E 出栈→ C 出栈→ B 出栈→ A 出栈 → 序列：D,E,C,B,A；
2. **情况 2**：D 出栈→ C 出栈→ E 入栈→ E 出栈→ B 出栈→ A 出栈 → 序列：D,C,E,B,A；
3. **情况 3**：D 出栈→ C 出栈→ B 出栈→ E 入栈→ E 出栈→ A 出栈 → 序列：D,C,B,E,A；
4. **情况 4**：D 出栈→ C 出栈→ B 出栈→ A 出栈→ E 入栈→ E 出栈 → 序列：D,C,B,A,E。

共 4 种合法序列。

#### 答案：B

### 5.6 真题 6：2011 年题（循环队列的初始指针）

#### 题干

已知循环队列存储在一维数组 A [0..n-1] 中，且队列非空时，front 和 rear 分别指向队头元素和队尾元素。若初始队列为空，且要求第一个入队的元素在 A [0] 处，则初始时 front 和 rear 的值分别是（ ）
A. 0，0 B. 0，n-1 C. n-1，0 D. n-1，n-1

#### 核心考点

循环队列的指针约定（rear 指向队尾元素时的初始值），视频重点强调的 “指针指向差异对初始值的影响”。

#### 解题步骤（视频关键逻辑）

1. 明确题干约定：
	- 队列非空时，`front`指向队头元素，`rear`指向队尾元素（而非 “队尾下一个位置”）；
	- 第一个入队元素需存于 A [0]。
2. 推导初始值：
	- 初始队列为空，需满足 “入队第一个元素时，直接存于 A [0]，且`rear`指向 A [0]（队尾元素）”；
	- 入队操作逻辑：若初始`rear = n-1`，则入队时先更新`rear = (rear + 1) % n`（此时`rear = 0`），再将元素存入 A [rear]（A [0]），符合要求；
	- 初始`front`需指向队头元素（初始为空，入队后第一个元素为队头，`front = 0`）。
3. 验证：
	- 初始`front=0`，`rear=n-1`→ 入队第一个元素：`rear=(n-1+1)%n=0`→ 存 A [0]→ 队列非空时，`front=0`（队头 A [0]），`rear=0`（队尾 A [0]），完全符合题干要求。

#### 答案：B

### 5.7 真题 7：循环队列的判空判满

#### 题干

循环队列放在一维数组 A [0..m-1] 中，front 指向队头元素，rear 指向队尾元素的后一个位置。假设队列两端均可进行入队和出队操作，队列最多能容纳 m-1 个元素，初始时为空。下列判断对空和对满的条件中，正确的是（ ）
A. 空：front == rear；满：(rear+1)% m == front
B. 空：front == rear；满：(front+1)% m == rear
C. 空：rear == (front+1)% m；满：front == rear
D. 空：front == (rear+1)% m；满：front == rear

#### 核心考点

循环队列的核心判空 / 判满条件（视频反复强调的公式），与指针指向约定强相关。

#### 解题步骤（视频公式应用）

1. 明确题干约定：
	- `rear`指向队尾元素的后一个位置（视频标准约定）；
	- 队列最多容纳`m-1`个元素（预留 1 个空间区分空 / 满）。
2. 判空条件：
	- 初始为空时，`front=rear`；所有元素出队后，`front`与`rear`再次重合→ 空：`front == rear`。
3. 判满条件：
	- 当`rear`的下一个位置（`(rear+1)%m`）等于`front`时，队列已满（避免与空队列的`front==rear`冲突）→ 满：`(rear+1)%m == front`。

#### 答案：A

## 6. 视频核心易错点与总结

### 6.1 循环队列的两大关键约定（视频高频强调）

| 约定类型               | rear 指向            | 初始值（maxSize=n） | 判空条件    | 判满条件            | 入队步骤                       |
| ---------------------- | -------------------- | ------------------- | ----------- | ------------------- | ------------------------------ |
| 约定 1（视频默认）     | 队尾元素的下一个位置 | front=0，rear=0     | front==rear | (rear+1)%n == front | 1. 判满→2. 存元素→3. 更新 rear |
| 约定 2（题干特殊情况） | 队尾元素             | front=0，rear=n-1   | front==rear | (rear+1)%n == front | 1. 判满→2. 更新 rear→3. 存元素 |

- 易错点：**必须先明确题干中 rear 的指向约定，再套用公式**，否则会混淆初始值和操作步骤。

### 6.2 链式队列的核心差异（与顺序队列对比）

| 对比维度   | 顺序队列（循环）         | 链式队列（带头节点）       |
| ---------- | ------------------------ | -------------------------- |
| 存储方式   | 数组（固定 / 动态分配）  | 链表（动态扩容）           |
| 容量限制   | 最多存 maxSize-1 个元素  | 无固定容量（按需扩容）     |
| 判空条件   | front==rear              | front==rear（均指头节点）  |
| 内存效率   | 可能有假溢出（循环解决） | 无内存浪费（节点按需创建） |
| 操作复杂度 | 入队 / 出队 O (1)        | 入队 / 出队 O (1)          |

### 6.3 栈与队列的本质区别（视频反复强调）

| 数据结构      | 核心特性         | 典型应用场景                            |
| ------------- | ---------------- | --------------------------------------- |
| 栈（Stack）   | 先进后出（LIFO） | 函数调用栈、表达式求值、括号匹配        |
| 队列（Queue） | 先进先出（FIFO） | 缓冲区（打印 / 网络）、调度（任务队列） |

- 解题关键：**遇到 “顺序匹配” 场景优先选队列，遇到 “逆序处理” 场景优先选栈**，考研题常围绕此本质设计。

## 7. 循环队列核心计算：元素个数公式（视频高频考点）

### 7.1 元素个数计算公式

已知循环队列的`front`（队头指针，指向队头元素）、`rear`（队尾指针，指向队尾元素的下一个位置）和`maxSize`（最大容量），队列中**实际元素个数**的计算公式为：

cpp







```cpp
int GetCirQueueSize(CirQueue q) {
    // 加maxSize避免rear < front时出现负数，取余确保结果在0~maxSize-1之间
    return (q.rear - q.front + q.maxSize) % q.maxSize;
}
```

### 7.2 公式推导与示例（视频推导逻辑）

- **场景 1：rear > front**（队列未绕圈，元素连续存储）
	例：`maxSize=8`，`front=2`，`rear=5` → 元素个数 = 5-2=3（元素存于下标 2、3、4），公式计算：`(5-2+8)%8=3`，正确。
- **场景 2：rear < front**（队列绕圈，元素分两段存储）
	例：`maxSize=8`，`front=5`，`rear=3` → 元素个数 =（8-5）+3=6（元素存于下标 5、6、7 和 0、1、2），公式计算：`(3-5+8)%8=6`，正确。
- **场景 3：队列空 / 满**
	- 空队列：`front=rear` → 个数 =（rear-front+maxSize）% maxSize=0，正确；
	- 满队列：`(rear+1)%maxSize=front` → 个数 =（rear-front+maxSize）% maxSize=maxSize-1，符合 “满队列存 maxSize-1 个元素” 的约定，正确。

## 8. 经典问题：用栈实现队列 & 用队列实现栈（视频重点讲解）

### 8.1 用两个栈实现队列（LeetCode 232. 真题原型，视频代码一致）

#### 8.1.1 核心原理

- 栈 1（`stackIn`）：负责**入队**（所有元素先压入栈 1，遵循栈的 LIFO）；
- 栈 2（`stackOut`）：负责**出队**（当栈 2 为空时，将栈 1 的所有元素弹出并压入栈 2，此时栈 2 的栈顶即为队列的队头，弹出顺序符合队列的 FIFO）。

#### 8.1.2 C++ 代码实现（与视频完全一致）

cpp







```cpp
#include <stack>
#include <iostream>
using namespace std;

class MyQueue {
private:
    stack<int> stackIn;  // 入队栈
    stack<int> stackOut; // 出队栈

    // 辅助函数：当stackOut为空时，将stackIn的元素全部转移到stackOut
    void transfer() {
        if (stackOut.empty()) {
            while (!stackIn.empty()) {
                stackOut.push(stackIn.top());
                stackIn.pop();
            }
        }
    }

public:
    // 初始化队列
    MyQueue() {}

    // 入队操作（压入stackIn）
    void push(int x) {
        stackIn.push(x);
    }

    // 出队操作（从stackOut弹出，需先转移）
    int pop() {
        transfer(); // 确保stackOut有元素
        int topVal = stackOut.top();
        stackOut.pop();
        return topVal;
    }

    // 获取队头元素（不弹出，需先转移）
    int peek() {
        transfer(); // 确保stackOut有元素
        return stackOut.top();
    }

    // 判断队列是否为空（两个栈均为空则队列空）
    bool empty() {
        return stackIn.empty() && stackOut.empty();
    }
};

// 测试示例（视频测试用例）
int main() {
    MyQueue q;
    q.push(1);  // 队列：[1]
    q.push(2);  // 队列：[1,2]
    cout << q.peek() << endl; // 输出队头1
    cout << q.pop() << endl;  // 出队1，队列：[2]
    cout << q.empty() << endl;// 输出0（非空）
    return 0;
}
```

- 输出结果：

	plaintext

	

	

	

	```plaintext
	1
	1
	0
	```

### 8.2 用两个队列实现栈（LeetCode 225. 真题原型，视频代码一致）

#### 8.2.1 核心原理

- 队列 1（`queue1`）：**存储当前所有元素**；
- 队列 2（`queue2`）：**辅助转移元素**；
- 出栈操作：将队列 1 的`n-1`个元素转移到队列 2，剩余的最后 1 个元素即为 “栈顶”，弹出后交换`queue1`和`queue2`的角色（确保下次操作仍用`queue1`存储元素）。

#### 8.2.2 C++ 代码实现（与视频完全一致）

cpp







```cpp
#include <queue>
#include <iostream>
using namespace std;

class MyStack {
private:
    queue<int> queue1; // 主队列（存储元素）
    queue<int> queue2; // 辅助队列

public:
    // 初始化栈
    MyStack() {}

    // 入栈操作（直接压入主队列queue1）
    void push(int x) {
        queue1.push(x);
    }

    // 出栈操作（转移n-1个元素到queue2，弹出剩余元素）
    int pop() {
        // 步骤1：将queue1的n-1个元素转移到queue2
        int size = queue1.size();
        while (size > 1) {
            queue2.push(queue1.front());
            queue1.pop();
            size--;
        }
        // 步骤2：弹出queue1中剩余的1个元素（栈顶）
        int topVal = queue1.front();
        queue1.pop();
        // 步骤3：交换queue1和queue2，确保下次主队列仍为queue1
        swap(queue1, queue2);
        return topVal;
    }

    // 获取栈顶元素（与pop逻辑类似，转移后不弹出，再恢复队列）
    int top() {
        int size = queue1.size();
        while (size > 1) {
            queue2.push(queue1.front());
            queue1.pop();
            size--;
        }
        int topVal = queue1.front(); // 栈顶元素
        // 恢复队列：将栈顶元素也转移到queue2，再交换
        queue2.push(topVal);
        queue1.pop();
        swap(queue1, queue2);
        return topVal;
    }

    // 判断栈是否为空（主队列queue1为空则栈空）
    bool empty() {
        return queue1.empty();
    }
};

// 测试示例（视频测试用例）
int main() {
    MyStack s;
    s.push(1);  // 栈：[1]
    s.push(2);  // 栈：[1,2]
    cout << s.top() << endl;  // 输出栈顶2
    cout << s.pop() << endl;  // 出栈2，栈：[1]
    cout << s.empty() << endl;// 输出0（非空）
    return 0;
}
```

- 输出结果：

	plaintext

	

	

	

	```plaintext
	2
	2
	0
	```

## 9. 补充考研真题解析（2013-2015 年 408 题，视频覆盖）

### 9.1 真题 8：2013 年题（循环队列元素个数计算）

#### 题干

已知循环队列的存储空间为数组 A [20]，front 指向队头元素的前一个位置，rear 指向队尾元素。若当前 front=15，rear=10，则队列中元素的个数为（ ）
A. 5 B. 6 C. 15 D. 16

#### 解题步骤（视频公式应用）

1. 明确题干约定：

	- 数组容量`maxSize=20`；
	- `front`指向队头元素的**前一个位置**（非标准约定，需调整公式）；
	- `rear`指向队尾元素。

2. 调整元素个数公式：
	标准公式基于 “front 指向队头元素”，本题 front 指向队头前一个位置，因此实际队头元素下标为`(front+1)%maxSize`，元素个数公式调整为：

	plaintext

	

	

	

	```plaintext
	个数 = (rear - (front+1) + maxSize) % maxSize + 1
	```

	（+1 是因为`rear`指向队尾元素，闭区间`[front+1, rear]`的元素个数为`rear - (front+1) + 1`）。

3. 代入计算：
	个数 = (10 - (15+1) + 20) % 20 + 1 = (10-16+20)%20 +1 =14%20 +1=14+1=15？
	（视频修正：更简单的逻辑 ——front=15（队头前一个），队头 = 16；rear=10，元素存储于 16、17、18、19、0、1、2、3、4、5、6、7、8、9、10，共 15 个）。

#### 答案：C

### 9.2 真题 9：2015 年题（链式队列插入操作）

#### 题干

设链式队列的队头指针为 front，队尾指针为 rear，每个节点包含数据域 data 和指针域 next。若要在链式队列中插入一个新节点（由指针 s 指向），则需执行的操作是（ ）
A. front->next = s; front = s;
B. s->next = rear; rear = s;
C. rear->next = s; rear = s;
D. s->next = front; front = s;

#### 解题步骤（视频链式队列入队逻辑）

1. 明确链式队列结构：带头节点，front 指向头节点，rear 指向队尾节点，入队为 “尾插法”。
2. 插入新节点 s 的步骤：
	- 步骤 1：将队尾节点 rear 的 next 指向 s（s 接在队尾后）；
	- 步骤 2：更新 rear 为 s（s 成为新的队尾节点）。
3. 匹配选项：选项 C 完全符合步骤。

#### 答案：C

### 9.3 真题 10：2014 年题（两个栈实现队列的出队顺序）

#### 题干

用两个栈实现一个队列，队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入整数和在队列头部删除整数的功能（若队列中没有元素，deleteHead 操作返回 - 1）。若插入序列为 1、2、3、4、5，删除序列不可能是（ ）
A. 1、2、3、4、5 B. 2、1、4、3、5 C. 3、2、1、4、5 D. 2、3、1、4、5

#### 解题步骤（视频栈转移逻辑）

1. 核心规则：栈 1 入队，栈 2 出队（栈 2 空时转移栈 1 元素）。
2. 验证各选项：
	- **选项 A（1,2,3,4,5）**：每次入栈 1 个就转移出队→ 可行；
	- **选项 B（2,1,4,3,5）**：入 1、2→ 转移出 2、1→ 入 3、4→ 转移出 4、3→ 入 5→ 出 5→ 可行；
	- **选项 C（3,2,1,4,5）**：入 1、2、3→ 转移出 3、2、1→ 入 4、5→ 出 4、5→ 可行；
	- **选项 D（2,3,1,4,5）**：入 1、2→ 转移出 2→ 此时栈 2 空，需转移栈 1 剩余的 1，但选项要出 3→ 3 未入队，无法实现→ 不可行。

#### 答案：D

## 10. 队列的实际应用场景（视频扩展案例）

### 10.1 打印缓冲区（已提及，补充细节）

- **问题**：主机处理速度（MB 级 / 秒）远快于打印机打印速度（KB 级 / 秒），直接传输会导致主机等待。
- **队列作用**：主机将打印数据依次写入队列（缓冲区），打印机从队列头部依次读取打印，主机无需等待，实现 “异步处理”。
- **数据结构选择**：循环队列（固定容量，避免内存溢出；绕圈复用空间，效率高）。

### 10.2 广度优先搜索（BFS）—— 二叉树层序遍历

- **原理**：BFS 需 “按层次访问节点”，队列的 FIFO 特性恰好匹配 “先访问的节点，其孩子节点也先被访问” 的需求。
- **步骤（视频示例：二叉树层序遍历）**：
	1. 初始化队列，将根节点入队；
	2. 队列非空时，出队当前节点并访问；
	3. 若当前节点有左孩子，左孩子入队；
	4. 若当前节点有右孩子，右孩子入队；
	5. 重复步骤 2-4，直至队空。
- **C++ 代码实现（链式队列结合二叉树）**：

cpp







```cpp
#include <iostream>
using namespace std;

// 二叉树节点结构
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 链式队列（复用之前的结构，存储TreeNode*）
struct QNode {
    TreeNode* data;
    QNode* next;
    QNode(TreeNode* x) : data(x), next(nullptr) {}
};

struct LinkQueue {
    QNode* front;
    QNode* rear;
    LinkQueue() {
        front = rear = new QNode(nullptr); // 头节点
    }
};

// 入队、出队、判空函数（适配TreeNode*）
void EnQueue(LinkQueue& q, TreeNode* x) {
    QNode* newNode = new QNode(x);
    q.rear->next = newNode;
    q.rear = newNode;
}

TreeNode* DeQueue(LinkQueue& q) {
    if (q.front == q.rear) return nullptr;
    QNode* delNode = q.front->next;
    TreeNode* val = delNode->data;
    q.front->next = delNode->next;
    if (q.rear == delNode) q.rear = q.front;
    delete delNode;
    return val;
}

bool IsEmpty(LinkQueue q) {
    return q.front == q.rear;
}

// 二叉树层序遍历（基于队列）
void LevelOrderTraversal(TreeNode* root) {
    if (!root) return;
    LinkQueue q;
    EnQueue(q, root); // 根节点入队
    while (!IsEmpty(q)) {
        TreeNode* curr = DeQueue(q); // 出队当前节点
        cout << curr->val << " ";   // 访问节点
        if (curr->left) EnQueue(q, curr->left); // 左孩子入队
        if (curr->right) EnQueue(q, curr->right); // 右孩子入队
    }
}

// 测试：构建二叉树并遍历
int main() {
    // 构建二叉树：
    //     1
    //    / \
    //   2   3
    //  / \
    // 4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    cout << "层序遍历结果：";
    LevelOrderTraversal(root); // 输出：1 2 3 4 5
    return 0;
}
```

## 11. 视频强调的常见错误与调试技巧

### 11.1 循环队列常见错误

| 错误类型            | 错误原因                                    | 调试技巧                                                     |
| ------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| 判满 / 判空条件混淆 | 未明确 rear 指向约定，误用`front==rear`为满 | 先在代码注释中注明`rear`指向（如 “rear 指向队尾下一个位置”），再套用公式 |
| 元素个数计算为负    | 未加`maxSize`直接计算`rear-front`           | 强制使用公式`(rear-front+maxSize)%maxSize`，避免负数         |
| 动态内存泄漏        | 忘记`delete[] data`释放数组                 | 在`Destroy`函数中统一释放，测试时用内存检测工具（如 Valgrind） |
| 数组越界            | 入队前未判满，直接赋值`data[rear]`          | 所有入队操作前必须调用`IsCirQueueFull`，返回 true 则拒绝入队 |

### 11.2 链式队列常见错误

| 错误类型                 | 错误原因                               | 调试技巧                                                     |
| ------------------------ | -------------------------------------- | ------------------------------------------------------------ |
| 野指针（访问已删除节点） | 删除节点后未置空指针，或`rear`未更新   | 删除节点后立即`delNode=nullptr`；删除队尾节点时强制`rear=front` |
| 内存泄漏                 | 只删除节点数据，未释放节点本身         | 每个`new QNode`对应一个`delete`，在`Destroy`中遍历释放所有节点 |
| 头节点遗漏               | 初始化时未创建头节点，直接操作数据节点 | 严格遵循 “带头节点” 结构，初始化时先创建空的头节点           |

## 12. 视频知识点总览（核心回顾）

1. **队列本质**：先进先出（FIFO），仅允许队头出、队尾入；
2. **核心实现**：
	- 循环队列：解决普通队列假溢出，关键是`(rear+1)%maxSize==front`判满；
	- 链式队列：动态扩容，关键是尾插法和头节点处理；
3. **经典问题**：两个栈实现队列（栈 1 入、栈 2 出），两个队列实现栈（转移 n-1 个元素）；
4. **考研重点**：指针约定（rear 指向）、元素个数计算、序列合法性判断、BFS 应用；
5. **避坑关键**：明确指针指向约定，操作前判空 / 判满，动态内存及时释放。

## 13. 循环队列的静态实现（视频基础补充）

之前重点讲解了**动态内存分配的循环队列**，视频中也提及 “静态数组实现”（适合固定容量场景，入门更易理解），以下为完整实现（与视频代码逻辑完全一致）。

### 13.1 静态循环队列的结构体定义

cpp







```cpp
#include <iostream>
using namespace std;

// 静态循环队列：数组大小通过宏定义固定（视频约定maxSize=8）
#define MAX_SIZE 8
struct StaticCirQueue {
    int data[MAX_SIZE];  // 静态数组（固定容量）
    int front;           // 队头指针（指向队头元素）
    int rear;            // 队尾指针（指向队尾元素的下一个位置）
};
```

### 13.2 静态循环队列核心操作代码

#### 13.2.1 初始化队列

cpp







```cpp
void InitStaticCirQueue(StaticCirQueue& q) {
    q.front = 0;  // 初始状态：front=rear=0（与动态队列一致）
    q.rear = 0;
    // 可选：静态数组初始化（避免脏数据，视频建议初学者添加）
    for (int i = 0; i < MAX_SIZE; i++) {
        q.data[i] = 0;
    }
}
```

#### 13.2.2 判空、判满、入队、出队（与动态队列逻辑一致）

cpp







```cpp
// 判空
bool IsStaticCirQueueEmpty(StaticCirQueue q) {
    return q.front == q.rear;
}

// 判满（公式不变：(rear+1)%MAX_SIZE == front）
bool IsStaticCirQueueFull(StaticCirQueue q) {
    return (q.rear + 1) % MAX_SIZE == q.front;
}

// 入队
bool EnStaticCirQueue(StaticCirQueue& q, int elem) {
    if (IsStaticCirQueueFull(q)) {
        cout << "静态队列已满，无法入队！" << endl;
        return false;
    }
    q.data[q.rear] = elem;
    q.rear = (q.rear + 1) % MAX_SIZE;  // 绕圈更新
    return true;
}

// 出队
bool DeStaticCirQueue(StaticCirQueue& q, int& elem) {
    if (IsStaticCirQueueEmpty(q)) {
        cout << "静态队列为空，无法出队！" << endl;
        return false;
    }
    elem = q.data[q.front];
    q.front = (q.front + 1) % MAX_SIZE;  // 绕圈更新
    return true;
}
```

#### 13.2.3 测试示例（视频基础用例）

cpp







```cpp
int main() {
    StaticCirQueue q;
    InitStaticCirQueue(q);

    // 入队6个元素（MAX_SIZE=8，最多存7个，此处留1个空闲）
    EnStaticCirQueue(q, 10);
    EnStaticCirQueue(q, 20);
    EnStaticCirQueue(q, 30);
    EnStaticCirQueue(q, 40);
    EnStaticCirQueue(q, 50);
    EnStaticCirQueue(q, 60);

    // 出队3个元素
    int elem;
    DeStaticCirQueue(q, elem);
    cout << "出队元素：" << elem << endl;  // 10
    DeStaticCirQueue(q, elem);
    cout << "出队元素：" << elem << endl;  // 20
    DeStaticCirQueue(q, elem);
    cout << "出队元素：" << elem << endl;  // 30

    // 再次入队2个元素（复用队头空闲空间）
    EnStaticCirQueue(q, 70);
    EnStaticCirQueue(q, 80);

    // 遍历队列（视频推荐的遍历方式）
    cout << "队列当前元素：";
    int size = (q.rear - q.front + MAX_SIZE) % MAX_SIZE;  // 元素个数
    int curr = q.front;
    for (int i = 0; i < size; i++) {
        cout << q.data[curr] << " ";
        curr = (curr + 1) % MAX_SIZE;
    }
    // 输出：40 50 60 70 80
    return 0;
}
```

### 13.3 静态 vs 动态循环队列对比（视频总结）

| 对比维度   | 静态循环队列                 | 动态循环队列                |
| ---------- | ---------------------------- | --------------------------- |
| 容量特性   | 固定（编译期通过宏定义确定） | 灵活（运行期指定 maxSize）  |
| 内存分配   | 栈内存（数组在栈上）         | 堆内存（new 分配在堆上）    |
| 内存释放   | 自动释放（栈内存出作用域）   | 手动释放（需调用 Destroy）  |
| 适用场景   | 容量已知、需求简单的场景     | 容量不确定、需动态调整场景  |
| 代码复杂度 | 低（无需处理内存分配失败）   | 稍高（需判断 new 是否成功） |

## 14. 链式队列的无表头节点实现（视频对比补充）

视频中主推 “带头节点的链式队列”（简化操作），但也提及 “无表头节点” 的实现（需特殊处理空队列），以下为完整代码（与视频逻辑一致），用于对比理解。

### 14.1 无表头链式队列的结构体定义

cpp







```cpp
#include <iostream>
using namespace std;

// 节点结构（与带头节点一致）
struct QNode {
    int data;
    QNode* next;
    QNode(int x) : data(x), next(nullptr) {}
};

// 无表头队列结构：front直接指向队头元素（空队列时front=rear=nullptr）
struct LinkQueueNoHead {
    QNode* front;  // 队头指针（指向第一个元素节点）
    QNode* rear;   // 队尾指针（指向最后一个元素节点）
};
```

### 14.2 核心操作代码（关键差异在初始化、入队、出队）

#### 14.2.1 初始化队列（空队列时 front=rear=nullptr）

cpp







```cpp
void InitLinkQueueNoHead(LinkQueueNoHead& q) {
    q.front = nullptr;
    q.rear = nullptr;
}
```

#### 14.2.2 判空（直接判断 front 是否为 nullptr）

cpp







```cpp
bool IsLinkQueueNoHeadEmpty(LinkQueueNoHead q) {
    return q.front == nullptr;  // 无表头时，front=nullptr即空
}
```

#### 14.2.3 入队操作（需区分 “空队列” 和 “非空队列”）

cpp







```cpp
bool EnLinkQueueNoHead(LinkQueueNoHead& q, int elem) {
    QNode* newNode = new QNode(elem);
    if (newNode == nullptr) {  // 内存分配失败（视频提醒需判断）
        cout << "内存分配失败，入队失败！" << endl;
        return false;
    }

    if (IsLinkQueueNoHeadEmpty(q)) {
        // 空队列：front和rear均指向新节点
        q.front = newNode;
        q.rear = newNode;
    } else {
        // 非空队列：新节点接在rear后，更新rear
        q.rear->next = newNode;
        q.rear = newNode;
    }
    return true;
}
```

#### 14.2.4 出队操作（需区分 “仅一个元素” 和 “多个元素”）

cpp







```cpp
bool DeLinkQueueNoHead(LinkQueueNoHead& q, int& elem) {
    if (IsLinkQueueNoHeadEmpty(q)) {
        cout << "无表头队列为空，无法出队！" << endl;
        return false;
    }

    QNode* delNode = q.front;  // 待删除节点（队头）
    elem = delNode->data;

    if (q.front == q.rear) {
        // 仅一个元素：删除后队列空，front和rear置nullptr
        q.front = nullptr;
        q.rear = nullptr;
    } else {
        // 多个元素：front指向后一个节点
        q.front = q.front->next;
    }

    delete delNode;
    delNode = nullptr;
    return true;
}
```

#### 14.2.5 测试示例

cpp







```cpp
int main() {
    LinkQueueNoHead q;
    InitLinkQueueNoHead(q);

    // 入队4个元素
    EnLinkQueueNoHead(q, 100);
    EnLinkQueueNoHead(q, 200);
    EnLinkQueueNoHead(q, 300);
    EnLinkQueueNoHead(q, 400);

    // 出队2个元素
    int elem;
    DeLinkQueueNoHead(q, elem);
    cout << "出队元素：" << elem << endl;  // 100
    DeLinkQueueNoHead(q, elem);
    cout << "出队元素：" << elem << endl;  // 200

    // 遍历队列
    cout << "队列当前元素：";
    QNode* curr = q.front;
    while (curr != nullptr) {
        cout << curr->data << " ";
        curr = curr->next;
    }
    // 输出：300 400

    return 0;
}
```

### 14.3 有表头 vs 无表头链式队列对比（视频重点）

| 对比维度   | 有表头节点链式队列             | 无表头节点链式队列                      |
| ---------- | ------------------------------ | --------------------------------------- |
| 空队列状态 | front=rear = 头节点（非 null） | front=rear=nullptr                      |
| 入队操作   | 无需区分空 / 非空（统一尾插）  | 需区分空队列（front/rear 均指向新节点） |
| 出队操作   | 无需区分 1 个 / 多个元素       | 需区分 1 个元素（删除后置 null）        |
| 代码复杂度 | 低（逻辑统一）                 | 稍高（需处理特殊情况）                  |
| 内存开销   | 多一个头节点（可忽略）         | 无额外开销                              |
| 视频推荐   | 优先选择（适合教学和工程）     | 仅在内存极端紧张时使用                  |

## 15. 队列的经典应用：生产者 - 消费者模型（视频场景拓展）

视频中提到 “队列是生产者 - 消费者模型的核心组件”，用于解决 “生产者（生成数据）” 与 “消费者（处理数据）” 的速度不匹配问题，以下为**基础模拟实现**（非多线程，视频入门级案例）。

### 15.1 模型原理（视频图解逻辑）

- **生产者**：不断生成数据，将数据入队（若队列满则等待）；
- **消费者**：不断从队列取数据处理（若队列空则等待）；
- **队列**：作为缓冲区，平衡生产者和消费者的速度差异。

### 15.2 基于循环队列的模拟代码（视频实现）

cpp







```cpp
#include <iostream>
#include <string>
using namespace std;

// 循环队列（复用动态循环队列结构）
struct CirQueue {
    int* data;
    int front;
    int rear;
    int maxSize;
};

// 队列基础操作（复用之前的函数）
void InitCirQueue(CirQueue& q, int maxS) {
    q.maxSize = maxS;
    q.data = new int[q.maxSize];
    q.front = q.rear = 0;
}

bool IsFull(CirQueue q) { return (q.rear + 1) % q.maxSize == q.front; }
bool IsEmpty(CirQueue q) { return q.front == q.rear; }

// 生产者：生成数据（1~100的随机数），入队
void Producer(CirQueue& q, int& count) {
    if (IsFull(q)) {
        cout << "[生产者] 队列满，等待消费者处理..." << endl;
        return;
    }
    int data = rand() % 100 + 1;  // 生成1~100的随机数
    q.data[q.rear] = data;
    q.rear = (q.rear + 1) % q.maxSize;
    count++;
    cout << "[生产者] 生成数据：" << data << "，累计生成：" << count << "个" << endl;
}

// 消费者：从队列取数据，模拟处理（输出即可）
void Consumer(CirQueue& q, int& count) {
    if (IsEmpty(q)) {
        cout << "[消费者] 队列空，等待生产者生成..." << endl;
        return;
    }
    int data = q.data[q.front];
    q.front = (q.front + 1) % q.maxSize;
    count++;
    cout << "[消费者] 处理数据：" << data << "，累计处理：" << count << "个" << endl;
}

// 模拟主函数（视频测试逻辑：生产者生成5次，消费者处理3次，再生成2次，再处理4次）
int main() {
    srand((unsigned int)time(nullptr));  // 随机数种子
    CirQueue q;
    InitCirQueue(q, 5);  // 缓冲区容量5

    int prodCount = 0;  // 生产者累计生成数
    int consCount = 0;  // 消费者累计处理数

    // 第一阶段：生产者生成5次
    cout << "=== 第一阶段：生产者生成5次 ===" << endl;
    for (int i = 0; i < 5; i++) {
        Producer(q, prodCount);
    }

    // 第二阶段：消费者处理3次
    cout << "\n=== 第二阶段：消费者处理3次 ===" << endl;
    for (int i = 0; i < 3; i++) {
        Consumer(q, consCount);
    }

    // 第三阶段：生产者再生成2次
    cout << "\n=== 第三阶段：生产者再生成2次 ===" << endl;
    for (int i = 0; i < 2; i++) {
        Producer(q, prodCount);
    }

    // 第四阶段：消费者再处理4次
    cout << "\n=== 第四阶段：消费者再处理4次 ===" << endl;
    for (int i = 0; i < 4; i++) {
        Consumer(q, consCount);
    }

    delete[] q.data;
    return 0;
}
```

#### 输出示例（视频预期结果）

plaintext







```plaintext
=== 第一阶段：生产者生成5次 ===
[生产者] 生成数据：43，累计生成：1个
[生产者] 生成数据：78，累计生成：2个
[生产者] 生成数据：22，累计生成：3个
[生产者] 生成数据：95，累计生成：4个
[生产者] 队列满，等待消费者处理...  // 第5次生成时队列满（容量5，最多存4个）

=== 第二阶段：消费者处理3次 ===
[消费者] 处理数据：43，累计处理：1个
[消费者] 处理数据：78，累计处理：2个
[消费者] 处理数据：22，累计处理：3个

=== 第三阶段：生产者再生成2次 ===
[生产者] 生成数据：15，累计生成：5个
[生产者] 生成数据：67，累计生成：6个

=== 第四阶段：消费者再处理4次 ===
[消费者] 处理数据：95，累计处理：4个
[消费者] 处理数据：15，累计处理：5个
[消费者] 处理数据：67，累计处理：6个
[消费者] 队列空，等待生产者生成...  // 第4次处理时队列空
```

## 16. 补充考研真题解析（2016-2020 年 408 题，视频覆盖）

### 16.1 真题 11：2016 年题（循环队列判满）

#### 题干

设有循环队列 Q [0..m-1]，初始状态为 front=rear=0，队列中元素个数的计算公式为（ ）
A. (rear - front + m) % m
B. rear - front + 1
C. rear - front - 1
D. rear - front

#### 解题步骤（视频公式回顾）

1. 明确题干约定：`front`和`rear`的初始值为 0，未明确`rear`指向，但选项中 A 为标准公式。
2. 分析选项：
	- B/C/D 未考虑 “rear < front” 的绕圈情况（会出现负数或计算错误）；
	- A 公式`(rear - front + m) % m`：无论 rear>front 还是 rear<front，均能正确计算元素个数（如 m=5，front=3，rear=1：(1-3+5)%5=3，正确）。

#### 答案：A

### 16.2 真题 12：2018 年题（链式队列操作）

#### 题干

若链式队列的队头指针为 front，队尾指针为 rear，每个节点包含数据域 data 和指针域 next，当执行入队操作时，正确的流程是（ ）
A. 新节点 s 的 next 域赋值为 nullptr；rear 的 next 域赋值为 s；rear 赋值为 s
B. 新节点 s 的 next 域赋值为 front；front 赋值为 s
C. 新节点 s 的 next 域赋值为 rear；rear 赋值为 s
D. 新节点 s 的 next 域赋值为 front 的 next；front 的 next 赋值为 s

#### 解题步骤（视频链式队列入队逻辑）

1. 题干未明确是否带头节点，但选项 A 符合 “带头节点 / 无表头节点” 的通用入队核心：
	- 新节点 s 的 next 置 nullptr（队尾节点 next 必为 null）；
	- 将 s 接在 rear 后（rear->next = s）；
	- 更新 rear 为 s（s 成为新队尾）。
2. 排除其他选项：
	- B/C：新节点 next 指向错误（front/rear，非队尾）；
	- D：是 “链式栈入栈” 或 “队列头插” 逻辑，不符合队列 FIFO。

#### 答案：A

### 16.3 真题 13：2020 年题（用队列实现栈的复杂度）

#### 题干

用两个队列实现一个栈，栈的 push 和 pop 操作的时间复杂度分别为（ ）
A. O(1)，O(1)
B. O(1)，O(n)
C. O(n)，O(1)
D. O(n)，O(n)

#### 解题步骤（视频复杂度分析）

1. push 操作：直接将元素入队到主队列（queue1），仅需 1 次操作→ 时间复杂度 O (1)。
2. pop 操作：需将主队列的 n-1 个元素转移到辅助队列（queue2），再弹出剩余 1 个元素→ 转移操作需 n-1 次→ 时间复杂度 O (n)。

#### 答案：B

## 17. 队列存储方式的选择依据（视频最终总结）

在实际应用中，选择**循环队列（顺序存储）** 还是**链式队列（链式存储）**，需结合以下 4 个核心因素（视频重点强调）：

| 选择因素   | 优先选循环队列（顺序）                | 优先选链式队列（链式）                            |
| ---------- | ------------------------------------- | ------------------------------------------------- |
| 容量需求   | 容量已知且固定                        | 容量未知或需动态扩容                              |
| 内存效率   | 内存利用率高（无指针开销）            | 内存利用率低（每个节点含指针域）                  |
| 操作效率   | 入队 / 出队均为 O (1)，无内存分配开销 | 入队 / 出队均为 O (1)，但需动态分配节点（有开销） |
| 实现复杂度 | 需处理判满 / 判空公式，静态实现简单   | 需处理指针和内存释放，带头节点实现简单            |
| 典型场景   | 打印缓冲区、固定大小的任务队列        | 不限容量的消息队列、日志存储                      |

## 18. 视频核心知识点最终回顾

1. **队列本质**：先进先出（FIFO），仅允许队头出、队尾入，核心是 “顺序匹配”。
2. **循环队列关键**：
	- 判满公式：`(rear+1)%maxSize == front`（预留 1 个空闲空间）；
	- 元素个数：`(rear-front+maxSize)%maxSize`；
	- 静态 / 动态实现的差异：容量是否固定、内存分配位置。
3. **链式队列关键**：
	- 带头节点更简单（无需处理空队列特殊情况）；
	- 核心操作：尾插入队、头删除队，需避免野指针和内存泄漏。
4. **经典问题**：
	- 两个栈实现队列：栈 1 入、栈 2 出（栈 2 空时转移）；
	- 两个队列实现栈：转移 n-1 个元素到辅助队列。
5. **应用场景**：打印缓冲区、BFS 遍历、生产者 - 消费者模型。
6. **考研重点**：指针指向约定、公式计算、序列合法性判断、复杂度分析。



# 表达式求值与枚举知识点总结（逊哥带你学计算机）

## 一、枚举（Enum）：自定义复合数据类型

视频中明确枚举是 C/C++ 中的**复合数据类型**，核心作用是 “将变量的取值范围一一列举”，适用于表示固定集合（如星期、运算符类型等）。

### 1. 枚举的核心特性

- **取值限制**：枚举变量只能赋值为枚举中定义的 “枚举元素”（如星期只能是 MONDAY~SUNDAY）。
- **默认值规则**：枚举元素的默认数值从`0`开始递增（如第一个元素 0，第二个 1，以此类推）。
- **自定义初始值**：可手动指定某个枚举元素的数值，后续元素从该值递增（如`MONDAY=1`，则 TUESDAY=2）。
- **typedef 简化声明**：枚举变量默认需加`enum`关键字声明（如`enum weekday a`），用`typedef`可省略`enum`（如`typedef enum {…} weekday;`，后续直接`weekday a`）。

### 2. 枚举示例代码（与视频一致）

视频中以 “星期” 和 “布尔类型” 为例，代码如下：

cpp







```cpp
#include <cstdio>

// 示例1：定义“星期”枚举，自定义初始值（MONDAY=1）
typedef enum {
    MONDAY = 1,  // 手动指定为1，后续元素递增
    TUESDAY,     // 自动为2
    WEDNESDAY,   // 3
    THURSDAY,    // 4
    FRIDAY,      // 5
    SATURDAY,    // 6
    SUNDAY       // 7
} weekday;

// 示例2：定义“布尔”枚举（模拟true/false）
typedef enum {
    FALSE,  // 默认0
    TRUE    // 默认1
} my_bool;

int main() {
    // 声明枚举变量（无需加enum，因用了typedef）
    weekday a = MONDAY;
    weekday b = TUESDAY;
    my_bool flag = TRUE;

    // 输出枚举元素的数值（%d格式）
    printf("a(MONDAY) = %d\n", a);    // 输出1
    printf("b(TUESDAY) = %d\n", b);  // 输出2
    printf("flag(TRUE) = %d\n", flag);// 输出1

    return 0;
}
```

**运行结果**（与视频一致）：

plaintext







```plaintext
a(MONDAY) = 1
b(TUESDAY) = 2
flag(TRUE) = 1
```

## 二、后缀表达式求值（栈的核心应用）

视频中明确：**后缀表达式（逆波兰表达式）是计算机可直接计算的表达式**，需借助 “栈” 实现求值，核心逻辑围绕 “数字压栈、运算符弹栈计算”。

### 1. 后缀表达式求值核心逻辑

1. **初始化栈**：用于存储操作数（int 类型）。
2. **扫描后缀表达式字符串**：
	- 若遇到**数字（操作数）**：将其转换为 int 类型后压入栈。
	- 若遇到**运算符（+、-、\*、/）**：
		1. 弹出栈顶元素作为`op2`（注意：先弹的是右操作数）；
		2. 弹出栈顶元素作为`op1`（后弹的是左操作数）；
		3. 计算`op1 运算符 op2`（如`op1 + op2`）；
		4. 将计算结果压入栈。
3. **结束扫描**：栈中剩余的唯一元素即为表达式的结果。

### 2. 关键前提：栈的实现（顺序栈，动态内存）

视频中使用 “动态数组” 实现栈，支持初始化、入栈、出栈、判空操作，代码如下：

cpp







```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

// 栈的结构体定义（顺序栈）
typedef struct {
    int* base;    // 栈底指针（动态数组）
    int* top;     // 栈顶指针
    int stackSize;// 栈的最大容量
} Stack;

// 1. 初始化栈（初始容量设为10）
void InitStack(Stack& S) {
    S.base = (int*)malloc(10 * sizeof(int));
    if (!S.base) exit(1);  // 内存分配失败
    S.top = S.base;
    S.stackSize = 10;
}

// 2. 判断栈是否为空
bool StackEmpty(Stack S) {
    return S.top == S.base;
}

// 3. 入栈（压栈）
void Push(Stack& S, int e) {
    // 栈满时扩容（加倍容量）
    if (S.top - S.base >= S.stackSize) {
        S.base = (int*)realloc(S.base, (S.stackSize + 10) * sizeof(int));
        if (!S.base) exit(1);
        S.top = S.base + S.stackSize;
        S.stackSize += 10;
    }
    *(S.top++) = e;  // 元素入栈，栈顶指针上移
}

// 4. 出栈（弹栈）：将栈顶元素存入e，返回是否成功
bool Pop(Stack& S, int& e) {
    if (StackEmpty(S)) return false;  // 栈空，出栈失败
    e = *(--S.top);  // 栈顶指针下移，取元素
    return true;
}

// 5. 获取栈顶元素
bool GetTop(Stack S, int& e) {
    if (StackEmpty(S)) return false;
    e = *(S.top - 1);
    return true;
}

// 6. 销毁栈（释放内存）
void DestroyStack(Stack& S) {
    free(S.base);
    S.base = S.top = NULL;
    S.stackSize = 0;
}
```

### 3. 后缀表达式求值完整代码（与视频一致）

视频中示例后缀表达式为 `"82/2+56*-"`（结果为`-24`），代码需先通过`get_token`函数识别字符类型，再通过`evil`函数求值：

#### 3.1 枚举：定义字符类型（content_type）

用于标记扫描到的字符是 “数字”“运算符” 还是 “结束符”：

cpp







```cpp
// 枚举：标记扫描到的字符类型（与视频一致）
typedef enum {
    LEFT_PAIR,   // 左括号 (
    RIGHT_PAIR,  // 右括号 )
    ADD,         // +
    SUB,         // -
    MUL,         // *
    DIV,         // /
    MOD,         // %（视频提及，未用）
    EOS,         // 结束符 \0
    NUM          // 数字
} content_type;

// 全局变量：存储后缀表达式（视频中为全局，方便多函数访问）
char expr[] = "82/2+56*-";
```

#### 3.2 get_token 函数：扫描字符并识别类型

功能：从`expr`中读取当前字符，判断其类型（如数字返回 NUM，除号返回 DIV），并更新扫描索引：

cpp







```cpp
// 参数：
// - symbol：存储当前扫描到的字符
// - index：扫描索引（传引用，更新下一次扫描位置）
// 返回：字符类型（content_type）
content_type get_token(char& symbol, int& index) {
    // 读取当前索引的字符
    symbol = expr[index];
    // 更新索引（下一次从下一个位置扫描）
    index++;

    // 判断字符类型
    switch (symbol) {
        case '(': return LEFT_PAIR;
        case ')': return RIGHT_PAIR;
        case '+': return ADD;
        case '-': return SUB;
        case '*': return MUL;
        case '/': return DIV;
        case '%': return MOD;
        case '\0': return EOS;
        // 数字（0-9）
        default: 
            if (symbol >= '0' && symbol <= '9') {
                return NUM;
            }
    }
    return EOS;  // 异常情况（视频未处理，默认返回结束符）
}
```

#### 3.3 evil 函数：核心求值逻辑

实现后缀表达式求值，调用栈操作和`get_token`：

cpp







```cpp
// 参数：栈S（用于存储操作数）
void evil(Stack& S) {
    char symbol;          // 当前扫描到的字符
    int op1, op2, result; // 操作数1、操作数2、计算结果
    int index = 0;        // 扫描索引（从0开始）
    content_type token;   // 当前字符类型

    // 循环扫描，直到遇到结束符EOS
    while (true) {
        // 1. 获取当前字符类型
        token = get_token(symbol, index);
        if (token == EOS) break;  // 结束符，退出循环

        // 2. 处理数字：压入栈
        if (token == NUM) {
            // 字符转数字（如'8' - '0' = 8）
            int num = symbol - '0';
            Push(S, num);
        }
        // 3. 处理运算符：弹栈计算，结果压栈
        else {
            // 弹出两个操作数（注意顺序：先弹op2，后弹op1）
            if (!Pop(S, op2)) { printf("表达式错误（op2不足）\n"); return; }
            if (!Pop(S, op1)) { printf("表达式错误（op1不足）\n"); return; }

            // 根据运算符计算
            switch (token) {
                case ADD: result = op1 + op2; break;
                case SUB: result = op1 - op2; break;
                case MUL: result = op1 * op2; break;
                case DIV: 
                    if (op2 == 0) { printf("除零错误\n"); return; }
                    result = op1 / op2;  // 整数除法（视频默认）
                    break;
                default: printf("未知运算符\n"); return;
            }

            // 计算结果压入栈
            Push(S, result);
        }
    }

    // 4. 最终栈顶元素即为结果
    if (GetTop(S, result)) {
        printf("后缀表达式 \"%s\" 的结果：%d\n", expr, result);
    } else {
        printf("表达式错误（无结果）\n");
    }
}
```

#### 3.4 main 函数：入口逻辑

初始化栈、调用求值函数、销毁栈：

cpp







```cpp
int main() {
    Stack S;
    InitStack(S);  // 初始化栈

    evil(S);       // 后缀表达式求值

    DestroyStack(S);// 销毁栈
    return 0;
}
```

**运行结果**（与视频一致）：

plaintext







```plaintext
后缀表达式 "82/2+56*-" 的结果：-24
```

## 三、中缀表达式转后缀表达式

视频中明确：中缀表达式（如`X/(I-J)*Y`）需转换为后缀表达式（如`XIJ-/Y*`）才能让计算机计算，核心难点是**运算符优先级处理**和**括号处理**。

### 1. 转换核心规则（与视频完全一致）

1. **初始化栈**：栈底需存入 “优先级最低” 的元素（如数值 0），用于避免栈空判断；栈中仅存储运算符和左括号。
2. **扫描中缀表达式**：
	- 若遇到**操作数（如 X、I、J、Y）**：直接输出（后缀表达式的操作数顺序与中缀一致）。
	- 若遇到**左括号 (**：
		- 站外优先级最高（如 15），直接压栈；
		- 站内优先级最低（如 0），确保后续运算符能压栈。
	- 若遇到**右括号 )**：
		- 弹出栈中运算符并输出，直到遇到左括号；
		- 左括号弹出后**不输出**（丢弃左括号）。
	- 若遇到**运算符（+、-、\*、/）**：
		- 比较当前运算符与**栈顶元素**的优先级：
			- 若当前优先级 **>** 栈顶优先级：直接压栈；
			- 若当前优先级 **≤** 栈顶优先级：弹出栈顶运算符并输出，重复比较直到满足 “当前优先级> 栈顶”，再压入当前运算符。
3. **扫描结束**：弹出栈中剩余的所有运算符并输出（不包括栈底的最低优先级元素）。

### 2. 运算符优先级表（视频参考 C 语言手册）

| 符号     | 站外优先级 | 站内优先级 | 说明                   |
| -------- | ---------- | ---------- | ---------------------- |
| 栈底元素 | 0          | 0          | 优先级最低（如默认 0） |
| 左括号 ( | 15         | 0          | 站外最高，站内最低     |
| 乘号 * / | 13         | 13         | 优先级高于加减         |
| 加号 + - | 12         | 12         | 优先级低于乘除         |
| 右括号 ) | -          | -          | 仅触发弹出，无优先级   |

### 3. 转换完整代码（与视频一致）

视频中示例中缀表达式为 `"X/(I-J)*Y"`，转换后后缀表达式为 `"XIJ-/Y*"`，代码如下：

#### 3.1 补充优先级判断函数

cpp







```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

// 复用之前的栈结构体（存储运算符，元素类型改为char）
typedef struct {
    char* base;    // 栈底指针（存储运算符：+、-、*、/、(）
    char* top;     // 栈顶指针
    int stackSize;// 栈最大容量
} OpStack;

// 初始化运算符栈（栈底存入'#'，标记优先级最低元素）
void InitOpStack(OpStack& S) {
    S.base = (char*)malloc(10 * sizeof(char));
    if (!S.base) exit(1);
    S.top = S.base;
    S.stackSize = 10;
    *(S.top++) = '#';  // 栈底元素：优先级最低（对应数值0）
}

// 入栈（运算符）
void OpPush(OpStack& S, char op) {
    if (S.top - S.base >= S.stackSize) {
        S.base = (char*)realloc(S.base, (S.stackSize + 10) * sizeof(char));
        if (!S.base) exit(1);
        S.top = S.base + S.stackSize;
        S.stackSize += 10;
    }
    *(S.top++) = op;
}

// 出栈（运算符）
bool OpPop(OpStack& S, char& op) {
    if (S.top == S.base) return false;
    op = *(--S.top);
    return true;
}

// 获取栈顶运算符
bool GetOpTop(OpStack S, char& op) {
    if (S.top == S.base) return false;
    op = *(S.top - 1);
    return true;
}

// 销毁运算符栈
void DestroyOpStack(OpStack& S) {
    free(S.base);
    S.base = S.top = NULL;
    S.stackSize = 0;
}

// 核心：获取运算符的优先级（参考视频优先级表）
int GetPriority(char op, bool isInStack) {
    switch (op) {
        case '#': return 0;          // 栈底元素：优先级0
        case '(': 
            return isInStack ? 0 : 15; // 左括号：站外15，站内0
        case '*': 
        case '/': return 13;         // 乘除：优先级13
        case '+': 
        case '-': return 12;         // 加减：优先级12
        default: return -1;          // 无效运算符
    }
}
```

#### 3.2 中缀转后缀核心函数

cpp







```cpp
// 参数：
// - infix：中缀表达式字符串
// - postfix：输出后缀表达式的缓冲区
void InfixToPostfix(const char* infix, char* postfix) {
    OpStack S;
    InitOpStack(S);  // 初始化运算符栈（栈底有#）

    int postIdx = 0; // 后缀表达式的索引
    int len = strlen(infix);

    // 遍历中缀表达式
    for (int i = 0; i < len; i++) {
        char c = infix[i];

        // 1. 处理操作数（字母：如X、I、J、Y）
        if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
            postfix[postIdx++] = c;  // 直接输出到后缀表达式
        }
        // 2. 处理左括号 (
        else if (c == '(') {
            OpPush(S, c);  // 直接压栈
        }
        // 3. 处理右括号 )
        else if (c == ')') {
            char topOp;
            // 弹出运算符并输出，直到遇到左括号
            while (GetOpTop(S, topOp) && topOp != '(') {
                OpPop(S, topOp);
                postfix[postIdx++] = topOp;
            }
            // 弹出左括号（不输出）
            OpPop(S, topOp);
        }
        // 4. 处理运算符（+、-、*、/）
        else if (c == '+' || c == '-' || c == '*' || c == '/') {
            char topOp;
            // 比较当前运算符与栈顶运算符的优先级
            while (GetOpTop(S, topOp)) {
                // 获取栈顶运算符的优先级（站内）
                int topPri = GetPriority(topOp, true);
                // 获取当前运算符的优先级（站外）
                int currPri = GetPriority(c, false);

                // 若当前优先级 ≤ 栈顶优先级：弹出栈顶并输出
                if (currPri <= topPri) {
                    OpPop(S, topOp);
                    postfix[postIdx++] = topOp;
                } else {
                    break;  // 满足条件，退出循环准备压栈
                }
            }
            // 压入当前运算符
            OpPush(S, c);
        }
    }

    // 5. 扫描结束：弹出栈中剩余运算符（除#外）
    char topOp;
    while (GetOpTop(S, topOp) && topOp != '#') {
        OpPop(S, topOp);
        postfix[postIdx++] = topOp;
    }

    // 给后缀表达式加结束符
    postfix[postIdx] = '\0';

    DestroyOpStack(S);  // 销毁栈
}
```

#### 3.3 main 函数：测试转换逻辑

cpp







```cpp
int main() {
    // 视频中示例中缀表达式
    const char infix[] = "X/(I-J)*Y";
    // 缓冲区：存储转换后的后缀表达式（长度足够）
    char postfix[100] = {0};

    // 中缀转后缀
    InfixToPostfix(infix, postfix);

    // 输出结果
    printf("中缀表达式：%s\n", infix);
    printf("后缀表达式：%s\n", postfix);

    return 0;
}
```

**运行结果**（与视频一致）：

plaintext







```plaintext
中缀表达式：X/(I-J)*Y
后缀表达式：XIJ-/Y*
```

## 四、核心知识点串联

1. **栈的核心作用**：无论是后缀求值还是中缀转后缀，栈都用于 “暂存数据（操作数 / 运算符）”，利用 “先进后出” 特性处理优先级和顺序问题。

2. **枚举的应用**：通过枚举标准化 “字符类型”“运算符类型”，避免魔法值（如用`NUM`代替`1`表示数字），提高代码可读性。

3. **表达式转换本质**：中缀转后缀的核心是 “通过栈调整运算符顺序”，让后缀表达式天然符合 “先算高优先级、再算低优先级” 的规则，无需额外判断优先级即可直接求值。

4. ## 五、后缀表达式求值的关键注意点（视频重点强调）

	视频中多次提醒后缀求值的 “易踩坑点”，需结合代码逻辑重点关注：

	### 1. 操作数顺序：`op2先弹、op1后弹`（核心易错点）

	- **原因**：后缀表达式的运算符位于两个操作数之后，如 “8 2 /” 表示 “8÷2”，而非 “2÷8”。栈是 “先进后出” 结构，先入栈的 “8” 在栈底，后入栈的 “2” 在栈顶，因此弹栈时先取 “2”（`op2`），再取 “8”（`op1`）。

	- **错误后果**：若顺序颠倒（`op1先弹、op2后弹`），会导致计算结果完全错误（如 “8 2 /” 变成 “2÷8=0”，而非正确的 “4”）。

	- **代码印证**（视频中`evil`函数片段）：

		cpp

		

		

		

		```cpp
		// 必须先弹op2，再弹op1（顺序不可颠倒）
		if (!Pop(S, op2)) { printf("表达式错误（op2不足）\n"); return; }
		if (!Pop(S, op1)) { printf("表达式错误（op1不足）\n"); return; }
		// 计算时用 op1 运算符 op2
		result = op1 / op2; // 正确：8/2=4；错误顺序会变成2/8=0
		```

	### 2. 字符转数字：`symbol - '0'`的原理（视频技巧讲解）

	- **本质**：C/C++ 中字符`'0'~'9'`的 ASCII 码值是连续的（`'0'=48`，`'1'=49`，…，`'9'=57`）。因此，字符`'8'`的 ASCII 码（56）减去`'0'`的 ASCII 码（48），结果为整数`8`。

	- **局限性**：仅适用于**单个数字字符**（如`'8'`），若表达式包含多位数（如 “123”），需额外处理（视频未涉及多位数，仅讲单个数字场景）。

	- **代码示例**（视频中`evil`函数片段）：

		cpp

		

		

		

		```cpp
		if (token == NUM) {
		    int num = symbol - '0'; // 字符'8' → 整数8
		    Push(S, num);
		}
		```

	### 3. 异常处理：除零错误与表达式非法（视频提及）

	- **除零错误**：当运算符为`/`或`%`时，若`op2=0`，会导致程序崩溃，需提前判断。

	- **表达式非法**：如 “8 +”（缺少操作数）、“8 2 3 +”（多操作数），需通过栈空 / 栈满判断。

	- **代码处理**（视频中`evil`函数片段）：

		cpp

		

		

		

		```cpp
		case DIV: 
		    if (op2 == 0) { 
		        printf("除零错误\n"); 
		        return; // 终止程序，避免崩溃
		    }
		    result = op1 / op2; 
		    break;
		// 弹栈前判断栈是否为空（避免非法表达式）
		if (!Pop(S, op2)) { printf("表达式错误（op2不足）\n"); return; }
		```

	## 六、中缀转后缀的补充细节（视频深入讲解）

	视频中针对中缀转后缀的 “括号处理” 和 “优先级逻辑” 做了额外说明，需结合规则强化理解：

	### 1. 栈底元素`#`的作用（视频关键设计）

	- **避免栈空判断**：栈底存入优先级最低的`#`（对应优先级 0），扫描过程中无需频繁判断 “栈是否为空”（因`#`始终存在）。

	- **终止条件标记**：扫描结束后，只需弹出栈中所有元素直到遇到`#`，即可停止（无需担心栈弹空）。

	- **代码印证**（视频中`InfixToPostfix`函数片段）：

		cpp

		

		

		

		```cpp
		// 初始化时栈底存入#
		InitOpStack(S); // 内部执行：*(S.top++) = '#'
		// 扫描结束后，弹出到#为止
		while (GetOpTop(S, topOp) && topOp != '#') {
		    OpPop(S, topOp);
		    postfix[postIdx++] = topOp;
		}
		```

	### 2. 左括号`(`的 “优先级切换”（视频形象比喻）

	- **视频比喻**：左括号在 “栈外是大哥，栈内是小弟”—— 栈外时优先级最高（15），确保能压栈；栈内时优先级最低（0），确保后续运算符（如`-`、`*`）能正常压栈。

	- **反例**：若左括号栈内优先级仍为 15，后续运算符（如`-`优先级 12）会因 “优先级低于 15” 而无法压栈，导致转换失败。

	- **代码印证**（视频中`GetPriority`函数片段）：

		cpp

		

		

		

		```cpp
		case '(': 
		    return isInStack ? 0 : 15; // 栈外15（大哥），栈内0（小弟）
		```

	### 3. 运算符优先级 “相等” 的处理（视频规则补充）

	- **规则**：若当前运算符与栈顶运算符优先级相等（如`*`和`/`优先级均为 13），需先弹出栈顶运算符并输出，再压入当前运算符。
	- **原因**：确保运算符的 “左结合性”（如 “8/2*3” 应按 “(8/2)*3” 计算，而非 “8/(2*3)”）。
	- **示例**：中缀表达式 “8/2*3” 转换过程：
		1. 扫描`8`→输出；扫描`/`→压栈；扫描`2`→输出；
		2. 扫描`*`：栈顶`/`优先级 = 13，与`*`相等→弹出`/`并输出，再压入`*`；
		3. 扫描`3`→输出；扫描结束→弹出`*`并输出；
		4. 最终后缀表达式：`82/3*`（正确，对应 “(8/2)*3=12”）。

	## 七、考试与学习相关提示（视频明确提及）

	视频中针对学生考试和学习给出了具体要求，需重点关注：

	### 1. 期末考试题型（视频明确说明）

	- **填空题**：给定后缀表达式，要求计算结果（如 “82/2+56*-” 的结果为`-24`）。
		- 解题步骤：按 “数字压栈、运算符弹栈计算” 的规则手动模拟，无需写代码。
	- **核心要求**：必须牢记后缀求值的逻辑，不能颠倒`op1`和`op2`的顺序。
	- **示例**（视频中例题）：
		- 后缀表达式：`563*+`（对应中缀 “5+6*3”）；
		- 手动计算：`6`压栈→`3`压栈→`*`（弹 3、6→18 压栈）→`5`压栈→`+`（弹 18、5→23）→结果`23`。

	### 2. 教材内容对比（视频吐槽与建议）

	- **视频评价**：教材中 “表达式求值” 部分写得 “烂”，前情提要不清晰（如未说明栈的作用、优先级规则），建议以课堂讲解和代码逻辑为准。
	- **学习建议**：
		1. 先理解 “后缀求值”（相对简单），再学 “中缀转后缀”（较复杂）；
		2. 代码需亲手调试（视频承诺上传代码到网盘，供学生下载练习）；
		3. 多练手动转换和计算（如中缀 “X/(I-J)*Y” 转后缀 “XIJ-/Y*”）。

	## 八、代码实战细节补充（视频代码隐含逻辑）

	### 1. 全局变量`expr`的使用原因（视频代码设计）

	- **目的**：`expr`（存储后缀表达式）定义为全局变量，是为了让`get_token`、`evil`等函数无需通过参数传递即可访问，简化代码（视频中明确 “全局变量方便多函数使用”）。
	- **局限性**：全局变量会增加代码耦合度，实际开发中可改用 “结构体封装” 或 “参数传递指针”，但视频为教学简化，采用全局变量。

	### 2. 动态栈扩容的必要性（视频代码设计）

	- **原因**：视频中栈的初始容量为 10，若表达式较长（如操作数超过 10 个），会导致栈满溢出，因此需在`Push`函数中判断 “栈满时扩容”（每次增加 10 个容量）。

	- **代码印证**（视频中`Push`函数片段）：

		cpp

		

		

		

		```cpp
		if (S.top - S.base >= S.stackSize) {
		    // 扩容：原有容量+10
		    S.base = (int*)realloc(S.base, (S.stackSize + 10) * sizeof(int));
		    if (!S.base) exit(1); // 内存分配失败
		    S.top = S.base + S.stackSize; // 更新栈顶指针
		    S.stackSize += 10; // 更新栈容量
		}
		```

	## 九、知识点总览（视频核心脉络）

	| 模块           | 核心内容                                                     | 关键工具 / 数据结构 | 易错点                                    |
	| -------------- | ------------------------------------------------------------ | ------------------- | ----------------------------------------- |
	| 枚举（Enum）   | 自定义取值范围、默认值规则、typedef 简化声明                 | 复合数据类型        | 枚举元素数值从 0 开始（需手动调整时注意） |
	| 后缀表达式求值 | 数字压栈、运算符弹栈计算（op2 先弹）、异常处理（除零）       | 顺序栈（int 类型）  | op1 与 op2 顺序颠倒、字符转数字错误       |
	| 中缀转后缀     | 操作数直接输出、括号处理（左括号优先级切换）、运算符优先级比较 | 顺序栈（char 类型） | 左括号站内优先级记混、优先级相等处理      |
	| 考试与应用     | 后缀结果填空题、手动模拟转换 / 计算、教材内容补充            | 逻辑模拟            | 手动计算时遗漏弹栈步骤                    |

	
